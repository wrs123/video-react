var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _handler, _a, _b, _paused, _reason, _aborted, _abort, _handler2, _controller, _c, _d, _ProxyAgent_instances, getUrl_fn, _e, _noProxyValue, _noProxyEntries, _opts, _EnvHttpProxyAgent_instances, getProxyAgentForUrl_fn, shouldProxy_fn, parseNoProxy_fn, noProxyChanged_get, noProxyEnv_get, _f, _agent, _options, _g, _handler3, _onCompleteCalled, _onErrorCalled, _onResponseStartCalled, _h, _statusCode, _contentType, _decoder, _headers, _body, _ResponseErrorHandler_instances, checkContentType_fn, _maxSize, _dumped, _size, _controller2, _DumpHandler_instances, abort_fn, _i, _maxTTL, _maxItems, _records, _DNSInstance_instances, defaultLookup_fn, defaultPick_fn, _j, _state, _opts2, _dispatch, _origin, _controller3, _newOrigin, _firstTry, _k, _cacheKey, _cacheType, _cacheByDefault, _store, _handler4, _writeStream, _l, _maxCount, _maxSize2, _maxEntrySize, _size2, _count, _entries, _m, _successful, _callback, _handler5, _context, _allowErrorStatusCodes, _n, _maxEntrySize2, _maxCount2, _db, _getValuesQuery, _updateValueQuery, _insertValueQuery, _deleteExpiredValuesQuery, _deleteByUrlQuery, _countEntriesQuery, _deleteOldValuesQuery, _SqliteCacheStore_instances, prune_fn, makeValueUrl_fn, findValue_fn, _o, _dispatcher, _dispatch2, _p, _ProxyAgent_instances2, getUrl_fn2, _q, _noProxyValue2, _noProxyEntries2, _opts3, _EnvHttpProxyAgent_instances2, getProxyAgentForUrl_fn2, shouldProxy_fn2, parseNoProxy_fn2, noProxyChanged_get2, noProxyEnv_get2, _r, _agent2, _options2, _s, _handler6, _t, _maxSize3, _abort2, _dumped2, _aborted2, _size3, _reason2, _handler7, _DumpHandler_instances2, customAbort_fn, _maxTTL2, _maxItems2, _records2, _DNSInstance_instances2, defaultLookup_fn2, defaultPick_fn2, _state2, _opts4, _dispatch3, _handler8, _origin2;
import { BrowserWindow, ipcMain, dialog, shell, app } from "electron";
import require$$1$3, { fileURLToPath } from "node:url";
import path$1 from "node:path";
import require$$0$7 from "stream";
import require$$1 from "string_decoder";
import require$$0$3 from "node:assert";
import require$$0$5 from "node:net";
import require$$2$1 from "node:http";
import require$$0$4 from "node:stream";
import require$$0$1 from "node:buffer";
import require$$0$2 from "node:util";
import require$$7 from "node:querystring";
import require$$8$1 from "node:events";
import require$$0$6 from "node:diagnostics_channel";
import require$$5 from "node:tls";
import require$$1$2 from "node:zlib";
import require$$5$1 from "node:perf_hooks";
import require$$8$2 from "node:util/types";
import require$$1$1 from "node:worker_threads";
import require$$1$4 from "node:async_hooks";
import require$$1$5 from "node:console";
import require$$1$6 from "node:dns";
import fs from "fs";
import require$$0$a from "net";
import require$$1$a from "tls";
import require$$2$2 from "assert";
import require$$1$7 from "tty";
import require$$1$8 from "util";
import require$$0$8 from "os";
import require$$0$9 from "http";
import require$$1$9 from "https";
import require$$5$2 from "url";
import require$$0$b from "timers";
import require$$1$b from "querystring";
import require$$3 from "vm";
import { createRequire } from "module";
import path, { join, resolve } from "path";
import crypto from "crypto";
import { createRequire as createRequire$1 } from "node:module";
var DownloadStatus = /* @__PURE__ */ ((DownloadStatus2) => {
  DownloadStatus2["PENDING"] = "PENDING";
  DownloadStatus2["ERROR"] = "ERROR";
  DownloadStatus2["FINISH"] = "FINISH";
  DownloadStatus2["PAUSE"] = "PAUSE";
  DownloadStatus2["ANAL"] = "ANAL";
  DownloadStatus2["ANALERROR"] = "ANALERROR";
  return DownloadStatus2;
})(DownloadStatus || {});
var ResultStatus = /* @__PURE__ */ ((ResultStatus2) => {
  ResultStatus2["ERROR"] = "ERROR";
  ResultStatus2["OK"] = "OK";
  return ResultStatus2;
})(ResultStatus || {});
var DownloadFileType = /* @__PURE__ */ ((DownloadFileType2) => {
  DownloadFileType2["NONE"] = "NONE";
  DownloadFileType2["MP4"] = "MP4";
  DownloadFileType2["M3U8"] = "M3U8";
  return DownloadFileType2;
})(DownloadFileType || {});
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var info = {};
var sax = {};
(function(exports) {
  (function(sax2) {
    sax2.parser = function(strict, opt) {
      return new SAXParser(strict, opt);
    };
    sax2.SAXParser = SAXParser;
    sax2.SAXStream = SAXStream;
    sax2.createStream = createStream2;
    sax2.MAX_BUFFER_LENGTH = 64 * 1024;
    var buffers = [
      "comment",
      "sgmlDecl",
      "textNode",
      "tagName",
      "doctype",
      "procInstName",
      "procInstBody",
      "entity",
      "attribName",
      "attribValue",
      "cdata",
      "script"
    ];
    sax2.EVENTS = [
      "text",
      "processinginstruction",
      "sgmldeclaration",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "opencdata",
      "cdata",
      "closecdata",
      "error",
      "end",
      "ready",
      "script",
      "opennamespace",
      "closenamespace"
    ];
    function SAXParser(strict, opt) {
      if (!(this instanceof SAXParser)) {
        return new SAXParser(strict, opt);
      }
      var parser = this;
      clearBuffers(parser);
      parser.q = parser.c = "";
      parser.bufferCheckPosition = sax2.MAX_BUFFER_LENGTH;
      parser.opt = opt || {};
      parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
      parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
      parser.tags = [];
      parser.closed = parser.closedRoot = parser.sawRoot = false;
      parser.tag = parser.error = null;
      parser.strict = !!strict;
      parser.noscript = !!(strict || parser.opt.noscript);
      parser.state = S.BEGIN;
      parser.strictEntities = parser.opt.strictEntities;
      parser.ENTITIES = parser.strictEntities ? Object.create(sax2.XML_ENTITIES) : Object.create(sax2.ENTITIES);
      parser.attribList = [];
      if (parser.opt.xmlns) {
        parser.ns = Object.create(rootNS);
      }
      if (parser.opt.unquotedAttributeValues === void 0) {
        parser.opt.unquotedAttributeValues = !strict;
      }
      parser.trackPosition = parser.opt.position !== false;
      if (parser.trackPosition) {
        parser.position = parser.line = parser.column = 0;
      }
      emit(parser, "onready");
    }
    if (!Object.create) {
      Object.create = function(o) {
        function F() {
        }
        F.prototype = o;
        var newf = new F();
        return newf;
      };
    }
    if (!Object.keys) {
      Object.keys = function(o) {
        var a = [];
        for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
        return a;
      };
    }
    function checkBufferLength(parser) {
      var maxAllowed = Math.max(sax2.MAX_BUFFER_LENGTH, 10);
      var maxActual = 0;
      for (var i = 0, l = buffers.length; i < l; i++) {
        var len = parser[buffers[i]].length;
        if (len > maxAllowed) {
          switch (buffers[i]) {
            case "textNode":
              closeText(parser);
              break;
            case "cdata":
              emitNode(parser, "oncdata", parser.cdata);
              parser.cdata = "";
              break;
            case "script":
              emitNode(parser, "onscript", parser.script);
              parser.script = "";
              break;
            default:
              error(parser, "Max buffer length exceeded: " + buffers[i]);
          }
        }
        maxActual = Math.max(maxActual, len);
      }
      var m = sax2.MAX_BUFFER_LENGTH - maxActual;
      parser.bufferCheckPosition = m + parser.position;
    }
    function clearBuffers(parser) {
      for (var i = 0, l = buffers.length; i < l; i++) {
        parser[buffers[i]] = "";
      }
    }
    function flushBuffers(parser) {
      closeText(parser);
      if (parser.cdata !== "") {
        emitNode(parser, "oncdata", parser.cdata);
        parser.cdata = "";
      }
      if (parser.script !== "") {
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
    }
    SAXParser.prototype = {
      end: function() {
        end(this);
      },
      write,
      resume: function() {
        this.error = null;
        return this;
      },
      close: function() {
        return this.write(null);
      },
      flush: function() {
        flushBuffers(this);
      }
    };
    var Stream;
    try {
      Stream = require("stream").Stream;
    } catch (ex) {
      Stream = function() {
      };
    }
    if (!Stream) Stream = function() {
    };
    var streamWraps = sax2.EVENTS.filter(function(ev) {
      return ev !== "error" && ev !== "end";
    });
    function createStream2(strict, opt) {
      return new SAXStream(strict, opt);
    }
    function SAXStream(strict, opt) {
      if (!(this instanceof SAXStream)) {
        return new SAXStream(strict, opt);
      }
      Stream.apply(this);
      this._parser = new SAXParser(strict, opt);
      this.writable = true;
      this.readable = true;
      var me = this;
      this._parser.onend = function() {
        me.emit("end");
      };
      this._parser.onerror = function(er) {
        me.emit("error", er);
        me._parser.error = null;
      };
      this._decoder = null;
      streamWraps.forEach(function(ev) {
        Object.defineProperty(me, "on" + ev, {
          get: function() {
            return me._parser["on" + ev];
          },
          set: function(h) {
            if (!h) {
              me.removeAllListeners(ev);
              me._parser["on" + ev] = h;
              return h;
            }
            me.on(ev, h);
          },
          enumerable: true,
          configurable: false
        });
      });
    }
    SAXStream.prototype = Object.create(Stream.prototype, {
      constructor: {
        value: SAXStream
      }
    });
    SAXStream.prototype.write = function(data) {
      if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
        if (!this._decoder) {
          var SD = require$$1.StringDecoder;
          this._decoder = new SD("utf8");
        }
        data = this._decoder.write(data);
      }
      this._parser.write(data.toString());
      this.emit("data", data);
      return true;
    };
    SAXStream.prototype.end = function(chunk) {
      if (chunk && chunk.length) {
        this.write(chunk);
      }
      this._parser.end();
      return true;
    };
    SAXStream.prototype.on = function(ev, handler) {
      var me = this;
      if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
        me._parser["on" + ev] = function() {
          var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          args.splice(0, 0, ev);
          me.emit.apply(me, args);
        };
      }
      return Stream.prototype.on.call(me, ev, handler);
    };
    var CDATA = "[CDATA[";
    var DOCTYPE = "DOCTYPE";
    var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
    var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
    var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function isWhitespace(c) {
      return c === " " || c === "\n" || c === "\r" || c === "	";
    }
    function isQuote(c) {
      return c === '"' || c === "'";
    }
    function isAttribEnd(c) {
      return c === ">" || isWhitespace(c);
    }
    function isMatch(regex, c) {
      return regex.test(c);
    }
    function notMatch(regex, c) {
      return !isMatch(regex, c);
    }
    var S = 0;
    sax2.STATE = {
      BEGIN: S++,
      // leading byte order mark or whitespace
      BEGIN_WHITESPACE: S++,
      // leading whitespace
      TEXT: S++,
      // general stuff
      TEXT_ENTITY: S++,
      // &amp and such.
      OPEN_WAKA: S++,
      // <
      SGML_DECL: S++,
      // <!BLARG
      SGML_DECL_QUOTED: S++,
      // <!BLARG foo "bar
      DOCTYPE: S++,
      // <!DOCTYPE
      DOCTYPE_QUOTED: S++,
      // <!DOCTYPE "//blah
      DOCTYPE_DTD: S++,
      // <!DOCTYPE "//blah" [ ...
      DOCTYPE_DTD_QUOTED: S++,
      // <!DOCTYPE "//blah" [ "foo
      COMMENT_STARTING: S++,
      // <!-
      COMMENT: S++,
      // <!--
      COMMENT_ENDING: S++,
      // <!-- blah -
      COMMENT_ENDED: S++,
      // <!-- blah --
      CDATA: S++,
      // <![CDATA[ something
      CDATA_ENDING: S++,
      // ]
      CDATA_ENDING_2: S++,
      // ]]
      PROC_INST: S++,
      // <?hi
      PROC_INST_BODY: S++,
      // <?hi there
      PROC_INST_ENDING: S++,
      // <?hi "there" ?
      OPEN_TAG: S++,
      // <strong
      OPEN_TAG_SLASH: S++,
      // <strong /
      ATTRIB: S++,
      // <a
      ATTRIB_NAME: S++,
      // <a foo
      ATTRIB_NAME_SAW_WHITE: S++,
      // <a foo _
      ATTRIB_VALUE: S++,
      // <a foo=
      ATTRIB_VALUE_QUOTED: S++,
      // <a foo="bar
      ATTRIB_VALUE_CLOSED: S++,
      // <a foo="bar"
      ATTRIB_VALUE_UNQUOTED: S++,
      // <a foo=bar
      ATTRIB_VALUE_ENTITY_Q: S++,
      // <foo bar="&quot;"
      ATTRIB_VALUE_ENTITY_U: S++,
      // <foo bar=&quot
      CLOSE_TAG: S++,
      // </a
      CLOSE_TAG_SAW_WHITE: S++,
      // </a   >
      SCRIPT: S++,
      // <script> ...
      SCRIPT_ENDING: S++
      // <script> ... <
    };
    sax2.XML_ENTITIES = {
      "amp": "&",
      "gt": ">",
      "lt": "<",
      "quot": '"',
      "apos": "'"
    };
    sax2.ENTITIES = {
      "amp": "&",
      "gt": ">",
      "lt": "<",
      "quot": '"',
      "apos": "'",
      "AElig": 198,
      "Aacute": 193,
      "Acirc": 194,
      "Agrave": 192,
      "Aring": 197,
      "Atilde": 195,
      "Auml": 196,
      "Ccedil": 199,
      "ETH": 208,
      "Eacute": 201,
      "Ecirc": 202,
      "Egrave": 200,
      "Euml": 203,
      "Iacute": 205,
      "Icirc": 206,
      "Igrave": 204,
      "Iuml": 207,
      "Ntilde": 209,
      "Oacute": 211,
      "Ocirc": 212,
      "Ograve": 210,
      "Oslash": 216,
      "Otilde": 213,
      "Ouml": 214,
      "THORN": 222,
      "Uacute": 218,
      "Ucirc": 219,
      "Ugrave": 217,
      "Uuml": 220,
      "Yacute": 221,
      "aacute": 225,
      "acirc": 226,
      "aelig": 230,
      "agrave": 224,
      "aring": 229,
      "atilde": 227,
      "auml": 228,
      "ccedil": 231,
      "eacute": 233,
      "ecirc": 234,
      "egrave": 232,
      "eth": 240,
      "euml": 235,
      "iacute": 237,
      "icirc": 238,
      "igrave": 236,
      "iuml": 239,
      "ntilde": 241,
      "oacute": 243,
      "ocirc": 244,
      "ograve": 242,
      "oslash": 248,
      "otilde": 245,
      "ouml": 246,
      "szlig": 223,
      "thorn": 254,
      "uacute": 250,
      "ucirc": 251,
      "ugrave": 249,
      "uuml": 252,
      "yacute": 253,
      "yuml": 255,
      "copy": 169,
      "reg": 174,
      "nbsp": 160,
      "iexcl": 161,
      "cent": 162,
      "pound": 163,
      "curren": 164,
      "yen": 165,
      "brvbar": 166,
      "sect": 167,
      "uml": 168,
      "ordf": 170,
      "laquo": 171,
      "not": 172,
      "shy": 173,
      "macr": 175,
      "deg": 176,
      "plusmn": 177,
      "sup1": 185,
      "sup2": 178,
      "sup3": 179,
      "acute": 180,
      "micro": 181,
      "para": 182,
      "middot": 183,
      "cedil": 184,
      "ordm": 186,
      "raquo": 187,
      "frac14": 188,
      "frac12": 189,
      "frac34": 190,
      "iquest": 191,
      "times": 215,
      "divide": 247,
      "OElig": 338,
      "oelig": 339,
      "Scaron": 352,
      "scaron": 353,
      "Yuml": 376,
      "fnof": 402,
      "circ": 710,
      "tilde": 732,
      "Alpha": 913,
      "Beta": 914,
      "Gamma": 915,
      "Delta": 916,
      "Epsilon": 917,
      "Zeta": 918,
      "Eta": 919,
      "Theta": 920,
      "Iota": 921,
      "Kappa": 922,
      "Lambda": 923,
      "Mu": 924,
      "Nu": 925,
      "Xi": 926,
      "Omicron": 927,
      "Pi": 928,
      "Rho": 929,
      "Sigma": 931,
      "Tau": 932,
      "Upsilon": 933,
      "Phi": 934,
      "Chi": 935,
      "Psi": 936,
      "Omega": 937,
      "alpha": 945,
      "beta": 946,
      "gamma": 947,
      "delta": 948,
      "epsilon": 949,
      "zeta": 950,
      "eta": 951,
      "theta": 952,
      "iota": 953,
      "kappa": 954,
      "lambda": 955,
      "mu": 956,
      "nu": 957,
      "xi": 958,
      "omicron": 959,
      "pi": 960,
      "rho": 961,
      "sigmaf": 962,
      "sigma": 963,
      "tau": 964,
      "upsilon": 965,
      "phi": 966,
      "chi": 967,
      "psi": 968,
      "omega": 969,
      "thetasym": 977,
      "upsih": 978,
      "piv": 982,
      "ensp": 8194,
      "emsp": 8195,
      "thinsp": 8201,
      "zwnj": 8204,
      "zwj": 8205,
      "lrm": 8206,
      "rlm": 8207,
      "ndash": 8211,
      "mdash": 8212,
      "lsquo": 8216,
      "rsquo": 8217,
      "sbquo": 8218,
      "ldquo": 8220,
      "rdquo": 8221,
      "bdquo": 8222,
      "dagger": 8224,
      "Dagger": 8225,
      "bull": 8226,
      "hellip": 8230,
      "permil": 8240,
      "prime": 8242,
      "Prime": 8243,
      "lsaquo": 8249,
      "rsaquo": 8250,
      "oline": 8254,
      "frasl": 8260,
      "euro": 8364,
      "image": 8465,
      "weierp": 8472,
      "real": 8476,
      "trade": 8482,
      "alefsym": 8501,
      "larr": 8592,
      "uarr": 8593,
      "rarr": 8594,
      "darr": 8595,
      "harr": 8596,
      "crarr": 8629,
      "lArr": 8656,
      "uArr": 8657,
      "rArr": 8658,
      "dArr": 8659,
      "hArr": 8660,
      "forall": 8704,
      "part": 8706,
      "exist": 8707,
      "empty": 8709,
      "nabla": 8711,
      "isin": 8712,
      "notin": 8713,
      "ni": 8715,
      "prod": 8719,
      "sum": 8721,
      "minus": 8722,
      "lowast": 8727,
      "radic": 8730,
      "prop": 8733,
      "infin": 8734,
      "ang": 8736,
      "and": 8743,
      "or": 8744,
      "cap": 8745,
      "cup": 8746,
      "int": 8747,
      "there4": 8756,
      "sim": 8764,
      "cong": 8773,
      "asymp": 8776,
      "ne": 8800,
      "equiv": 8801,
      "le": 8804,
      "ge": 8805,
      "sub": 8834,
      "sup": 8835,
      "nsub": 8836,
      "sube": 8838,
      "supe": 8839,
      "oplus": 8853,
      "otimes": 8855,
      "perp": 8869,
      "sdot": 8901,
      "lceil": 8968,
      "rceil": 8969,
      "lfloor": 8970,
      "rfloor": 8971,
      "lang": 9001,
      "rang": 9002,
      "loz": 9674,
      "spades": 9824,
      "clubs": 9827,
      "hearts": 9829,
      "diams": 9830
    };
    Object.keys(sax2.ENTITIES).forEach(function(key) {
      var e = sax2.ENTITIES[key];
      var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
      sax2.ENTITIES[key] = s2;
    });
    for (var s in sax2.STATE) {
      sax2.STATE[sax2.STATE[s]] = s;
    }
    S = sax2.STATE;
    function emit(parser, event, data) {
      parser[event] && parser[event](data);
    }
    function emitNode(parser, nodeType, data) {
      if (parser.textNode) closeText(parser);
      emit(parser, nodeType, data);
    }
    function closeText(parser) {
      parser.textNode = textopts(parser.opt, parser.textNode);
      if (parser.textNode) emit(parser, "ontext", parser.textNode);
      parser.textNode = "";
    }
    function textopts(opt, text) {
      if (opt.trim) text = text.trim();
      if (opt.normalize) text = text.replace(/\s+/g, " ");
      return text;
    }
    function error(parser, er) {
      closeText(parser);
      if (parser.trackPosition) {
        er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
      }
      er = new Error(er);
      parser.error = er;
      emit(parser, "onerror", er);
      return parser;
    }
    function end(parser) {
      if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
      if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
        error(parser, "Unexpected end");
      }
      closeText(parser);
      parser.c = "";
      parser.closed = true;
      emit(parser, "onend");
      SAXParser.call(parser, parser.strict, parser.opt);
      return parser;
    }
    function strictFail(parser, message) {
      if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
        throw new Error("bad call to strictFail");
      }
      if (parser.strict) {
        error(parser, message);
      }
    }
    function newTag(parser) {
      if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
      var parent = parser.tags[parser.tags.length - 1] || parser;
      var tag = parser.tag = { name: parser.tagName, attributes: {} };
      if (parser.opt.xmlns) {
        tag.ns = parent.ns;
      }
      parser.attribList.length = 0;
      emitNode(parser, "onopentagstart", tag);
    }
    function qname(name, attribute) {
      var i = name.indexOf(":");
      var qualName = i < 0 ? ["", name] : name.split(":");
      var prefix = qualName[0];
      var local = qualName[1];
      if (attribute && name === "xmlns") {
        prefix = "xmlns";
        local = "";
      }
      return { prefix, local };
    }
    function attrib(parser) {
      if (!parser.strict) {
        parser.attribName = parser.attribName[parser.looseCase]();
      }
      if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
        parser.attribName = parser.attribValue = "";
        return;
      }
      if (parser.opt.xmlns) {
        var qn = qname(parser.attribName, true);
        var prefix = qn.prefix;
        var local = qn.local;
        if (prefix === "xmlns") {
          if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
            strictFail(
              parser,
              "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
            );
          } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
            strictFail(
              parser,
              "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
            );
          } else {
            var tag = parser.tag;
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns === parent.ns) {
              tag.ns = Object.create(parent.ns);
            }
            tag.ns[local] = parser.attribValue;
          }
        }
        parser.attribList.push([parser.attribName, parser.attribValue]);
      } else {
        parser.tag.attributes[parser.attribName] = parser.attribValue;
        emitNode(parser, "onattribute", {
          name: parser.attribName,
          value: parser.attribValue
        });
      }
      parser.attribName = parser.attribValue = "";
    }
    function openTag(parser, selfClosing) {
      if (parser.opt.xmlns) {
        var tag = parser.tag;
        var qn = qname(parser.tagName);
        tag.prefix = qn.prefix;
        tag.local = qn.local;
        tag.uri = tag.ns[qn.prefix] || "";
        if (tag.prefix && !tag.uri) {
          strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
          tag.uri = qn.prefix;
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (tag.ns && parent.ns !== tag.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            emitNode(parser, "onopennamespace", {
              prefix: p,
              uri: tag.ns[p]
            });
          });
        }
        for (var i = 0, l = parser.attribList.length; i < l; i++) {
          var nv = parser.attribList[i];
          var name = nv[0];
          var value = nv[1];
          var qualName = qname(name, true);
          var prefix = qualName.prefix;
          var local = qualName.local;
          var uri = prefix === "" ? "" : tag.ns[prefix] || "";
          var a = {
            name,
            value,
            prefix,
            local,
            uri
          };
          if (prefix && prefix !== "xmlns" && !uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
            a.uri = prefix;
          }
          parser.tag.attributes[name] = a;
          emitNode(parser, "onattribute", a);
        }
        parser.attribList.length = 0;
      }
      parser.tag.isSelfClosing = !!selfClosing;
      parser.sawRoot = true;
      parser.tags.push(parser.tag);
      emitNode(parser, "onopentag", parser.tag);
      if (!selfClosing) {
        if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
          parser.state = S.SCRIPT;
        } else {
          parser.state = S.TEXT;
        }
        parser.tag = null;
        parser.tagName = "";
      }
      parser.attribName = parser.attribValue = "";
      parser.attribList.length = 0;
    }
    function closeTag(parser) {
      if (!parser.tagName) {
        strictFail(parser, "Weird empty close tag.");
        parser.textNode += "</>";
        parser.state = S.TEXT;
        return;
      }
      if (parser.script) {
        if (parser.tagName !== "script") {
          parser.script += "</" + parser.tagName + ">";
          parser.tagName = "";
          parser.state = S.SCRIPT;
          return;
        }
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
      var t = parser.tags.length;
      var tagName = parser.tagName;
      if (!parser.strict) {
        tagName = tagName[parser.looseCase]();
      }
      var closeTo = tagName;
      while (t--) {
        var close = parser.tags[t];
        if (close.name !== closeTo) {
          strictFail(parser, "Unexpected close tag");
        } else {
          break;
        }
      }
      if (t < 0) {
        strictFail(parser, "Unmatched closing tag: " + parser.tagName);
        parser.textNode += "</" + parser.tagName + ">";
        parser.state = S.TEXT;
        return;
      }
      parser.tagName = tagName;
      var s2 = parser.tags.length;
      while (s2-- > t) {
        var tag = parser.tag = parser.tags.pop();
        parser.tagName = parser.tag.name;
        emitNode(parser, "onclosetag", parser.tagName);
        var x = {};
        for (var i in tag.ns) {
          x[i] = tag.ns[i];
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (parser.opt.xmlns && tag.ns !== parent.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            var n = tag.ns[p];
            emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
          });
        }
      }
      if (t === 0) parser.closedRoot = true;
      parser.tagName = parser.attribValue = parser.attribName = "";
      parser.attribList.length = 0;
      parser.state = S.TEXT;
    }
    function parseEntity(parser) {
      var entity = parser.entity;
      var entityLC = entity.toLowerCase();
      var num;
      var numStr = "";
      if (parser.ENTITIES[entity]) {
        return parser.ENTITIES[entity];
      }
      if (parser.ENTITIES[entityLC]) {
        return parser.ENTITIES[entityLC];
      }
      entity = entityLC;
      if (entity.charAt(0) === "#") {
        if (entity.charAt(1) === "x") {
          entity = entity.slice(2);
          num = parseInt(entity, 16);
          numStr = num.toString(16);
        } else {
          entity = entity.slice(1);
          num = parseInt(entity, 10);
          numStr = num.toString(10);
        }
      }
      entity = entity.replace(/^0+/, "");
      if (isNaN(num) || numStr.toLowerCase() !== entity) {
        strictFail(parser, "Invalid character entity");
        return "&" + parser.entity + ";";
      }
      return String.fromCodePoint(num);
    }
    function beginWhiteSpace(parser, c) {
      if (c === "<") {
        parser.state = S.OPEN_WAKA;
        parser.startTagPosition = parser.position;
      } else if (!isWhitespace(c)) {
        strictFail(parser, "Non-whitespace before first tag.");
        parser.textNode = c;
        parser.state = S.TEXT;
      }
    }
    function charAt(chunk, i) {
      var result = "";
      if (i < chunk.length) {
        result = chunk.charAt(i);
      }
      return result;
    }
    function write(chunk) {
      var parser = this;
      if (this.error) {
        throw this.error;
      }
      if (parser.closed) {
        return error(
          parser,
          "Cannot write after close. Assign an onready handler."
        );
      }
      if (chunk === null) {
        return end(parser);
      }
      if (typeof chunk === "object") {
        chunk = chunk.toString();
      }
      var i = 0;
      var c = "";
      while (true) {
        c = charAt(chunk, i++);
        parser.c = c;
        if (!c) {
          break;
        }
        if (parser.trackPosition) {
          parser.position++;
          if (c === "\n") {
            parser.line++;
            parser.column = 0;
          } else {
            parser.column++;
          }
        }
        switch (parser.state) {
          case S.BEGIN:
            parser.state = S.BEGIN_WHITESPACE;
            if (c === "\uFEFF") {
              continue;
            }
            beginWhiteSpace(parser, c);
            continue;
          case S.BEGIN_WHITESPACE:
            beginWhiteSpace(parser, c);
            continue;
          case S.TEXT:
            if (parser.sawRoot && !parser.closedRoot) {
              var starti = i - 1;
              while (c && c !== "<" && c !== "&") {
                c = charAt(chunk, i++);
                if (c && parser.trackPosition) {
                  parser.position++;
                  if (c === "\n") {
                    parser.line++;
                    parser.column = 0;
                  } else {
                    parser.column++;
                  }
                }
              }
              parser.textNode += chunk.substring(starti, i - 1);
            }
            if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
              parser.state = S.OPEN_WAKA;
              parser.startTagPosition = parser.position;
            } else {
              if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                strictFail(parser, "Text data outside of root node.");
              }
              if (c === "&") {
                parser.state = S.TEXT_ENTITY;
              } else {
                parser.textNode += c;
              }
            }
            continue;
          case S.SCRIPT:
            if (c === "<") {
              parser.state = S.SCRIPT_ENDING;
            } else {
              parser.script += c;
            }
            continue;
          case S.SCRIPT_ENDING:
            if (c === "/") {
              parser.state = S.CLOSE_TAG;
            } else {
              parser.script += "<" + c;
              parser.state = S.SCRIPT;
            }
            continue;
          case S.OPEN_WAKA:
            if (c === "!") {
              parser.state = S.SGML_DECL;
              parser.sgmlDecl = "";
            } else if (isWhitespace(c)) ;
            else if (isMatch(nameStart, c)) {
              parser.state = S.OPEN_TAG;
              parser.tagName = c;
            } else if (c === "/") {
              parser.state = S.CLOSE_TAG;
              parser.tagName = "";
            } else if (c === "?") {
              parser.state = S.PROC_INST;
              parser.procInstName = parser.procInstBody = "";
            } else {
              strictFail(parser, "Unencoded <");
              if (parser.startTagPosition + 1 < parser.position) {
                var pad = parser.position - parser.startTagPosition;
                c = new Array(pad).join(" ") + c;
              }
              parser.textNode += "<" + c;
              parser.state = S.TEXT;
            }
            continue;
          case S.SGML_DECL:
            if (parser.sgmlDecl + c === "--") {
              parser.state = S.COMMENT;
              parser.comment = "";
              parser.sgmlDecl = "";
              continue;
            }
            if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {
              parser.state = S.DOCTYPE_DTD;
              parser.doctype += "<!" + parser.sgmlDecl + c;
              parser.sgmlDecl = "";
            } else if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
              emitNode(parser, "onopencdata");
              parser.state = S.CDATA;
              parser.sgmlDecl = "";
              parser.cdata = "";
            } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
              parser.state = S.DOCTYPE;
              if (parser.doctype || parser.sawRoot) {
                strictFail(
                  parser,
                  "Inappropriately located doctype declaration"
                );
              }
              parser.doctype = "";
              parser.sgmlDecl = "";
            } else if (c === ">") {
              emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
              parser.sgmlDecl = "";
              parser.state = S.TEXT;
            } else if (isQuote(c)) {
              parser.state = S.SGML_DECL_QUOTED;
              parser.sgmlDecl += c;
            } else {
              parser.sgmlDecl += c;
            }
            continue;
          case S.SGML_DECL_QUOTED:
            if (c === parser.q) {
              parser.state = S.SGML_DECL;
              parser.q = "";
            }
            parser.sgmlDecl += c;
            continue;
          case S.DOCTYPE:
            if (c === ">") {
              parser.state = S.TEXT;
              emitNode(parser, "ondoctype", parser.doctype);
              parser.doctype = true;
            } else {
              parser.doctype += c;
              if (c === "[") {
                parser.state = S.DOCTYPE_DTD;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_QUOTED;
                parser.q = c;
              }
            }
            continue;
          case S.DOCTYPE_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.q = "";
              parser.state = S.DOCTYPE;
            }
            continue;
          case S.DOCTYPE_DTD:
            if (c === "]") {
              parser.doctype += c;
              parser.state = S.DOCTYPE;
            } else if (c === "<") {
              parser.state = S.OPEN_WAKA;
              parser.startTagPosition = parser.position;
            } else if (isQuote(c)) {
              parser.doctype += c;
              parser.state = S.DOCTYPE_DTD_QUOTED;
              parser.q = c;
            } else {
              parser.doctype += c;
            }
            continue;
          case S.DOCTYPE_DTD_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.state = S.DOCTYPE_DTD;
              parser.q = "";
            }
            continue;
          case S.COMMENT:
            if (c === "-") {
              parser.state = S.COMMENT_ENDING;
            } else {
              parser.comment += c;
            }
            continue;
          case S.COMMENT_ENDING:
            if (c === "-") {
              parser.state = S.COMMENT_ENDED;
              parser.comment = textopts(parser.opt, parser.comment);
              if (parser.comment) {
                emitNode(parser, "oncomment", parser.comment);
              }
              parser.comment = "";
            } else {
              parser.comment += "-" + c;
              parser.state = S.COMMENT;
            }
            continue;
          case S.COMMENT_ENDED:
            if (c !== ">") {
              strictFail(parser, "Malformed comment");
              parser.comment += "--" + c;
              parser.state = S.COMMENT;
            } else if (parser.doctype && parser.doctype !== true) {
              parser.state = S.DOCTYPE_DTD;
            } else {
              parser.state = S.TEXT;
            }
            continue;
          case S.CDATA:
            if (c === "]") {
              parser.state = S.CDATA_ENDING;
            } else {
              parser.cdata += c;
            }
            continue;
          case S.CDATA_ENDING:
            if (c === "]") {
              parser.state = S.CDATA_ENDING_2;
            } else {
              parser.cdata += "]" + c;
              parser.state = S.CDATA;
            }
            continue;
          case S.CDATA_ENDING_2:
            if (c === ">") {
              if (parser.cdata) {
                emitNode(parser, "oncdata", parser.cdata);
              }
              emitNode(parser, "onclosecdata");
              parser.cdata = "";
              parser.state = S.TEXT;
            } else if (c === "]") {
              parser.cdata += "]";
            } else {
              parser.cdata += "]]" + c;
              parser.state = S.CDATA;
            }
            continue;
          case S.PROC_INST:
            if (c === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else if (isWhitespace(c)) {
              parser.state = S.PROC_INST_BODY;
            } else {
              parser.procInstName += c;
            }
            continue;
          case S.PROC_INST_BODY:
            if (!parser.procInstBody && isWhitespace(c)) {
              continue;
            } else if (c === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else {
              parser.procInstBody += c;
            }
            continue;
          case S.PROC_INST_ENDING:
            if (c === ">") {
              emitNode(parser, "onprocessinginstruction", {
                name: parser.procInstName,
                body: parser.procInstBody
              });
              parser.procInstName = parser.procInstBody = "";
              parser.state = S.TEXT;
            } else {
              parser.procInstBody += "?" + c;
              parser.state = S.PROC_INST_BODY;
            }
            continue;
          case S.OPEN_TAG:
            if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else {
              newTag(parser);
              if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid character in tag name");
                }
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.OPEN_TAG_SLASH:
            if (c === ">") {
              openTag(parser, true);
              closeTag(parser);
            } else {
              strictFail(parser, "Forward-slash in opening tag not followed by >");
              parser.state = S.ATTRIB;
            }
            continue;
          case S.ATTRIB:
            if (isWhitespace(c)) {
              continue;
            } else if (c === ">") {
              openTag(parser);
            } else if (c === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME:
            if (c === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (c === ">") {
              strictFail(parser, "Attribute without value");
              parser.attribValue = parser.attribName;
              attrib(parser);
              openTag(parser);
            } else if (isWhitespace(c)) {
              parser.state = S.ATTRIB_NAME_SAW_WHITE;
            } else if (isMatch(nameBody, c)) {
              parser.attribName += c;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME_SAW_WHITE:
            if (c === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (isWhitespace(c)) {
              continue;
            } else {
              strictFail(parser, "Attribute without value");
              parser.tag.attributes[parser.attribName] = "";
              parser.attribValue = "";
              emitNode(parser, "onattribute", {
                name: parser.attribName,
                value: ""
              });
              parser.attribName = "";
              if (c === ">") {
                openTag(parser);
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.ATTRIB_VALUE:
            if (isWhitespace(c)) {
              continue;
            } else if (isQuote(c)) {
              parser.q = c;
              parser.state = S.ATTRIB_VALUE_QUOTED;
            } else {
              if (!parser.opt.unquotedAttributeValues) {
                error(parser, "Unquoted attribute value");
              }
              parser.state = S.ATTRIB_VALUE_UNQUOTED;
              parser.attribValue = c;
            }
            continue;
          case S.ATTRIB_VALUE_QUOTED:
            if (c !== parser.q) {
              if (c === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_Q;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            parser.q = "";
            parser.state = S.ATTRIB_VALUE_CLOSED;
            continue;
          case S.ATTRIB_VALUE_CLOSED:
            if (isWhitespace(c)) {
              parser.state = S.ATTRIB;
            } else if (c === ">") {
              openTag(parser);
            } else if (c === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              strictFail(parser, "No whitespace between attributes");
              parser.attribName = c;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_VALUE_UNQUOTED:
            if (!isAttribEnd(c)) {
              if (c === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_U;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            if (c === ">") {
              openTag(parser);
            } else {
              parser.state = S.ATTRIB;
            }
            continue;
          case S.CLOSE_TAG:
            if (!parser.tagName) {
              if (isWhitespace(c)) {
                continue;
              } else if (notMatch(nameStart, c)) {
                if (parser.script) {
                  parser.script += "</" + c;
                  parser.state = S.SCRIPT;
                } else {
                  strictFail(parser, "Invalid tagname in closing tag.");
                }
              } else {
                parser.tagName = c;
              }
            } else if (c === ">") {
              closeTag(parser);
            } else if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else if (parser.script) {
              parser.script += "</" + parser.tagName;
              parser.tagName = "";
              parser.state = S.SCRIPT;
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, "Invalid tagname in closing tag");
              }
              parser.state = S.CLOSE_TAG_SAW_WHITE;
            }
            continue;
          case S.CLOSE_TAG_SAW_WHITE:
            if (isWhitespace(c)) {
              continue;
            }
            if (c === ">") {
              closeTag(parser);
            } else {
              strictFail(parser, "Invalid characters in closing tag");
            }
            continue;
          case S.TEXT_ENTITY:
          case S.ATTRIB_VALUE_ENTITY_Q:
          case S.ATTRIB_VALUE_ENTITY_U:
            var returnState;
            var buffer;
            switch (parser.state) {
              case S.TEXT_ENTITY:
                returnState = S.TEXT;
                buffer = "textNode";
                break;
              case S.ATTRIB_VALUE_ENTITY_Q:
                returnState = S.ATTRIB_VALUE_QUOTED;
                buffer = "attribValue";
                break;
              case S.ATTRIB_VALUE_ENTITY_U:
                returnState = S.ATTRIB_VALUE_UNQUOTED;
                buffer = "attribValue";
                break;
            }
            if (c === ";") {
              var parsedEntity = parseEntity(parser);
              if (parser.opt.unparsedEntities && !Object.values(sax2.XML_ENTITIES).includes(parsedEntity)) {
                parser.entity = "";
                parser.state = returnState;
                parser.write(parsedEntity);
              } else {
                parser[buffer] += parsedEntity;
                parser.entity = "";
                parser.state = returnState;
              }
            } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
              parser.entity += c;
            } else {
              strictFail(parser, "Invalid character in entity name");
              parser[buffer] += "&" + parser.entity + c;
              parser.entity = "";
              parser.state = returnState;
            }
            continue;
          default: {
            throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
      }
      if (parser.position >= parser.bufferCheckPosition) {
        checkBufferLength(parser);
      }
      return parser;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
    if (!String.fromCodePoint) {
      (function() {
        var stringFromCharCode = String.fromCharCode;
        var floor = Math.floor;
        var fromCodePoint = function() {
          var MAX_SIZE = 16384;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index = -1;
          var length = arguments.length;
          if (!length) {
            return "";
          }
          var result = "";
          while (++index < length) {
            var codePoint = Number(arguments[index]);
            if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 1114111 || // not a valid Unicode code point
            floor(codePoint) !== codePoint) {
              throw RangeError("Invalid code point: " + codePoint);
            }
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              highSurrogate = (codePoint >> 10) + 55296;
              lowSurrogate = codePoint % 1024 + 56320;
              codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 === length || codeUnits.length > MAX_SIZE) {
              result += stringFromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        };
        if (Object.defineProperty) {
          Object.defineProperty(String, "fromCodePoint", {
            value: fromCodePoint,
            configurable: true,
            writable: true
          });
        } else {
          String.fromCodePoint = fromCodePoint;
        }
      })();
    }
  })(exports);
})(sax);
var utils$5 = {};
var undici$3 = { exports: {} };
var symbols$5 = {
  kClose: Symbol("close"),
  kDestroy: Symbol("destroy"),
  kDispatch: Symbol("dispatch"),
  kUrl: Symbol("url"),
  kWriting: Symbol("writing"),
  kResuming: Symbol("resuming"),
  kQueue: Symbol("queue"),
  kConnect: Symbol("connect"),
  kConnecting: Symbol("connecting"),
  kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
  kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
  kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
  kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
  kHeadersTimeout: Symbol("headers timeout"),
  kBodyTimeout: Symbol("body timeout"),
  kServerName: Symbol("server name"),
  kLocalAddress: Symbol("local address"),
  kNoRef: Symbol("no ref"),
  kBodyUsed: Symbol("used"),
  kBody: Symbol("abstracted request body"),
  kRunning: Symbol("running"),
  kBlocking: Symbol("blocking"),
  kPending: Symbol("pending"),
  kSize: Symbol("size"),
  kBusy: Symbol("busy"),
  kQueued: Symbol("queued"),
  kFree: Symbol("free"),
  kConnected: Symbol("connected"),
  kClosed: Symbol("closed"),
  kNeedDrain: Symbol("need drain"),
  kReset: Symbol("reset"),
  kDestroyed: Symbol.for("nodejs.stream.destroyed"),
  kResume: Symbol("resume"),
  kOnError: Symbol("on error"),
  kMaxHeadersSize: Symbol("max headers size"),
  kRunningIdx: Symbol("running index"),
  kPendingIdx: Symbol("pending index"),
  kError: Symbol("error"),
  kClients: Symbol("clients"),
  kClient: Symbol("client"),
  kParser: Symbol("parser"),
  kPipelining: Symbol("pipelining"),
  kSocket: Symbol("socket"),
  kHostHeader: Symbol("host header"),
  kConnector: Symbol("connector"),
  kStrictContentLength: Symbol("strict content length"),
  kMaxRequests: Symbol("maxRequestsPerClient"),
  kProxy: Symbol("proxy agent options"),
  kCounter: Symbol("socket request counter"),
  kMaxResponseSize: Symbol("max response size"),
  kHTTP2Session: Symbol("http2Session"),
  kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
  kConstruct: Symbol("constructable"),
  kListeners: Symbol("listeners"),
  kHTTPContext: Symbol("http context"),
  kMaxConcurrentStreams: Symbol("max concurrent streams"),
  kNoProxyAgent: Symbol("no proxy agent"),
  kHttpProxyAgent: Symbol("http proxy agent"),
  kHttpsProxyAgent: Symbol("https proxy agent")
};
let UndiciError$5 = class UndiciError extends Error {
  constructor(message, options) {
    super(message, options);
    this.name = "UndiciError";
    this.code = "UND_ERR";
  }
};
let ConnectTimeoutError$3 = class ConnectTimeoutError extends UndiciError$5 {
  constructor(message) {
    super(message);
    this.name = "ConnectTimeoutError";
    this.message = message || "Connect Timeout Error";
    this.code = "UND_ERR_CONNECT_TIMEOUT";
  }
};
let HeadersTimeoutError$3 = class HeadersTimeoutError extends UndiciError$5 {
  constructor(message) {
    super(message);
    this.name = "HeadersTimeoutError";
    this.message = message || "Headers Timeout Error";
    this.code = "UND_ERR_HEADERS_TIMEOUT";
  }
};
let HeadersOverflowError$3 = class HeadersOverflowError extends UndiciError$5 {
  constructor(message) {
    super(message);
    this.name = "HeadersOverflowError";
    this.message = message || "Headers Overflow Error";
    this.code = "UND_ERR_HEADERS_OVERFLOW";
  }
};
let BodyTimeoutError$3 = class BodyTimeoutError extends UndiciError$5 {
  constructor(message) {
    super(message);
    this.name = "BodyTimeoutError";
    this.message = message || "Body Timeout Error";
    this.code = "UND_ERR_BODY_TIMEOUT";
  }
};
let ResponseStatusCodeError$2 = class ResponseStatusCodeError extends UndiciError$5 {
  constructor(message, statusCode, headers2, body2) {
    super(message);
    this.name = "ResponseStatusCodeError";
    this.message = message || "Response Status Code Error";
    this.code = "UND_ERR_RESPONSE_STATUS_CODE";
    this.body = body2;
    this.status = statusCode;
    this.statusCode = statusCode;
    this.headers = headers2;
  }
};
let InvalidArgumentError$Q = class InvalidArgumentError extends UndiciError$5 {
  constructor(message) {
    super(message);
    this.name = "InvalidArgumentError";
    this.message = message || "Invalid Argument Error";
    this.code = "UND_ERR_INVALID_ARG";
  }
};
let InvalidReturnValueError$5 = class InvalidReturnValueError extends UndiciError$5 {
  constructor(message) {
    super(message);
    this.name = "InvalidReturnValueError";
    this.message = message || "Invalid Return Value Error";
    this.code = "UND_ERR_INVALID_RETURN_VALUE";
  }
};
let AbortError$4 = class AbortError extends UndiciError$5 {
  constructor(message) {
    super(message);
    this.name = "AbortError";
    this.message = message || "The operation was aborted";
  }
};
let RequestAbortedError$h = class RequestAbortedError extends AbortError$4 {
  constructor(message) {
    super(message);
    this.name = "AbortError";
    this.message = message || "Request aborted";
    this.code = "UND_ERR_ABORTED";
  }
};
let InformationalError$9 = class InformationalError extends UndiciError$5 {
  constructor(message) {
    super(message);
    this.name = "InformationalError";
    this.message = message || "Request information";
    this.code = "UND_ERR_INFO";
  }
};
let RequestContentLengthMismatchError$5 = class RequestContentLengthMismatchError extends UndiciError$5 {
  constructor(message) {
    super(message);
    this.name = "RequestContentLengthMismatchError";
    this.message = message || "Request body length does not match content-length header";
    this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
  }
};
let ResponseContentLengthMismatchError$3 = class ResponseContentLengthMismatchError extends UndiciError$5 {
  constructor(message) {
    super(message);
    this.name = "ResponseContentLengthMismatchError";
    this.message = message || "Response body length does not match content-length header";
    this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
  }
};
let ClientDestroyedError$5 = class ClientDestroyedError extends UndiciError$5 {
  constructor(message) {
    super(message);
    this.name = "ClientDestroyedError";
    this.message = message || "The client is destroyed";
    this.code = "UND_ERR_DESTROYED";
  }
};
let ClientClosedError$3 = class ClientClosedError extends UndiciError$5 {
  constructor(message) {
    super(message);
    this.name = "ClientClosedError";
    this.message = message || "The client is closed";
    this.code = "UND_ERR_CLOSED";
  }
};
let SocketError$9 = class SocketError extends UndiciError$5 {
  constructor(message, socket) {
    super(message);
    this.name = "SocketError";
    this.message = message || "Socket error";
    this.code = "UND_ERR_SOCKET";
    this.socket = socket;
  }
};
let NotSupportedError$5 = class NotSupportedError extends UndiciError$5 {
  constructor(message) {
    super(message);
    this.name = "NotSupportedError";
    this.message = message || "Not supported error";
    this.code = "UND_ERR_NOT_SUPPORTED";
  }
};
let BalancedPoolMissingUpstreamError$3 = class BalancedPoolMissingUpstreamError extends UndiciError$5 {
  constructor(message) {
    super(message);
    this.name = "MissingUpstreamError";
    this.message = message || "No upstream has been added to the BalancedPool";
    this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
  }
};
let HTTPParserError$3 = class HTTPParserError extends Error {
  constructor(message, code, data) {
    super(message);
    this.name = "HTTPParserError";
    this.code = code ? `HPE_${code}` : void 0;
    this.data = data ? data.toString() : void 0;
  }
};
let ResponseExceededMaxSizeError$3 = class ResponseExceededMaxSizeError extends UndiciError$5 {
  constructor(message) {
    super(message);
    this.name = "ResponseExceededMaxSizeError";
    this.message = message || "Response content exceeded max size";
    this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
  }
};
let RequestRetryError$3 = class RequestRetryError extends UndiciError$5 {
  constructor(message, code, { headers: headers2, data }) {
    super(message);
    this.name = "RequestRetryError";
    this.message = message || "Request retry error";
    this.code = "UND_ERR_REQ_RETRY";
    this.statusCode = code;
    this.data = data;
    this.headers = headers2;
  }
};
let ResponseError$2 = class ResponseError extends UndiciError$5 {
  constructor(message, code, { headers: headers2, body: body2 }) {
    super(message);
    this.name = "ResponseError";
    this.message = message || "Response error";
    this.code = "UND_ERR_RESPONSE";
    this.statusCode = code;
    this.body = body2;
    this.headers = headers2;
  }
};
let SecureProxyConnectionError$3 = class SecureProxyConnectionError extends UndiciError$5 {
  constructor(cause, message, options = {}) {
    super(message, { cause, ...options });
    this.name = "SecureProxyConnectionError";
    this.message = message || "Secure Proxy Connection failed";
    this.code = "UND_ERR_PRX_TLS";
    this.cause = cause;
  }
};
var errors$2 = {
  AbortError: AbortError$4,
  HTTPParserError: HTTPParserError$3,
  UndiciError: UndiciError$5,
  HeadersTimeoutError: HeadersTimeoutError$3,
  HeadersOverflowError: HeadersOverflowError$3,
  BodyTimeoutError: BodyTimeoutError$3,
  RequestContentLengthMismatchError: RequestContentLengthMismatchError$5,
  ConnectTimeoutError: ConnectTimeoutError$3,
  ResponseStatusCodeError: ResponseStatusCodeError$2,
  InvalidArgumentError: InvalidArgumentError$Q,
  InvalidReturnValueError: InvalidReturnValueError$5,
  RequestAbortedError: RequestAbortedError$h,
  ClientDestroyedError: ClientDestroyedError$5,
  ClientClosedError: ClientClosedError$3,
  InformationalError: InformationalError$9,
  SocketError: SocketError$9,
  NotSupportedError: NotSupportedError$5,
  ResponseContentLengthMismatchError: ResponseContentLengthMismatchError$3,
  BalancedPoolMissingUpstreamError: BalancedPoolMissingUpstreamError$3,
  ResponseExceededMaxSizeError: ResponseExceededMaxSizeError$3,
  RequestRetryError: RequestRetryError$3,
  ResponseError: ResponseError$2,
  SecureProxyConnectionError: SecureProxyConnectionError$3
};
const wellknownHeaderNames$3 = (
  /** @type {const} */
  [
    "Accept",
    "Accept-Encoding",
    "Accept-Language",
    "Accept-Ranges",
    "Access-Control-Allow-Credentials",
    "Access-Control-Allow-Headers",
    "Access-Control-Allow-Methods",
    "Access-Control-Allow-Origin",
    "Access-Control-Expose-Headers",
    "Access-Control-Max-Age",
    "Access-Control-Request-Headers",
    "Access-Control-Request-Method",
    "Age",
    "Allow",
    "Alt-Svc",
    "Alt-Used",
    "Authorization",
    "Cache-Control",
    "Clear-Site-Data",
    "Connection",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-Length",
    "Content-Location",
    "Content-Range",
    "Content-Security-Policy",
    "Content-Security-Policy-Report-Only",
    "Content-Type",
    "Cookie",
    "Cross-Origin-Embedder-Policy",
    "Cross-Origin-Opener-Policy",
    "Cross-Origin-Resource-Policy",
    "Date",
    "Device-Memory",
    "Downlink",
    "ECT",
    "ETag",
    "Expect",
    "Expect-CT",
    "Expires",
    "Forwarded",
    "From",
    "Host",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Range",
    "If-Unmodified-Since",
    "Keep-Alive",
    "Last-Modified",
    "Link",
    "Location",
    "Max-Forwards",
    "Origin",
    "Permissions-Policy",
    "Pragma",
    "Proxy-Authenticate",
    "Proxy-Authorization",
    "RTT",
    "Range",
    "Referer",
    "Referrer-Policy",
    "Refresh",
    "Retry-After",
    "Sec-WebSocket-Accept",
    "Sec-WebSocket-Extensions",
    "Sec-WebSocket-Key",
    "Sec-WebSocket-Protocol",
    "Sec-WebSocket-Version",
    "Server",
    "Server-Timing",
    "Service-Worker-Allowed",
    "Service-Worker-Navigation-Preload",
    "Set-Cookie",
    "SourceMap",
    "Strict-Transport-Security",
    "Supports-Loading-Mode",
    "TE",
    "Timing-Allow-Origin",
    "Trailer",
    "Transfer-Encoding",
    "Upgrade",
    "Upgrade-Insecure-Requests",
    "User-Agent",
    "Vary",
    "Via",
    "WWW-Authenticate",
    "X-Content-Type-Options",
    "X-DNS-Prefetch-Control",
    "X-Frame-Options",
    "X-Permitted-Cross-Domain-Policies",
    "X-Powered-By",
    "X-Requested-With",
    "X-XSS-Protection"
  ]
);
const headerNameLowerCasedRecord$7 = {};
Object.setPrototypeOf(headerNameLowerCasedRecord$7, null);
const wellknownHeaderNameBuffers = {};
Object.setPrototypeOf(wellknownHeaderNameBuffers, null);
for (let i = 0; i < wellknownHeaderNames$3.length; ++i) {
  const key = wellknownHeaderNames$3[i];
  const lowerCasedKey = key.toLowerCase();
  headerNameLowerCasedRecord$7[key] = headerNameLowerCasedRecord$7[lowerCasedKey] = lowerCasedKey;
}
var constants$c = {
  wellknownHeaderNames: wellknownHeaderNames$3,
  headerNameLowerCasedRecord: headerNameLowerCasedRecord$7
};
const {
  wellknownHeaderNames: wellknownHeaderNames$2,
  headerNameLowerCasedRecord: headerNameLowerCasedRecord$6
} = constants$c;
let TstNode$1 = class TstNode {
  /**
   * @param {string} key
   * @param {any} value
   * @param {number} index
   */
  constructor(key, value, index) {
    /** @type {any} */
    __publicField(this, "value", null);
    /** @type {null | TstNode} */
    __publicField(this, "left", null);
    /** @type {null | TstNode} */
    __publicField(this, "middle", null);
    /** @type {null | TstNode} */
    __publicField(this, "right", null);
    /** @type {number} */
    __publicField(this, "code");
    if (index === void 0 || index >= key.length) {
      throw new TypeError("Unreachable");
    }
    const code = this.code = key.charCodeAt(index);
    if (code > 127) {
      throw new TypeError("key must be ascii string");
    }
    if (key.length !== ++index) {
      this.middle = new TstNode(key, value, index);
    } else {
      this.value = value;
    }
  }
  /**
   * @param {string} key
   * @param {any} value
   * @returns {void}
   */
  add(key, value) {
    const length = key.length;
    if (length === 0) {
      throw new TypeError("Unreachable");
    }
    let index = 0;
    let node2 = this;
    while (true) {
      const code = key.charCodeAt(index);
      if (code > 127) {
        throw new TypeError("key must be ascii string");
      }
      if (node2.code === code) {
        if (length === ++index) {
          node2.value = value;
          break;
        } else if (node2.middle !== null) {
          node2 = node2.middle;
        } else {
          node2.middle = new TstNode(key, value, index);
          break;
        }
      } else if (node2.code < code) {
        if (node2.left !== null) {
          node2 = node2.left;
        } else {
          node2.left = new TstNode(key, value, index);
          break;
        }
      } else if (node2.right !== null) {
        node2 = node2.right;
      } else {
        node2.right = new TstNode(key, value, index);
        break;
      }
    }
  }
  /**
   * @param {Uint8Array} key
   * @return {TstNode | null}
   */
  search(key) {
    const keylength = key.length;
    let index = 0;
    let node2 = this;
    while (node2 !== null && index < keylength) {
      let code = key[index];
      if (code <= 90 && code >= 65) {
        code |= 32;
      }
      while (node2 !== null) {
        if (code === node2.code) {
          if (keylength === ++index) {
            return node2;
          }
          node2 = node2.middle;
          break;
        }
        node2 = node2.code < code ? node2.left : node2.right;
      }
    }
    return null;
  }
};
let TernarySearchTree$1 = class TernarySearchTree {
  constructor() {
    /** @type {TstNode | null} */
    __publicField(this, "node", null);
  }
  /**
   * @param {string} key
   * @param {any} value
   * @returns {void}
   * */
  insert(key, value) {
    if (this.node === null) {
      this.node = new TstNode$1(key, value, 0);
    } else {
      this.node.add(key, value);
    }
  }
  /**
   * @param {Uint8Array} key
   * @returns {any}
   */
  lookup(key) {
    var _a2, _b2;
    return ((_b2 = (_a2 = this.node) == null ? void 0 : _a2.search(key)) == null ? void 0 : _b2.value) ?? null;
  }
};
const tree$3 = new TernarySearchTree$1();
for (let i = 0; i < wellknownHeaderNames$2.length; ++i) {
  const key = headerNameLowerCasedRecord$6[wellknownHeaderNames$2[i]];
  tree$3.insert(key, key);
}
var tree_1$1 = {
  tree: tree$3
};
const assert$v = require$$0$3;
const { kDestroyed: kDestroyed$5, kBodyUsed: kBodyUsed$3, kListeners: kListeners$1, kBody: kBody$5 } = symbols$5;
const { IncomingMessage: IncomingMessage$1 } = require$$2$1;
const stream$3 = require$$0$4;
const net$6 = require$$0$5;
const { Blob: Blob$2 } = require$$0$1;
const nodeUtil$1 = require$$0$2;
const { stringify: stringify$1 } = require$$7;
const { EventEmitter: EE$3 } = require$$8$1;
const { InvalidArgumentError: InvalidArgumentError$P } = errors$2;
const { headerNameLowerCasedRecord: headerNameLowerCasedRecord$5 } = constants$c;
const { tree: tree$2 } = tree_1$1;
const [nodeMajor$1, nodeMinor$1] = process.versions.node.split(".").map((v) => Number(v));
let BodyAsyncIterable$3 = class BodyAsyncIterable {
  constructor(body2) {
    this[kBody$5] = body2;
    this[kBodyUsed$3] = false;
  }
  async *[Symbol.asyncIterator]() {
    assert$v(!this[kBodyUsed$3], "disturbed");
    this[kBodyUsed$3] = true;
    yield* this[kBody$5];
  }
};
function wrapRequestBody$3(body2) {
  if (isStream$3(body2)) {
    if (bodyLength$1(body2) === 0) {
      body2.on("data", function() {
        assert$v(false);
      });
    }
    if (typeof body2.readableDidRead !== "boolean") {
      body2[kBodyUsed$3] = false;
      EE$3.prototype.on.call(body2, "data", function() {
        this[kBodyUsed$3] = true;
      });
    }
    return body2;
  } else if (body2 && typeof body2.pipeTo === "function") {
    return new BodyAsyncIterable$3(body2);
  } else if (body2 && typeof body2 !== "string" && !ArrayBuffer.isView(body2) && isIterable$4(body2)) {
    return new BodyAsyncIterable$3(body2);
  } else {
    return body2;
  }
}
function isStream$3(obj) {
  return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
}
function isBlobLike$3(object) {
  if (object === null) {
    return false;
  } else if (object instanceof Blob$2) {
    return true;
  } else if (typeof object !== "object") {
    return false;
  } else {
    const sTag = object[Symbol.toStringTag];
    return (sTag === "Blob" || sTag === "File") && ("stream" in object && typeof object.stream === "function" || "arrayBuffer" in object && typeof object.arrayBuffer === "function");
  }
}
function serializePathWithQuery$3(url, queryParams) {
  if (url.includes("?") || url.includes("#")) {
    throw new Error('Query params cannot be passed when url already contains "?" or "#".');
  }
  const stringified = stringify$1(queryParams);
  if (stringified) {
    url += "?" + stringified;
  }
  return url;
}
function isValidPort$1(port) {
  const value = parseInt(port, 10);
  return value === Number(port) && value >= 0 && value <= 65535;
}
function isHttpOrHttpsPrefixed$1(value) {
  return value != null && value[0] === "h" && value[1] === "t" && value[2] === "t" && value[3] === "p" && (value[4] === ":" || value[4] === "s" && value[5] === ":");
}
function parseURL$1(url) {
  if (typeof url === "string") {
    url = new URL(url);
    if (!isHttpOrHttpsPrefixed$1(url.origin || url.protocol)) {
      throw new InvalidArgumentError$P("Invalid URL protocol: the URL must start with `http:` or `https:`.");
    }
    return url;
  }
  if (!url || typeof url !== "object") {
    throw new InvalidArgumentError$P("Invalid URL: The URL argument must be a non-null object.");
  }
  if (!(url instanceof URL)) {
    if (url.port != null && url.port !== "" && isValidPort$1(url.port) === false) {
      throw new InvalidArgumentError$P("Invalid URL: port must be a valid integer or a string representation of an integer.");
    }
    if (url.path != null && typeof url.path !== "string") {
      throw new InvalidArgumentError$P("Invalid URL path: the path must be a string or null/undefined.");
    }
    if (url.pathname != null && typeof url.pathname !== "string") {
      throw new InvalidArgumentError$P("Invalid URL pathname: the pathname must be a string or null/undefined.");
    }
    if (url.hostname != null && typeof url.hostname !== "string") {
      throw new InvalidArgumentError$P("Invalid URL hostname: the hostname must be a string or null/undefined.");
    }
    if (url.origin != null && typeof url.origin !== "string") {
      throw new InvalidArgumentError$P("Invalid URL origin: the origin must be a string or null/undefined.");
    }
    if (!isHttpOrHttpsPrefixed$1(url.origin || url.protocol)) {
      throw new InvalidArgumentError$P("Invalid URL protocol: the URL must start with `http:` or `https:`.");
    }
    const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
    let origin = url.origin != null ? url.origin : `${url.protocol || ""}//${url.hostname || ""}:${port}`;
    let path2 = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
    if (origin[origin.length - 1] === "/") {
      origin = origin.slice(0, origin.length - 1);
    }
    if (path2 && path2[0] !== "/") {
      path2 = `/${path2}`;
    }
    return new URL(`${origin}${path2}`);
  }
  if (!isHttpOrHttpsPrefixed$1(url.origin || url.protocol)) {
    throw new InvalidArgumentError$P("Invalid URL protocol: the URL must start with `http:` or `https:`.");
  }
  return url;
}
function parseOrigin$3(url) {
  url = parseURL$1(url);
  if (url.pathname !== "/" || url.search || url.hash) {
    throw new InvalidArgumentError$P("invalid url");
  }
  return url;
}
function getHostname$2(host) {
  if (host[0] === "[") {
    const idx2 = host.indexOf("]");
    assert$v(idx2 !== -1);
    return host.substring(1, idx2);
  }
  const idx = host.indexOf(":");
  if (idx === -1) return host;
  return host.substring(0, idx);
}
function getServerName$3(host) {
  if (!host) {
    return null;
  }
  assert$v(typeof host === "string");
  const servername = getHostname$2(host);
  if (net$6.isIP(servername)) {
    return "";
  }
  return servername;
}
function deepClone$1(obj) {
  return JSON.parse(JSON.stringify(obj));
}
function isAsyncIterable$1(obj) {
  return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
}
function isIterable$4(obj) {
  return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
}
function bodyLength$1(body2) {
  if (body2 == null) {
    return 0;
  } else if (isStream$3(body2)) {
    const state = body2._readableState;
    return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
  } else if (isBlobLike$3(body2)) {
    return body2.size != null ? body2.size : null;
  } else if (isBuffer$3(body2)) {
    return body2.byteLength;
  }
  return null;
}
function isDestroyed$1(body2) {
  var _a2;
  return body2 && !!(body2.destroyed || body2[kDestroyed$5] || ((_a2 = stream$3.isDestroyed) == null ? void 0 : _a2.call(stream$3, body2)));
}
function destroy$3(stream2, err) {
  if (stream2 == null || !isStream$3(stream2) || isDestroyed$1(stream2)) {
    return;
  }
  if (typeof stream2.destroy === "function") {
    if (Object.getPrototypeOf(stream2).constructor === IncomingMessage$1) {
      stream2.socket = null;
    }
    stream2.destroy(err);
  } else if (err) {
    queueMicrotask(() => {
      stream2.emit("error", err);
    });
  }
  if (stream2.destroyed !== true) {
    stream2[kDestroyed$5] = true;
  }
}
const KEEPALIVE_TIMEOUT_EXPR$1 = /timeout=(\d+)/;
function parseKeepAliveTimeout$1(val) {
  const m = val.match(KEEPALIVE_TIMEOUT_EXPR$1);
  return m ? parseInt(m[1], 10) * 1e3 : null;
}
function headerNameToString$1(value) {
  return typeof value === "string" ? headerNameLowerCasedRecord$5[value] ?? value.toLowerCase() : tree$2.lookup(value) ?? value.toString("latin1").toLowerCase();
}
function bufferToLowerCasedHeaderName$1(value) {
  return tree$2.lookup(value) ?? value.toString("latin1").toLowerCase();
}
function parseHeaders$3(headers2, obj) {
  if (obj === void 0) obj = {};
  for (let i = 0; i < headers2.length; i += 2) {
    const key = headerNameToString$1(headers2[i]);
    let val = obj[key];
    if (val) {
      if (typeof val === "string") {
        val = [val];
        obj[key] = val;
      }
      val.push(headers2[i + 1].toString("utf8"));
    } else {
      const headersValue = headers2[i + 1];
      if (typeof headersValue === "string") {
        obj[key] = headersValue;
      } else {
        obj[key] = Array.isArray(headersValue) ? headersValue.map((x) => x.toString("utf8")) : headersValue.toString("utf8");
      }
    }
  }
  if ("content-length" in obj && "content-disposition" in obj) {
    obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
  }
  return obj;
}
function parseRawHeaders$1(headers2) {
  const headersLength = headers2.length;
  const ret = new Array(headersLength);
  let hasContentLength = false;
  let contentDispositionIdx = -1;
  let key;
  let val;
  let kLen = 0;
  for (let n = 0; n < headersLength; n += 2) {
    key = headers2[n];
    val = headers2[n + 1];
    typeof key !== "string" && (key = key.toString());
    typeof val !== "string" && (val = val.toString("utf8"));
    kLen = key.length;
    if (kLen === 14 && key[7] === "-" && (key === "content-length" || key.toLowerCase() === "content-length")) {
      hasContentLength = true;
    } else if (kLen === 19 && key[7] === "-" && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
      contentDispositionIdx = n + 1;
    }
    ret[n] = key;
    ret[n + 1] = val;
  }
  if (hasContentLength && contentDispositionIdx !== -1) {
    ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
  }
  return ret;
}
function encodeRawHeaders(headers2) {
  if (!Array.isArray(headers2)) {
    throw new TypeError("expected headers to be an array");
  }
  return headers2.map((x) => Buffer.from(x));
}
function isBuffer$3(buffer) {
  return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
}
function assertRequestHandler$1(handler, method, upgrade2) {
  if (!handler || typeof handler !== "object") {
    throw new InvalidArgumentError$P("handler must be an object");
  }
  if (typeof handler.onRequestStart === "function") {
    return;
  }
  if (typeof handler.onConnect !== "function") {
    throw new InvalidArgumentError$P("invalid onConnect method");
  }
  if (typeof handler.onError !== "function") {
    throw new InvalidArgumentError$P("invalid onError method");
  }
  if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) {
    throw new InvalidArgumentError$P("invalid onBodySent method");
  }
  if (upgrade2 || method === "CONNECT") {
    if (typeof handler.onUpgrade !== "function") {
      throw new InvalidArgumentError$P("invalid onUpgrade method");
    }
  } else {
    if (typeof handler.onHeaders !== "function") {
      throw new InvalidArgumentError$P("invalid onHeaders method");
    }
    if (typeof handler.onData !== "function") {
      throw new InvalidArgumentError$P("invalid onData method");
    }
    if (typeof handler.onComplete !== "function") {
      throw new InvalidArgumentError$P("invalid onComplete method");
    }
  }
}
function isDisturbed$3(body2) {
  return !!(body2 && (stream$3.isDisturbed(body2) || body2[kBodyUsed$3]));
}
function getSocketInfo$1(socket) {
  return {
    localAddress: socket.localAddress,
    localPort: socket.localPort,
    remoteAddress: socket.remoteAddress,
    remotePort: socket.remotePort,
    remoteFamily: socket.remoteFamily,
    timeout: socket.timeout,
    bytesWritten: socket.bytesWritten,
    bytesRead: socket.bytesRead
  };
}
function ReadableStreamFrom$3(iterable) {
  let iterator;
  return new ReadableStream(
    {
      async start() {
        iterator = iterable[Symbol.asyncIterator]();
      },
      pull(controller) {
        async function pull() {
          const { done, value } = await iterator.next();
          if (done) {
            queueMicrotask(() => {
              var _a2;
              controller.close();
              (_a2 = controller.byobRequest) == null ? void 0 : _a2.respond(0);
            });
          } else {
            const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
            if (buf.byteLength) {
              controller.enqueue(new Uint8Array(buf));
            } else {
              return await pull();
            }
          }
        }
        return pull();
      },
      async cancel() {
        await iterator.return();
      },
      type: "bytes"
    }
  );
}
function isFormDataLike$3(object) {
  return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
}
function addAbortListener$3(signal, listener) {
  if ("addEventListener" in signal) {
    signal.addEventListener("abort", listener, { once: true });
    return () => signal.removeEventListener("abort", listener);
  }
  signal.once("abort", listener);
  return () => signal.removeListener("abort", listener);
}
const toUSVString$1 = (() => {
  if (typeof String.prototype.toWellFormed === "function") {
    return (value) => `${value}`.toWellFormed();
  } else {
    return nodeUtil$1.toUSVString;
  }
})();
const isUSVString$1 = (() => {
  if (typeof String.prototype.isWellFormed === "function") {
    return (value) => `${value}`.isWellFormed();
  } else {
    return (value) => toUSVString$1(value) === `${value}`;
  }
})();
function isTokenCharCode$1(c) {
  switch (c) {
    case 34:
    case 40:
    case 41:
    case 44:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 123:
    case 125:
      return false;
    default:
      return c >= 33 && c <= 126;
  }
}
function isValidHTTPToken$3(characters) {
  if (characters.length === 0) {
    return false;
  }
  for (let i = 0; i < characters.length; ++i) {
    if (!isTokenCharCode$1(characters.charCodeAt(i))) {
      return false;
    }
  }
  return true;
}
const headerCharRegex$1 = /[^\t\x20-\x7e\x80-\xff]/;
function isValidHeaderValue$3(characters) {
  return !headerCharRegex$1.test(characters);
}
const rangeHeaderRegex = /^bytes (\d+)-(\d+)\/(\d+)?$/;
function parseRangeHeader$3(range) {
  if (range == null || range === "") return { start: 0, end: null, size: null };
  const m = range ? range.match(rangeHeaderRegex) : null;
  return m ? {
    start: parseInt(m[1]),
    end: m[2] ? parseInt(m[2]) : null,
    size: m[3] ? parseInt(m[3]) : null
  } : null;
}
function addListener$2(obj, name, listener) {
  const listeners = obj[kListeners$1] ?? (obj[kListeners$1] = []);
  listeners.push([name, listener]);
  obj.on(name, listener);
  return obj;
}
function removeAllListeners$3(obj) {
  if (obj[kListeners$1] != null) {
    for (const [name, listener] of obj[kListeners$1]) {
      obj.removeListener(name, listener);
    }
    obj[kListeners$1] = null;
  }
  return obj;
}
function errorRequest$1(client2, request2, err) {
  try {
    request2.onError(err);
    assert$v(request2.aborted);
  } catch (err2) {
    client2.emit("error", err2);
  }
}
const kEnumerableProperty$1 = /* @__PURE__ */ Object.create(null);
kEnumerableProperty$1.enumerable = true;
const normalizedMethodRecordsBase$1 = {
  delete: "DELETE",
  DELETE: "DELETE",
  get: "GET",
  GET: "GET",
  head: "HEAD",
  HEAD: "HEAD",
  options: "OPTIONS",
  OPTIONS: "OPTIONS",
  post: "POST",
  POST: "POST",
  put: "PUT",
  PUT: "PUT"
};
const normalizedMethodRecords$3 = {
  ...normalizedMethodRecordsBase$1,
  patch: "patch",
  PATCH: "PATCH"
};
Object.setPrototypeOf(normalizedMethodRecordsBase$1, null);
Object.setPrototypeOf(normalizedMethodRecords$3, null);
var util$J = {
  kEnumerableProperty: kEnumerableProperty$1,
  isDisturbed: isDisturbed$3,
  toUSVString: toUSVString$1,
  isUSVString: isUSVString$1,
  isBlobLike: isBlobLike$3,
  parseOrigin: parseOrigin$3,
  parseURL: parseURL$1,
  getServerName: getServerName$3,
  isStream: isStream$3,
  isIterable: isIterable$4,
  isAsyncIterable: isAsyncIterable$1,
  isDestroyed: isDestroyed$1,
  headerNameToString: headerNameToString$1,
  bufferToLowerCasedHeaderName: bufferToLowerCasedHeaderName$1,
  addListener: addListener$2,
  removeAllListeners: removeAllListeners$3,
  errorRequest: errorRequest$1,
  parseRawHeaders: parseRawHeaders$1,
  encodeRawHeaders,
  parseHeaders: parseHeaders$3,
  parseKeepAliveTimeout: parseKeepAliveTimeout$1,
  destroy: destroy$3,
  bodyLength: bodyLength$1,
  deepClone: deepClone$1,
  ReadableStreamFrom: ReadableStreamFrom$3,
  isBuffer: isBuffer$3,
  assertRequestHandler: assertRequestHandler$1,
  getSocketInfo: getSocketInfo$1,
  isFormDataLike: isFormDataLike$3,
  serializePathWithQuery: serializePathWithQuery$3,
  addAbortListener: addAbortListener$3,
  isValidHTTPToken: isValidHTTPToken$3,
  isValidHeaderValue: isValidHeaderValue$3,
  isTokenCharCode: isTokenCharCode$1,
  parseRangeHeader: parseRangeHeader$3,
  normalizedMethodRecordsBase: normalizedMethodRecordsBase$1,
  normalizedMethodRecords: normalizedMethodRecords$3,
  isValidPort: isValidPort$1,
  isHttpOrHttpsPrefixed: isHttpOrHttpsPrefixed$1,
  nodeMajor: nodeMajor$1,
  nodeMinor: nodeMinor$1,
  safeHTTPMethods: Object.freeze(["GET", "HEAD", "OPTIONS", "TRACE"]),
  wrapRequestBody: wrapRequestBody$3
};
const diagnosticsChannel$1 = require$$0$6;
const util$I = require$$0$2;
const undiciDebugLog$1 = util$I.debuglog("undici");
const fetchDebuglog$1 = util$I.debuglog("fetch");
const websocketDebuglog$1 = util$I.debuglog("websocket");
const channels$8 = {
  // Client
  beforeConnect: diagnosticsChannel$1.channel("undici:client:beforeConnect"),
  connected: diagnosticsChannel$1.channel("undici:client:connected"),
  connectError: diagnosticsChannel$1.channel("undici:client:connectError"),
  sendHeaders: diagnosticsChannel$1.channel("undici:client:sendHeaders"),
  // Request
  create: diagnosticsChannel$1.channel("undici:request:create"),
  bodySent: diagnosticsChannel$1.channel("undici:request:bodySent"),
  headers: diagnosticsChannel$1.channel("undici:request:headers"),
  trailers: diagnosticsChannel$1.channel("undici:request:trailers"),
  error: diagnosticsChannel$1.channel("undici:request:error"),
  // WebSocket
  open: diagnosticsChannel$1.channel("undici:websocket:open"),
  close: diagnosticsChannel$1.channel("undici:websocket:close"),
  socketError: diagnosticsChannel$1.channel("undici:websocket:socket_error"),
  ping: diagnosticsChannel$1.channel("undici:websocket:ping"),
  pong: diagnosticsChannel$1.channel("undici:websocket:pong")
};
let isTrackingClientEvents = false;
function trackClientEvents(debugLog = undiciDebugLog$1) {
  if (isTrackingClientEvents) {
    return;
  }
  isTrackingClientEvents = true;
  diagnosticsChannel$1.subscribe(
    "undici:client:beforeConnect",
    (evt) => {
      const {
        connectParams: { version: version2, protocol, port, host }
      } = evt;
      debugLog(
        "connecting to %s%s using %s%s",
        host,
        port ? `:${port}` : "",
        protocol,
        version2
      );
    }
  );
  diagnosticsChannel$1.subscribe(
    "undici:client:connected",
    (evt) => {
      const {
        connectParams: { version: version2, protocol, port, host }
      } = evt;
      debugLog(
        "connected to %s%s using %s%s",
        host,
        port ? `:${port}` : "",
        protocol,
        version2
      );
    }
  );
  diagnosticsChannel$1.subscribe(
    "undici:client:connectError",
    (evt) => {
      const {
        connectParams: { version: version2, protocol, port, host },
        error
      } = evt;
      debugLog(
        "connection to %s%s using %s%s errored - %s",
        host,
        port ? `:${port}` : "",
        protocol,
        version2,
        error.message
      );
    }
  );
  diagnosticsChannel$1.subscribe(
    "undici:client:sendHeaders",
    (evt) => {
      const {
        request: { method, path: path2, origin }
      } = evt;
      debugLog("sending request to %s %s/%s", method, origin, path2);
    }
  );
}
let isTrackingRequestEvents = false;
function trackRequestEvents(debugLog = undiciDebugLog$1) {
  if (isTrackingRequestEvents) {
    return;
  }
  isTrackingRequestEvents = true;
  diagnosticsChannel$1.subscribe(
    "undici:request:headers",
    (evt) => {
      const {
        request: { method, path: path2, origin },
        response: { statusCode }
      } = evt;
      debugLog(
        "received response to %s %s/%s - HTTP %d",
        method,
        origin,
        path2,
        statusCode
      );
    }
  );
  diagnosticsChannel$1.subscribe(
    "undici:request:trailers",
    (evt) => {
      const {
        request: { method, path: path2, origin }
      } = evt;
      debugLog("trailers received from %s %s/%s", method, origin, path2);
    }
  );
  diagnosticsChannel$1.subscribe(
    "undici:request:error",
    (evt) => {
      const {
        request: { method, path: path2, origin },
        error
      } = evt;
      debugLog(
        "request to %s %s/%s errored - %s",
        method,
        origin,
        path2,
        error.message
      );
    }
  );
}
let isTrackingWebSocketEvents = false;
function trackWebSocketEvents(debugLog = websocketDebuglog$1) {
  if (isTrackingWebSocketEvents) {
    return;
  }
  isTrackingWebSocketEvents = true;
  diagnosticsChannel$1.subscribe(
    "undici:websocket:open",
    (evt) => {
      const {
        address: { address, port }
      } = evt;
      debugLog("connection opened %s%s", address, port ? `:${port}` : "");
    }
  );
  diagnosticsChannel$1.subscribe(
    "undici:websocket:close",
    (evt) => {
      const { websocket: websocket2, code, reason } = evt;
      debugLog(
        "closed connection to %s - %s %s",
        websocket2.url,
        code,
        reason
      );
    }
  );
  diagnosticsChannel$1.subscribe(
    "undici:websocket:socket_error",
    (err) => {
      debugLog("connection errored - %s", err.message);
    }
  );
  diagnosticsChannel$1.subscribe(
    "undici:websocket:ping",
    (evt) => {
      debugLog("ping received");
    }
  );
  diagnosticsChannel$1.subscribe(
    "undici:websocket:pong",
    (evt) => {
      debugLog("pong received");
    }
  );
}
if (undiciDebugLog$1.enabled || fetchDebuglog$1.enabled) {
  trackClientEvents(fetchDebuglog$1.enabled ? fetchDebuglog$1 : undiciDebugLog$1);
  trackRequestEvents(fetchDebuglog$1.enabled ? fetchDebuglog$1 : undiciDebugLog$1);
}
if (websocketDebuglog$1.enabled) {
  trackClientEvents(undiciDebugLog$1.enabled ? undiciDebugLog$1 : websocketDebuglog$1);
  trackWebSocketEvents(websocketDebuglog$1);
}
var diagnostics$1 = {
  channels: channels$8
};
const {
  InvalidArgumentError: InvalidArgumentError$O,
  NotSupportedError: NotSupportedError$4
} = errors$2;
const assert$u = require$$0$3;
const {
  isValidHTTPToken: isValidHTTPToken$2,
  isValidHeaderValue: isValidHeaderValue$2,
  isStream: isStream$2,
  destroy: destroy$2,
  isBuffer: isBuffer$2,
  isFormDataLike: isFormDataLike$2,
  isIterable: isIterable$3,
  isBlobLike: isBlobLike$2,
  serializePathWithQuery: serializePathWithQuery$2,
  assertRequestHandler,
  getServerName: getServerName$2,
  normalizedMethodRecords: normalizedMethodRecords$2
} = util$J;
const { channels: channels$7 } = diagnostics$1;
const { headerNameLowerCasedRecord: headerNameLowerCasedRecord$4 } = constants$c;
const invalidPathRegex$1 = /[^\u0021-\u00ff]/;
const kHandler$1 = Symbol("handler");
let Request$3 = class Request {
  constructor(origin, {
    path: path2,
    method,
    body: body2,
    headers: headers2,
    query,
    idempotent,
    blocking,
    upgrade: upgrade2,
    headersTimeout,
    bodyTimeout,
    reset,
    expectContinue,
    servername,
    throwOnError
  }, handler) {
    if (typeof path2 !== "string") {
      throw new InvalidArgumentError$O("path must be a string");
    } else if (path2[0] !== "/" && !(path2.startsWith("http://") || path2.startsWith("https://")) && method !== "CONNECT") {
      throw new InvalidArgumentError$O("path must be an absolute URL or start with a slash");
    } else if (invalidPathRegex$1.test(path2)) {
      throw new InvalidArgumentError$O("invalid request path");
    }
    if (typeof method !== "string") {
      throw new InvalidArgumentError$O("method must be a string");
    } else if (normalizedMethodRecords$2[method] === void 0 && !isValidHTTPToken$2(method)) {
      throw new InvalidArgumentError$O("invalid request method");
    }
    if (upgrade2 && typeof upgrade2 !== "string") {
      throw new InvalidArgumentError$O("upgrade must be a string");
    }
    if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
      throw new InvalidArgumentError$O("invalid headersTimeout");
    }
    if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
      throw new InvalidArgumentError$O("invalid bodyTimeout");
    }
    if (reset != null && typeof reset !== "boolean") {
      throw new InvalidArgumentError$O("invalid reset");
    }
    if (expectContinue != null && typeof expectContinue !== "boolean") {
      throw new InvalidArgumentError$O("invalid expectContinue");
    }
    if (throwOnError != null) {
      throw new InvalidArgumentError$O("invalid throwOnError");
    }
    this.headersTimeout = headersTimeout;
    this.bodyTimeout = bodyTimeout;
    this.method = method;
    this.abort = null;
    if (body2 == null) {
      this.body = null;
    } else if (isStream$2(body2)) {
      this.body = body2;
      const rState = this.body._readableState;
      if (!rState || !rState.autoDestroy) {
        this.endHandler = function autoDestroy() {
          destroy$2(this);
        };
        this.body.on("end", this.endHandler);
      }
      this.errorHandler = (err) => {
        if (this.abort) {
          this.abort(err);
        } else {
          this.error = err;
        }
      };
      this.body.on("error", this.errorHandler);
    } else if (isBuffer$2(body2)) {
      this.body = body2.byteLength ? body2 : null;
    } else if (ArrayBuffer.isView(body2)) {
      this.body = body2.buffer.byteLength ? Buffer.from(body2.buffer, body2.byteOffset, body2.byteLength) : null;
    } else if (body2 instanceof ArrayBuffer) {
      this.body = body2.byteLength ? Buffer.from(body2) : null;
    } else if (typeof body2 === "string") {
      this.body = body2.length ? Buffer.from(body2) : null;
    } else if (isFormDataLike$2(body2) || isIterable$3(body2) || isBlobLike$2(body2)) {
      this.body = body2;
    } else {
      throw new InvalidArgumentError$O("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
    }
    this.completed = false;
    this.aborted = false;
    this.upgrade = upgrade2 || null;
    this.path = query ? serializePathWithQuery$2(path2, query) : path2;
    this.origin = origin;
    this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
    this.blocking = blocking ?? this.method !== "HEAD";
    this.reset = reset == null ? null : reset;
    this.host = null;
    this.contentLength = null;
    this.contentType = null;
    this.headers = [];
    this.expectContinue = expectContinue != null ? expectContinue : false;
    if (Array.isArray(headers2)) {
      if (headers2.length % 2 !== 0) {
        throw new InvalidArgumentError$O("headers array must be even");
      }
      for (let i = 0; i < headers2.length; i += 2) {
        processHeader$1(this, headers2[i], headers2[i + 1]);
      }
    } else if (headers2 && typeof headers2 === "object") {
      if (headers2[Symbol.iterator]) {
        for (const header of headers2) {
          if (!Array.isArray(header) || header.length !== 2) {
            throw new InvalidArgumentError$O("headers must be in key-value pair format");
          }
          processHeader$1(this, header[0], header[1]);
        }
      } else {
        const keys = Object.keys(headers2);
        for (let i = 0; i < keys.length; ++i) {
          processHeader$1(this, keys[i], headers2[keys[i]]);
        }
      }
    } else if (headers2 != null) {
      throw new InvalidArgumentError$O("headers must be an object or an array");
    }
    assertRequestHandler(handler, method, upgrade2);
    this.servername = servername || getServerName$2(this.host) || null;
    this[kHandler$1] = handler;
    if (channels$7.create.hasSubscribers) {
      channels$7.create.publish({ request: this });
    }
  }
  onBodySent(chunk) {
    if (this[kHandler$1].onBodySent) {
      try {
        return this[kHandler$1].onBodySent(chunk);
      } catch (err) {
        this.abort(err);
      }
    }
  }
  onRequestSent() {
    if (channels$7.bodySent.hasSubscribers) {
      channels$7.bodySent.publish({ request: this });
    }
    if (this[kHandler$1].onRequestSent) {
      try {
        return this[kHandler$1].onRequestSent();
      } catch (err) {
        this.abort(err);
      }
    }
  }
  onConnect(abort2) {
    assert$u(!this.aborted);
    assert$u(!this.completed);
    if (this.error) {
      abort2(this.error);
    } else {
      this.abort = abort2;
      return this[kHandler$1].onConnect(abort2);
    }
  }
  onResponseStarted() {
    var _a2, _b2;
    return (_b2 = (_a2 = this[kHandler$1]).onResponseStarted) == null ? void 0 : _b2.call(_a2);
  }
  onHeaders(statusCode, headers2, resume2, statusText) {
    assert$u(!this.aborted);
    assert$u(!this.completed);
    if (channels$7.headers.hasSubscribers) {
      channels$7.headers.publish({ request: this, response: { statusCode, headers: headers2, statusText } });
    }
    try {
      return this[kHandler$1].onHeaders(statusCode, headers2, resume2, statusText);
    } catch (err) {
      this.abort(err);
    }
  }
  onData(chunk) {
    assert$u(!this.aborted);
    assert$u(!this.completed);
    try {
      return this[kHandler$1].onData(chunk);
    } catch (err) {
      this.abort(err);
      return false;
    }
  }
  onUpgrade(statusCode, headers2, socket) {
    assert$u(!this.aborted);
    assert$u(!this.completed);
    return this[kHandler$1].onUpgrade(statusCode, headers2, socket);
  }
  onComplete(trailers) {
    this.onFinally();
    assert$u(!this.aborted);
    assert$u(!this.completed);
    this.completed = true;
    if (channels$7.trailers.hasSubscribers) {
      channels$7.trailers.publish({ request: this, trailers });
    }
    try {
      return this[kHandler$1].onComplete(trailers);
    } catch (err) {
      this.onError(err);
    }
  }
  onError(error) {
    this.onFinally();
    if (channels$7.error.hasSubscribers) {
      channels$7.error.publish({ request: this, error });
    }
    if (this.aborted) {
      return;
    }
    this.aborted = true;
    return this[kHandler$1].onError(error);
  }
  onFinally() {
    if (this.errorHandler) {
      this.body.off("error", this.errorHandler);
      this.errorHandler = null;
    }
    if (this.endHandler) {
      this.body.off("end", this.endHandler);
      this.endHandler = null;
    }
  }
  addHeader(key, value) {
    processHeader$1(this, key, value);
    return this;
  }
};
function processHeader$1(request2, key, val) {
  if (val && (typeof val === "object" && !Array.isArray(val))) {
    throw new InvalidArgumentError$O(`invalid ${key} header`);
  } else if (val === void 0) {
    return;
  }
  let headerName = headerNameLowerCasedRecord$4[key];
  if (headerName === void 0) {
    headerName = key.toLowerCase();
    if (headerNameLowerCasedRecord$4[headerName] === void 0 && !isValidHTTPToken$2(headerName)) {
      throw new InvalidArgumentError$O("invalid header key");
    }
  }
  if (Array.isArray(val)) {
    const arr = [];
    for (let i = 0; i < val.length; i++) {
      if (typeof val[i] === "string") {
        if (!isValidHeaderValue$2(val[i])) {
          throw new InvalidArgumentError$O(`invalid ${key} header`);
        }
        arr.push(val[i]);
      } else if (val[i] === null) {
        arr.push("");
      } else if (typeof val[i] === "object") {
        throw new InvalidArgumentError$O(`invalid ${key} header`);
      } else {
        arr.push(`${val[i]}`);
      }
    }
    val = arr;
  } else if (typeof val === "string") {
    if (!isValidHeaderValue$2(val)) {
      throw new InvalidArgumentError$O(`invalid ${key} header`);
    }
  } else if (val === null) {
    val = "";
  } else {
    val = `${val}`;
  }
  if (request2.host === null && headerName === "host") {
    if (typeof val !== "string") {
      throw new InvalidArgumentError$O("invalid host header");
    }
    request2.host = val;
  } else if (request2.contentLength === null && headerName === "content-length") {
    request2.contentLength = parseInt(val, 10);
    if (!Number.isFinite(request2.contentLength)) {
      throw new InvalidArgumentError$O("invalid content-length header");
    }
  } else if (request2.contentType === null && headerName === "content-type") {
    request2.contentType = val;
    request2.headers.push(key, val);
  } else if (headerName === "transfer-encoding" || headerName === "keep-alive" || headerName === "upgrade") {
    throw new InvalidArgumentError$O(`invalid ${headerName} header`);
  } else if (headerName === "connection") {
    const value = typeof val === "string" ? val.toLowerCase() : null;
    if (value !== "close" && value !== "keep-alive") {
      throw new InvalidArgumentError$O("invalid connection header");
    }
    if (value === "close") {
      request2.reset = true;
    }
  } else if (headerName === "expect") {
    throw new NotSupportedError$4("expect header not supported");
  } else {
    request2.headers.push(key, val);
  }
}
var request$5 = Request$3;
const { InvalidArgumentError: InvalidArgumentError$N } = errors$2;
var wrapHandler = (_a = class {
  constructor(handler) {
    __privateAdd(this, _handler);
    __privateSet(this, _handler, handler);
  }
  static wrap(handler) {
    return handler.onRequestStart ? handler : new _a(handler);
  }
  // Unwrap Interface
  onConnect(abort2, context) {
    var _a2, _b2;
    return (_b2 = (_a2 = __privateGet(this, _handler)).onConnect) == null ? void 0 : _b2.call(_a2, abort2, context);
  }
  onHeaders(statusCode, rawHeaders, resume2, statusMessage) {
    var _a2, _b2;
    return (_b2 = (_a2 = __privateGet(this, _handler)).onHeaders) == null ? void 0 : _b2.call(_a2, statusCode, rawHeaders, resume2, statusMessage);
  }
  onUpgrade(statusCode, rawHeaders, socket) {
    var _a2, _b2;
    return (_b2 = (_a2 = __privateGet(this, _handler)).onUpgrade) == null ? void 0 : _b2.call(_a2, statusCode, rawHeaders, socket);
  }
  onData(data) {
    var _a2, _b2;
    return (_b2 = (_a2 = __privateGet(this, _handler)).onData) == null ? void 0 : _b2.call(_a2, data);
  }
  onComplete(trailers) {
    var _a2, _b2;
    return (_b2 = (_a2 = __privateGet(this, _handler)).onComplete) == null ? void 0 : _b2.call(_a2, trailers);
  }
  onError(err) {
    var _a2, _b2;
    if (!__privateGet(this, _handler).onError) {
      throw err;
    }
    return (_b2 = (_a2 = __privateGet(this, _handler)).onError) == null ? void 0 : _b2.call(_a2, err);
  }
  // Wrap Interface
  onRequestStart(controller, context) {
    var _a2, _b2;
    (_b2 = (_a2 = __privateGet(this, _handler)).onConnect) == null ? void 0 : _b2.call(_a2, (reason) => controller.abort(reason), context);
  }
  onRequestUpgrade(controller, statusCode, headers2, socket) {
    var _a2, _b2;
    const rawHeaders = [];
    for (const [key, val] of Object.entries(headers2)) {
      rawHeaders.push(Buffer.from(key), Array.isArray(val) ? val.map((v) => Buffer.from(v)) : Buffer.from(val));
    }
    (_b2 = (_a2 = __privateGet(this, _handler)).onUpgrade) == null ? void 0 : _b2.call(_a2, statusCode, rawHeaders, socket);
  }
  onResponseStart(controller, statusCode, headers2, statusMessage) {
    var _a2, _b2;
    const rawHeaders = [];
    for (const [key, val] of Object.entries(headers2)) {
      rawHeaders.push(Buffer.from(key), Array.isArray(val) ? val.map((v) => Buffer.from(v)) : Buffer.from(val));
    }
    if (((_b2 = (_a2 = __privateGet(this, _handler)).onHeaders) == null ? void 0 : _b2.call(_a2, statusCode, rawHeaders, () => controller.resume(), statusMessage)) === false) {
      controller.pause();
    }
  }
  onResponseData(controller, data) {
    var _a2, _b2;
    if (((_b2 = (_a2 = __privateGet(this, _handler)).onData) == null ? void 0 : _b2.call(_a2, data)) === false) {
      controller.pause();
    }
  }
  onResponseEnd(controller, trailers) {
    var _a2, _b2;
    const rawTrailers = [];
    for (const [key, val] of Object.entries(trailers)) {
      rawTrailers.push(Buffer.from(key), Array.isArray(val) ? val.map((v) => Buffer.from(v)) : Buffer.from(val));
    }
    (_b2 = (_a2 = __privateGet(this, _handler)).onComplete) == null ? void 0 : _b2.call(_a2, rawTrailers);
  }
  onResponseError(controller, err) {
    var _a2, _b2;
    if (!__privateGet(this, _handler).onError) {
      throw new InvalidArgumentError$N("invalid onError method");
    }
    (_b2 = (_a2 = __privateGet(this, _handler)).onError) == null ? void 0 : _b2.call(_a2, err);
  }
}, _handler = new WeakMap(), _a);
const EventEmitter$1 = require$$8$1;
const WrapHandler$2 = wrapHandler;
const wrapInterceptor = (dispatch) => (opts, handler) => dispatch(opts, WrapHandler$2.wrap(handler));
let Dispatcher$8 = class Dispatcher extends EventEmitter$1 {
  dispatch() {
    throw new Error("not implemented");
  }
  close() {
    throw new Error("not implemented");
  }
  destroy() {
    throw new Error("not implemented");
  }
  compose(...args) {
    const interceptors = Array.isArray(args[0]) ? args[0] : args;
    let dispatch = this.dispatch.bind(this);
    for (const interceptor of interceptors) {
      if (interceptor == null) {
        continue;
      }
      if (typeof interceptor !== "function") {
        throw new TypeError(`invalid interceptor, expected function received ${typeof interceptor}`);
      }
      dispatch = interceptor(dispatch);
      dispatch = wrapInterceptor(dispatch);
      if (dispatch == null || typeof dispatch !== "function" || dispatch.length !== 2) {
        throw new TypeError("invalid interceptor");
      }
    }
    return new Proxy(this, {
      get: (target, key) => key === "dispatch" ? dispatch : target[key]
    });
  }
};
var dispatcher$1 = Dispatcher$8;
const { parseHeaders: parseHeaders$2 } = util$J;
const { InvalidArgumentError: InvalidArgumentError$M } = errors$2;
const kResume$8 = Symbol("resume");
_b = kResume$8;
class UnwrapController {
  constructor(abort2) {
    __privateAdd(this, _paused, false);
    __privateAdd(this, _reason, null);
    __privateAdd(this, _aborted, false);
    __privateAdd(this, _abort);
    __publicField(this, _b, null);
    __privateSet(this, _abort, abort2);
  }
  pause() {
    __privateSet(this, _paused, true);
  }
  resume() {
    var _a2;
    if (__privateGet(this, _paused)) {
      __privateSet(this, _paused, false);
      (_a2 = this[kResume$8]) == null ? void 0 : _a2.call(this);
    }
  }
  abort(reason) {
    if (!__privateGet(this, _aborted)) {
      __privateSet(this, _aborted, true);
      __privateSet(this, _reason, reason);
      __privateGet(this, _abort).call(this, reason);
    }
  }
  get aborted() {
    return __privateGet(this, _aborted);
  }
  get reason() {
    return __privateGet(this, _reason);
  }
  get paused() {
    return __privateGet(this, _paused);
  }
}
_paused = new WeakMap();
_reason = new WeakMap();
_aborted = new WeakMap();
_abort = new WeakMap();
var unwrapHandler = (_c = class {
  constructor(handler) {
    __privateAdd(this, _handler2);
    __privateAdd(this, _controller);
    __privateSet(this, _handler2, handler);
  }
  static unwrap(handler) {
    return !handler.onRequestStart ? handler : new _c(handler);
  }
  onConnect(abort2, context) {
    var _a2, _b2;
    __privateSet(this, _controller, new UnwrapController(abort2));
    (_b2 = (_a2 = __privateGet(this, _handler2)).onRequestStart) == null ? void 0 : _b2.call(_a2, __privateGet(this, _controller), context);
  }
  onUpgrade(statusCode, rawHeaders, socket) {
    var _a2, _b2;
    (_b2 = (_a2 = __privateGet(this, _handler2)).onRequestUpgrade) == null ? void 0 : _b2.call(_a2, __privateGet(this, _controller), statusCode, parseHeaders$2(rawHeaders), socket);
  }
  onHeaders(statusCode, rawHeaders, resume2, statusMessage) {
    var _a2, _b2;
    __privateGet(this, _controller)[kResume$8] = resume2;
    (_b2 = (_a2 = __privateGet(this, _handler2)).onResponseStart) == null ? void 0 : _b2.call(_a2, __privateGet(this, _controller), statusCode, parseHeaders$2(rawHeaders), statusMessage);
    return !__privateGet(this, _controller).paused;
  }
  onData(data) {
    var _a2, _b2;
    (_b2 = (_a2 = __privateGet(this, _handler2)).onResponseData) == null ? void 0 : _b2.call(_a2, __privateGet(this, _controller), data);
    return !__privateGet(this, _controller).paused;
  }
  onComplete(rawTrailers) {
    var _a2, _b2;
    (_b2 = (_a2 = __privateGet(this, _handler2)).onResponseEnd) == null ? void 0 : _b2.call(_a2, __privateGet(this, _controller), parseHeaders$2(rawTrailers));
  }
  onError(err) {
    var _a2, _b2;
    if (!__privateGet(this, _handler2).onResponseError) {
      throw new InvalidArgumentError$M("invalid onError method");
    }
    (_b2 = (_a2 = __privateGet(this, _handler2)).onResponseError) == null ? void 0 : _b2.call(_a2, __privateGet(this, _controller), err);
  }
}, _handler2 = new WeakMap(), _controller = new WeakMap(), _c);
const Dispatcher$7 = dispatcher$1;
const UnwrapHandler = unwrapHandler;
const {
  ClientDestroyedError: ClientDestroyedError$4,
  ClientClosedError: ClientClosedError$2,
  InvalidArgumentError: InvalidArgumentError$L
} = errors$2;
const { kDestroy: kDestroy$b, kClose: kClose$f, kClosed: kClosed$5, kDestroyed: kDestroyed$4, kDispatch: kDispatch$9 } = symbols$5;
const kOnDestroyed$1 = Symbol("onDestroyed");
const kOnClosed$1 = Symbol("onClosed");
let DispatcherBase$b = class DispatcherBase extends Dispatcher$7 {
  constructor() {
    super();
    this[kDestroyed$4] = false;
    this[kOnDestroyed$1] = null;
    this[kClosed$5] = false;
    this[kOnClosed$1] = [];
  }
  get destroyed() {
    return this[kDestroyed$4];
  }
  get closed() {
    return this[kClosed$5];
  }
  close(callback) {
    if (callback === void 0) {
      return new Promise((resolve2, reject) => {
        this.close((err, data) => {
          return err ? reject(err) : resolve2(data);
        });
      });
    }
    if (typeof callback !== "function") {
      throw new InvalidArgumentError$L("invalid callback");
    }
    if (this[kDestroyed$4]) {
      queueMicrotask(() => callback(new ClientDestroyedError$4(), null));
      return;
    }
    if (this[kClosed$5]) {
      if (this[kOnClosed$1]) {
        this[kOnClosed$1].push(callback);
      } else {
        queueMicrotask(() => callback(null, null));
      }
      return;
    }
    this[kClosed$5] = true;
    this[kOnClosed$1].push(callback);
    const onClosed = () => {
      const callbacks = this[kOnClosed$1];
      this[kOnClosed$1] = null;
      for (let i = 0; i < callbacks.length; i++) {
        callbacks[i](null, null);
      }
    };
    this[kClose$f]().then(() => this.destroy()).then(() => {
      queueMicrotask(onClosed);
    });
  }
  destroy(err, callback) {
    if (typeof err === "function") {
      callback = err;
      err = null;
    }
    if (callback === void 0) {
      return new Promise((resolve2, reject) => {
        this.destroy(err, (err2, data) => {
          return err2 ? (
            /* istanbul ignore next: should never error */
            reject(err2)
          ) : resolve2(data);
        });
      });
    }
    if (typeof callback !== "function") {
      throw new InvalidArgumentError$L("invalid callback");
    }
    if (this[kDestroyed$4]) {
      if (this[kOnDestroyed$1]) {
        this[kOnDestroyed$1].push(callback);
      } else {
        queueMicrotask(() => callback(null, null));
      }
      return;
    }
    if (!err) {
      err = new ClientDestroyedError$4();
    }
    this[kDestroyed$4] = true;
    this[kOnDestroyed$1] = this[kOnDestroyed$1] || [];
    this[kOnDestroyed$1].push(callback);
    const onDestroyed = () => {
      const callbacks = this[kOnDestroyed$1];
      this[kOnDestroyed$1] = null;
      for (let i = 0; i < callbacks.length; i++) {
        callbacks[i](null, null);
      }
    };
    this[kDestroy$b](err).then(() => {
      queueMicrotask(onDestroyed);
    });
  }
  dispatch(opts, handler) {
    if (!handler || typeof handler !== "object") {
      throw new InvalidArgumentError$L("handler must be an object");
    }
    handler = UnwrapHandler.unwrap(handler);
    try {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError$L("opts must be an object.");
      }
      if (this[kDestroyed$4] || this[kOnDestroyed$1]) {
        throw new ClientDestroyedError$4();
      }
      if (this[kClosed$5]) {
        throw new ClientClosedError$2();
      }
      return this[kDispatch$9](opts, handler);
    } catch (err) {
      if (typeof handler.onError !== "function") {
        throw err;
      }
      handler.onError(err);
      return false;
    }
  }
};
var dispatcherBase$1 = DispatcherBase$b;
let fastNow$1 = 0;
const RESOLUTION_MS$1 = 1e3;
const TICK_MS$1 = (RESOLUTION_MS$1 >> 1) - 1;
let fastNowTimeout$1;
const kFastTimer$1 = Symbol("kFastTimer");
const fastTimers$1 = [];
const NOT_IN_LIST$1 = -2;
const TO_BE_CLEARED$1 = -1;
const PENDING$1 = 0;
const ACTIVE$1 = 1;
function onTick$1() {
  fastNow$1 += TICK_MS$1;
  let idx = 0;
  let len = fastTimers$1.length;
  while (idx < len) {
    const timer = fastTimers$1[idx];
    if (timer._state === PENDING$1) {
      timer._idleStart = fastNow$1 - TICK_MS$1;
      timer._state = ACTIVE$1;
    } else if (timer._state === ACTIVE$1 && fastNow$1 >= timer._idleStart + timer._idleTimeout) {
      timer._state = TO_BE_CLEARED$1;
      timer._idleStart = -1;
      timer._onTimeout(timer._timerArg);
    }
    if (timer._state === TO_BE_CLEARED$1) {
      timer._state = NOT_IN_LIST$1;
      if (--len !== 0) {
        fastTimers$1[idx] = fastTimers$1[len];
      }
    } else {
      ++idx;
    }
  }
  fastTimers$1.length = len;
  if (fastTimers$1.length !== 0) {
    refreshTimeout$1();
  }
}
function refreshTimeout$1() {
  if (fastNowTimeout$1) {
    fastNowTimeout$1.refresh();
  } else {
    clearTimeout(fastNowTimeout$1);
    fastNowTimeout$1 = setTimeout(onTick$1, TICK_MS$1);
    if (fastNowTimeout$1.unref) {
      fastNowTimeout$1.unref();
    }
  }
}
let FastTimer$1 = (_d = kFastTimer$1, class FastTimer {
  /**
   * @constructor
   * @param {Function} callback A function to be executed after the timer
   * expires.
   * @param {number} delay The time, in milliseconds that the timer should wait
   * before the specified function or code is executed.
   * @param {*} arg
   */
  constructor(callback, delay, arg) {
    __publicField(this, _d, true);
    /**
     * The state of the timer, which can be one of the following:
     * - NOT_IN_LIST (-2)
     * - TO_BE_CLEARED (-1)
     * - PENDING (0)
     * - ACTIVE (1)
     *
     * @type {-2|-1|0|1}
     * @private
     */
    __publicField(this, "_state", NOT_IN_LIST$1);
    /**
     * The number of milliseconds to wait before calling the callback.
     *
     * @type {number}
     * @private
     */
    __publicField(this, "_idleTimeout", -1);
    /**
     * The time in milliseconds when the timer was started. This value is used to
     * calculate when the timer should expire.
     *
     * @type {number}
     * @default -1
     * @private
     */
    __publicField(this, "_idleStart", -1);
    /**
     * The function to be executed when the timer expires.
     * @type {Function}
     * @private
     */
    __publicField(this, "_onTimeout");
    /**
     * The argument to be passed to the callback when the timer expires.
     *
     * @type {*}
     * @private
     */
    __publicField(this, "_timerArg");
    this._onTimeout = callback;
    this._idleTimeout = delay;
    this._timerArg = arg;
    this.refresh();
  }
  /**
   * Sets the timer's start time to the current time, and reschedules the timer
   * to call its callback at the previously specified duration adjusted to the
   * current time.
   * Using this on a timer that has already called its callback will reactivate
   * the timer.
   *
   * @returns {void}
   */
  refresh() {
    if (this._state === NOT_IN_LIST$1) {
      fastTimers$1.push(this);
    }
    if (!fastNowTimeout$1 || fastTimers$1.length === 1) {
      refreshTimeout$1();
    }
    this._state = PENDING$1;
  }
  /**
   * The `clear` method cancels the timer, preventing it from executing.
   *
   * @returns {void}
   * @private
   */
  clear() {
    this._state = TO_BE_CLEARED$1;
    this._idleStart = -1;
  }
});
var timers$5 = {
  /**
   * The setTimeout() method sets a timer which executes a function once the
   * timer expires.
   * @param {Function} callback A function to be executed after the timer
   * expires.
   * @param {number} delay The time, in milliseconds that the timer should
   * wait before the specified function or code is executed.
   * @param {*} [arg] An optional argument to be passed to the callback function
   * when the timer expires.
   * @returns {NodeJS.Timeout|FastTimer}
   */
  setTimeout(callback, delay, arg) {
    return delay <= RESOLUTION_MS$1 ? setTimeout(callback, delay, arg) : new FastTimer$1(callback, delay, arg);
  },
  /**
   * The clearTimeout method cancels an instantiated Timer previously created
   * by calling setTimeout.
   *
   * @param {NodeJS.Timeout|FastTimer} timeout
   */
  clearTimeout(timeout) {
    if (timeout[kFastTimer$1]) {
      timeout.clear();
    } else {
      clearTimeout(timeout);
    }
  },
  /**
   * The setFastTimeout() method sets a fastTimer which executes a function once
   * the timer expires.
   * @param {Function} callback A function to be executed after the timer
   * expires.
   * @param {number} delay The time, in milliseconds that the timer should
   * wait before the specified function or code is executed.
   * @param {*} [arg] An optional argument to be passed to the callback function
   * when the timer expires.
   * @returns {FastTimer}
   */
  setFastTimeout(callback, delay, arg) {
    return new FastTimer$1(callback, delay, arg);
  },
  /**
   * The clearTimeout method cancels an instantiated FastTimer previously
   * created by calling setFastTimeout.
   *
   * @param {FastTimer} timeout
   */
  clearFastTimeout(timeout) {
    timeout.clear();
  },
  /**
   * The now method returns the value of the internal fast timer clock.
   *
   * @returns {number}
   */
  now() {
    return fastNow$1;
  },
  /**
   * Trigger the onTick function to process the fastTimers array.
   * Exported for testing purposes only.
   * Marking as deprecated to discourage any use outside of testing.
   * @deprecated
   * @param {number} [delay=0] The delay in milliseconds to add to the now value.
   */
  tick(delay = 0) {
    fastNow$1 += delay - RESOLUTION_MS$1 + 1;
    onTick$1();
    onTick$1();
  },
  /**
   * Reset FastTimers.
   * Exported for testing purposes only.
   * Marking as deprecated to discourage any use outside of testing.
   * @deprecated
   */
  reset() {
    fastNow$1 = 0;
    fastTimers$1.length = 0;
    clearTimeout(fastNowTimeout$1);
    fastNowTimeout$1 = null;
  },
  /**
   * Exporting for testing purposes only.
   * Marking as deprecated to discourage any use outside of testing.
   * @deprecated
   */
  kFastTimer: kFastTimer$1
};
const net$5 = require$$0$5;
const assert$t = require$$0$3;
const util$H = util$J;
const { InvalidArgumentError: InvalidArgumentError$K, ConnectTimeoutError: ConnectTimeoutError$2 } = errors$2;
const timers$4 = timers$5;
function noop$c() {
}
let tls$2;
let SessionCache$1;
if (commonjsGlobal.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG)) {
  SessionCache$1 = class WeakSessionCache {
    constructor(maxCachedSessions) {
      this._maxCachedSessions = maxCachedSessions;
      this._sessionCache = /* @__PURE__ */ new Map();
      this._sessionRegistry = new commonjsGlobal.FinalizationRegistry((key) => {
        if (this._sessionCache.size < this._maxCachedSessions) {
          return;
        }
        const ref = this._sessionCache.get(key);
        if (ref !== void 0 && ref.deref() === void 0) {
          this._sessionCache.delete(key);
        }
      });
    }
    get(sessionKey) {
      const ref = this._sessionCache.get(sessionKey);
      return ref ? ref.deref() : null;
    }
    set(sessionKey, session) {
      if (this._maxCachedSessions === 0) {
        return;
      }
      this._sessionCache.set(sessionKey, new WeakRef(session));
      this._sessionRegistry.register(session, sessionKey);
    }
  };
} else {
  SessionCache$1 = class SimpleSessionCache {
    constructor(maxCachedSessions) {
      this._maxCachedSessions = maxCachedSessions;
      this._sessionCache = /* @__PURE__ */ new Map();
    }
    get(sessionKey) {
      return this._sessionCache.get(sessionKey);
    }
    set(sessionKey, session) {
      if (this._maxCachedSessions === 0) {
        return;
      }
      if (this._sessionCache.size >= this._maxCachedSessions) {
        const { value: oldestKey } = this._sessionCache.keys().next();
        this._sessionCache.delete(oldestKey);
      }
      this._sessionCache.set(sessionKey, session);
    }
  };
}
function buildConnector$8({ allowH2, maxCachedSessions, socketPath, timeout, session: customSession, ...opts }) {
  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
    throw new InvalidArgumentError$K("maxCachedSessions must be a positive integer or zero");
  }
  const options = { path: socketPath, ...opts };
  const sessionCache = new SessionCache$1(maxCachedSessions == null ? 100 : maxCachedSessions);
  timeout = timeout == null ? 1e4 : timeout;
  allowH2 = allowH2 != null ? allowH2 : false;
  return function connect2({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
    let socket;
    if (protocol === "https:") {
      if (!tls$2) {
        tls$2 = require$$5;
      }
      servername = servername || options.servername || util$H.getServerName(host) || null;
      const sessionKey = servername || hostname;
      assert$t(sessionKey);
      const session = customSession || sessionCache.get(sessionKey) || null;
      port = port || 443;
      socket = tls$2.connect({
        highWaterMark: 16384,
        // TLS in node can't have bigger HWM anyway...
        ...options,
        servername,
        session,
        localAddress,
        // TODO(HTTP/2): Add support for h2c
        ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
        socket: httpSocket,
        // upgrade socket connection
        port,
        host: hostname
      });
      socket.on("session", function(session2) {
        sessionCache.set(sessionKey, session2);
      });
    } else {
      assert$t(!httpSocket, "httpSocket can only be sent on TLS update");
      port = port || 80;
      socket = net$5.connect({
        highWaterMark: 64 * 1024,
        // Same as nodejs fs streams.
        ...options,
        localAddress,
        port,
        host: hostname
      });
    }
    if (options.keepAlive == null || options.keepAlive) {
      const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
      socket.setKeepAlive(true, keepAliveInitialDelay);
    }
    const clearConnectTimeout = setupConnectTimeout$1(new WeakRef(socket), { timeout, hostname, port });
    socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
      queueMicrotask(clearConnectTimeout);
      if (callback) {
        const cb = callback;
        callback = null;
        cb(null, this);
      }
    }).on("error", function(err) {
      queueMicrotask(clearConnectTimeout);
      if (callback) {
        const cb = callback;
        callback = null;
        cb(err);
      }
    });
    return socket;
  };
}
const setupConnectTimeout$1 = process.platform === "win32" ? (socketWeakRef, opts) => {
  if (!opts.timeout) {
    return noop$c;
  }
  let s1 = null;
  let s2 = null;
  const fastTimer = timers$4.setFastTimeout(() => {
    s1 = setImmediate(() => {
      s2 = setImmediate(() => onConnectTimeout$1(socketWeakRef.deref(), opts));
    });
  }, opts.timeout);
  return () => {
    timers$4.clearFastTimeout(fastTimer);
    clearImmediate(s1);
    clearImmediate(s2);
  };
} : (socketWeakRef, opts) => {
  if (!opts.timeout) {
    return noop$c;
  }
  let s1 = null;
  const fastTimer = timers$4.setFastTimeout(() => {
    s1 = setImmediate(() => {
      onConnectTimeout$1(socketWeakRef.deref(), opts);
    });
  }, opts.timeout);
  return () => {
    timers$4.clearFastTimeout(fastTimer);
    clearImmediate(s1);
  };
};
function onConnectTimeout$1(socket, opts) {
  if (socket == null) {
    return;
  }
  let message = "Connect Timeout Error";
  if (Array.isArray(socket.autoSelectFamilyAttemptedAddresses)) {
    message += ` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(", ")},`;
  } else {
    message += ` (attempted address: ${opts.hostname}:${opts.port},`;
  }
  message += ` timeout: ${opts.timeout}ms)`;
  util$H.destroy(socket, new ConnectTimeoutError$2(message));
}
var connect$6 = buildConnector$8;
var constants$b = {};
var utils$4 = {};
Object.defineProperty(utils$4, "__esModule", { value: true });
utils$4.enumToMap = void 0;
function enumToMap$1(obj, filter = [], exceptions2 = []) {
  var _a2, _b2;
  const emptyFilter = ((_a2 = filter === null || filter === void 0 ? void 0 : filter.length) !== null && _a2 !== void 0 ? _a2 : 0) === 0;
  const emptyExceptions = ((_b2 = exceptions2 === null || exceptions2 === void 0 ? void 0 : exceptions2.length) !== null && _b2 !== void 0 ? _b2 : 0) === 0;
  return Object.fromEntries(Object.entries(obj).filter(([, value]) => {
    return typeof value === "number" && (emptyFilter || filter.includes(value)) && (emptyExceptions || !exceptions2.includes(value));
  }));
}
utils$4.enumToMap = enumToMap$1;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SPECIAL_HEADERS = exports.MINOR = exports.MAJOR = exports.HTAB_SP_VCHAR_OBS_TEXT = exports.QUOTED_STRING = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.HEX = exports.URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.STATUSES_HTTP = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.HEADER_STATE = exports.FINISH = exports.STATUSES = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;
  const utils_12 = utils$4;
  exports.ERROR = {
    OK: 0,
    INTERNAL: 1,
    STRICT: 2,
    CR_EXPECTED: 25,
    LF_EXPECTED: 3,
    UNEXPECTED_CONTENT_LENGTH: 4,
    UNEXPECTED_SPACE: 30,
    CLOSED_CONNECTION: 5,
    INVALID_METHOD: 6,
    INVALID_URL: 7,
    INVALID_CONSTANT: 8,
    INVALID_VERSION: 9,
    INVALID_HEADER_TOKEN: 10,
    INVALID_CONTENT_LENGTH: 11,
    INVALID_CHUNK_SIZE: 12,
    INVALID_STATUS: 13,
    INVALID_EOF_STATE: 14,
    INVALID_TRANSFER_ENCODING: 15,
    CB_MESSAGE_BEGIN: 16,
    CB_HEADERS_COMPLETE: 17,
    CB_MESSAGE_COMPLETE: 18,
    CB_CHUNK_HEADER: 19,
    CB_CHUNK_COMPLETE: 20,
    PAUSED: 21,
    PAUSED_UPGRADE: 22,
    PAUSED_H2_UPGRADE: 23,
    USER: 24,
    CB_URL_COMPLETE: 26,
    CB_STATUS_COMPLETE: 27,
    CB_METHOD_COMPLETE: 32,
    CB_VERSION_COMPLETE: 33,
    CB_HEADER_FIELD_COMPLETE: 28,
    CB_HEADER_VALUE_COMPLETE: 29,
    CB_CHUNK_EXTENSION_NAME_COMPLETE: 34,
    CB_CHUNK_EXTENSION_VALUE_COMPLETE: 35,
    CB_RESET: 31
  };
  exports.TYPE = {
    BOTH: 0,
    // default
    REQUEST: 1,
    RESPONSE: 2
  };
  exports.FLAGS = {
    CONNECTION_KEEP_ALIVE: 1 << 0,
    CONNECTION_CLOSE: 1 << 1,
    CONNECTION_UPGRADE: 1 << 2,
    CHUNKED: 1 << 3,
    UPGRADE: 1 << 4,
    CONTENT_LENGTH: 1 << 5,
    SKIPBODY: 1 << 6,
    TRAILING: 1 << 7,
    // 1 << 8 is unused
    TRANSFER_ENCODING: 1 << 9
  };
  exports.LENIENT_FLAGS = {
    HEADERS: 1 << 0,
    CHUNKED_LENGTH: 1 << 1,
    KEEP_ALIVE: 1 << 2,
    TRANSFER_ENCODING: 1 << 3,
    VERSION: 1 << 4,
    DATA_AFTER_CLOSE: 1 << 5,
    OPTIONAL_LF_AFTER_CR: 1 << 6,
    OPTIONAL_CRLF_AFTER_CHUNK: 1 << 7,
    OPTIONAL_CR_BEFORE_LF: 1 << 8,
    SPACES_AFTER_CHUNK_SIZE: 1 << 9
  };
  exports.METHODS = {
    "DELETE": 0,
    "GET": 1,
    "HEAD": 2,
    "POST": 3,
    "PUT": 4,
    /* pathological */
    "CONNECT": 5,
    "OPTIONS": 6,
    "TRACE": 7,
    /* WebDAV */
    "COPY": 8,
    "LOCK": 9,
    "MKCOL": 10,
    "MOVE": 11,
    "PROPFIND": 12,
    "PROPPATCH": 13,
    "SEARCH": 14,
    "UNLOCK": 15,
    "BIND": 16,
    "REBIND": 17,
    "UNBIND": 18,
    "ACL": 19,
    /* subversion */
    "REPORT": 20,
    "MKACTIVITY": 21,
    "CHECKOUT": 22,
    "MERGE": 23,
    /* upnp */
    "M-SEARCH": 24,
    "NOTIFY": 25,
    "SUBSCRIBE": 26,
    "UNSUBSCRIBE": 27,
    /* RFC-5789 */
    "PATCH": 28,
    "PURGE": 29,
    /* CalDAV */
    "MKCALENDAR": 30,
    /* RFC-2068, section 19.6.1.2 */
    "LINK": 31,
    "UNLINK": 32,
    /* icecast */
    "SOURCE": 33,
    /* RFC-7540, section 11.6 */
    "PRI": 34,
    /* RFC-2326 RTSP */
    "DESCRIBE": 35,
    "ANNOUNCE": 36,
    "SETUP": 37,
    "PLAY": 38,
    "PAUSE": 39,
    "TEARDOWN": 40,
    "GET_PARAMETER": 41,
    "SET_PARAMETER": 42,
    "REDIRECT": 43,
    "RECORD": 44,
    /* RAOP */
    "FLUSH": 45,
    /* DRAFT https://www.ietf.org/archive/id/draft-ietf-httpbis-safe-method-w-body-02.html */
    "QUERY": 46
  };
  exports.STATUSES = {
    CONTINUE: 100,
    SWITCHING_PROTOCOLS: 101,
    PROCESSING: 102,
    EARLY_HINTS: 103,
    RESPONSE_IS_STALE: 110,
    // Unofficial
    REVALIDATION_FAILED: 111,
    // Unofficial
    DISCONNECTED_OPERATION: 112,
    // Unofficial
    HEURISTIC_EXPIRATION: 113,
    // Unofficial
    MISCELLANEOUS_WARNING: 199,
    // Unofficial
    OK: 200,
    CREATED: 201,
    ACCEPTED: 202,
    NON_AUTHORITATIVE_INFORMATION: 203,
    NO_CONTENT: 204,
    RESET_CONTENT: 205,
    PARTIAL_CONTENT: 206,
    MULTI_STATUS: 207,
    ALREADY_REPORTED: 208,
    TRANSFORMATION_APPLIED: 214,
    // Unofficial
    IM_USED: 226,
    MISCELLANEOUS_PERSISTENT_WARNING: 299,
    // Unofficial
    MULTIPLE_CHOICES: 300,
    MOVED_PERMANENTLY: 301,
    FOUND: 302,
    SEE_OTHER: 303,
    NOT_MODIFIED: 304,
    USE_PROXY: 305,
    SWITCH_PROXY: 306,
    // No longer used
    TEMPORARY_REDIRECT: 307,
    PERMANENT_REDIRECT: 308,
    BAD_REQUEST: 400,
    UNAUTHORIZED: 401,
    PAYMENT_REQUIRED: 402,
    FORBIDDEN: 403,
    NOT_FOUND: 404,
    METHOD_NOT_ALLOWED: 405,
    NOT_ACCEPTABLE: 406,
    PROXY_AUTHENTICATION_REQUIRED: 407,
    REQUEST_TIMEOUT: 408,
    CONFLICT: 409,
    GONE: 410,
    LENGTH_REQUIRED: 411,
    PRECONDITION_FAILED: 412,
    PAYLOAD_TOO_LARGE: 413,
    URI_TOO_LONG: 414,
    UNSUPPORTED_MEDIA_TYPE: 415,
    RANGE_NOT_SATISFIABLE: 416,
    EXPECTATION_FAILED: 417,
    IM_A_TEAPOT: 418,
    PAGE_EXPIRED: 419,
    // Unofficial
    ENHANCE_YOUR_CALM: 420,
    // Unofficial
    MISDIRECTED_REQUEST: 421,
    UNPROCESSABLE_ENTITY: 422,
    LOCKED: 423,
    FAILED_DEPENDENCY: 424,
    TOO_EARLY: 425,
    UPGRADE_REQUIRED: 426,
    PRECONDITION_REQUIRED: 428,
    TOO_MANY_REQUESTS: 429,
    REQUEST_HEADER_FIELDS_TOO_LARGE_UNOFFICIAL: 430,
    // Unofficial
    REQUEST_HEADER_FIELDS_TOO_LARGE: 431,
    LOGIN_TIMEOUT: 440,
    // Unofficial
    NO_RESPONSE: 444,
    // Unofficial
    RETRY_WITH: 449,
    // Unofficial
    BLOCKED_BY_PARENTAL_CONTROL: 450,
    // Unofficial
    UNAVAILABLE_FOR_LEGAL_REASONS: 451,
    CLIENT_CLOSED_LOAD_BALANCED_REQUEST: 460,
    // Unofficial
    INVALID_X_FORWARDED_FOR: 463,
    // Unofficial
    REQUEST_HEADER_TOO_LARGE: 494,
    // Unofficial
    SSL_CERTIFICATE_ERROR: 495,
    // Unofficial
    SSL_CERTIFICATE_REQUIRED: 496,
    // Unofficial
    HTTP_REQUEST_SENT_TO_HTTPS_PORT: 497,
    // Unofficial
    INVALID_TOKEN: 498,
    // Unofficial
    CLIENT_CLOSED_REQUEST: 499,
    // Unofficial
    INTERNAL_SERVER_ERROR: 500,
    NOT_IMPLEMENTED: 501,
    BAD_GATEWAY: 502,
    SERVICE_UNAVAILABLE: 503,
    GATEWAY_TIMEOUT: 504,
    HTTP_VERSION_NOT_SUPPORTED: 505,
    VARIANT_ALSO_NEGOTIATES: 506,
    INSUFFICIENT_STORAGE: 507,
    LOOP_DETECTED: 508,
    BANDWIDTH_LIMIT_EXCEEDED: 509,
    NOT_EXTENDED: 510,
    NETWORK_AUTHENTICATION_REQUIRED: 511,
    WEB_SERVER_UNKNOWN_ERROR: 520,
    // Unofficial
    WEB_SERVER_IS_DOWN: 521,
    // Unofficial
    CONNECTION_TIMEOUT: 522,
    // Unofficial
    ORIGIN_IS_UNREACHABLE: 523,
    // Unofficial
    TIMEOUT_OCCURED: 524,
    // Unofficial
    SSL_HANDSHAKE_FAILED: 525,
    // Unofficial
    INVALID_SSL_CERTIFICATE: 526,
    // Unofficial
    RAILGUN_ERROR: 527,
    // Unofficial
    SITE_IS_OVERLOADED: 529,
    // Unofficial
    SITE_IS_FROZEN: 530,
    // Unofficial
    IDENTITY_PROVIDER_AUTHENTICATION_ERROR: 561,
    // Unofficial
    NETWORK_READ_TIMEOUT: 598,
    // Unofficial
    NETWORK_CONNECT_TIMEOUT: 599
    // Unofficial
  };
  exports.FINISH = {
    SAFE: 0,
    SAFE_WITH_CB: 1,
    UNSAFE: 2
  };
  exports.HEADER_STATE = {
    GENERAL: 0,
    CONNECTION: 1,
    CONTENT_LENGTH: 2,
    TRANSFER_ENCODING: 3,
    UPGRADE: 4,
    CONNECTION_KEEP_ALIVE: 5,
    CONNECTION_CLOSE: 6,
    CONNECTION_UPGRADE: 7,
    TRANSFER_ENCODING_CHUNKED: 8
  };
  exports.METHODS_HTTP = [
    exports.METHODS.DELETE,
    exports.METHODS.GET,
    exports.METHODS.HEAD,
    exports.METHODS.POST,
    exports.METHODS.PUT,
    exports.METHODS.CONNECT,
    exports.METHODS.OPTIONS,
    exports.METHODS.TRACE,
    exports.METHODS.COPY,
    exports.METHODS.LOCK,
    exports.METHODS.MKCOL,
    exports.METHODS.MOVE,
    exports.METHODS.PROPFIND,
    exports.METHODS.PROPPATCH,
    exports.METHODS.SEARCH,
    exports.METHODS.UNLOCK,
    exports.METHODS.BIND,
    exports.METHODS.REBIND,
    exports.METHODS.UNBIND,
    exports.METHODS.ACL,
    exports.METHODS.REPORT,
    exports.METHODS.MKACTIVITY,
    exports.METHODS.CHECKOUT,
    exports.METHODS.MERGE,
    exports.METHODS["M-SEARCH"],
    exports.METHODS.NOTIFY,
    exports.METHODS.SUBSCRIBE,
    exports.METHODS.UNSUBSCRIBE,
    exports.METHODS.PATCH,
    exports.METHODS.PURGE,
    exports.METHODS.MKCALENDAR,
    exports.METHODS.LINK,
    exports.METHODS.UNLINK,
    exports.METHODS.PRI,
    // TODO(indutny): should we allow it with HTTP?
    exports.METHODS.SOURCE,
    exports.METHODS.QUERY
  ];
  exports.METHODS_ICE = [
    exports.METHODS.SOURCE
  ];
  exports.METHODS_RTSP = [
    exports.METHODS.OPTIONS,
    exports.METHODS.DESCRIBE,
    exports.METHODS.ANNOUNCE,
    exports.METHODS.SETUP,
    exports.METHODS.PLAY,
    exports.METHODS.PAUSE,
    exports.METHODS.TEARDOWN,
    exports.METHODS.GET_PARAMETER,
    exports.METHODS.SET_PARAMETER,
    exports.METHODS.REDIRECT,
    exports.METHODS.RECORD,
    exports.METHODS.FLUSH,
    // For AirPlay
    exports.METHODS.GET,
    exports.METHODS.POST
  ];
  exports.METHOD_MAP = (0, utils_12.enumToMap)(exports.METHODS);
  exports.H_METHOD_MAP = Object.fromEntries(Object.entries(exports.METHODS).filter(([k]) => k.startsWith("H")));
  exports.STATUSES_HTTP = [
    exports.STATUSES.CONTINUE,
    exports.STATUSES.SWITCHING_PROTOCOLS,
    exports.STATUSES.PROCESSING,
    exports.STATUSES.EARLY_HINTS,
    exports.STATUSES.RESPONSE_IS_STALE,
    exports.STATUSES.REVALIDATION_FAILED,
    exports.STATUSES.DISCONNECTED_OPERATION,
    exports.STATUSES.HEURISTIC_EXPIRATION,
    exports.STATUSES.MISCELLANEOUS_WARNING,
    exports.STATUSES.OK,
    exports.STATUSES.CREATED,
    exports.STATUSES.ACCEPTED,
    exports.STATUSES.NON_AUTHORITATIVE_INFORMATION,
    exports.STATUSES.NO_CONTENT,
    exports.STATUSES.RESET_CONTENT,
    exports.STATUSES.PARTIAL_CONTENT,
    exports.STATUSES.MULTI_STATUS,
    exports.STATUSES.ALREADY_REPORTED,
    exports.STATUSES.TRANSFORMATION_APPLIED,
    exports.STATUSES.IM_USED,
    exports.STATUSES.MISCELLANEOUS_PERSISTENT_WARNING,
    exports.STATUSES.MULTIPLE_CHOICES,
    exports.STATUSES.MOVED_PERMANENTLY,
    exports.STATUSES.FOUND,
    exports.STATUSES.SEE_OTHER,
    exports.STATUSES.NOT_MODIFIED,
    exports.STATUSES.USE_PROXY,
    exports.STATUSES.SWITCH_PROXY,
    exports.STATUSES.TEMPORARY_REDIRECT,
    exports.STATUSES.PERMANENT_REDIRECT,
    exports.STATUSES.BAD_REQUEST,
    exports.STATUSES.UNAUTHORIZED,
    exports.STATUSES.PAYMENT_REQUIRED,
    exports.STATUSES.FORBIDDEN,
    exports.STATUSES.NOT_FOUND,
    exports.STATUSES.METHOD_NOT_ALLOWED,
    exports.STATUSES.NOT_ACCEPTABLE,
    exports.STATUSES.PROXY_AUTHENTICATION_REQUIRED,
    exports.STATUSES.REQUEST_TIMEOUT,
    exports.STATUSES.CONFLICT,
    exports.STATUSES.GONE,
    exports.STATUSES.LENGTH_REQUIRED,
    exports.STATUSES.PRECONDITION_FAILED,
    exports.STATUSES.PAYLOAD_TOO_LARGE,
    exports.STATUSES.URI_TOO_LONG,
    exports.STATUSES.UNSUPPORTED_MEDIA_TYPE,
    exports.STATUSES.RANGE_NOT_SATISFIABLE,
    exports.STATUSES.EXPECTATION_FAILED,
    exports.STATUSES.IM_A_TEAPOT,
    exports.STATUSES.PAGE_EXPIRED,
    exports.STATUSES.ENHANCE_YOUR_CALM,
    exports.STATUSES.MISDIRECTED_REQUEST,
    exports.STATUSES.UNPROCESSABLE_ENTITY,
    exports.STATUSES.LOCKED,
    exports.STATUSES.FAILED_DEPENDENCY,
    exports.STATUSES.TOO_EARLY,
    exports.STATUSES.UPGRADE_REQUIRED,
    exports.STATUSES.PRECONDITION_REQUIRED,
    exports.STATUSES.TOO_MANY_REQUESTS,
    exports.STATUSES.REQUEST_HEADER_FIELDS_TOO_LARGE_UNOFFICIAL,
    exports.STATUSES.REQUEST_HEADER_FIELDS_TOO_LARGE,
    exports.STATUSES.LOGIN_TIMEOUT,
    exports.STATUSES.NO_RESPONSE,
    exports.STATUSES.RETRY_WITH,
    exports.STATUSES.BLOCKED_BY_PARENTAL_CONTROL,
    exports.STATUSES.UNAVAILABLE_FOR_LEGAL_REASONS,
    exports.STATUSES.CLIENT_CLOSED_LOAD_BALANCED_REQUEST,
    exports.STATUSES.INVALID_X_FORWARDED_FOR,
    exports.STATUSES.REQUEST_HEADER_TOO_LARGE,
    exports.STATUSES.SSL_CERTIFICATE_ERROR,
    exports.STATUSES.SSL_CERTIFICATE_REQUIRED,
    exports.STATUSES.HTTP_REQUEST_SENT_TO_HTTPS_PORT,
    exports.STATUSES.INVALID_TOKEN,
    exports.STATUSES.CLIENT_CLOSED_REQUEST,
    exports.STATUSES.INTERNAL_SERVER_ERROR,
    exports.STATUSES.NOT_IMPLEMENTED,
    exports.STATUSES.BAD_GATEWAY,
    exports.STATUSES.SERVICE_UNAVAILABLE,
    exports.STATUSES.GATEWAY_TIMEOUT,
    exports.STATUSES.HTTP_VERSION_NOT_SUPPORTED,
    exports.STATUSES.VARIANT_ALSO_NEGOTIATES,
    exports.STATUSES.INSUFFICIENT_STORAGE,
    exports.STATUSES.LOOP_DETECTED,
    exports.STATUSES.BANDWIDTH_LIMIT_EXCEEDED,
    exports.STATUSES.NOT_EXTENDED,
    exports.STATUSES.NETWORK_AUTHENTICATION_REQUIRED,
    exports.STATUSES.WEB_SERVER_UNKNOWN_ERROR,
    exports.STATUSES.WEB_SERVER_IS_DOWN,
    exports.STATUSES.CONNECTION_TIMEOUT,
    exports.STATUSES.ORIGIN_IS_UNREACHABLE,
    exports.STATUSES.TIMEOUT_OCCURED,
    exports.STATUSES.SSL_HANDSHAKE_FAILED,
    exports.STATUSES.INVALID_SSL_CERTIFICATE,
    exports.STATUSES.RAILGUN_ERROR,
    exports.STATUSES.SITE_IS_OVERLOADED,
    exports.STATUSES.SITE_IS_FROZEN,
    exports.STATUSES.IDENTITY_PROVIDER_AUTHENTICATION_ERROR,
    exports.STATUSES.NETWORK_READ_TIMEOUT,
    exports.STATUSES.NETWORK_CONNECT_TIMEOUT
  ];
  exports.ALPHA = [];
  for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
    exports.ALPHA.push(String.fromCharCode(i));
    exports.ALPHA.push(String.fromCharCode(i + 32));
  }
  exports.NUM_MAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9
  };
  exports.HEX_MAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15
  };
  exports.NUM = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9"
  ];
  exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
  exports.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
  exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
  exports.URL_CHAR = [
    "!",
    '"',
    "$",
    "%",
    "&",
    "'",
    "(",
    ")",
    "*",
    "+",
    ",",
    "-",
    ".",
    "/",
    ":",
    ";",
    "<",
    "=",
    ">",
    "@",
    "[",
    "\\",
    "]",
    "^",
    "_",
    "`",
    "{",
    "|",
    "}",
    "~"
  ].concat(exports.ALPHANUM);
  exports.HEX = exports.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
  exports.TOKEN = [
    "!",
    "#",
    "$",
    "%",
    "&",
    "'",
    "*",
    "+",
    "-",
    ".",
    "^",
    "_",
    "`",
    "|",
    "~"
  ].concat(exports.ALPHANUM);
  exports.HEADER_CHARS = ["	"];
  for (let i = 32; i <= 255; i++) {
    if (i !== 127) {
      exports.HEADER_CHARS.push(i);
    }
  }
  exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
  exports.QUOTED_STRING = ["	", " "];
  for (let i = 33; i <= 255; i++) {
    if (i !== 34 && i !== 92) {
      exports.QUOTED_STRING.push(i);
    }
  }
  exports.HTAB_SP_VCHAR_OBS_TEXT = ["	", " "];
  for (let i = 33; i <= 126; i++) {
    exports.HTAB_SP_VCHAR_OBS_TEXT.push(i);
  }
  for (let i = 128; i <= 255; i++) {
    exports.HTAB_SP_VCHAR_OBS_TEXT.push(i);
  }
  exports.MAJOR = exports.NUM_MAP;
  exports.MINOR = exports.MAJOR;
  exports.SPECIAL_HEADERS = {
    "connection": exports.HEADER_STATE.CONNECTION,
    "content-length": exports.HEADER_STATE.CONTENT_LENGTH,
    "proxy-connection": exports.HEADER_STATE.CONNECTION,
    "transfer-encoding": exports.HEADER_STATE.TRANSFER_ENCODING,
    "upgrade": exports.HEADER_STATE.UPGRADE
  };
})(constants$b);
var llhttpWasm$1 = { exports: {} };
llhttpWasm$1.exports;
var hasRequiredLlhttpWasm$1;
function requireLlhttpWasm$1() {
  if (hasRequiredLlhttpWasm$1) return llhttpWasm$1.exports;
  hasRequiredLlhttpWasm$1 = 1;
  (function(module) {
    const { Buffer: Buffer2 } = require$$0$1;
    const wasmBase64 = "AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAn9/AGABfwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzQzBQYAAAMAAAAAAAADAQMAAwMDAAACAAAAAAICAgICAgICAgIBAQEBAQEBAQEDAAADAAAABAUBcAESEgUDAQACBggBfwFBgNgECwfFBygGbWVtb3J5AgALX2luaXRpYWxpemUACBlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQACRhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUANgxsbGh0dHBfYWxsb2MACwZtYWxsb2MAOAtsbGh0dHBfZnJlZQAMBGZyZWUADA9sbGh0dHBfZ2V0X3R5cGUADRVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADhVsbGh0dHBfZ2V0X2h0dHBfbWlub3IADxFsbGh0dHBfZ2V0X21ldGhvZAAQFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAERJsbGh0dHBfZ2V0X3VwZ3JhZGUAEgxsbGh0dHBfcmVzZXQAEw5sbGh0dHBfZXhlY3V0ZQAUFGxsaHR0cF9zZXR0aW5nc19pbml0ABUNbGxodHRwX2ZpbmlzaAAWDGxsaHR0cF9wYXVzZQAXDWxsaHR0cF9yZXN1bWUAGBtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGRBsbGh0dHBfZ2V0X2Vycm5vABoXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AGxdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAcFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB0RbGxodHRwX2Vycm5vX25hbWUAHhJsbGh0dHBfbWV0aG9kX25hbWUAHxJsbGh0dHBfc3RhdHVzX25hbWUAIBpsbGh0dHBf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a0E+aiECCyABIAI2AhwgAUIANwIQIAJBAnRBsNYAaiEAAkBBhNQAKAIAIgNBASACdCIHcUUEQCAAIAE2AgBBhNQAIAMgB3I2AgAgASAANgIYIAEgATYCCCABIAE2AgwMAQsgBEEZIAJBAXZrQQAgAkEfRxt0IQIgACgCACEAAkADQCAAIgMoAgRBeHEgBEYNASACQR12IQAgAkEBdCECIAMgAEEEcWpBEGoiBygCACIADQALIAcgATYCACABIAM2AhggASABNgIMIAEgATYCCAwBCyADKAIIIgAgATYCDCADIAE2AgggAUEANgIYIAEgAzYCDCABIAA2AggLQaDUAEGg1AAoAgBBAWsiAEF/IAAbNgIACwsHACAALQAoCwcAIAAtACoLBwAgAC0AKwsHACAALQApCwcAIAAvATQLBwAgAC0AMAtAAQR/IAAoAhghASAALwEuIQIgAC0AKCEDIAAoAjghBCAAEDcgACAENgI4IAAgAzoAKCAAIAI7AS4gACABNgIYC8X4AQIHfwN+IAEgAmohBAJAIAAiAygCDCIADQAgAygCBARAIAMgATYCBAsjAEEQayIJJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJ/AkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACDtQBAAECAwQFBgcICQoLDA0ODxARFBUWFxgZGhscHR4fICEjJCUnKCmIA4cDhQOEA/wC9QLuAusC6ALmAuMC4ALfAt0C2wLWAtUC1ALTAtICygLJAsgCxwLGAsUCxALDAr0CvAK6ArkCuAK3ArYCtQK0ArICsQKsAqoCqAKnAqYCpQKkAqMCogKhAqACnwKbApoCmQKYApcCkAKIAoQCgwKCAvkB9gH1AfQB8wHyAfEB8AHvAe0B6wHoAeMB4QHgAd8B3gHdAdwB2wHaAdkB2AHX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QEBAQEBAQEBAQEBAAEALQQAhAiADQQA2AhwgA0G3CzYCECADQQI2AgwgAyABQQFqNgIUDIEDCyADQS9qIQIDQCABIARGBEBBISECDIIDCwJAAkACQCABLQAAIgBBCWsOGAIAKioBKioqKioqKioqKioqKioqKioqAigLIAFBAWohASADQS9qLQAAQQFxRQ0LDBkLIAFBAWohAQwYCyABQQFqIQEgAi0AAEECcQ0AC0EAIQIgA0EANgIcIAMgATYCFCADQc4UNgIQIANBDDYCDAyAAwsgAUEBaiEBC0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAADQEM0QILIANCADcDIAw8CyAAQRVGBEAgA0EkNgIcIAMgATYCFCADQYYaNgIQIANBFTYCDEEAIQIM/QILQQAhAiADQQA2AhwgAyABNgIUIANB4g02AhAgA0EUNgIMDPwCCyADKAIEIQBBACECIANBADYCBCADIAAgASAMp2oiARAxIgBFDSsgA0EHNgIcIAMgATYCFCADIAA2AgwM+wILIAMtAC5BwABxRQ0BC0EAIQACQCADKAI4IgJFDQAgAigCUCICRQ0AIAMgAhEAACEACyAARQ0rIABBFUYEQCADQQo2AhwgAyABNgIUIANB8Rg2AhAgA0EVNgIMQQAhAgz6AgtBACECIANBADYCHCADIAE2AhQgA0GLDDYCECADQRM2AgwM+QILQQAhAiADQQA2AhwgAyABNgIUIANBsRQ2AhAgA0ECNgIMDPgCC0EAIQIgA0EANgIcIAMgATYCFCADQYwUNgIQIANBGTYCDAz3AgtBACECIANBADYCHCADIAE2AhQgA0HRHDYCECADQRk2AgwM9gILIABBFUYNPUEAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAz1AgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQ0oIANBDTYCHCADIAE2AhQgAyAANgIMDPQCCyAAQRVGDTpBACECIANBADYCHCADIAE2AhQgA0GiDzYCECADQSI2AgwM8wILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDIiAEUEQCABQQFqIQEMKAsgA0EONgIcIAMgADYCDCADIAFBAWo2AhQM8gILIABBFUYNN0EAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAzxAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQRAIAFBAWohAQwnCyADQQ82AhwgAyAANgIMIAMgAUEBajYCFAzwAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM7wILIABBFUYNM0EAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzuAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMyIARQ0lIANBETYCHCADIAE2AhQgAyAANgIMDO0CCyAAQRVGDTBBACECIANBADYCHCADIAE2AhQgA0HODDYCECADQSM2AgwM7AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEMJQsgA0ESNgIcIAMgADYCDCADIAFBAWo2AhQM6wILIANBL2otAABBAXFFDQELQRUhAgzPAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM6AILIABBO0cNACABQQFqIQEMDAtBACECIANBADYCHCADIAE2AhQgA0GYFzYCECADQQI2AgwM5gILIABBFUYNKEEAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzlAgsgA0EUNgIcIAMgATYCFCADIAA2AgwM5AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEM3AILIANBFTYCHCADIAA2AgwgAyABQQFqNgIUDOMCCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNoCCyADQRc2AhwgAyAANgIMIAMgAUEBajYCFAziAgsgAEEVRg0jQQAhAiADQQA2AhwgAyABNgIUIANBzgw2AhAgA0EjNgIMDOECCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDB0LIANBGTYCHCADIAA2AgwgAyABQQFqNgIUDOACCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNYCCyADQRo2AhwgAyAANgIMIAMgAUEBajYCFAzfAgsgAEEVRg0fQQAhAiADQQA2AhwgAyABNgIUIANBog82AhAgA0EiNgIMDN4CCyADKAIEIQBBACEC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DLMCCyABIARGBEBB6QEhAgyzAgsgAS0AAEHIAEYNASADQQE6ACgLQbYBIQIMlwILQcoBIQIMlgILIAEgBEcEQCADQQw2AgggAyABNgIEQckBIQIMlgILQegBIQIMrwILIAEgBEYEQEHnASECDK8CCyABLQAAQcgARw0EIAFBAWohAUHIASECDJQCCyABIARGBEBB5gEhAgyuAgsCQAJAIAEtAABBxQBrDhAABQUFBQUFBQUFBQUFBQUBBQsgAUEBaiEBQcYBIQIMlAILIAFBAWohAUHHASECDJMCC0HlASECIAEgBEYNrAIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB99MAai0AAEcNAyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMrQILIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgBFBEBB1AEhAgyTAgsgA0HkATYCHCADIAE2AhQgAyAANgIMQQAhAgysAgtB4wEhAiABIARGDasCIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQfXTAGotAABHDQIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADKwCCyADQYEEOwEoIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgANAwwCCyADQQA2AgALQQAhAiADQQA2AhwgAyABNgIUIANB0B42AhAgA0EINgIMDKkCC0HFASECDI4CCyADQeIBNgIcIAMgATYCFCADIAA2AgxBACECDKcCC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ1lIABBFUcEQCADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgynAgsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDKYCC0HhASECIAQgASIARg2lAiAEIAFrIAMoAgAiAWohBSAAIAFrQQRqIQYCQANAIAAtAAAgAUHw0wBqLQAARw0BIAFBBEYNAyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBTYCAAymAgsgA0EANgIcIAMgADYCFCADQYQ3NgIQIANBCDYCDCADQQA2AgBBACECDKUCCyABIARHBEAgA0ENNgIIIAMgATYCBEHCASECDIsCC0HgASECDKQCCyADQQA2AgAgBkEBaiEBC0HDASECDIgCCyABIARGBEBB3wEhAgyiAgsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFBwQEhAgyIAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYgCIANB3gE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAEgBEYEQEHdASECDKECCwJAIAEtAABBLkYEQCABQQFqIQEMAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYkCIANB3AE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILQcABIQIMhgILIAEgBEYEQEHbASECDKACC0EAIQBBASEFQQEhB0EAIQICQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQCABLQAAQTBrDgoKCQABAgMEBQYICwtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshAkEAIQVBACEHDAILQQkhAkEBIQBBACEFQQAhBwwBC0EAIQVBASECCyADIAI6ACsgAUEBaiEBAkACQCADLQAuQRBxDQACQAJAAkAgAy0AKg4DAQACBAsgB0UNAwwCCyAADQEMAgsgBUUNAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDQIgA0HYATYCHCADIAE2AhQgAyAANgIMQQAhAgyiAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYsCIANB2QE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ2JAiADQdoBNgIcIAMgATYCFCADIAA2AgwMoAILQb8BIQIMhQILQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALAkAgAARAIABBFUYNASADQQA2AhwgAyABNgIUIANBnA02AhAgA0EhNgIMQQAhAgygAgtBvgEhAgyFAgsgA0HXATYCHCADIAE2AhQgA0HWGTYCECADQRU2AgxBACECDJ4CCyABIARGBEBB1wEhAgyeAgsCQCABLQAAQSBGBEAgA0EAOwE0IAFBAWohAQwBCyADQQA2AhwgAyABNgIUIANB6xA2AhAgA0EJNgIMQQAhAgyeAgtBvQEhAgyDAgsgASAERgRAQdYBIQIM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LgsgAUEBaiEBQZcBIQIM2AELIAFBAWohAUEiDCsLIAEgBEYEQEGvASECDPEBCyABLQAAQdAARw0rIAFBAWohAUGWASECDNYBCyABIARGBEBBrgEhAgzwAQsCQAJAIAEtAABBxgBrDgsALCwsLCwsLCwsASwLIAFBAWohAUGUASECDNYBCyABQQFqIQFBlQEhAgzVAQtBrQEhAiABIARGDe4BIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQazTAGotAABHDSggAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO8BCyADQQA2AgAgBkEBaiEBQQ0MKAtBrAEhAiABIARGDe0BIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQeHTAGotAABHDScgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO4BCyADQQA2AgAgBkEBaiEBQQwMJwtBqwEhAiABIARGDewBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQarTAGotAABHDSYgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO0BCyADQQA2AgAgBkEBaiEBQQMMJgtBqgEhAiABIARGDesBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQajTAGotAABHDSUgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADOwBCyADQQA2AgAgBkEBaiEBQSYMJQsgASAERgRAQakBIQIM6wELAkACQCABLQAAQdQAaw4CAAEnCyABQQFqIQFBjwEhAgzRAQsgAUEBaiEBQZABIQIM0AELQagBIQIgASAERg3pASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGm0wBqLQAARw0jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzqAQsgA0EANgIAIAZBAWohAUEnDCMLQacBIQIgASAERg3oASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGk0wBqLQAARw0iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzpAQsgA0EANgIAIAZBAWohAUEcDCILQaYBIQIgASAERg3nASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGe0wBqLQAARw0hIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzoAQsgA0EANgIAIAZBAWohAUEGDCELQaUBIQIgASAERg3mASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEGZ0wBqLQAARw0gIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAznAQsgA0EANgIAIAZBAWohAUEZDCALIAEgBEYEQEGkASECDOYBCwJAAkACQAJAIAEtAABBLWsOIwAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAEkJCQkJAIkJCQDJAsgAUEBaiEBQYQBIQIMzgELIAFBAWohAUGFASECDM0BCyABQQFqIQFBigEhAgzMAQsgAUEBaiEBQYsBIQIMywELQaMBIQIgASAERg3kASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGX0wBqLQAARw0eIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzlAQsgA0EANgIAIAZBAWohAUELDB4LIAEgBEYEQEGiASECDOQBCwJAAkAgAS0AAEHBAGsOAwAgASALIAFBAWohAUGGASECDMoBCyABQQFqIQFBiQEhAgzJAQsgASAERgRAQaEBIQIM4wELAkACQCABLQAAQcEAaw4PAB8fHx8fHx8fHx8fHx8BHwsgAUEBaiEBQYcBIQIMyQELIAFBAWohAUGIASECDMgBCyABIARGBEBBoAEhAgziAQsgAS0AAEHMAEcNHCABQQFqIQFBCgwbC0GfASECIAEgBEYN4AEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBkdMAai0AAEcNGiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4QELIANBADYCACAGQQFqIQFBHgwaC0GeASECIAEgBEYN3wEgAygCACIAIAQgAWtqIQUgASAAa0EGaiEGAkADQCABLQAAIABBitMAai0AAEcNGSAAQQZGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4AELIANBADYCACAGQQFqIQFBFQwZC0GdASECIAEgBEYN3gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBh9MAai0AAEcNGCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3wELIANBADYCACAGQQFqIQFBFwwYC0GcASECIAEgBEYN3QEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBgdMAai0AAEcNFyAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3gELIANBADYCACAGQQFqIQFBGAwXCyABIARGBEBBmwEhAgzdAQsCQAJAIAEtAABByQBrDgcAGRkZGRkBGQsgAUEBaiEBQYEBIQIMwwELIAFBAWohAUGCASECDMIBC0GaASECIAEgBEYN2wEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5tMAai0AAEcNFSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3AELIANBADYCACAGQQFqIQFBCQwVC0GZASECIAEgBEYN2gEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5NMAai0AAEcNFCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2wELIANBADYCACAGQQFqIQFBHwwUC0GYASECIAEgBEYN2QEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB/tIAai0AAEcNEyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2gELIANBADYCACAGQQFqIQFBAgwTC0GXASECIAEgBEYN2AEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGA0AgAS0AACAAQfzSAGotAABHDREgAEEBRg0CIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNgBCyABIARGBEBBlgEhAgzYAQtBASABLQAAQd8ARw0RGiABQQFqIQFB/QAhAgy9AQsgA0EANgIAIAZBAWohAUH+ACECDLwBC0GVASECIAEgBEYN1QEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBxNMAai0AAEcNDyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1gELIANBADYCACAGQQFqIQFBKQwPC0GUASECIAEgBEYN1AEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB+NIAai0AAEcNDiAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1QELIANBADYCACAGQQFqIQFBLQwOCyABIARGBEBBkwEhAgzUAQsgAS0AAEHFAEcNDiABQQFqIQFB+gAhAgy5AQsgASAERgRAQZIBIQIM0wELAkACQCABLQAAQcwAaw4IAA8PDw8PDwEPCyABQQFqIQFB+AAhAgy5AQsgAUEBaiEBQfkAIQIMuAELQZEBIQIgASAERg3RASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHz0gBqLQAARw0LIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzSAQsgA0EANgIAIAZBAWohAUEjDAsLQZABIQIgASAERg3QASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHw0gBqLQAARw0KIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzRAQsgA0EANgIAIAZBAWohAUEADAoLIAEgBEYEQEGPASECDNABCwJAAkAgAS0AAEHIAGsOCAAMDAwMDAwBDAsgAUEBaiEBQfMAIQIMtgELIAFBAWohAUH2ACECDLUBCyABIARGBEBBjgEhAgzPAQsCQAJAIAEtAABBzgBrDgMACwELCyABQQFqIQFB9AAhAgy1AQsgAUEBaiEBQfUAIQIMtAELIAEgBEYEQEGNASECDM4BCyABLQAAQdkARw0IIAFBAWohAUEIDAcLQYwBIQIgASAERg3MASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHs0gBqLQAARw0GIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzNAQsgA0EANgIAIAZBAWohAUEFDAYLQYsBIQIgASAERg3LASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHm0gBqLQAARw0FIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzMAQsgA0EANgIAIAZBAWohAUEWDAULQYoBIQIgASAERg3KASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHh0wBqLQAARw0EIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzLAQsgA0EANgIAIAZBAWohAUEQDAQLIAEgBEYEQEGJASECDMoBCwJAAkAgAS0AAEHDAGsODAAGBgYGBgYGBgYGAQYLIAFBAWohAUHvACECDLABCyABQQFqIQFB8AAhAgyvAQtBiAEhAiABIARGDcgBIAMoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQeDSAGotAABHDQIgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADMkBCyADQQA2AgAgBkEBaiEBQSQMAgsgA0EANgIADAILIAEgBEYEQEGHASECDMcBCyABLQAAQcwARw0BIAFBAWohAUETCzoAKSADKAIEIQAgA0EANgIEIAMgACABEC0iAA0CDAELQQAhAiADQQA2AhwgAyABNgIUIANB6R42AhAgA0EGNgIMDMQBC0HuACECDKkBCyADQYYBNgIcIAMgATYCFCADIAA2AgxBACECDMIBC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ0AIABBFUYNASADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgzBAQtB7QAhAgymAQsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDL8BCyABIARGBEBBhQEhAgy/AQsCQCABLQAAQSBGBEAgAUEBaiEBDAELIANBADYCHCADIAE2AhQgA0GGHjYCECADQQY2AgxBACECDL8BC0ECIQIMpAELA0AgAS0AAEEgRw0CIAQgAUEBaiIBRw0AC0GEASECDL0BCyABIARGBEBBgwEhAgy9AQsCQCABLQAAQQlrDgRAAABAAAtB6wAhAgyiAQsgAy0AKUEFRgRAQewAIQIMogELQeoAIQIMoQELIAEgBEYEQEGCASECDLsBCyADQQ82AgggAyABNgIEDAoLIAEgBEYEQEGBASECDLoBCwJAIAEtAABBCWsOBD0AAD0AC0HpACECDJ8BCyABIARHBEAgA0EPNgIIIAMgATYCBEHnACECDJ8BC0GAASECDLgBCwJAIAEgBEcEQANAIAEtAABB4M4Aai0AACIAQQNHBEACQCAAQQFrDgI/AAQLQeYAIQIMoQELIAQgAUEBaiIBRw0AC0H+ACECDLkBC0H+ACECDLgBCyADQQA2AhwgAyABNgIUIANBxh82AhAgA0EHNgIMQQAhAgy3AQsgASAERgRAQf8AIQIMtwELAkACQAJAIAEtAABB4NAAai0AAEEBaw4DPAIAAQtB6AAhAgyeAQsgA0EANgIcIAMgATYCFCADQYYSNgIQIANBBzYCDEEAIQIMtwELQeAAIQIMnAELIAEgBEcEQCABQQFqIQFB5QAhAgycAQtB/QAhAgy1AQsgBCABIgBGBEBB/AAhAgy1AQsgAC0AACIBQS9GBEAgAEEBaiEBQeQAIQIMmwELIAFBCWsiAkEXSw0BIAAhAUEBIAJ0QZuAgARxDTcMAQsgBCABIgBGBEBB+wAhAgy0AQsgAC0AAEEvRw0AIABBAWohAQwDC0EAIQIgA0EANgIcIAMgADYCFCADQcYfNgIQIANBBzYCDAyyAQsCQAJAAkACQAJAA0AgAS0AAEHgzABqLQAAIgBBBUcEQAJAAkAgAEEBaw4IPQUGBwgABAEIC0HhACECDJ8BCyABQQFqIQFB4wAhAgyeAQsgBCABQQFqIgFHDQALQfoAIQIMtgELIAFBAWoMFAsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgy0AQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyzAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyyAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMsQELIAEgBEYEQEH5ACECDLEBCwJAIAEtAABB4MwAai0AAEEBaw4INAQFBgAIAgMHCyABQQFqIQELQQMhAgyVAQsgAUEBagwNC0EAIQIgA0EANgIcIANBoxI2AhAgA0EHNgIMIAMgAUEBajYCFAytAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgysAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyrAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyqAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMqQELQeIAIQIMjgELIAEgBEYEQEH4ACECDKgBCyABQQFqDAILIAEgBEYEQEH3ACECDKcBCyABQQFqDAELIAEgBEYNASABQQFqCyEBQQQhAgyKAQtB9gAhAgyjAQsDQCABLQAAQeDKAGotAAAiAEECRwRAIABBAUcEQEHfACECDIsBCwwnCyAEIAFBAWoiAUcNAAtB9QAhAgyiAQsgASAERgRAQfQAIQIMogELAkAgAS0AAEEJaw43JQMGJQQGBgYGBgYGBgYGBgYGBgYGBgYFBgYCBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGAAYLIAFBAWoLIQFBBSECDIYBCyABQQFqDAYLIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB2wA2AhwgAyABNgIUIAMgADYCDEEAIQIMngELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB3QA2AhwgAyABNgIUIAMgADYCDEEAIQIMnQELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB8AA2AhwgAyABNgIUIAMgADYCDEEAIQIMnAELIANBADYCHCADIAE2AhQgA0G8EzYCECADQQc2AgxBACECDJsBCwJAAkACQAJAA0AgAS0AAEHgyABqLQAAIgBBBUcEQAJAIABBAWsOBiQDBAUGAAYLQd4AIQIMhgELIAQgAUEBaiIBRw0AC0HzACECDJ4BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQdsANgIcIAMgATYCFCADIAA2AgxBACECDJ0BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQd0ANgIcIAMgATYCFCADIAA2AgxBACECDJwBCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQfAANgIcIAMgATYCFCADIAA2AgxBACECDJsBCyADQQA2AhwgAyABNgIUIANB3Ag2AhAgA0EHNgIMQQAhAgyaAQsgASAERg0BIAFBAWoLIQFBBiECDH4LQfIAIQIMlwELAkACQAJAAkADQCABLQAAQeDGAGotAAAiAEEFRwRAIABBAWsOBB8CAwQFCyAEIAFBAWoiAUcNAAtB8QAhAgyaAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgyZAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyYAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyXAQsgA0EANgIcIAMgATYCFCADQbQKNgIQIANBBzYCDEEAIQIMlgELQc4AIQIMewtB0AAhAgx6C0HdACECDHkLIAEgBEYEQEHwACECDJMBCwJAIAEtAABBCWsOBBYAABYACyABQQFqIQFB3AAhAgx4CyABIARGBEBB7wAhAgySAQsCQCABLQAAQQlrDgQVAAAVAAtBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUEQEHTASECDHgLIABBFUcEQCADQQA2AhwgAyABNgIUIANBwQ02AhAgA0EaNgIMQQAhAgySAQsgA0HuADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDJEBC0HtACECIAEgBEYNkAEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB18YAai0AAEcNBCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMkQELIANBADYCACAGQQFqIQEgAy0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACECIANBADYCHCADIAE2AhQgA0HlCTYCECADQQg2AgwMkAELQewAIQIgASAERg2PASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHUxgBqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyQAQsgA0EANgIAIAZBAWohASADLQApQSFGDQMgA0EANgIcIAMgATYCFCADQYkKNgIQIANBCDYCDEEAIQIMjwELQesAIQIgASAERg2OASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHQxgBqLQAARw0CIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyPAQsgA0EANgIAIAZBAWohASADLQApIgBBI0kNAiAAQS5GDQIgA0EANgIcIAMgATYCFCADQcEJNgIQIANBCDYCDEEAIQIMjgELIANBADYCAAtBACECIANBADYCHCADIAE2AhQgA0GENzYCECADQQg2AgwMjAELQdgAIQIMcQsgASAERwRAIANBDTYCCCADIAE2AgRB1wAhAgxxC0HqACECDIoBCyABIARGBEBB6QAhAgyKAQsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFB1gAhAgxwCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdCADQegANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyABIARGBEBB5wAhAgyJAQsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ11IANB5gA2AhwgAyABNgIUIAMgADYCDEEAIQIMiQELQdUAIQIMbgsgASAERgRAQeUAIQIMiAELQQAhAEEBIQVBASEHQQAhAgJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAEtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyECQQAhBUEAIQcMAgtBCSECQQEhAEEAIQVBACEHDAELQQAhBUEBIQILIAMgAjoAKyABQQFqIQECQAJAIAMtAC5BEHENAAJAAkACQCADLQAqDgMBAAIECyAHRQ0DDAILIAANAQwCCyAFRQ0BCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNAiADQeIANgIcIAMgATYCFCADIAA2AgxBACECDIoBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdyADQeMANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdSADQeQANgIcIAMgATYCFCADIAA2AgwMiAELQdMAIQIMbQsgAy0AKUEiRg2AAUHSACECDGwLQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALIABFBEBB1AAhAgxsCyAAQRVHBEAgA0EANgIcIAMgATYCFCADQZwNNgIQIANBITYCDEEAIQIMhgELIANB4QA2AhwgAyABNgIUIANB1hk2AhAgA0EVNgIMQQAhAgyFAQsgASAERgRAQeAAIQIMhQELAkACQAJAAkACQCABLQAAQQprDgQBBAQABAsgAUEBaiEBDAELIAFBAWohASADQS9qLQAAQQFxRQ0BC0HRACECDGwLIANBADYCHCADIAE2AhQgA0GIETYCECADQQk2AgxBACECDIUBCyADQQA2AhwgAyABNgIUIANBiBE2AhAgA0EJNgIMQQAhAgyEAQsgASAERgRAQd8AIQIMhAELIAEtAABBCkYEQCABQQFqIQEMCQsgAy0ALkHAAHENCCADQQA2AhwgAyABNgIUIANBiBE2AhAgA0ECNgIMQQAhAgyDAQsgASAERgRAQd0AIQIMgwELIAEtAAAiAkENRgRAIAFBAWohAUHPACECDGkLIAEhACACQQlrDgQFAQEFAQsgBCABIgBGBEBB3AAhAgyCAQsgAC0AAEEKRw0AIABBAWoMAgtBACECIANBADYCHCADIAA2AhQgA0G1LDYCECADQQc2AgwMgAELIAEgBEYEQEHbACECDIABCwJAIAEtAABBCWsOBAMAAAMACyABQQFqCyEBQc0AIQIMZAsgASAERgRAQdoAIQIMfgsgAS0AAEEJaw4EAAEBAAELQQAhAiADQQA2AhwgA0HsETYCECADQQc2AgwgAyABQQFqNgIUDHwLIANBgBI7ASpBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUNACAAQRVHDQEgA0HZADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDHsLQcwAIQIMYAsgA0EANgIcIAMgATYCFCADQcENNgIQIANBGjYCDEEAIQIMeQsgASAERgRAQdkAIQIMeQsgAS0AAEEgRw06IAFBAWohASADLQAuQQFxDTogA0EANgIcIAMgATYCFCADQa0bNgIQIANBHjYCDEEAIQIMeAsgASAERgRAQdgAIQIMeAsCQAJAAkACQAJAIAEtAAAiAEEKaw4EAgMD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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQTBrDjcVFAABAgMEBQYHFhYWFhYWFggJCgsMDRYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWDg8QERITFgtCAiEKDBQLQgMhCgwTC0IEIQoMEgtCBSEKDBELQgYhCgwQC0IHIQoMDwtCCCEKDA4LQgkhCgwNC0IKIQoMDAtCCyEKDAsLQgwhCgwKC0INIQoMCQtCDiEKDAgLQg8hCgwHC0IKIQoMBgtCCyEKDAULQgwhCgwEC0INIQoMAwtCDiEKDAILQg8hCgwBC0IBIQoLIAFBAWohASADKQMgIgtC//////////8PWARAIAMgC0IEhiAKhDcDIAwCC0EAIQIgA0EANgIcIAMgATYCFCADQa0JNgIQIANBDDYCDAwfC0ElIQIMBAtBJiECDAMLIAMgAToALCADQQA2AgAgB0EBaiEBQQwhAgwCCyADQQA2AgAgBkEBaiEBQQohAgwBCyABQQFqIQFBCCECDAALAAtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMGAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMFwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMFgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMFQtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMFAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMEwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMEgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMEQtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMEAtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMDwtBACECIANBADYCHCADIAE2AhQgA0HIEjYCECADQQs2AgwMDgtBACECIANBADYCHCADIAE2AhQgA0GVCTYCECADQQs2AgwMDQtBACECIANBADYCHCADIAE2AhQgA0HpDzYCECADQQo2AgwMDAtBACECIANBADYCHCADIAE2AhQgA0GDEDYCECADQQo2AgwMCwtBACECIANBADYCHCADIAE2AhQgA0GmHDYCECADQQI2AgwMCgtBACECIANBADYCHCADIAE2AhQgA0HFFTYCECADQQI2AgwMCQtBACECIANBADYCHCADIAE2AhQgA0H/FzYCECADQQI2AgwMCAtBACECIANBADYCHCADIAE2AhQgA0HKFzYCECADQQI2AgwMBwsgA0ECNgIcIAMgATYCFCADQZQdNgIQIANBFjYCDEEAIQIMBgtB3gAhAiABIARGDQUgCUEIaiEHIAMoAgAhBQJAAkAgASAERwRAIAVBxsYAaiEIIAQgBWogAWshBiAFQX9zQQpqIgUgAWohAANAIAEtAAAgCC0AAEcEQEECIQgMAwsgBUUEQEEAIQggACEBDAMLIAVBAWshBSAIQQFqIQggBCABQQFqIgFHDQALIAYhBSAEIQELIAdBATYCACADIAU2AgAMAQsgA0EANgIAIAcgCDYCAAsgByABNgIEIAkoAgwhACAJKAIIDgMBBQIACwALIANBADYCHCADQa0dNgIQIANBFzYCDCADIABBAWo2AhRBACECDAMLIANBADYCHCADIAA2AhQgA0HCHTYCECADQQk2AgxBACECDAILIAEgBEYEQEEoIQIMAgsgA0EJNgIIIAMgATYCBEEnIQIMAQsgASAERgRAQQEhAgwBCwNAAkACQAJAIAEtAABBCmsOBAABAQABCyABQQFqIQEMAQsgAUEBaiEBIAMtAC5BIHENAEEAIQIgA0EANgIcIAMgATYCFCADQYwgNgIQIANBBTYCDAwCC0EBIQIgASAERw0ACwsgCUEQaiQAIAJFBEAgAygCDCEADAELIAMgAjYCHEEAIQAgAygCBCIBRQ0AIAMgASAEIAMoAggRAQAiAUUNACADIAQ2AhQgAyABNgIMIAEhAAsgAAu+AgECfyAAQQA6AAAgAEHcAGoiAUEBa0EAOgAAIABBADoAAiAAQQA6AAEgAUEDa0EAOgAAIAFBAmtBADoAACAAQQA6AAMgAUEEa0EAOgAAQQAgAGtBA3EiASAAaiIAQQA2AgBB3AAgAWtBfHEiAiAAaiIBQQRrQQA2AgACQCACQQlJDQAgAEEANgIIIABBADYCBCABQQhrQQA2AgAgAUEMa0EANgIAIAJBGUkNACAAQQA2AhggAEEANgIUIABBADYC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YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBFeHBlY3RlZCBMRiBhZnRlciBoZWFkZXJzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fcmVzZXRgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABUcmFuc2Zlci1FbmNvZGluZyBjYW4ndCBiZSBwcmVzZW50IHdpdGggQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBzaXplAEV4cGVjdGVkIExGIGFmdGVyIGNodW5rIHNpemUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBleHRlbnNpb24gdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIHF1b3RlZC1wYWlyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciByZXNwb25zZSBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgZXh0ZW5zaW9uIG5hbWUASW52YWxpZCBzdGF0dXMgY29kZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGNodW5rIGRhdGEARXhwZWN0ZWQgTEYgYWZ0ZXIgY2h1bmsgZGF0YQBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AARGF0YSBhZnRlciBgQ29ubmVjdGlvbjogY2xvc2VgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBRVUVSWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAEV4cGVjdGVkIExGIGFmdGVyIENSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAUhUAABoVAAAPEgAA5BkAAJEVAAAJFAAALRkAAOQUAADpEQAAaRQAAKEUAAB2FQAAQxYAAF4SAACUFwAAFxYAAH0UAAB/FgAAQRcAALMTAADDFgAABBoAAL0YAADQGAAAoBMAANQZAACvFgAAaBYAAHAXAADZFgAA/BgAAP4RAABZFwAAlxYAABwXAAD2FgAAjRcAAAsSAAB/GwAALhEAALMQAABJEgAArRIAAPYYAABoEAAAYhUAABAVAABaFgAAShkAALUVAADBFQAAYBUAAFwZAABaGQAAUxkAABYVAACtEQAAQhAAALcQAABXGAAAvxUAAIkQAAAcGQAAGhkAALkVAABRGAAA3BMAAFsVAABZFQAA5hgAAGcVAAARGQAA7RgAAOcTAACuEAAAwhcAAAAUAACSEwAAhBMAAEASAAAmGQAArxUAAGIQAEHpOQsBAQBBgDoL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB6jsLBAEAAAIAQYE8C14DBAMDAwMDAAADAwADAwADAwMDAwMDAwMDAAUAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwADAEHqPQsEAQAAAgBBgT4LXgMAAwMDAwMAAAMDAAMDAAMDAwMDAwMDAwMABAAFAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAAMAQeA/Cw1sb3NlZWVwLWFsaXZlAEH5PwsBAQBBkMAAC+ABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQfnBAAsBAQBBkMIAC+cBAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAEGhxAALXgEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAQYDGAAshZWN0aW9uZW50LWxlbmd0aG9ucm94eS1jb25uZWN0aW9uAEGwxgALK3JhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KU00NCg0KVFRQL0NFL1RTUC8AQenGAAsFAQIAAQMAQYDHAAtfBAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQenIAAsFAQIAAQMAQYDJAAtfBAUFBgUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQenKAAsEAQAAAQBBgcsAC14CAgACAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAEHpzAALBQECAAEDAEGAzQALXwQFAAAFBQUFBQUFBQUFBQYFBQUFBQUFBQUFBQUABQAHCAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQAFAAUABQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAAAAFAEHpzgALBQEBAAEBAEGAzwALAQEAQZrPAAtBAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQenQAAsFAQEAAQEAQYDRAAsBAQBBitEACwYCAAAAAAIAQaHRAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB4NIAC5oBTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRVVFUllPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
    let wasmBuffer;
    Object.defineProperty(module, "exports", {
      get: () => {
        return wasmBuffer ? wasmBuffer : wasmBuffer = Buffer2.from(wasmBase64, "base64");
      }
    });
  })(llhttpWasm$1);
  return llhttpWasm$1.exports;
}
var llhttp_simdWasm$1 = { exports: {} };
llhttp_simdWasm$1.exports;
var hasRequiredLlhttp_simdWasm$1;
function requireLlhttp_simdWasm$1() {
  if (hasRequiredLlhttp_simdWasm$1) return llhttp_simdWasm$1.exports;
  hasRequiredLlhttp_simdWasm$1 = 1;
  (function(module) {
    const { Buffer: Buffer2 } = require$$0$1;
    const wasmBase64 = "AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAn9/AGABfwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzQzBQYAAAMAAAAAAAADAQMAAwMDAAACAAAAAAICAgICAgICAgIBAQEBAQEBAQEDAAADAAAABAUBcAESEgUDAQACBggBfwFBgNgECwfFBygGbWVtb3J5AgALX2luaXRpYWxpemUACBlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQACRhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUANgxsbGh0dHBfYWxsb2MACwZtYWxsb2MAOAtsbGh0dHBfZnJlZQAMBGZyZWUADA9sbGh0dHBfZ2V0X3R5cGUADRVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADhVsbGh0dHBfZ2V0X2h0dHBfbWlub3IADxFsbGh0dHBfZ2V0X21ldGhvZAAQFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAERJsbGh0dHBfZ2V0X3VwZ3JhZGUAEgxsbGh0dHBfcmVzZXQAEw5sbGh0dHBfZXhlY3V0ZQAUFGxsaHR0cF9zZXR0aW5nc19pbml0ABUNbGxodHRwX2ZpbmlzaAAWDGxsaHR0cF9wYXVzZQAXDWxsaHR0cF9yZXN1bWUAGBtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGRBsbGh0dHBfZ2V0X2Vycm5vABoXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AGxdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAcFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB0RbGxodHRwX2Vycm5vX25hbWUAHhJsbGh0dHBfbWV0aG9kX25hbWUAHxJsbGh0dHBfc3RhdHVzX25hbWUAIBpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAhIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAiHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACMkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACQabGxodHRwX3NldF9sZW5pZW50X3ZlcnNpb24AJSNsbGh0dHBfc2V0X2xlbmllbnRfZGF0YV9hZnRlcl9jbG9zZQAmJ2xsaHR0cF9zZXRfbGVuaWVudF9vcHRpb25hbF9sZl9hZnRlcl9jcgAnLGxsaHR0cF9zZXRfbGVuaWVudF9vcHRpb25hbF9jcmxmX2FmdGVyX2NodW5rACgobGxodHRwX3NldF9sZW5pZW50X29wdGlvbmFsX2NyX2JlZm9yZV9sZgApKmxsaHR0cF9zZXRfbGVuaWVudF9zcGFjZXNfYWZ0ZXJfY2h1bmtfc2l6ZQAqGGxsaHR0cF9tZXNzYWdlX25lZWRzX2VvZgA1CRcBAEEBCxEBAgMEBQoGBzEzMi0uLCsvMArYywIzFgBB/NMAKAIABEAAC0H80wBBATYCAAsUACAAEDcgACACNgI4IAAgAToAKAsUACAAIAAvATQgAC0AMCAAEDYQAAseAQF/QcAAEDkiARA3IAFBgAg2AjggASAAOgAoIAELjwwBB38CQCAARQ0AIABBCGsiASAAQQRrKAIAIgBBeHEiBGohBQJAIABBAXENACAAQQNxRQ0BIAEgASgCACIAayIBQZDUACgCAEkNASAAIARqIQQCQAJAQZTUACgCACABRwRAIABB/wFNBEAgAEEDdiEDIAEoAggiACABKAIMIgJGBEBBgNQAQYDUACgCAEF+IAN3cTYCAAwFCyACIAA2AgggACACNgIMDAQLIAEoAhghBiABIAEoAgwiAEcEQCAAIAEoAggiAjYCCCACIAA2AgwMAwsgAUEUaiIDKAIAIgJFBEAgASgCECICRQ0CIAFBEGohAwsDQCADIQcgAiIAQRRqIgMoAgAiAg0AIABBEGohAyAAKAIQIgINAAsgB0EANgIADAILIAUoAgQiAEEDcUEDRw0CIAUgAEF+cTYCBEGI1AAgBDYCACAFIAQ2AgAgASAEQQFyNgIEDAMLQQAhAAsgBkUNAAJAIAEoAhwiAkECdEGw1gBqIgMoAgAgAUYEQCADIAA2AgAgAA0BQYTUAEGE1AAoAgBBfiACd3E2AgAMAgsgBkEQQRQgBigCECABRhtqIAA2AgAgAEUNAQsgACAGNgIYIAEoAhAiAgRAIAAgAjYCECACIAA2AhgLIAFBFGooAgAiAkUNACAAQRRqIAI2AgAgAiAANgIYCyABIAVPDQAgBSgCBCIAQQFxRQ0AAkACQAJAAkAgAEECcUUEQEGY1AAoAgAgBUYEQEGY1AAgATYCAEGM1ABBjNQAKAIAIARqIgA2AgAgASAAQQFyNgIEIAFBlNQAKAIARw0GQYjUAEEANgIAQZTUAEEANgIADAYLQZTUACgCACAFRgRAQZTUACABNgIAQYjUAEGI1AAoAgAgBGoiADYCACABIABBAXI2AgQgACABaiAANgIADAYLIABBeHEgBGohBCAAQf8BTQRAIABBA3YhAyAFKAIIIgAgBSgCDCICRgRAQYDUAEGA1AAoAgBBfiADd3E2AgAMBQsgAiAANgIIIAAgAjYCDAwECyAFKAIYIQYgBSAFKAIMIgBHBEBBkNQAKAIAGiAAIAUoAggiAjYCCCACIAA2AgwMAwsgBUEUaiIDKAIAIgJFBEAgBSgCECICRQ0CIAVBEGohAwsDQCADIQcgAiIAQRRqIgMoAgAiAg0AIABBEGohAyAAKAIQIgINAAsgB0EANgIADAILIAUgAEF+cTYCBCABIARqIAQ2AgAgASAEQQFyNgIEDAMLQQAhAAsgBkUNAAJAIAUoAhwiAkECdEGw1gBqIgMoAgAgBUYEQCADIAA2AgAgAA0BQYTUAEGE1AAoAgBBfiACd3E2AgAMAgsgBkEQQRQgBigCECAFRhtqIAA2AgAgAEUNAQsgACAGNgIYIAUoAhAiAgRAIAAgAjYCECACIAA2AhgLIAVBFGooAgAiAkUNACAAQRRqIAI2AgAgAiAANgIYCyABIARqIAQ2AgAgASAEQQFyNgIEIAFBlNQAKAIARw0AQYjUACAENgIADAELIARB/wFNBEAgBEF4cUGo1ABqIQACf0GA1AAoAgAiAkEBIARBA3Z0IgNxRQRAQYDUACACIANyNgIAIAAMAQsgACgCCAsiAiABNgIMIAAgATYCCCABIAA2AgwgASACNgIIDAELQR8hAiAEQf///wdNBEAgBEEmIARBCHZnIgBrdkEBcSAAQQF0a0E+aiECCyABIAI2AhwgAUIANwIQIAJBAnRBsNYAaiEAAkBBhNQAKAIAIgNBASACdCIHcUUEQCAAIAE2AgBBhNQAIAMgB3I2AgAgASAANgIYIAEgATYCCCABIAE2AgwMAQsgBEEZIAJBAXZrQQAgAkEfRxt0IQIgACgCACEAAkADQCAAIgMoAgRBeHEgBEYNASACQR12IQAgAkEBdCECIAMgAEEEcWpBEGoiBygCACIADQALIAcgATYCACABIAM2AhggASABNgIMIAEgATYCCAwBCyADKAIIIgAgATYCDCADIAE2AgggAUEANgIYIAEgAzYCDCABIAA2AggLQaDUAEGg1AAoAgBBAWsiAEF/IAAbNgIACwsHACAALQAoCwcAIAAtACoLBwAgAC0AKwsHACAALQApCwcAIAAvATQLBwAgAC0AMAtAAQR/IAAoAhghASAALwEuIQIgAC0AKCEDIAAoAjghBCAAEDcgACAENgI4IAAgAzoAKCAAIAI7AS4gACABNgIYC8X4AQIHfwN+IAEgAmohBAJAIAAiAygCDCIADQAgAygCBARAIAMgATYCBAsjAEEQayIJJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJ/AkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACDtQBAAECAwQFBgcICQoLDA0ODxARFBUWFxgZGhscHR4fICEjJCUnKCmIA4cDhQOEA/wC9QLuAusC6ALmAuMC4ALfAt0C2wLWAtUC1ALTAtICygLJAsgCxwLGAsUCxALDAr0CvAK6ArkCuAK3ArYCtQK0ArICsQKsAqoCqAKnAqYCpQKkAqMCogKhAqACnwKbApoCmQKYApcCkAKIAoQCgwKCAvkB9gH1AfQB8wHyAfEB8AHvAe0B6wHoAeMB4QHgAd8B3gHdAdwB2wHaAdkB2AHX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QEBAQEBAQEBAQEBAAEALQQAhAiADQQA2AhwgA0G3CzYCECADQQI2AgwgAyABQQFqNgIUDIEDCyADQS9qIQIDQCABIARGBEBBISECDIIDCwJAAkACQCABLQAAIgBBCWsOGAIAKioBKioqKioqKioqKioqKioqKioqAigLIAFBAWohASADQS9qLQAAQQFxRQ0LDBkLIAFBAWohAQwYCyABQQFqIQEgAi0AAEECcQ0AC0EAIQIgA0EANgIcIAMgATYCFCADQc4UNgIQIANBDDYCDAyAAwsgAUEBaiEBC0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAADQEM0QILIANCADcDIAw8CyAAQRVGBEAgA0EkNgIcIAMgATYCFCADQYYaNgIQIANBFTYCDEEAIQIM/QILQQAhAiADQQA2AhwgAyABNgIUIANB4g02AhAgA0EUNgIMDPwCCyADKAIEIQBBACECIANBADYCBCADIAAgASAMp2oiARAxIgBFDSsgA0EHNgIcIAMgATYCFCADIAA2AgwM+wILIAMtAC5BwABxRQ0BC0EAIQACQCADKAI4IgJFDQAgAigCUCICRQ0AIAMgAhEAACEACyAARQ0rIABBFUYEQCADQQo2AhwgAyABNgIUIANB8Rg2AhAgA0EVNgIMQQAhAgz6AgtBACECIANBADYCHCADIAE2AhQgA0GLDDYCECADQRM2AgwM+QILQQAhAiADQQA2AhwgAyABNgIUIANBsRQ2AhAgA0ECNgIMDPgCC0EAIQIgA0EANgIcIAMgATYCFCADQYwUNgIQIANBGTYCDAz3AgtBACECIANBADYCHCADIAE2AhQgA0HRHDYCECADQRk2AgwM9gILIABBFUYNPUEAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAz1AgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQ0oIANBDTYCHCADIAE2AhQgAyAANgIMDPQCCyAAQRVGDTpBACECIANBADYCHCADIAE2AhQgA0GiDzYCECADQSI2AgwM8wILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDIiAEUEQCABQQFqIQEMKAsgA0EONgIcIAMgADYCDCADIAFBAWo2AhQM8gILIABBFUYNN0EAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAzxAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQRAIAFBAWohAQwnCyADQQ82AhwgAyAANgIMIAMgAUEBajYCFAzwAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM7wILIABBFUYNM0EAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzuAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMyIARQ0lIANBETYCHCADIAE2AhQgAyAANgIMDO0CCyAAQRVGDTBBACECIANBADYCHCADIAE2AhQgA0HODDYCECADQSM2AgwM7AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEMJQsgA0ESNgIcIAMgADYCDCADIAFBAWo2AhQM6wILIANBL2otAABBAXFFDQELQRUhAgzPAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM6AILIABBO0cNACABQQFqIQEMDAtBACECIANBADYCHCADIAE2AhQgA0GYFzYCECADQQI2AgwM5gILIABBFUYNKEEAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzlAgsgA0EUNgIcIAMgATYCFCADIAA2AgwM5AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEM3AILIANBFTYCHCADIAA2AgwgAyABQQFqNgIUDOMCCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNoCCyADQRc2AhwgAyAANgIMIAMgAUEBajYCFAziAgsgAEEVRg0jQQAhAiADQQA2AhwgAyABNgIUIANBzgw2AhAgA0EjNgIMDOECCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDB0LIANBGTYCHCADIAA2AgwgAyABQQFqNgIUDOACCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNYCCyADQRo2AhwgAyAANgIMIAMgAUEBajYCFAzfAgsgAEEVRg0fQQAhAiADQQA2AhwgAyABNgIUIANBog82AhAgA0EiNgIMDN4CCyADKAIEIQBBACEC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DLMCCyABIARGBEBB6QEhAgyzAgsgAS0AAEHIAEYNASADQQE6ACgLQbYBIQIMlwILQcoBIQIMlgILIAEgBEcEQCADQQw2AgggAyABNgIEQckBIQIMlgILQegBIQIMrwILIAEgBEYEQEHnASECDK8CCyABLQAAQcgARw0EIAFBAWohAUHIASECDJQCCyABIARGBEBB5gEhAgyuAgsCQAJAIAEtAABBxQBrDhAABQUFBQUFBQUFBQUFBQUBBQsgAUEBaiEBQcYBIQIMlAILIAFBAWohAUHHASECDJMCC0HlASECIAEgBEYNrAIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB99MAai0AAEcNAyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMrQILIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgBFBEBB1AEhAgyTAgsgA0HkATYCHCADIAE2AhQgAyAANgIMQQAhAgysAgtB4wEhAiABIARGDasCIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQfXTAGotAABHDQIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADKwCCyADQYEEOwEoIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgANAwwCCyADQQA2AgALQQAhAiADQQA2AhwgAyABNgIUIANB0B42AhAgA0EINgIMDKkCC0HFASECDI4CCyADQeIBNgIcIAMgATYCFCADIAA2AgxBACECDKcCC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ1lIABBFUcEQCADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgynAgsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDKYCC0HhASECIAQgASIARg2lAiAEIAFrIAMoAgAiAWohBSAAIAFrQQRqIQYCQANAIAAtAAAgAUHw0wBqLQAARw0BIAFBBEYNAyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBTYCAAymAgsgA0EANgIcIAMgADYCFCADQYQ3NgIQIANBCDYCDCADQQA2AgBBACECDKUCCyABIARHBEAgA0ENNgIIIAMgATYCBEHCASECDIsCC0HgASECDKQCCyADQQA2AgAgBkEBaiEBC0HDASECDIgCCyABIARGBEBB3wEhAgyiAgsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFBwQEhAgyIAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYgCIANB3gE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAEgBEYEQEHdASECDKECCwJAIAEtAABBLkYEQCABQQFqIQEMAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYkCIANB3AE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILQcABIQIMhgILIAEgBEYEQEHbASECDKACC0EAIQBBASEFQQEhB0EAIQICQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQCABLQAAQTBrDgoKCQABAgMEBQYICwtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshAkEAIQVBACEHDAILQQkhAkEBIQBBACEFQQAhBwwBC0EAIQVBASECCyADIAI6ACsgAUEBaiEBAkACQCADLQAuQRBxDQACQAJAAkAgAy0AKg4DAQACBAsgB0UNAwwCCyAADQEMAgsgBUUNAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDQIgA0HYATYCHCADIAE2AhQgAyAANgIMQQAhAgyiAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYsCIANB2QE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ2JAiADQdoBNgIcIAMgATYCFCADIAA2AgwMoAILQb8BIQIMhQILQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALAkAgAARAIABBFUYNASADQQA2AhwgAyABNgIUIANBnA02AhAgA0EhNgIMQQAhAgygAgtBvgEhAgyFAgsgA0HXATYCHCADIAE2AhQgA0HWGTYCECADQRU2AgxBACECDJ4CCyABIARGBEBB1wEhAgyeAgsCQCABLQAAQSBGBEAgA0EAOwE0IAFBAWohAQwBCyADQQA2AhwgAyABNgIUIANB6xA2AhAgA0EJNgIMQQAhAgyeAgtBvQEhAgyDAgsgASAERgRAQdYBIQIM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LgsgAUEBaiEBQZcBIQIM2AELIAFBAWohAUEiDCsLIAEgBEYEQEGvASECDPEBCyABLQAAQdAARw0rIAFBAWohAUGWASECDNYBCyABIARGBEBBrgEhAgzwAQsCQAJAIAEtAABBxgBrDgsALCwsLCwsLCwsASwLIAFBAWohAUGUASECDNYBCyABQQFqIQFBlQEhAgzVAQtBrQEhAiABIARGDe4BIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQazTAGotAABHDSggAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO8BCyADQQA2AgAgBkEBaiEBQQ0MKAtBrAEhAiABIARGDe0BIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQeHTAGotAABHDScgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO4BCyADQQA2AgAgBkEBaiEBQQwMJwtBqwEhAiABIARGDewBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQarTAGotAABHDSYgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO0BCyADQQA2AgAgBkEBaiEBQQMMJgtBqgEhAiABIARGDesBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQajTAGotAABHDSUgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADOwBCyADQQA2AgAgBkEBaiEBQSYMJQsgASAERgRAQakBIQIM6wELAkACQCABLQAAQdQAaw4CAAEnCyABQQFqIQFBjwEhAgzRAQsgAUEBaiEBQZABIQIM0AELQagBIQIgASAERg3pASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGm0wBqLQAARw0jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzqAQsgA0EANgIAIAZBAWohAUEnDCMLQacBIQIgASAERg3oASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGk0wBqLQAARw0iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzpAQsgA0EANgIAIAZBAWohAUEcDCILQaYBIQIgASAERg3nASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGe0wBqLQAARw0hIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzoAQsgA0EANgIAIAZBAWohAUEGDCELQaUBIQIgASAERg3mASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEGZ0wBqLQAARw0gIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAznAQsgA0EANgIAIAZBAWohAUEZDCALIAEgBEYEQEGkASECDOYBCwJAAkACQAJAIAEtAABBLWsOIwAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAEkJCQkJAIkJCQDJAsgAUEBaiEBQYQBIQIMzgELIAFBAWohAUGFASECDM0BCyABQQFqIQFBigEhAgzMAQsgAUEBaiEBQYsBIQIMywELQaMBIQIgASAERg3kASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGX0wBqLQAARw0eIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzlAQsgA0EANgIAIAZBAWohAUELDB4LIAEgBEYEQEGiASECDOQBCwJAAkAgAS0AAEHBAGsOAwAgASALIAFBAWohAUGGASECDMoBCyABQQFqIQFBiQEhAgzJAQsgASAERgRAQaEBIQIM4wELAkACQCABLQAAQcEAaw4PAB8fHx8fHx8fHx8fHx8BHwsgAUEBaiEBQYcBIQIMyQELIAFBAWohAUGIASECDMgBCyABIARGBEBBoAEhAgziAQsgAS0AAEHMAEcNHCABQQFqIQFBCgwbC0GfASECIAEgBEYN4AEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBkdMAai0AAEcNGiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4QELIANBADYCACAGQQFqIQFBHgwaC0GeASECIAEgBEYN3wEgAygCACIAIAQgAWtqIQUgASAAa0EGaiEGAkADQCABLQAAIABBitMAai0AAEcNGSAAQQZGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4AELIANBADYCACAGQQFqIQFBFQwZC0GdASECIAEgBEYN3gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBh9MAai0AAEcNGCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3wELIANBADYCACAGQQFqIQFBFwwYC0GcASECIAEgBEYN3QEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBgdMAai0AAEcNFyAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3gELIANBADYCACAGQQFqIQFBGAwXCyABIARGBEBBmwEhAgzdAQsCQAJAIAEtAABByQBrDgcAGRkZGRkBGQsgAUEBaiEBQYEBIQIMwwELIAFBAWohAUGCASECDMIBC0GaASECIAEgBEYN2wEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5tMAai0AAEcNFSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3AELIANBADYCACAGQQFqIQFBCQwVC0GZASECIAEgBEYN2gEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5NMAai0AAEcNFCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2wELIANBADYCACAGQQFqIQFBHwwUC0GYASECIAEgBEYN2QEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB/tIAai0AAEcNEyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2gELIANBADYCACAGQQFqIQFBAgwTC0GXASECIAEgBEYN2AEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGA0AgAS0AACAAQfzSAGotAABHDREgAEEBRg0CIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNgBCyABIARGBEBBlgEhAgzYAQtBASABLQAAQd8ARw0RGiABQQFqIQFB/QAhAgy9AQsgA0EANgIAIAZBAWohAUH+ACECDLwBC0GVASECIAEgBEYN1QEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBxNMAai0AAEcNDyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1gELIANBADYCACAGQQFqIQFBKQwPC0GUASECIAEgBEYN1AEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB+NIAai0AAEcNDiAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1QELIANBADYCACAGQQFqIQFBLQwOCyABIARGBEBBkwEhAgzUAQsgAS0AAEHFAEcNDiABQQFqIQFB+gAhAgy5AQsgASAERgRAQZIBIQIM0wELAkACQCABLQAAQcwAaw4IAA8PDw8PDwEPCyABQQFqIQFB+AAhAgy5AQsgAUEBaiEBQfkAIQIMuAELQZEBIQIgASAERg3RASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHz0gBqLQAARw0LIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzSAQsgA0EANgIAIAZBAWohAUEjDAsLQZABIQIgASAERg3QASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHw0gBqLQAARw0KIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzRAQsgA0EANgIAIAZBAWohAUEADAoLIAEgBEYEQEGPASECDNABCwJAAkAgAS0AAEHIAGsOCAAMDAwMDAwBDAsgAUEBaiEBQfMAIQIMtgELIAFBAWohAUH2ACECDLUBCyABIARGBEBBjgEhAgzPAQsCQAJAIAEtAABBzgBrDgMACwELCyABQQFqIQFB9AAhAgy1AQsgAUEBaiEBQfUAIQIMtAELIAEgBEYEQEGNASECDM4BCyABLQAAQdkARw0IIAFBAWohAUEIDAcLQYwBIQIgASAERg3MASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHs0gBqLQAARw0GIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzNAQsgA0EANgIAIAZBAWohAUEFDAYLQYsBIQIgASAERg3LASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHm0gBqLQAARw0FIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzMAQsgA0EANgIAIAZBAWohAUEWDAULQYoBIQIgASAERg3KASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHh0wBqLQAARw0EIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzLAQsgA0EANgIAIAZBAWohAUEQDAQLIAEgBEYEQEGJASECDMoBCwJAAkAgAS0AAEHDAGsODAAGBgYGBgYGBgYGAQYLIAFBAWohAUHvACECDLABCyABQQFqIQFB8AAhAgyvAQtBiAEhAiABIARGDcgBIAMoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQeDSAGotAABHDQIgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADMkBCyADQQA2AgAgBkEBaiEBQSQMAgsgA0EANgIADAILIAEgBEYEQEGHASECDMcBCyABLQAAQcwARw0BIAFBAWohAUETCzoAKSADKAIEIQAgA0EANgIEIAMgACABEC0iAA0CDAELQQAhAiADQQA2AhwgAyABNgIUIANB6R42AhAgA0EGNgIMDMQBC0HuACECDKkBCyADQYYBNgIcIAMgATYCFCADIAA2AgxBACECDMIBC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ0AIABBFUYNASADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgzBAQtB7QAhAgymAQsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDL8BCyABIARGBEBBhQEhAgy/AQsCQCABLQAAQSBGBEAgAUEBaiEBDAELIANBADYCHCADIAE2AhQgA0GGHjYCECADQQY2AgxBACECDL8BC0ECIQIMpAELA0AgAS0AAEEgRw0CIAQgAUEBaiIBRw0AC0GEASECDL0BCyABIARGBEBBgwEhAgy9AQsCQCABLQAAQQlrDgRAAABAAAtB6wAhAgyiAQsgAy0AKUEFRgRAQewAIQIMogELQeoAIQIMoQELIAEgBEYEQEGCASECDLsBCyADQQ82AgggAyABNgIEDAoLIAEgBEYEQEGBASECDLoBCwJAIAEtAABBCWsOBD0AAD0AC0HpACECDJ8BCyABIARHBEAgA0EPNgIIIAMgATYCBEHnACECDJ8BC0GAASECDLgBCwJAIAEgBEcEQANAIAEtAABB4M4Aai0AACIAQQNHBEACQCAAQQFrDgI/AAQLQeYAIQIMoQELIAQgAUEBaiIBRw0AC0H+ACECDLkBC0H+ACECDLgBCyADQQA2AhwgAyABNgIUIANBxh82AhAgA0EHNgIMQQAhAgy3AQsgASAERgRAQf8AIQIMtwELAkACQAJAIAEtAABB4NAAai0AAEEBaw4DPAIAAQtB6AAhAgyeAQsgA0EANgIcIAMgATYCFCADQYYSNgIQIANBBzYCDEEAIQIMtwELQeAAIQIMnAELIAEgBEcEQCABQQFqIQFB5QAhAgycAQtB/QAhAgy1AQsgBCABIgBGBEBB/AAhAgy1AQsgAC0AACIBQS9GBEAgAEEBaiEBQeQAIQIMmwELIAFBCWsiAkEXSw0BIAAhAUEBIAJ0QZuAgARxDTcMAQsgBCABIgBGBEBB+wAhAgy0AQsgAC0AAEEvRw0AIABBAWohAQwDC0EAIQIgA0EANgIcIAMgADYCFCADQcYfNgIQIANBBzYCDAyyAQsCQAJAAkACQAJAA0AgAS0AAEHgzABqLQAAIgBBBUcEQAJAAkAgAEEBaw4IPQUGBwgABAEIC0HhACECDJ8BCyABQQFqIQFB4wAhAgyeAQsgBCABQQFqIgFHDQALQfoAIQIMtgELIAFBAWoMFAsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgy0AQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyzAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyyAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMsQELIAEgBEYEQEH5ACECDLEBCwJAIAEtAABB4MwAai0AAEEBaw4INAQFBgAIAgMHCyABQQFqIQELQQMhAgyVAQsgAUEBagwNC0EAIQIgA0EANgIcIANBoxI2AhAgA0EHNgIMIAMgAUEBajYCFAytAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgysAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyrAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyqAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMqQELQeIAIQIMjgELIAEgBEYEQEH4ACECDKgBCyABQQFqDAILIAEgBEYEQEH3ACECDKcBCyABQQFqDAELIAEgBEYNASABQQFqCyEBQQQhAgyKAQtB9gAhAgyjAQsDQCABLQAAQeDKAGotAAAiAEECRwRAIABBAUcEQEHfACECDIsBCwwnCyAEIAFBAWoiAUcNAAtB9QAhAgyiAQsgASAERgRAQfQAIQIMogELAkAgAS0AAEEJaw43JQMGJQQGBgYGBgYGBgYGBgYGBgYGBgYFBgYCBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGAAYLIAFBAWoLIQFBBSECDIYBCyABQQFqDAYLIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB2wA2AhwgAyABNgIUIAMgADYCDEEAIQIMngELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB3QA2AhwgAyABNgIUIAMgADYCDEEAIQIMnQELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB8AA2AhwgAyABNgIUIAMgADYCDEEAIQIMnAELIANBADYCHCADIAE2AhQgA0G8EzYCECADQQc2AgxBACECDJsBCwJAAkACQAJAA0AgAS0AAEHgyABqLQAAIgBBBUcEQAJAIABBAWsOBiQDBAUGAAYLQd4AIQIMhgELIAQgAUEBaiIBRw0AC0HzACECDJ4BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQdsANgIcIAMgATYCFCADIAA2AgxBACECDJ0BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQd0ANgIcIAMgATYCFCADIAA2AgxBACECDJwBCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQfAANgIcIAMgATYCFCADIAA2AgxBACECDJsBCyADQQA2AhwgAyABNgIUIANB3Ag2AhAgA0EHNgIMQQAhAgyaAQsgASAERg0BIAFBAWoLIQFBBiECDH4LQfIAIQIMlwELAkACQAJAAkADQCABLQAAQeDGAGotAAAiAEEFRwRAIABBAWsOBB8CAwQFCyAEIAFBAWoiAUcNAAtB8QAhAgyaAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgyZAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyYAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyXAQsgA0EANgIcIAMgATYCFCADQbQKNgIQIANBBzYCDEEAIQIMlgELQc4AIQIMewtB0AAhAgx6C0HdACECDHkLIAEgBEYEQEHwACECDJMBCwJAIAEtAABBCWsOBBYAABYACyABQQFqIQFB3AAhAgx4CyABIARGBEBB7wAhAgySAQsCQCABLQAAQQlrDgQVAAAVAAtBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUEQEHTASECDHgLIABBFUcEQCADQQA2AhwgAyABNgIUIANBwQ02AhAgA0EaNgIMQQAhAgySAQsgA0HuADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDJEBC0HtACECIAEgBEYNkAEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB18YAai0AAEcNBCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMkQELIANBADYCACAGQQFqIQEgAy0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACECIANBADYCHCADIAE2AhQgA0HlCTYCECADQQg2AgwMkAELQewAIQIgASAERg2PASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHUxgBqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyQAQsgA0EANgIAIAZBAWohASADLQApQSFGDQMgA0EANgIcIAMgATYCFCADQYkKNgIQIANBCDYCDEEAIQIMjwELQesAIQIgASAERg2OASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHQxgBqLQAARw0CIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyPAQsgA0EANgIAIAZBAWohASADLQApIgBBI0kNAiAAQS5GDQIgA0EANgIcIAMgATYCFCADQcEJNgIQIANBCDYCDEEAIQIMjgELIANBADYCAAtBACECIANBADYCHCADIAE2AhQgA0GENzYCECADQQg2AgwMjAELQdgAIQIMcQsgASAERwRAIANBDTYCCCADIAE2AgRB1wAhAgxxC0HqACECDIoBCyABIARGBEBB6QAhAgyKAQsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFB1gAhAgxwCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdCADQegANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyABIARGBEBB5wAhAgyJAQsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ11IANB5gA2AhwgAyABNgIUIAMgADYCDEEAIQIMiQELQdUAIQIMbgsgASAERgRAQeUAIQIMiAELQQAhAEEBIQVBASEHQQAhAgJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAEtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyECQQAhBUEAIQcMAgtBCSECQQEhAEEAIQVBACEHDAELQQAhBUEBIQILIAMgAjoAKyABQQFqIQECQAJAIAMtAC5BEHENAAJAAkACQCADLQAqDgMBAAIECyAHRQ0DDAILIAANAQwCCyAFRQ0BCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNAiADQeIANgIcIAMgATYCFCADIAA2AgxBACECDIoBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdyADQeMANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdSADQeQANgIcIAMgATYCFCADIAA2AgwMiAELQdMAIQIMbQsgAy0AKUEiRg2AAUHSACECDGwLQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALIABFBEBB1AAhAgxsCyAAQRVHBEAgA0EANgIcIAMgATYCFCADQZwNNgIQIANBITYCDEEAIQIMhgELIANB4QA2AhwgAyABNgIUIANB1hk2AhAgA0EVNgIMQQAhAgyFAQsgASAERgRAQeAAIQIMhQELAkACQAJAAkACQCABLQAAQQprDgQBBAQABAsgAUEBaiEBDAELIAFBAWohASADQS9qLQAAQQFxRQ0BC0HRACECDGwLIANBADYCHCADIAE2AhQgA0GIETYCECADQQk2AgxBACECDIUBCyADQQA2AhwgAyABNgIUIANBiBE2AhAgA0EJNgIMQQAhAgyEAQsgASAERgRAQd8AIQIMhAELIAEtAABBCkYEQCABQQFqIQEMCQsgAy0ALkHAAHENCCADQQA2AhwgAyABNgIUIANBiBE2AhAgA0ECNgIMQQAhAgyDAQsgASAERgRAQd0AIQIMgwELIAEtAAAiAkENRgRAIAFBAWohAUHPACECDGkLIAEhACACQQlrDgQFAQEFAQsgBCABIgBGBEBB3AAhAgyCAQsgAC0AAEEKRw0AIABBAWoMAgtBACECIANBADYCHCADIAA2AhQgA0G1LDYCECADQQc2AgwMgAELIAEgBEYEQEHbACECDIABCwJAIAEtAABBCWsOBAMAAAMACyABQQFqCyEBQc0AIQIMZAsgASAERgRAQdoAIQIMfgsgAS0AAEEJaw4EAAEBAAELQQAhAiADQQA2AhwgA0HsETYCECADQQc2AgwgAyABQQFqNgIUDHwLIANBgBI7ASpBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUNACAAQRVHDQEgA0HZADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDHsLQcwAIQIMYAsgA0EANgIcIAMgATYCFCADQcENNgIQIANBGjYCDEEAIQIMeQsgASAERgRAQdkAIQIMeQsgAS0AAEEgRw06IAFBAWohASADLQAuQQFxDTogA0EANgIcIAMgATYCFCADQa0bNgIQIANBHjYCDEEAIQIMeAsgASAERgRAQdgAIQIMeAsCQAJAAkACQAJAIAEtAAAiAEEKaw4EAgMD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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQTBrDjcVFAABAgMEBQYHFhYWFhYWFggJCgsMDRYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWDg8QERITFgtCAiEKDBQLQgMhCgwTC0IEIQoMEgtCBSEKDBELQgYhCgwQC0IHIQoMDwtCCCEKDA4LQgkhCgwNC0IKIQoMDAtCCyEKDAsLQgwhCgwKC0INIQoMCQtCDiEKDAgLQg8hCgwHC0IKIQoMBgtCCyEKDAULQgwhCgwEC0INIQoMAwtCDiEKDAILQg8hCgwBC0IBIQoLIAFBAWohASADKQMgIgtC//////////8PWARAIAMgC0IEhiAKhDcDIAwCC0EAIQIgA0EANgIcIAMgATYCFCADQa0JNgIQIANBDDYCDAwfC0ElIQIMBAtBJiECDAMLIAMgAToALCADQQA2AgAgB0EBaiEBQQwhAgwCCyADQQA2AgAgBkEBaiEBQQohAgwBCyABQQFqIQFBCCECDAALAAtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMGAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMFwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMFgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMFQtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMFAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMEwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMEgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMEQtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMEAtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMDwtBACECIANBADYCHCADIAE2AhQgA0HIEjYCECADQQs2AgwMDgtBACECIANBADYCHCADIAE2AhQgA0GVCTYCECADQQs2AgwMDQtBACECIANBADYCHCADIAE2AhQgA0HpDzYCECADQQo2AgwMDAtBACECIANBADYCHCADIAE2AhQgA0GDEDYCECADQQo2AgwMCwtBACECIANBADYCHCADIAE2AhQgA0GmHDYCECADQQI2AgwMCgtBACECIANBADYCHCADIAE2AhQgA0HFFTYCECADQQI2AgwMCQtBACECIANBADYCHCADIAE2AhQgA0H/FzYCECADQQI2AgwMCAtBACECIANBADYCHCADIAE2AhQgA0HKFzYCECADQQI2AgwMBwsgA0ECNgIcIAMgATYCFCADQZQdNgIQIANBFjYCDEEAIQIMBgtB3gAhAiABIARGDQUgCUEIaiEHIAMoAgAhBQJAAkAgASAERwRAIAVBxsYAaiEIIAQgBWogAWshBiAFQX9zQQpqIgUgAWohAANAIAEtAAAgCC0AAEcEQEECIQgMAwsgBUUEQEEAIQggACEBDAMLIAVBAWshBSAIQQFqIQggBCABQQFqIgFHDQALIAYhBSAEIQELIAdBATYCACADIAU2AgAMAQsgA0EANgIAIAcgCDYCAAsgByABNgIEIAkoAgwhACAJKAIIDgMBBQIACwALIANBADYCHCADQa0dNgIQIANBFzYCDCADIABBAWo2AhRBACECDAMLIANBADYCHCADIAA2AhQgA0HCHTYCECADQQk2AgxBACECDAILIAEgBEYEQEEoIQIMAgsgA0EJNgIIIAMgATYCBEEnIQIMAQsgASAERgRAQQEhAgwBCwNAAkACQAJAIAEtAABBCmsOBAABAQABCyABQQFqIQEMAQsgAUEBaiEBIAMtAC5BIHENAEEAIQIgA0EANgIcIAMgATYCFCADQYwgNgIQIANBBTYCDAwCC0EBIQIgASAERw0ACwsgCUEQaiQAIAJFBEAgAygCDCEADAELIAMgAjYCHEEAIQAgAygCBCIBRQ0AIAMgASAEIAMoAggRAQAiAUUNACADIAQ2AhQgAyABNgIMIAEhAAsgAAu+AgECfyAAQQA6AAAgAEHcAGoiAUEBa0EAOgAAIABBADoAAiAAQQA6AAEgAUEDa0EAOgAAIAFBAmtBADoAACAAQQA6AAMgAUEEa0EAOgAAQQAgAGtBA3EiASAAaiIAQQA2AgBB3AAgAWtBfHEiAiAAaiIBQQRrQQA2AgACQCACQQlJDQAgAEEANgIIIABBADYCBCABQQhrQQA2AgAgAUEMa0EANgIAIAJBGUkNACAAQQA2AhggAEEANgIUIABBADYC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U3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMARXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVycwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgAVHJhbnNmZXItRW5jb2RpbmcgY2FuJ3QgYmUgcHJlc2VudCB3aXRoIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgc2l6ZQBFeHBlY3RlZCBMRiBhZnRlciBjaHVuayBzaXplAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGhlYWRlciB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgZXh0ZW5zaW9uIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBxdW90ZWQtcGFpciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgcmVzcG9uc2UgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGNodW5rIGV4dGVuc2lvbiBuYW1lAEludmFsaWQgc3RhdHVzIGNvZGUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBkYXRhAEV4cGVjdGVkIExGIGFmdGVyIGNodW5rIGRhdGEAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAERhdGEgYWZ0ZXIgYENvbm5lY3Rpb246IGNsb3NlYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAUVVFUlkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBFeHBlY3RlZCBMRiBhZnRlciBDUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAFIVAAAaFQAADxIAAOQZAACRFQAACRQAAC0ZAADkFAAA6REAAGkUAAChFAAAdhUAAEMWAABeEgAAlBcAABcWAAB9FAAAfxYAAEEXAACzEwAAwxYAAAQaAAC9GAAA0BgAAKATAADUGQAArxYAAGgWAABwFwAA2RYAAPwYAAD+EQAAWRcAAJcWAAAcFwAA9hYAAI0XAAALEgAAfxsAAC4RAACzEAAASRIAAK0SAAD2GAAAaBAAAGIVAAAQFQAAWhYAAEoZAAC1FQAAwRUAAGAVAABcGQAAWhkAAFMZAAAWFQAArREAAEIQAAC3EAAAVxgAAL8VAACJEAAAHBkAABoZAAC5FQAAURgAANwTAABbFQAAWRUAAOYYAABnFQAAERkAAO0YAADnEwAArhAAAMIXAAAAFAAAkhMAAIQTAABAEgAAJhkAAK8VAABiEABB6TkLAQEAQYA6C+ABAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAwEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQeo7CwQBAAACAEGBPAteAwQDAwMDAwAAAwMAAwMAAwMDAwMDAwMDAwAFAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAMAAwBB6j0LBAEAAAIAQYE+C14DAAMDAwMDAAADAwADAwADAwMDAwMDAwMDAAQABQAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwADAEHgPwsNbG9zZWVlcC1hbGl2ZQBB+T8LAQEAQZDAAAvgAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH5wQALAQEAQZDCAAvnAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZABBocQAC14BAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAEGAxgALIWVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgBBsMYACytyYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNClNNDQoNClRUUC9DRS9UU1AvAEHpxgALBQECAAEDAEGAxwALXwQFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAEHpyAALBQECAAEDAEGAyQALXwQFBQYFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAEHpygALBAEAAAEAQYHLAAteAgIAAgICAgICAgICAgICAgICAgICAgICAgICAgICAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgBB6cwACwUBAgABAwBBgM0AC18EBQAABQUFBQUFBQUFBQUGBQUFBQUFBQUFBQUFAAUABwgFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUABQAFAAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAAAABQBB6c4ACwUBAQABAQBBgM8ACwEBAEGazwALQQIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAEHp0AALBQEBAAEBAEGA0QALAQEAQYrRAAsGAgAAAAACAEGh0QALOgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQeDSAAuaAU5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VVRVJZT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
    let wasmBuffer;
    Object.defineProperty(module, "exports", {
      get: () => {
        return wasmBuffer ? wasmBuffer : wasmBuffer = Buffer2.from(wasmBase64, "base64");
      }
    });
  })(llhttp_simdWasm$1);
  return llhttp_simdWasm$1.exports;
}
var constants$a;
var hasRequiredConstants$5;
function requireConstants$5() {
  if (hasRequiredConstants$5) return constants$a;
  hasRequiredConstants$5 = 1;
  const corsSafeListedMethods = (
    /** @type {const} */
    ["GET", "HEAD", "POST"]
  );
  const corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
  const nullBodyStatus = (
    /** @type {const} */
    [101, 204, 205, 304]
  );
  const redirectStatus = (
    /** @type {const} */
    [301, 302, 303, 307, 308]
  );
  const redirectStatusSet = new Set(redirectStatus);
  const badPorts = (
    /** @type {const} */
    [
      "1",
      "7",
      "9",
      "11",
      "13",
      "15",
      "17",
      "19",
      "20",
      "21",
      "22",
      "23",
      "25",
      "37",
      "42",
      "43",
      "53",
      "69",
      "77",
      "79",
      "87",
      "95",
      "101",
      "102",
      "103",
      "104",
      "109",
      "110",
      "111",
      "113",
      "115",
      "117",
      "119",
      "123",
      "135",
      "137",
      "139",
      "143",
      "161",
      "179",
      "389",
      "427",
      "465",
      "512",
      "513",
      "514",
      "515",
      "526",
      "530",
      "531",
      "532",
      "540",
      "548",
      "554",
      "556",
      "563",
      "587",
      "601",
      "636",
      "989",
      "990",
      "993",
      "995",
      "1719",
      "1720",
      "1723",
      "2049",
      "3659",
      "4045",
      "4190",
      "5060",
      "5061",
      "6000",
      "6566",
      "6665",
      "6666",
      "6667",
      "6668",
      "6669",
      "6679",
      "6697",
      "10080"
    ]
  );
  const badPortsSet = new Set(badPorts);
  const referrerPolicyTokens = (
    /** @type {const} */
    [
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ]
  );
  const referrerPolicy = (
    /** @type {const} */
    [
      "",
      ...referrerPolicyTokens
    ]
  );
  const referrerPolicyTokensSet = new Set(referrerPolicyTokens);
  const requestRedirect = (
    /** @type {const} */
    ["follow", "manual", "error"]
  );
  const safeMethods = (
    /** @type {const} */
    ["GET", "HEAD", "OPTIONS", "TRACE"]
  );
  const safeMethodsSet = new Set(safeMethods);
  const requestMode = (
    /** @type {const} */
    ["navigate", "same-origin", "no-cors", "cors"]
  );
  const requestCredentials = (
    /** @type {const} */
    ["omit", "same-origin", "include"]
  );
  const requestCache = (
    /** @type {const} */
    [
      "default",
      "no-store",
      "reload",
      "no-cache",
      "force-cache",
      "only-if-cached"
    ]
  );
  const requestBodyHeader = (
    /** @type {const} */
    [
      "content-encoding",
      "content-language",
      "content-location",
      "content-type",
      // See https://github.com/nodejs/undici/issues/2021
      // 'Content-Length' is a forbidden header name, which is typically
      // removed in the Headers implementation. However, undici doesn't
      // filter out headers, so we add it here.
      "content-length"
    ]
  );
  const requestDuplex = (
    /** @type {const} */
    [
      "half"
    ]
  );
  const forbiddenMethods = (
    /** @type {const} */
    ["CONNECT", "TRACE", "TRACK"]
  );
  const forbiddenMethodsSet = new Set(forbiddenMethods);
  const subresource = (
    /** @type {const} */
    [
      "audio",
      "audioworklet",
      "font",
      "image",
      "manifest",
      "paintworklet",
      "script",
      "style",
      "track",
      "video",
      "xslt",
      ""
    ]
  );
  const subresourceSet = new Set(subresource);
  constants$a = {
    subresource,
    forbiddenMethods,
    requestBodyHeader,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    redirectStatus,
    corsSafeListedMethods,
    nullBodyStatus,
    safeMethods,
    badPorts,
    requestDuplex,
    subresourceSet,
    badPortsSet,
    redirectStatusSet,
    corsSafeListedMethodsSet,
    safeMethodsSet,
    forbiddenMethodsSet,
    referrerPolicyTokens: referrerPolicyTokensSet
  };
  return constants$a;
}
var global$4;
var hasRequiredGlobal$1;
function requireGlobal$1() {
  if (hasRequiredGlobal$1) return global$4;
  hasRequiredGlobal$1 = 1;
  const globalOrigin = Symbol.for("undici.globalOrigin.1");
  function getGlobalOrigin2() {
    return globalThis[globalOrigin];
  }
  function setGlobalOrigin2(newOrigin) {
    if (newOrigin === void 0) {
      Object.defineProperty(globalThis, globalOrigin, {
        value: void 0,
        writable: true,
        enumerable: false,
        configurable: false
      });
      return;
    }
    const parsedURL = new URL(newOrigin);
    if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
      throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
    }
    Object.defineProperty(globalThis, globalOrigin, {
      value: parsedURL,
      writable: true,
      enumerable: false,
      configurable: false
    });
  }
  global$4 = {
    getGlobalOrigin: getGlobalOrigin2,
    setGlobalOrigin: setGlobalOrigin2
  };
  return global$4;
}
var dataUrl$1;
var hasRequiredDataUrl$1;
function requireDataUrl$1() {
  if (hasRequiredDataUrl$1) return dataUrl$1;
  hasRequiredDataUrl$1 = 1;
  const assert2 = require$$0$3;
  const encoder = new TextEncoder();
  const HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+\-.^_|~A-Za-z0-9]+$/;
  const HTTP_WHITESPACE_REGEX = /[\u000A\u000D\u0009\u0020]/;
  const ASCII_WHITESPACE_REPLACE_REGEX = /[\u0009\u000A\u000C\u000D\u0020]/g;
  const HTTP_QUOTED_STRING_TOKENS = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
  function dataURLProcessor(dataURL) {
    assert2(dataURL.protocol === "data:");
    let input = URLSerializer(dataURL, true);
    input = input.slice(5);
    const position = { position: 0 };
    let mimeType = collectASequenceOfCodePointsFast(
      ",",
      input,
      position
    );
    const mimeTypeLength = mimeType.length;
    mimeType = removeASCIIWhitespace(mimeType, true, true);
    if (position.position >= input.length) {
      return "failure";
    }
    position.position++;
    const encodedBody = input.slice(mimeTypeLength + 1);
    let body2 = stringPercentDecode(encodedBody);
    if (/;(\u0020){0,}base64$/i.test(mimeType)) {
      const stringBody = isomorphicDecode(body2);
      body2 = forgivingBase64(stringBody);
      if (body2 === "failure") {
        return "failure";
      }
      mimeType = mimeType.slice(0, -6);
      mimeType = mimeType.replace(/(\u0020)+$/, "");
      mimeType = mimeType.slice(0, -1);
    }
    if (mimeType.startsWith(";")) {
      mimeType = "text/plain" + mimeType;
    }
    let mimeTypeRecord = parseMIMEType2(mimeType);
    if (mimeTypeRecord === "failure") {
      mimeTypeRecord = parseMIMEType2("text/plain;charset=US-ASCII");
    }
    return { mimeType: mimeTypeRecord, body: body2 };
  }
  function URLSerializer(url, excludeFragment = false) {
    if (!excludeFragment) {
      return url.href;
    }
    const href = url.href;
    const hashLength = url.hash.length;
    const serialized = hashLength === 0 ? href : href.substring(0, href.length - hashLength);
    if (!hashLength && href.endsWith("#")) {
      return serialized.slice(0, -1);
    }
    return serialized;
  }
  function collectASequenceOfCodePoints(condition, input, position) {
    let result = "";
    while (position.position < input.length && condition(input[position.position])) {
      result += input[position.position];
      position.position++;
    }
    return result;
  }
  function collectASequenceOfCodePointsFast(char, input, position) {
    const idx = input.indexOf(char, position.position);
    const start = position.position;
    if (idx === -1) {
      position.position = input.length;
      return input.slice(start);
    }
    position.position = idx;
    return input.slice(start, position.position);
  }
  function stringPercentDecode(input) {
    const bytes = encoder.encode(input);
    return percentDecode(bytes);
  }
  function isHexCharByte(byte) {
    return byte >= 48 && byte <= 57 || byte >= 65 && byte <= 70 || byte >= 97 && byte <= 102;
  }
  function hexByteToNumber(byte) {
    return (
      // 0-9
      byte >= 48 && byte <= 57 ? byte - 48 : (byte & 223) - 55
    );
  }
  function percentDecode(input) {
    const length = input.length;
    const output = new Uint8Array(length);
    let j = 0;
    for (let i = 0; i < length; ++i) {
      const byte = input[i];
      if (byte !== 37) {
        output[j++] = byte;
      } else if (byte === 37 && !(isHexCharByte(input[i + 1]) && isHexCharByte(input[i + 2]))) {
        output[j++] = 37;
      } else {
        output[j++] = hexByteToNumber(input[i + 1]) << 4 | hexByteToNumber(input[i + 2]);
        i += 2;
      }
    }
    return length === j ? output : output.subarray(0, j);
  }
  function parseMIMEType2(input) {
    input = removeHTTPWhitespace(input, true, true);
    const position = { position: 0 };
    const type = collectASequenceOfCodePointsFast(
      "/",
      input,
      position
    );
    if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
      return "failure";
    }
    if (position.position >= input.length) {
      return "failure";
    }
    position.position++;
    let subtype = collectASequenceOfCodePointsFast(
      ";",
      input,
      position
    );
    subtype = removeHTTPWhitespace(subtype, false, true);
    if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
      return "failure";
    }
    const typeLowercase = type.toLowerCase();
    const subtypeLowercase = subtype.toLowerCase();
    const mimeType = {
      type: typeLowercase,
      subtype: subtypeLowercase,
      /** @type {Map<string, string>} */
      parameters: /* @__PURE__ */ new Map(),
      // https://mimesniff.spec.whatwg.org/#mime-type-essence
      essence: `${typeLowercase}/${subtypeLowercase}`
    };
    while (position.position < input.length) {
      position.position++;
      collectASequenceOfCodePoints(
        // https://fetch.spec.whatwg.org/#http-whitespace
        (char) => HTTP_WHITESPACE_REGEX.test(char),
        input,
        position
      );
      let parameterName = collectASequenceOfCodePoints(
        (char) => char !== ";" && char !== "=",
        input,
        position
      );
      parameterName = parameterName.toLowerCase();
      if (position.position < input.length) {
        if (input[position.position] === ";") {
          continue;
        }
        position.position++;
      }
      if (position.position >= input.length) {
        break;
      }
      let parameterValue = null;
      if (input[position.position] === '"') {
        parameterValue = collectAnHTTPQuotedString(input, position, true);
        collectASequenceOfCodePointsFast(
          ";",
          input,
          position
        );
      } else {
        parameterValue = collectASequenceOfCodePointsFast(
          ";",
          input,
          position
        );
        parameterValue = removeHTTPWhitespace(parameterValue, false, true);
        if (parameterValue.length === 0) {
          continue;
        }
      }
      if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
        mimeType.parameters.set(parameterName, parameterValue);
      }
    }
    return mimeType;
  }
  function forgivingBase64(data) {
    data = data.replace(ASCII_WHITESPACE_REPLACE_REGEX, "");
    let dataLength = data.length;
    if (dataLength % 4 === 0) {
      if (data.charCodeAt(dataLength - 1) === 61) {
        --dataLength;
        if (data.charCodeAt(dataLength - 1) === 61) {
          --dataLength;
        }
      }
    }
    if (dataLength % 4 === 1) {
      return "failure";
    }
    if (/[^+/0-9A-Za-z]/.test(data.length === dataLength ? data : data.substring(0, dataLength))) {
      return "failure";
    }
    const buffer = Buffer.from(data, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  }
  function collectAnHTTPQuotedString(input, position, extractValue = false) {
    const positionStart = position.position;
    let value = "";
    assert2(input[position.position] === '"');
    position.position++;
    while (true) {
      value += collectASequenceOfCodePoints(
        (char) => char !== '"' && char !== "\\",
        input,
        position
      );
      if (position.position >= input.length) {
        break;
      }
      const quoteOrBackslash = input[position.position];
      position.position++;
      if (quoteOrBackslash === "\\") {
        if (position.position >= input.length) {
          value += "\\";
          break;
        }
        value += input[position.position];
        position.position++;
      } else {
        assert2(quoteOrBackslash === '"');
        break;
      }
    }
    if (extractValue) {
      return value;
    }
    return input.slice(positionStart, position.position);
  }
  function serializeAMimeType2(mimeType) {
    assert2(mimeType !== "failure");
    const { parameters, essence } = mimeType;
    let serialization = essence;
    for (let [name, value] of parameters.entries()) {
      serialization += ";";
      serialization += name;
      serialization += "=";
      if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
        value = value.replace(/(\\|")/g, "\\$1");
        value = '"' + value;
        value += '"';
      }
      serialization += value;
    }
    return serialization;
  }
  function isHTTPWhiteSpace(char) {
    return char === 13 || char === 10 || char === 9 || char === 32;
  }
  function removeHTTPWhitespace(str, leading = true, trailing = true) {
    return removeChars(str, leading, trailing, isHTTPWhiteSpace);
  }
  function isASCIIWhitespace(char) {
    return char === 13 || char === 10 || char === 9 || char === 12 || char === 32;
  }
  function removeASCIIWhitespace(str, leading = true, trailing = true) {
    return removeChars(str, leading, trailing, isASCIIWhitespace);
  }
  function removeChars(str, leading, trailing, predicate) {
    let lead = 0;
    let trail = str.length - 1;
    if (leading) {
      while (lead < str.length && predicate(str.charCodeAt(lead))) lead++;
    }
    if (trailing) {
      while (trail > 0 && predicate(str.charCodeAt(trail))) trail--;
    }
    return lead === 0 && trail === str.length - 1 ? str : str.slice(lead, trail + 1);
  }
  function isomorphicDecode(input) {
    const length = input.length;
    if ((2 << 15) - 1 > length) {
      return String.fromCharCode.apply(null, input);
    }
    let result = "";
    let i = 0;
    let addition = (2 << 15) - 1;
    while (i < length) {
      if (i + addition > length) {
        addition = length - i;
      }
      result += String.fromCharCode.apply(null, input.subarray(i, i += addition));
    }
    return result;
  }
  function minimizeSupportedMimeType(mimeType) {
    switch (mimeType.essence) {
      case "application/ecmascript":
      case "application/javascript":
      case "application/x-ecmascript":
      case "application/x-javascript":
      case "text/ecmascript":
      case "text/javascript":
      case "text/javascript1.0":
      case "text/javascript1.1":
      case "text/javascript1.2":
      case "text/javascript1.3":
      case "text/javascript1.4":
      case "text/javascript1.5":
      case "text/jscript":
      case "text/livescript":
      case "text/x-ecmascript":
      case "text/x-javascript":
        return "text/javascript";
      case "application/json":
      case "text/json":
        return "application/json";
      case "image/svg+xml":
        return "image/svg+xml";
      case "text/xml":
      case "application/xml":
        return "application/xml";
    }
    if (mimeType.subtype.endsWith("+json")) {
      return "application/json";
    }
    if (mimeType.subtype.endsWith("+xml")) {
      return "application/xml";
    }
    return "";
  }
  dataUrl$1 = {
    dataURLProcessor,
    URLSerializer,
    collectASequenceOfCodePoints,
    collectASequenceOfCodePointsFast,
    stringPercentDecode,
    parseMIMEType: parseMIMEType2,
    collectAnHTTPQuotedString,
    serializeAMimeType: serializeAMimeType2,
    removeChars,
    removeHTTPWhitespace,
    minimizeSupportedMimeType,
    HTTP_TOKEN_CODEPOINTS,
    isomorphicDecode
  };
  return dataUrl$1;
}
var webidl_1$1;
var hasRequiredWebidl$1;
function requireWebidl$1() {
  if (hasRequiredWebidl$1) return webidl_1$1;
  hasRequiredWebidl$1 = 1;
  const { types, inspect } = require$$0$2;
  const { markAsUncloneable } = require$$1$1;
  const { toUSVString: toUSVString2 } = util$J;
  const UNDEFINED = 1;
  const BOOLEAN = 2;
  const STRING = 3;
  const SYMBOL = 4;
  const NUMBER = 5;
  const BIGINT = 6;
  const NULL = 7;
  const OBJECT = 8;
  const FunctionPrototypeSymbolHasInstance = Function.call.bind(Function.prototype[Symbol.hasInstance]);
  const webidl = {
    converters: {},
    util: {},
    errors: {},
    is: {}
  };
  webidl.errors.exception = function(message) {
    return new TypeError(`${message.header}: ${message.message}`);
  };
  webidl.errors.conversionFailed = function(context) {
    const plural = context.types.length === 1 ? "" : " one of";
    const message = `${context.argument} could not be converted to${plural}: ${context.types.join(", ")}.`;
    return webidl.errors.exception({
      header: context.prefix,
      message
    });
  };
  webidl.errors.invalidArgument = function(context) {
    return webidl.errors.exception({
      header: context.prefix,
      message: `"${context.value}" is an invalid ${context.type}.`
    });
  };
  webidl.brandCheck = function(V, I) {
    if (!FunctionPrototypeSymbolHasInstance(I, V)) {
      const err = new TypeError("Illegal invocation");
      err.code = "ERR_INVALID_THIS";
      throw err;
    }
  };
  webidl.brandCheckMultiple = function(List) {
    const prototypes = List.map((c) => webidl.util.MakeTypeAssertion(c));
    return (V) => {
      if (prototypes.every((typeCheck) => !typeCheck(V))) {
        const err = new TypeError("Illegal invocation");
        err.code = "ERR_INVALID_THIS";
        throw err;
      }
    };
  };
  webidl.argumentLengthCheck = function({ length }, min, ctx) {
    if (length < min) {
      throw webidl.errors.exception({
        message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
        header: ctx
      });
    }
  };
  webidl.illegalConstructor = function() {
    throw webidl.errors.exception({
      header: "TypeError",
      message: "Illegal constructor"
    });
  };
  webidl.util.MakeTypeAssertion = function(I) {
    return (O) => FunctionPrototypeSymbolHasInstance(I, O);
  };
  webidl.util.Type = function(V) {
    switch (typeof V) {
      case "undefined":
        return UNDEFINED;
      case "boolean":
        return BOOLEAN;
      case "string":
        return STRING;
      case "symbol":
        return SYMBOL;
      case "number":
        return NUMBER;
      case "bigint":
        return BIGINT;
      case "function":
      case "object": {
        if (V === null) {
          return NULL;
        }
        return OBJECT;
      }
    }
  };
  webidl.util.Types = {
    UNDEFINED,
    BOOLEAN,
    STRING,
    SYMBOL,
    NUMBER,
    BIGINT,
    NULL,
    OBJECT
  };
  webidl.util.TypeValueToString = function(o) {
    switch (webidl.util.Type(o)) {
      case UNDEFINED:
        return "Undefined";
      case BOOLEAN:
        return "Boolean";
      case STRING:
        return "String";
      case SYMBOL:
        return "Symbol";
      case NUMBER:
        return "Number";
      case BIGINT:
        return "BigInt";
      case NULL:
        return "Null";
      case OBJECT:
        return "Object";
    }
  };
  webidl.util.markAsUncloneable = markAsUncloneable || (() => {
  });
  webidl.util.ConvertToInt = function(V, bitLength, signedness, opts) {
    let upperBound;
    let lowerBound;
    if (bitLength === 64) {
      upperBound = Math.pow(2, 53) - 1;
      if (signedness === "unsigned") {
        lowerBound = 0;
      } else {
        lowerBound = Math.pow(-2, 53) + 1;
      }
    } else if (signedness === "unsigned") {
      lowerBound = 0;
      upperBound = Math.pow(2, bitLength) - 1;
    } else {
      lowerBound = Math.pow(-2, bitLength) - 1;
      upperBound = Math.pow(2, bitLength - 1) - 1;
    }
    let x = Number(V);
    if (x === 0) {
      x = 0;
    }
    if ((opts == null ? void 0 : opts.enforceRange) === true) {
      if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Could not convert ${webidl.util.Stringify(V)} to an integer.`
        });
      }
      x = webidl.util.IntegerPart(x);
      if (x < lowerBound || x > upperBound) {
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
        });
      }
      return x;
    }
    if (!Number.isNaN(x) && (opts == null ? void 0 : opts.clamp) === true) {
      x = Math.min(Math.max(x, lowerBound), upperBound);
      if (Math.floor(x) % 2 === 0) {
        x = Math.floor(x);
      } else {
        x = Math.ceil(x);
      }
      return x;
    }
    if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
      return 0;
    }
    x = webidl.util.IntegerPart(x);
    x = x % Math.pow(2, bitLength);
    if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
      return x - Math.pow(2, bitLength);
    }
    return x;
  };
  webidl.util.IntegerPart = function(n) {
    const r = Math.floor(Math.abs(n));
    if (n < 0) {
      return -1 * r;
    }
    return r;
  };
  webidl.util.Stringify = function(V) {
    const type = webidl.util.Type(V);
    switch (type) {
      case SYMBOL:
        return `Symbol(${V.description})`;
      case OBJECT:
        return inspect(V);
      case STRING:
        return `"${V}"`;
      default:
        return `${V}`;
    }
  };
  webidl.sequenceConverter = function(converter) {
    return (V, prefix, argument, Iterable) => {
      var _a2;
      if (webidl.util.Type(V) !== OBJECT) {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} (${webidl.util.Stringify(V)}) is not iterable.`
        });
      }
      const method = typeof Iterable === "function" ? Iterable() : (_a2 = V == null ? void 0 : V[Symbol.iterator]) == null ? void 0 : _a2.call(V);
      const seq = [];
      let index = 0;
      if (method === void 0 || typeof method.next !== "function") {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} is not iterable.`
        });
      }
      while (true) {
        const { done, value } = method.next();
        if (done) {
          break;
        }
        seq.push(converter(value, prefix, `${argument}[${index++}]`));
      }
      return seq;
    };
  };
  webidl.recordConverter = function(keyConverter, valueConverter) {
    return (O, prefix, argument) => {
      if (webidl.util.Type(O) !== OBJECT) {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} ("${webidl.util.TypeValueToString(O)}") is not an Object.`
        });
      }
      const result = {};
      if (!types.isProxy(O)) {
        const keys2 = [...Object.getOwnPropertyNames(O), ...Object.getOwnPropertySymbols(O)];
        for (const key of keys2) {
          const keyName = webidl.util.Stringify(key);
          const typedKey = keyConverter(key, prefix, `Key ${keyName} in ${argument}`);
          const typedValue = valueConverter(O[key], prefix, `${argument}[${keyName}]`);
          result[typedKey] = typedValue;
        }
        return result;
      }
      const keys = Reflect.ownKeys(O);
      for (const key of keys) {
        const desc = Reflect.getOwnPropertyDescriptor(O, key);
        if (desc == null ? void 0 : desc.enumerable) {
          const typedKey = keyConverter(key, prefix, argument);
          const typedValue = valueConverter(O[key], prefix, argument);
          result[typedKey] = typedValue;
        }
      }
      return result;
    };
  };
  webidl.interfaceConverter = function(TypeCheck, name) {
    return (V, prefix, argument) => {
      if (!TypeCheck(V)) {
        throw webidl.errors.exception({
          header: prefix,
          message: `Expected ${argument} ("${webidl.util.Stringify(V)}") to be an instance of ${name}.`
        });
      }
      return V;
    };
  };
  webidl.dictionaryConverter = function(converters) {
    return (dictionary, prefix, argument) => {
      const dict = {};
      if (dictionary != null && webidl.util.Type(dictionary) !== OBJECT) {
        throw webidl.errors.exception({
          header: prefix,
          message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
        });
      }
      for (const options of converters) {
        const { key, defaultValue, required, converter } = options;
        if (required === true) {
          if (dictionary == null || !Object.hasOwn(dictionary, key)) {
            throw webidl.errors.exception({
              header: prefix,
              message: `Missing required key "${key}".`
            });
          }
        }
        let value = dictionary == null ? void 0 : dictionary[key];
        const hasDefault = defaultValue !== void 0;
        if (hasDefault && value === void 0) {
          value = defaultValue();
        }
        if (required || hasDefault || value !== void 0) {
          value = converter(value, prefix, `${argument}.${key}`);
          if (options.allowedValues && !options.allowedValues.includes(value)) {
            throw webidl.errors.exception({
              header: prefix,
              message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
            });
          }
          dict[key] = value;
        }
      }
      return dict;
    };
  };
  webidl.nullableConverter = function(converter) {
    return (V, prefix, argument) => {
      if (V === null) {
        return V;
      }
      return converter(V, prefix, argument);
    };
  };
  webidl.is.ReadableStream = webidl.util.MakeTypeAssertion(ReadableStream);
  webidl.is.Blob = webidl.util.MakeTypeAssertion(Blob);
  webidl.is.URLSearchParams = webidl.util.MakeTypeAssertion(URLSearchParams);
  webidl.is.File = webidl.util.MakeTypeAssertion(globalThis.File ?? require$$0$1.File);
  webidl.is.URL = webidl.util.MakeTypeAssertion(URL);
  webidl.is.AbortSignal = webidl.util.MakeTypeAssertion(AbortSignal);
  webidl.is.MessagePort = webidl.util.MakeTypeAssertion(MessagePort);
  webidl.converters.DOMString = function(V, prefix, argument, opts) {
    if (V === null && (opts == null ? void 0 : opts.legacyNullToEmptyString)) {
      return "";
    }
    if (typeof V === "symbol") {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} is a symbol, which cannot be converted to a DOMString.`
      });
    }
    return String(V);
  };
  webidl.converters.ByteString = function(V, prefix, argument) {
    if (typeof V === "symbol") {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} is a symbol, which cannot be converted to a ByteString.`
      });
    }
    const x = String(V);
    for (let index = 0; index < x.length; index++) {
      if (x.charCodeAt(index) > 255) {
        throw new TypeError(
          `Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`
        );
      }
    }
    return x;
  };
  webidl.converters.USVString = toUSVString2;
  webidl.converters.boolean = function(V) {
    const x = Boolean(V);
    return x;
  };
  webidl.converters.any = function(V) {
    return V;
  };
  webidl.converters["long long"] = function(V, prefix, argument) {
    const x = webidl.util.ConvertToInt(V, 64, "signed", void 0, prefix, argument);
    return x;
  };
  webidl.converters["unsigned long long"] = function(V, prefix, argument) {
    const x = webidl.util.ConvertToInt(V, 64, "unsigned", void 0, prefix, argument);
    return x;
  };
  webidl.converters["unsigned long"] = function(V, prefix, argument) {
    const x = webidl.util.ConvertToInt(V, 32, "unsigned", void 0, prefix, argument);
    return x;
  };
  webidl.converters["unsigned short"] = function(V, prefix, argument, opts) {
    const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts, prefix, argument);
    return x;
  };
  webidl.converters.ArrayBuffer = function(V, prefix, argument, opts) {
    if (webidl.util.Type(V) !== OBJECT || !types.isAnyArrayBuffer(V)) {
      throw webidl.errors.conversionFailed({
        prefix,
        argument: `${argument} ("${webidl.util.Stringify(V)}")`,
        types: ["ArrayBuffer"]
      });
    }
    if ((opts == null ? void 0 : opts.allowShared) === false && types.isSharedArrayBuffer(V)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    if (V.resizable || V.growable) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "Received a resizable ArrayBuffer."
      });
    }
    return V;
  };
  webidl.converters.TypedArray = function(V, T, prefix, name, opts) {
    if (webidl.util.Type(V) !== OBJECT || !types.isTypedArray(V) || V.constructor.name !== T.name) {
      throw webidl.errors.conversionFailed({
        prefix,
        argument: `${name} ("${webidl.util.Stringify(V)}")`,
        types: [T.name]
      });
    }
    if ((opts == null ? void 0 : opts.allowShared) === false && types.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    if (V.buffer.resizable || V.buffer.growable) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "Received a resizable ArrayBuffer."
      });
    }
    return V;
  };
  webidl.converters.DataView = function(V, prefix, name, opts) {
    if (webidl.util.Type(V) !== OBJECT || !types.isDataView(V)) {
      throw webidl.errors.exception({
        header: prefix,
        message: `${name} is not a DataView.`
      });
    }
    if ((opts == null ? void 0 : opts.allowShared) === false && types.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    if (V.buffer.resizable || V.buffer.growable) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "Received a resizable ArrayBuffer."
      });
    }
    return V;
  };
  webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
    webidl.converters.ByteString
  );
  webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(
    webidl.converters["sequence<ByteString>"]
  );
  webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(
    webidl.converters.ByteString,
    webidl.converters.ByteString
  );
  webidl.converters.Blob = webidl.interfaceConverter(webidl.is.Blob, "Blob");
  webidl.converters.AbortSignal = webidl.interfaceConverter(
    webidl.is.AbortSignal,
    "AbortSignal"
  );
  webidl_1$1 = {
    webidl
  };
  return webidl_1$1;
}
var util$G;
var hasRequiredUtil$a;
function requireUtil$a() {
  var _zlibOptions;
  if (hasRequiredUtil$a) return util$G;
  hasRequiredUtil$a = 1;
  const { Transform: Transform2 } = require$$0$4;
  const zlib = require$$1$2;
  const { redirectStatusSet, referrerPolicyTokens, badPortsSet } = requireConstants$5();
  const { getGlobalOrigin: getGlobalOrigin2 } = requireGlobal$1();
  const { collectASequenceOfCodePoints, collectAnHTTPQuotedString, removeChars, parseMIMEType: parseMIMEType2 } = requireDataUrl$1();
  const { performance: performance2 } = require$$5$1;
  const { ReadableStreamFrom: ReadableStreamFrom2, isValidHTTPToken: isValidHTTPToken2, normalizedMethodRecordsBase: normalizedMethodRecordsBase2 } = util$J;
  const assert2 = require$$0$3;
  const { isUint8Array } = require$$8$2;
  const { webidl } = requireWebidl$1();
  let supportedHashes = [];
  let crypto2;
  try {
    crypto2 = require("node:crypto");
    const possibleRelevantHashes = ["sha256", "sha384", "sha512"];
    supportedHashes = crypto2.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
  } catch {
  }
  function responseURL(response2) {
    const urlList = response2.urlList;
    const length = urlList.length;
    return length === 0 ? null : urlList[length - 1].toString();
  }
  function responseLocationURL(response2, requestFragment) {
    if (!redirectStatusSet.has(response2.status)) {
      return null;
    }
    let location = response2.headersList.get("location", true);
    if (location !== null && isValidHeaderValue2(location)) {
      if (!isValidEncodedURL(location)) {
        location = normalizeBinaryStringToUtf8(location);
      }
      location = new URL(location, responseURL(response2));
    }
    if (location && !location.hash) {
      location.hash = requestFragment;
    }
    return location;
  }
  function isValidEncodedURL(url) {
    for (let i = 0; i < url.length; ++i) {
      const code = url.charCodeAt(i);
      if (code > 126 || // Non-US-ASCII + DEL
      code < 32) {
        return false;
      }
    }
    return true;
  }
  function normalizeBinaryStringToUtf8(value) {
    return Buffer.from(value, "binary").toString("utf8");
  }
  function requestCurrentURL(request2) {
    return request2.urlList[request2.urlList.length - 1];
  }
  function requestBadPort(request2) {
    const url = requestCurrentURL(request2);
    if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
      return "blocked";
    }
    return "allowed";
  }
  function isErrorLike(object) {
    var _a2, _b2;
    return object instanceof Error || (((_a2 = object == null ? void 0 : object.constructor) == null ? void 0 : _a2.name) === "Error" || ((_b2 = object == null ? void 0 : object.constructor) == null ? void 0 : _b2.name) === "DOMException");
  }
  function isValidReasonPhrase(statusText) {
    for (let i = 0; i < statusText.length; ++i) {
      const c = statusText.charCodeAt(i);
      if (!(c === 9 || // HTAB
      c >= 32 && c <= 126 || // SP / VCHAR
      c >= 128 && c <= 255)) {
        return false;
      }
    }
    return true;
  }
  const isValidHeaderName = isValidHTTPToken2;
  function isValidHeaderValue2(potentialValue) {
    return (potentialValue[0] === "	" || potentialValue[0] === " " || potentialValue[potentialValue.length - 1] === "	" || potentialValue[potentialValue.length - 1] === " " || potentialValue.includes("\n") || potentialValue.includes("\r") || potentialValue.includes("\0")) === false;
  }
  function parseReferrerPolicy(actualResponse) {
    const policyHeader = (actualResponse.headersList.get("referrer-policy", true) ?? "").split(",");
    let policy = "";
    if (policyHeader.length) {
      for (let i = policyHeader.length; i !== 0; i--) {
        const token = policyHeader[i - 1].trim();
        if (referrerPolicyTokens.has(token)) {
          policy = token;
          break;
        }
      }
    }
    return policy;
  }
  function setRequestReferrerPolicyOnRedirect(request2, actualResponse) {
    const policy = parseReferrerPolicy(actualResponse);
    if (policy !== "") {
      request2.referrerPolicy = policy;
    }
  }
  function crossOriginResourcePolicyCheck() {
    return "allowed";
  }
  function corsCheck() {
    return "success";
  }
  function TAOCheck() {
    return "success";
  }
  function appendFetchMetadata(httpRequest) {
    let header = null;
    header = httpRequest.mode;
    httpRequest.headersList.set("sec-fetch-mode", header, true);
  }
  function appendRequestOriginHeader(request2) {
    let serializedOrigin = request2.origin;
    if (serializedOrigin === "client" || serializedOrigin === void 0) {
      return;
    }
    if (request2.responseTainting === "cors" || request2.mode === "websocket") {
      request2.headersList.append("origin", serializedOrigin, true);
    } else if (request2.method !== "GET" && request2.method !== "HEAD") {
      switch (request2.referrerPolicy) {
        case "no-referrer":
          serializedOrigin = null;
          break;
        case "no-referrer-when-downgrade":
        case "strict-origin":
        case "strict-origin-when-cross-origin":
          if (request2.origin && urlHasHttpsScheme(request2.origin) && !urlHasHttpsScheme(requestCurrentURL(request2))) {
            serializedOrigin = null;
          }
          break;
        case "same-origin":
          if (!sameOrigin(request2, requestCurrentURL(request2))) {
            serializedOrigin = null;
          }
          break;
      }
      request2.headersList.append("origin", serializedOrigin, true);
    }
  }
  function coarsenTime(timestamp, crossOriginIsolatedCapability) {
    return timestamp;
  }
  function clampAndCoarsenConnectionTimingInfo(connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {
    if (!(connectionTimingInfo == null ? void 0 : connectionTimingInfo.startTime) || connectionTimingInfo.startTime < defaultStartTime) {
      return {
        domainLookupStartTime: defaultStartTime,
        domainLookupEndTime: defaultStartTime,
        connectionStartTime: defaultStartTime,
        connectionEndTime: defaultStartTime,
        secureConnectionStartTime: defaultStartTime,
        ALPNNegotiatedProtocol: connectionTimingInfo == null ? void 0 : connectionTimingInfo.ALPNNegotiatedProtocol
      };
    }
    return {
      domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime),
      domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime),
      connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime),
      connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime),
      secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime),
      ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol
    };
  }
  function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
    return coarsenTime(performance2.now());
  }
  function createOpaqueTimingInfo(timingInfo) {
    return {
      startTime: timingInfo.startTime ?? 0,
      redirectStartTime: 0,
      redirectEndTime: 0,
      postRedirectStartTime: timingInfo.startTime ?? 0,
      finalServiceWorkerStartTime: 0,
      finalNetworkResponseStartTime: 0,
      finalNetworkRequestStartTime: 0,
      endTime: 0,
      encodedBodySize: 0,
      decodedBodySize: 0,
      finalConnectionTimingInfo: null
    };
  }
  function makePolicyContainer() {
    return {
      referrerPolicy: "strict-origin-when-cross-origin"
    };
  }
  function clonePolicyContainer(policyContainer) {
    return {
      referrerPolicy: policyContainer.referrerPolicy
    };
  }
  function determineRequestsReferrer(request2) {
    const policy = request2.referrerPolicy;
    assert2(policy);
    let referrerSource = null;
    if (request2.referrer === "client") {
      const globalOrigin = getGlobalOrigin2();
      if (!globalOrigin || globalOrigin.origin === "null") {
        return "no-referrer";
      }
      referrerSource = new URL(globalOrigin);
    } else if (webidl.is.URL(request2.referrer)) {
      referrerSource = request2.referrer;
    }
    let referrerURL = stripURLForReferrer(referrerSource);
    const referrerOrigin = stripURLForReferrer(referrerSource, true);
    if (referrerURL.toString().length > 4096) {
      referrerURL = referrerOrigin;
    }
    switch (policy) {
      case "no-referrer":
        return "no-referrer";
      case "origin":
        if (referrerOrigin != null) {
          return referrerOrigin;
        }
        return stripURLForReferrer(referrerSource, true);
      case "unsafe-url":
        return referrerURL;
      case "strict-origin": {
        const currentURL = requestCurrentURL(request2);
        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
          return "no-referrer";
        }
        return referrerOrigin;
      }
      case "strict-origin-when-cross-origin": {
        const currentURL = requestCurrentURL(request2);
        if (sameOrigin(referrerURL, currentURL)) {
          return referrerURL;
        }
        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
          return "no-referrer";
        }
        return referrerOrigin;
      }
      case "same-origin":
        if (sameOrigin(request2, referrerURL)) {
          return referrerURL;
        }
        return "no-referrer";
      case "origin-when-cross-origin":
        if (sameOrigin(request2, referrerURL)) {
          return referrerURL;
        }
        return referrerOrigin;
      case "no-referrer-when-downgrade": {
        const currentURL = requestCurrentURL(request2);
        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
          return "no-referrer";
        }
        return referrerOrigin;
      }
    }
  }
  function stripURLForReferrer(url, originOnly = false) {
    assert2(webidl.is.URL(url));
    url = new URL(url);
    if (urlIsLocal(url)) {
      return "no-referrer";
    }
    url.username = "";
    url.password = "";
    url.hash = "";
    if (originOnly === true) {
      url.pathname = "";
      url.search = "";
    }
    return url;
  }
  const potentialleTrustworthyIPv4RegExp = new RegExp("^(?:(?:127\\.)(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){2}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[1-9]))$");
  const potentialleTrustworthyIPv6RegExp = new RegExp("^(?:(?:(?:0{1,4}):){7}(?:(?:0{0,3}1))|(?:(?:0{1,4}):){1,6}(?::(?:0{0,3}1))|(?:::(?:0{0,3}1))|)$");
  function isOriginIPPotentiallyTrustworthy(origin) {
    if (origin.includes(":")) {
      if (origin[0] === "[" && origin[origin.length - 1] === "]") {
        origin = origin.slice(1, -1);
      }
      return potentialleTrustworthyIPv6RegExp.test(origin);
    }
    return potentialleTrustworthyIPv4RegExp.test(origin);
  }
  function isOriginPotentiallyTrustworthy(origin) {
    if (origin == null || origin === "null") {
      return false;
    }
    origin = new URL(origin);
    if (origin.protocol === "https:" || origin.protocol === "wss:") {
      return true;
    }
    if (isOriginIPPotentiallyTrustworthy(origin.hostname)) {
      return true;
    }
    if (origin.hostname === "localhost" || origin.hostname === "localhost.") {
      return true;
    }
    if (origin.hostname.endsWith(".localhost") || origin.hostname.endsWith(".localhost.")) {
      return true;
    }
    if (origin.protocol === "file:") {
      return true;
    }
    return false;
  }
  function isURLPotentiallyTrustworthy(url) {
    if (!webidl.is.URL(url)) {
      return false;
    }
    if (url.href === "about:blank" || url.href === "about:srcdoc") {
      return true;
    }
    if (url.protocol === "data:") return true;
    if (url.protocol === "blob:") return true;
    return isOriginPotentiallyTrustworthy(url.origin);
  }
  function bytesMatch(bytes, metadataList) {
    if (crypto2 === void 0) {
      return true;
    }
    const parsedMetadata = parseMetadata(metadataList);
    if (parsedMetadata === "no metadata") {
      return true;
    }
    if (parsedMetadata.length === 0) {
      return true;
    }
    const strongest = getStrongestMetadata(parsedMetadata);
    const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
    for (const item of metadata) {
      const algorithm = item.algo;
      const expectedValue = item.hash;
      let actualValue = crypto2.createHash(algorithm).update(bytes).digest("base64");
      if (actualValue[actualValue.length - 1] === "=") {
        if (actualValue[actualValue.length - 2] === "=") {
          actualValue = actualValue.slice(0, -2);
        } else {
          actualValue = actualValue.slice(0, -1);
        }
      }
      if (compareBase64Mixed(actualValue, expectedValue)) {
        return true;
      }
    }
    return false;
  }
  const parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
  function parseMetadata(metadata) {
    const result = [];
    let empty = true;
    for (const token of metadata.split(" ")) {
      empty = false;
      const parsedToken = parseHashWithOptions.exec(token);
      if (parsedToken === null || parsedToken.groups === void 0 || parsedToken.groups.algo === void 0) {
        continue;
      }
      const algorithm = parsedToken.groups.algo.toLowerCase();
      if (supportedHashes.includes(algorithm)) {
        result.push(parsedToken.groups);
      }
    }
    if (empty === true) {
      return "no metadata";
    }
    return result;
  }
  function getStrongestMetadata(metadataList) {
    let algorithm = metadataList[0].algo;
    if (algorithm[3] === "5") {
      return algorithm;
    }
    for (let i = 1; i < metadataList.length; ++i) {
      const metadata = metadataList[i];
      if (metadata.algo[3] === "5") {
        algorithm = "sha512";
        break;
      } else if (algorithm[3] === "3") {
        continue;
      } else if (metadata.algo[3] === "3") {
        algorithm = "sha384";
      }
    }
    return algorithm;
  }
  function filterMetadataListByAlgorithm(metadataList, algorithm) {
    if (metadataList.length === 1) {
      return metadataList;
    }
    let pos = 0;
    for (let i = 0; i < metadataList.length; ++i) {
      if (metadataList[i].algo === algorithm) {
        metadataList[pos++] = metadataList[i];
      }
    }
    metadataList.length = pos;
    return metadataList;
  }
  function compareBase64Mixed(actualValue, expectedValue) {
    if (actualValue.length !== expectedValue.length) {
      return false;
    }
    for (let i = 0; i < actualValue.length; ++i) {
      if (actualValue[i] !== expectedValue[i]) {
        if (actualValue[i] === "+" && expectedValue[i] === "-" || actualValue[i] === "/" && expectedValue[i] === "_") {
          continue;
        }
        return false;
      }
    }
    return true;
  }
  function tryUpgradeRequestToAPotentiallyTrustworthyURL(request2) {
  }
  function sameOrigin(A, B) {
    if (A.origin === B.origin && A.origin === "null") {
      return true;
    }
    if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
      return true;
    }
    return false;
  }
  function createDeferredPromise() {
    let res;
    let rej;
    const promise = new Promise((resolve2, reject) => {
      res = resolve2;
      rej = reject;
    });
    return { promise, resolve: res, reject: rej };
  }
  function isAborted(fetchParams) {
    return fetchParams.controller.state === "aborted";
  }
  function isCancelled(fetchParams) {
    return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
  }
  function normalizeMethod(method) {
    return normalizedMethodRecordsBase2[method.toLowerCase()] ?? method;
  }
  function serializeJavascriptValueToJSONString(value) {
    const result = JSON.stringify(value);
    if (result === void 0) {
      throw new TypeError("Value is not JSON serializable");
    }
    assert2(typeof result === "string");
    return result;
  }
  const esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
  function createIterator(name, kInternalIterator, keyIndex = 0, valueIndex = 1) {
    var _target, _kind, _index;
    class FastIterableIterator {
      /**
       * @see https://webidl.spec.whatwg.org/#dfn-default-iterator-object
       * @param {unknown} target
       * @param {'key' | 'value' | 'key+value'} kind
       */
      constructor(target, kind) {
        /** @type {any} */
        __privateAdd(this, _target);
        /** @type {'key' | 'value' | 'key+value'} */
        __privateAdd(this, _kind);
        /** @type {number} */
        __privateAdd(this, _index);
        __privateSet(this, _target, target);
        __privateSet(this, _kind, kind);
        __privateSet(this, _index, 0);
      }
      next() {
        if (typeof this !== "object" || this === null || !__privateIn(_target, this)) {
          throw new TypeError(
            `'next' called on an object that does not implement interface ${name} Iterator.`
          );
        }
        const index = __privateGet(this, _index);
        const values = kInternalIterator(__privateGet(this, _target));
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        const { [keyIndex]: key, [valueIndex]: value } = values[index];
        __privateSet(this, _index, index + 1);
        let result;
        switch (__privateGet(this, _kind)) {
          case "key":
            result = key;
            break;
          case "value":
            result = value;
            break;
          case "key+value":
            result = [key, value];
            break;
        }
        return {
          value: result,
          done: false
        };
      }
    }
    _target = new WeakMap();
    _kind = new WeakMap();
    _index = new WeakMap();
    delete FastIterableIterator.prototype.constructor;
    Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype);
    Object.defineProperties(FastIterableIterator.prototype, {
      [Symbol.toStringTag]: {
        writable: false,
        enumerable: false,
        configurable: true,
        value: `${name} Iterator`
      },
      next: { writable: true, enumerable: true, configurable: true }
    });
    return function(target, kind) {
      return new FastIterableIterator(target, kind);
    };
  }
  function iteratorMixin(name, object, kInternalIterator, keyIndex = 0, valueIndex = 1) {
    const makeIterator = createIterator(name, kInternalIterator, keyIndex, valueIndex);
    const properties = {
      keys: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function keys() {
          webidl.brandCheck(this, object);
          return makeIterator(this, "key");
        }
      },
      values: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function values() {
          webidl.brandCheck(this, object);
          return makeIterator(this, "value");
        }
      },
      entries: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function entries() {
          webidl.brandCheck(this, object);
          return makeIterator(this, "key+value");
        }
      },
      forEach: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function forEach(callbackfn, thisArg = globalThis) {
          webidl.brandCheck(this, object);
          webidl.argumentLengthCheck(arguments, 1, `${name}.forEach`);
          if (typeof callbackfn !== "function") {
            throw new TypeError(
              `Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`
            );
          }
          for (const { 0: key, 1: value } of makeIterator(this, "key+value")) {
            callbackfn.call(thisArg, value, key, this);
          }
        }
      }
    };
    return Object.defineProperties(object.prototype, {
      ...properties,
      [Symbol.iterator]: {
        writable: true,
        enumerable: false,
        configurable: true,
        value: properties.entries.value
      }
    });
  }
  function fullyReadBody(body2, processBody, processBodyError) {
    const successSteps = processBody;
    const errorSteps = processBodyError;
    let reader;
    try {
      reader = body2.stream.getReader();
    } catch (e) {
      errorSteps(e);
      return;
    }
    readAllBytes(reader, successSteps, errorSteps);
  }
  function readableStreamClose(controller) {
    var _a2;
    try {
      controller.close();
      (_a2 = controller.byobRequest) == null ? void 0 : _a2.respond(0);
    } catch (err) {
      if (!err.message.includes("Controller is already closed") && !err.message.includes("ReadableStream is already closed")) {
        throw err;
      }
    }
  }
  const invalidIsomorphicEncodeValueRegex = /[^\x00-\xFF]/;
  function isomorphicEncode(input) {
    assert2(!invalidIsomorphicEncodeValueRegex.test(input));
    return input;
  }
  async function readAllBytes(reader, successSteps, failureSteps) {
    const bytes = [];
    let byteLength = 0;
    try {
      do {
        const { done, value: chunk } = await reader.read();
        if (done) {
          successSteps(Buffer.concat(bytes, byteLength));
          return;
        }
        if (!isUint8Array(chunk)) {
          failureSteps(TypeError("Received non-Uint8Array chunk"));
          return;
        }
        bytes.push(chunk);
        byteLength += chunk.length;
      } while (true);
    } catch (e) {
      failureSteps(e);
    }
  }
  function urlIsLocal(url) {
    assert2("protocol" in url);
    const protocol = url.protocol;
    return protocol === "about:" || protocol === "blob:" || protocol === "data:";
  }
  function urlHasHttpsScheme(url) {
    return typeof url === "string" && url[5] === ":" && url[0] === "h" && url[1] === "t" && url[2] === "t" && url[3] === "p" && url[4] === "s" || url.protocol === "https:";
  }
  function urlIsHttpHttpsScheme(url) {
    assert2("protocol" in url);
    const protocol = url.protocol;
    return protocol === "http:" || protocol === "https:";
  }
  function simpleRangeHeaderValue(value, allowWhitespace) {
    const data = value;
    if (!data.startsWith("bytes")) {
      return "failure";
    }
    const position = { position: 5 };
    if (allowWhitespace) {
      collectASequenceOfCodePoints(
        (char) => char === "	" || char === " ",
        data,
        position
      );
    }
    if (data.charCodeAt(position.position) !== 61) {
      return "failure";
    }
    position.position++;
    if (allowWhitespace) {
      collectASequenceOfCodePoints(
        (char) => char === "	" || char === " ",
        data,
        position
      );
    }
    const rangeStart = collectASequenceOfCodePoints(
      (char) => {
        const code = char.charCodeAt(0);
        return code >= 48 && code <= 57;
      },
      data,
      position
    );
    const rangeStartValue = rangeStart.length ? Number(rangeStart) : null;
    if (allowWhitespace) {
      collectASequenceOfCodePoints(
        (char) => char === "	" || char === " ",
        data,
        position
      );
    }
    if (data.charCodeAt(position.position) !== 45) {
      return "failure";
    }
    position.position++;
    if (allowWhitespace) {
      collectASequenceOfCodePoints(
        (char) => char === "	" || char === " ",
        data,
        position
      );
    }
    const rangeEnd = collectASequenceOfCodePoints(
      (char) => {
        const code = char.charCodeAt(0);
        return code >= 48 && code <= 57;
      },
      data,
      position
    );
    const rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null;
    if (position.position < data.length) {
      return "failure";
    }
    if (rangeEndValue === null && rangeStartValue === null) {
      return "failure";
    }
    if (rangeStartValue > rangeEndValue) {
      return "failure";
    }
    return { rangeStartValue, rangeEndValue };
  }
  function buildContentRange(rangeStart, rangeEnd, fullLength) {
    let contentRange = "bytes ";
    contentRange += isomorphicEncode(`${rangeStart}`);
    contentRange += "-";
    contentRange += isomorphicEncode(`${rangeEnd}`);
    contentRange += "/";
    contentRange += isomorphicEncode(`${fullLength}`);
    return contentRange;
  }
  class InflateStream extends Transform2 {
    /** @param {zlib.ZlibOptions} [zlibOptions] */
    constructor(zlibOptions) {
      super();
      __privateAdd(this, _zlibOptions);
      __privateSet(this, _zlibOptions, zlibOptions);
    }
    _transform(chunk, encoding2, callback) {
      if (!this._inflateStream) {
        if (chunk.length === 0) {
          callback();
          return;
        }
        this._inflateStream = (chunk[0] & 15) === 8 ? zlib.createInflate(__privateGet(this, _zlibOptions)) : zlib.createInflateRaw(__privateGet(this, _zlibOptions));
        this._inflateStream.on("data", this.push.bind(this));
        this._inflateStream.on("end", () => this.push(null));
        this._inflateStream.on("error", (err) => this.destroy(err));
      }
      this._inflateStream.write(chunk, encoding2, callback);
    }
    _final(callback) {
      if (this._inflateStream) {
        this._inflateStream.end();
        this._inflateStream = null;
      }
      callback();
    }
  }
  _zlibOptions = new WeakMap();
  function createInflate(zlibOptions) {
    return new InflateStream(zlibOptions);
  }
  function extractMimeType(headers2) {
    let charset = null;
    let essence = null;
    let mimeType = null;
    const values = getDecodeSplit("content-type", headers2);
    if (values === null) {
      return "failure";
    }
    for (const value of values) {
      const temporaryMimeType = parseMIMEType2(value);
      if (temporaryMimeType === "failure" || temporaryMimeType.essence === "*/*") {
        continue;
      }
      mimeType = temporaryMimeType;
      if (mimeType.essence !== essence) {
        charset = null;
        if (mimeType.parameters.has("charset")) {
          charset = mimeType.parameters.get("charset");
        }
        essence = mimeType.essence;
      } else if (!mimeType.parameters.has("charset") && charset !== null) {
        mimeType.parameters.set("charset", charset);
      }
    }
    if (mimeType == null) {
      return "failure";
    }
    return mimeType;
  }
  function gettingDecodingSplitting(value) {
    const input = value;
    const position = { position: 0 };
    const values = [];
    let temporaryValue = "";
    while (position.position < input.length) {
      temporaryValue += collectASequenceOfCodePoints(
        (char) => char !== '"' && char !== ",",
        input,
        position
      );
      if (position.position < input.length) {
        if (input.charCodeAt(position.position) === 34) {
          temporaryValue += collectAnHTTPQuotedString(
            input,
            position
          );
          if (position.position < input.length) {
            continue;
          }
        } else {
          assert2(input.charCodeAt(position.position) === 44);
          position.position++;
        }
      }
      temporaryValue = removeChars(temporaryValue, true, true, (char) => char === 9 || char === 32);
      values.push(temporaryValue);
      temporaryValue = "";
    }
    return values;
  }
  function getDecodeSplit(name, list) {
    const value = list.get(name, true);
    if (value === null) {
      return null;
    }
    return gettingDecodingSplitting(value);
  }
  const textDecoder = new TextDecoder();
  function utf8DecodeBytes(buffer) {
    if (buffer.length === 0) {
      return "";
    }
    if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
      buffer = buffer.subarray(3);
    }
    const output = textDecoder.decode(buffer);
    return output;
  }
  class EnvironmentSettingsObjectBase {
    constructor() {
      __publicField(this, "policyContainer", makePolicyContainer());
    }
    get baseUrl() {
      return getGlobalOrigin2();
    }
    get origin() {
      var _a2;
      return (_a2 = this.baseUrl) == null ? void 0 : _a2.origin;
    }
  }
  class EnvironmentSettingsObject {
    constructor() {
      __publicField(this, "settingsObject", new EnvironmentSettingsObjectBase());
    }
  }
  const environmentSettingsObject = new EnvironmentSettingsObject();
  util$G = {
    isAborted,
    isCancelled,
    isValidEncodedURL,
    createDeferredPromise,
    ReadableStreamFrom: ReadableStreamFrom2,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    clampAndCoarsenConnectionTimingInfo,
    coarsenedSharedCurrentTime,
    determineRequestsReferrer,
    makePolicyContainer,
    clonePolicyContainer,
    appendFetchMetadata,
    appendRequestOriginHeader,
    TAOCheck,
    corsCheck,
    crossOriginResourcePolicyCheck,
    createOpaqueTimingInfo,
    setRequestReferrerPolicyOnRedirect,
    isValidHTTPToken: isValidHTTPToken2,
    requestBadPort,
    requestCurrentURL,
    responseURL,
    responseLocationURL,
    isURLPotentiallyTrustworthy,
    isValidReasonPhrase,
    sameOrigin,
    normalizeMethod,
    serializeJavascriptValueToJSONString,
    iteratorMixin,
    createIterator,
    isValidHeaderName,
    isValidHeaderValue: isValidHeaderValue2,
    isErrorLike,
    fullyReadBody,
    bytesMatch,
    readableStreamClose,
    isomorphicEncode,
    urlIsLocal,
    urlHasHttpsScheme,
    urlIsHttpHttpsScheme,
    readAllBytes,
    simpleRangeHeaderValue,
    buildContentRange,
    parseMetadata,
    createInflate,
    extractMimeType,
    getDecodeSplit,
    utf8DecodeBytes,
    environmentSettingsObject,
    isOriginIPPotentiallyTrustworthy
  };
  return util$G;
}
var formdata$1;
var hasRequiredFormdata$1;
function requireFormdata$1() {
  var _state3;
  if (hasRequiredFormdata$1) return formdata$1;
  hasRequiredFormdata$1 = 1;
  const { iteratorMixin } = requireUtil$a();
  const { kEnumerableProperty: kEnumerableProperty2 } = util$J;
  const { webidl } = requireWebidl$1();
  const { File: NativeFile } = require$$0$1;
  const nodeUtil2 = require$$0$2;
  const File = globalThis.File ?? NativeFile;
  const _FormData = class _FormData {
    constructor(form) {
      __privateAdd(this, _state3, []);
      webidl.util.markAsUncloneable(this);
      if (form !== void 0) {
        throw webidl.errors.conversionFailed({
          prefix: "FormData constructor",
          argument: "Argument 1",
          types: ["undefined"]
        });
      }
    }
    append(name, value, filename = void 0) {
      webidl.brandCheck(this, _FormData);
      const prefix = "FormData.append";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      name = webidl.converters.USVString(name);
      if (arguments.length === 3 || webidl.is.Blob(value)) {
        value = webidl.converters.Blob(value, prefix, "value");
        if (filename !== void 0) {
          filename = webidl.converters.USVString(filename);
        }
      } else {
        value = webidl.converters.USVString(value);
      }
      const entry = makeEntry(name, value, filename);
      __privateGet(this, _state3).push(entry);
    }
    delete(name) {
      webidl.brandCheck(this, _FormData);
      const prefix = "FormData.delete";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name);
      __privateSet(this, _state3, __privateGet(this, _state3).filter((entry) => entry.name !== name));
    }
    get(name) {
      webidl.brandCheck(this, _FormData);
      const prefix = "FormData.get";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name);
      const idx = __privateGet(this, _state3).findIndex((entry) => entry.name === name);
      if (idx === -1) {
        return null;
      }
      return __privateGet(this, _state3)[idx].value;
    }
    getAll(name) {
      webidl.brandCheck(this, _FormData);
      const prefix = "FormData.getAll";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name);
      return __privateGet(this, _state3).filter((entry) => entry.name === name).map((entry) => entry.value);
    }
    has(name) {
      webidl.brandCheck(this, _FormData);
      const prefix = "FormData.has";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name);
      return __privateGet(this, _state3).findIndex((entry) => entry.name === name) !== -1;
    }
    set(name, value, filename = void 0) {
      webidl.brandCheck(this, _FormData);
      const prefix = "FormData.set";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      name = webidl.converters.USVString(name);
      if (arguments.length === 3 || webidl.is.Blob(value)) {
        value = webidl.converters.Blob(value, prefix, "value");
        if (filename !== void 0) {
          filename = webidl.converters.USVString(filename);
        }
      } else {
        value = webidl.converters.USVString(value);
      }
      const entry = makeEntry(name, value, filename);
      const idx = __privateGet(this, _state3).findIndex((entry2) => entry2.name === name);
      if (idx !== -1) {
        __privateSet(this, _state3, [
          ...__privateGet(this, _state3).slice(0, idx),
          entry,
          ...__privateGet(this, _state3).slice(idx + 1).filter((entry2) => entry2.name !== name)
        ]);
      } else {
        __privateGet(this, _state3).push(entry);
      }
    }
    [nodeUtil2.inspect.custom](depth, options) {
      const state = __privateGet(this, _state3).reduce((a, b) => {
        if (a[b.name]) {
          if (Array.isArray(a[b.name])) {
            a[b.name].push(b.value);
          } else {
            a[b.name] = [a[b.name], b.value];
          }
        } else {
          a[b.name] = b.value;
        }
        return a;
      }, { __proto__: null });
      options.depth ?? (options.depth = depth);
      options.colors ?? (options.colors = true);
      const output = nodeUtil2.formatWithOptions(options, state);
      return `FormData ${output.slice(output.indexOf("]") + 2)}`;
    }
    /**
     * @param {FormData} formData
     */
    static getFormDataState(formData) {
      return __privateGet(formData, _state3);
    }
    /**
     * @param {FormData} formData
     * @param {any[]} newState
     */
    static setFormDataState(formData, newState) {
      __privateSet(formData, _state3, newState);
    }
  };
  _state3 = new WeakMap();
  let FormData = _FormData;
  const { getFormDataState, setFormDataState } = FormData;
  Reflect.deleteProperty(FormData, "getFormDataState");
  Reflect.deleteProperty(FormData, "setFormDataState");
  iteratorMixin("FormData", FormData, getFormDataState, "name", "value");
  Object.defineProperties(FormData.prototype, {
    append: kEnumerableProperty2,
    delete: kEnumerableProperty2,
    get: kEnumerableProperty2,
    getAll: kEnumerableProperty2,
    has: kEnumerableProperty2,
    set: kEnumerableProperty2,
    [Symbol.toStringTag]: {
      value: "FormData",
      configurable: true
    }
  });
  function makeEntry(name, value, filename) {
    if (typeof value === "string") ;
    else {
      if (!webidl.is.File(value)) {
        value = new File([value], "blob", { type: value.type });
      }
      if (filename !== void 0) {
        const options = {
          type: value.type,
          lastModified: value.lastModified
        };
        value = new File([value], filename, options);
      }
    }
    return { name, value };
  }
  webidl.is.FormData = webidl.util.MakeTypeAssertion(FormData);
  formdata$1 = { FormData, makeEntry, setFormDataState };
  return formdata$1;
}
var formdataParser$1;
var hasRequiredFormdataParser$1;
function requireFormdataParser$1() {
  if (hasRequiredFormdataParser$1) return formdataParser$1;
  hasRequiredFormdataParser$1 = 1;
  const { isUSVString: isUSVString2, bufferToLowerCasedHeaderName: bufferToLowerCasedHeaderName2 } = util$J;
  const { utf8DecodeBytes } = requireUtil$a();
  const { HTTP_TOKEN_CODEPOINTS, isomorphicDecode } = requireDataUrl$1();
  const { makeEntry } = requireFormdata$1();
  const { webidl } = requireWebidl$1();
  const assert2 = require$$0$3;
  const { File: NodeFile } = require$$0$1;
  const File = globalThis.File ?? NodeFile;
  const formDataNameBuffer = Buffer.from('form-data; name="');
  const filenameBuffer = Buffer.from("filename");
  const dd = Buffer.from("--");
  const ddcrlf = Buffer.from("--\r\n");
  function isAsciiString(chars) {
    for (let i = 0; i < chars.length; ++i) {
      if ((chars.charCodeAt(i) & -128) !== 0) {
        return false;
      }
    }
    return true;
  }
  function validateBoundary(boundary) {
    const length = boundary.length;
    if (length < 27 || length > 70) {
      return false;
    }
    for (let i = 0; i < length; ++i) {
      const cp = boundary.charCodeAt(i);
      if (!(cp >= 48 && cp <= 57 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 39 || cp === 45 || cp === 95)) {
        return false;
      }
    }
    return true;
  }
  function multipartFormDataParser(input, mimeType) {
    assert2(mimeType !== "failure" && mimeType.essence === "multipart/form-data");
    const boundaryString = mimeType.parameters.get("boundary");
    if (boundaryString === void 0) {
      throw parsingError("missing boundary in content-type header");
    }
    const boundary = Buffer.from(`--${boundaryString}`, "utf8");
    const entryList = [];
    const position = { position: 0 };
    while (input[position.position] === 13 && input[position.position + 1] === 10) {
      position.position += 2;
    }
    let trailing = input.length;
    while (input[trailing - 1] === 10 && input[trailing - 2] === 13) {
      trailing -= 2;
    }
    if (trailing !== input.length) {
      input = input.subarray(0, trailing);
    }
    while (true) {
      if (input.subarray(position.position, position.position + boundary.length).equals(boundary)) {
        position.position += boundary.length;
      } else {
        throw parsingError("expected a value starting with -- and the boundary");
      }
      if (position.position === input.length - 2 && bufferStartsWith(input, dd, position) || position.position === input.length - 4 && bufferStartsWith(input, ddcrlf, position)) {
        return entryList;
      }
      if (input[position.position] !== 13 || input[position.position + 1] !== 10) {
        throw parsingError("expected CRLF");
      }
      position.position += 2;
      const result = parseMultipartFormDataHeaders(input, position);
      let { name, filename, contentType, encoding: encoding2 } = result;
      position.position += 2;
      let body2;
      {
        const boundaryIndex = input.indexOf(boundary.subarray(2), position.position);
        if (boundaryIndex === -1) {
          throw parsingError("expected boundary after body");
        }
        body2 = input.subarray(position.position, boundaryIndex - 4);
        position.position += body2.length;
        if (encoding2 === "base64") {
          body2 = Buffer.from(body2.toString(), "base64");
        }
      }
      if (input[position.position] !== 13 || input[position.position + 1] !== 10) {
        throw parsingError("expected CRLF");
      } else {
        position.position += 2;
      }
      let value;
      if (filename !== null) {
        contentType ?? (contentType = "text/plain");
        if (!isAsciiString(contentType)) {
          contentType = "";
        }
        value = new File([body2], filename, { type: contentType });
      } else {
        value = utf8DecodeBytes(Buffer.from(body2));
      }
      assert2(isUSVString2(name));
      assert2(typeof value === "string" && isUSVString2(value) || webidl.is.File(value));
      entryList.push(makeEntry(name, value, filename));
    }
  }
  function parseMultipartFormDataHeaders(input, position) {
    let name = null;
    let filename = null;
    let contentType = null;
    let encoding2 = null;
    while (true) {
      if (input[position.position] === 13 && input[position.position + 1] === 10) {
        if (name === null) {
          throw parsingError("header name is null");
        }
        return { name, filename, contentType, encoding: encoding2 };
      }
      let headerName = collectASequenceOfBytes(
        (char) => char !== 10 && char !== 13 && char !== 58,
        input,
        position
      );
      headerName = removeChars(headerName, true, true, (char) => char === 9 || char === 32);
      if (!HTTP_TOKEN_CODEPOINTS.test(headerName.toString())) {
        throw parsingError("header name does not match the field-name token production");
      }
      if (input[position.position] !== 58) {
        throw parsingError("expected :");
      }
      position.position++;
      collectASequenceOfBytes(
        (char) => char === 32 || char === 9,
        input,
        position
      );
      switch (bufferToLowerCasedHeaderName2(headerName)) {
        case "content-disposition": {
          name = filename = null;
          if (!bufferStartsWith(input, formDataNameBuffer, position)) {
            throw parsingError('expected form-data; name=" for content-disposition header');
          }
          position.position += 17;
          name = parseMultipartFormDataName(input, position);
          if (input[position.position] === 59 && input[position.position + 1] === 32) {
            const at = { position: position.position + 2 };
            if (bufferStartsWith(input, filenameBuffer, at)) {
              if (input[at.position + 8] === 42) {
                at.position += 10;
                collectASequenceOfBytes(
                  (char) => char === 32 || char === 9,
                  input,
                  at
                );
                const headerValue = collectASequenceOfBytes(
                  (char) => char !== 32 && char !== 13 && char !== 10,
                  // ' ' or CRLF
                  input,
                  at
                );
                if (headerValue[0] !== 117 && headerValue[0] !== 85 || // u or U
                headerValue[1] !== 116 && headerValue[1] !== 84 || // t or T
                headerValue[2] !== 102 && headerValue[2] !== 70 || // f or F
                headerValue[3] !== 45 || // -
                headerValue[4] !== 56) {
                  throw parsingError("unknown encoding, expected utf-8''");
                }
                filename = decodeURIComponent(new TextDecoder().decode(headerValue.subarray(7)));
                position.position = at.position;
              } else {
                position.position += 11;
                collectASequenceOfBytes(
                  (char) => char === 32 || char === 9,
                  input,
                  position
                );
                position.position++;
                filename = parseMultipartFormDataName(input, position);
              }
            }
          }
          break;
        }
        case "content-type": {
          let headerValue = collectASequenceOfBytes(
            (char) => char !== 10 && char !== 13,
            input,
            position
          );
          headerValue = removeChars(headerValue, false, true, (char) => char === 9 || char === 32);
          contentType = isomorphicDecode(headerValue);
          break;
        }
        case "content-transfer-encoding": {
          let headerValue = collectASequenceOfBytes(
            (char) => char !== 10 && char !== 13,
            input,
            position
          );
          headerValue = removeChars(headerValue, false, true, (char) => char === 9 || char === 32);
          encoding2 = isomorphicDecode(headerValue);
          break;
        }
        default: {
          collectASequenceOfBytes(
            (char) => char !== 10 && char !== 13,
            input,
            position
          );
        }
      }
      if (input[position.position] !== 13 && input[position.position + 1] !== 10) {
        throw parsingError("expected CRLF");
      } else {
        position.position += 2;
      }
    }
  }
  function parseMultipartFormDataName(input, position) {
    assert2(input[position.position - 1] === 34);
    let name = collectASequenceOfBytes(
      (char) => char !== 10 && char !== 13 && char !== 34,
      input,
      position
    );
    if (input[position.position] !== 34) {
      throw parsingError('expected "');
    } else {
      position.position++;
    }
    name = new TextDecoder().decode(name).replace(/%0A/ig, "\n").replace(/%0D/ig, "\r").replace(/%22/g, '"');
    return name;
  }
  function collectASequenceOfBytes(condition, input, position) {
    let start = position.position;
    while (start < input.length && condition(input[start])) {
      ++start;
    }
    return input.subarray(position.position, position.position = start);
  }
  function removeChars(buf, leading, trailing, predicate) {
    let lead = 0;
    let trail = buf.length - 1;
    if (leading) {
      while (lead < buf.length && predicate(buf[lead])) lead++;
    }
    {
      while (trail > 0 && predicate(buf[trail])) trail--;
    }
    return lead === 0 && trail === buf.length - 1 ? buf : buf.subarray(lead, trail + 1);
  }
  function bufferStartsWith(buffer, start, position) {
    if (buffer.length < start.length) {
      return false;
    }
    for (let i = 0; i < start.length; i++) {
      if (start[i] !== buffer[position.position + i]) {
        return false;
      }
    }
    return true;
  }
  function parsingError(cause) {
    return new TypeError("Failed to parse body as FormData.", { cause: new TypeError(cause) });
  }
  formdataParser$1 = {
    multipartFormDataParser,
    validateBoundary
  };
  return formdataParser$1;
}
var body$1;
var hasRequiredBody$1;
function requireBody$1() {
  if (hasRequiredBody$1) return body$1;
  hasRequiredBody$1 = 1;
  const util2 = util$J;
  const {
    ReadableStreamFrom: ReadableStreamFrom2,
    readableStreamClose,
    createDeferredPromise,
    fullyReadBody,
    extractMimeType,
    utf8DecodeBytes
  } = requireUtil$a();
  const { FormData, setFormDataState } = requireFormdata$1();
  const { webidl } = requireWebidl$1();
  const { Blob: Blob2 } = require$$0$1;
  const assert2 = require$$0$3;
  const { isErrored: isErrored2, isDisturbed: isDisturbed2 } = require$$0$4;
  const { isArrayBuffer } = require$$8$2;
  const { serializeAMimeType: serializeAMimeType2 } = requireDataUrl$1();
  const { multipartFormDataParser } = requireFormdataParser$1();
  let random;
  try {
    const crypto2 = require("node:crypto");
    random = (max) => crypto2.randomInt(0, max);
  } catch {
    random = (max) => Math.floor(Math.random() * max);
  }
  const textEncoder = new TextEncoder();
  function noop2() {
  }
  const hasFinalizationRegistry = globalThis.FinalizationRegistry && process.version.indexOf("v18") !== 0;
  let streamRegistry;
  if (hasFinalizationRegistry) {
    streamRegistry = new FinalizationRegistry((weakRef) => {
      const stream2 = weakRef.deref();
      if (stream2 && !stream2.locked && !isDisturbed2(stream2) && !isErrored2(stream2)) {
        stream2.cancel("Response object has been garbage collected").catch(noop2);
      }
    });
  }
  function extractBody2(object, keepalive = false) {
    let stream2 = null;
    if (webidl.is.ReadableStream(object)) {
      stream2 = object;
    } else if (webidl.is.Blob(object)) {
      stream2 = object.stream();
    } else {
      stream2 = new ReadableStream({
        async pull(controller) {
          const buffer = typeof source === "string" ? textEncoder.encode(source) : source;
          if (buffer.byteLength) {
            controller.enqueue(buffer);
          }
          queueMicrotask(() => readableStreamClose(controller));
        },
        start() {
        },
        type: "bytes"
      });
    }
    assert2(webidl.is.ReadableStream(stream2));
    let action = null;
    let source = null;
    let length = null;
    let type = null;
    if (typeof object === "string") {
      source = object;
      type = "text/plain;charset=UTF-8";
    } else if (webidl.is.URLSearchParams(object)) {
      source = object.toString();
      type = "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isArrayBuffer(object)) {
      source = new Uint8Array(object.slice());
    } else if (ArrayBuffer.isView(object)) {
      source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
    } else if (webidl.is.FormData(object)) {
      const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, "0")}`;
      const prefix = `--${boundary}\r
Content-Disposition: form-data`;
      /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
      const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
      const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
      const blobParts = [];
      const rn = new Uint8Array([13, 10]);
      length = 0;
      let hasUnknownSizeValue = false;
      for (const [name, value] of object) {
        if (typeof value === "string") {
          const chunk2 = textEncoder.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
          blobParts.push(chunk2);
          length += chunk2.byteLength;
        } else {
          const chunk2 = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
          blobParts.push(chunk2, value, rn);
          if (typeof value.size === "number") {
            length += chunk2.byteLength + value.size + rn.byteLength;
          } else {
            hasUnknownSizeValue = true;
          }
        }
      }
      const chunk = textEncoder.encode(`--${boundary}--\r
`);
      blobParts.push(chunk);
      length += chunk.byteLength;
      if (hasUnknownSizeValue) {
        length = null;
      }
      source = object;
      action = async function* () {
        for (const part of blobParts) {
          if (part.stream) {
            yield* part.stream();
          } else {
            yield part;
          }
        }
      };
      type = `multipart/form-data; boundary=${boundary}`;
    } else if (webidl.is.Blob(object)) {
      source = object;
      length = object.size;
      if (object.type) {
        type = object.type;
      }
    } else if (typeof object[Symbol.asyncIterator] === "function") {
      if (keepalive) {
        throw new TypeError("keepalive");
      }
      if (util2.isDisturbed(object) || object.locked) {
        throw new TypeError(
          "Response body object should not be disturbed or locked"
        );
      }
      stream2 = webidl.is.ReadableStream(object) ? object : ReadableStreamFrom2(object);
    }
    if (typeof source === "string" || util2.isBuffer(source)) {
      length = Buffer.byteLength(source);
    }
    if (action != null) {
      let iterator;
      stream2 = new ReadableStream({
        async start() {
          iterator = action(object)[Symbol.asyncIterator]();
        },
        async pull(controller) {
          const { value, done } = await iterator.next();
          if (done) {
            queueMicrotask(() => {
              var _a2;
              controller.close();
              (_a2 = controller.byobRequest) == null ? void 0 : _a2.respond(0);
            });
          } else {
            if (!isErrored2(stream2)) {
              const buffer = new Uint8Array(value);
              if (buffer.byteLength) {
                controller.enqueue(buffer);
              }
            }
          }
          return controller.desiredSize > 0;
        },
        async cancel(reason) {
          await iterator.return();
        },
        type: "bytes"
      });
    }
    const body2 = { stream: stream2, source, length };
    return [body2, type];
  }
  function safelyExtractBody(object, keepalive = false) {
    if (webidl.is.ReadableStream(object)) {
      assert2(!util2.isDisturbed(object), "The body has already been consumed.");
      assert2(!object.locked, "The stream is locked.");
    }
    return extractBody2(object, keepalive);
  }
  function cloneBody(instance, body2) {
    const [out1, out2] = body2.stream.tee();
    if (hasFinalizationRegistry) {
      streamRegistry.register(instance, new WeakRef(out1));
    }
    body2.stream = out1;
    return {
      stream: out2,
      length: body2.length,
      source: body2.source
    };
  }
  function throwIfAborted(state) {
    if (state.aborted) {
      throw new DOMException("The operation was aborted.", "AbortError");
    }
  }
  function bodyMixinMethods(instance, getInternalState) {
    const methods = {
      blob() {
        return consumeBody(this, (bytes) => {
          let mimeType = bodyMimeType(getInternalState(this));
          if (mimeType === null) {
            mimeType = "";
          } else if (mimeType) {
            mimeType = serializeAMimeType2(mimeType);
          }
          return new Blob2([bytes], { type: mimeType });
        }, instance, getInternalState);
      },
      arrayBuffer() {
        return consumeBody(this, (bytes) => {
          return new Uint8Array(bytes).buffer;
        }, instance, getInternalState);
      },
      text() {
        return consumeBody(this, utf8DecodeBytes, instance, getInternalState);
      },
      json() {
        return consumeBody(this, parseJSONFromBytes, instance, getInternalState);
      },
      formData() {
        return consumeBody(this, (value) => {
          const mimeType = bodyMimeType(getInternalState(this));
          if (mimeType !== null) {
            switch (mimeType.essence) {
              case "multipart/form-data": {
                const parsed = multipartFormDataParser(value, mimeType);
                const fd = new FormData();
                setFormDataState(fd, parsed);
                return fd;
              }
              case "application/x-www-form-urlencoded": {
                const entries = new URLSearchParams(value.toString());
                const fd = new FormData();
                for (const [name, value2] of entries) {
                  fd.append(name, value2);
                }
                return fd;
              }
            }
          }
          throw new TypeError(
            'Content-Type was not one of "multipart/form-data" or "application/x-www-form-urlencoded".'
          );
        }, instance, getInternalState);
      },
      bytes() {
        return consumeBody(this, (bytes) => {
          return new Uint8Array(bytes);
        }, instance, getInternalState);
      }
    };
    return methods;
  }
  function mixinBody(prototype, getInternalState) {
    Object.assign(prototype.prototype, bodyMixinMethods(prototype, getInternalState));
  }
  async function consumeBody(object, convertBytesToJSValue, instance, getInternalState) {
    webidl.brandCheck(object, instance);
    const state = getInternalState(object);
    if (bodyUnusable(state)) {
      throw new TypeError("Body is unusable: Body has already been read");
    }
    throwIfAborted(state);
    const promise = createDeferredPromise();
    const errorSteps = (error) => promise.reject(error);
    const successSteps = (data) => {
      try {
        promise.resolve(convertBytesToJSValue(data));
      } catch (e) {
        errorSteps(e);
      }
    };
    if (state.body == null) {
      successSteps(Buffer.allocUnsafe(0));
      return promise.promise;
    }
    fullyReadBody(state.body, successSteps, errorSteps);
    return promise.promise;
  }
  function bodyUnusable(object) {
    const body2 = object.body;
    return body2 != null && (body2.stream.locked || util2.isDisturbed(body2.stream));
  }
  function parseJSONFromBytes(bytes) {
    return JSON.parse(utf8DecodeBytes(bytes));
  }
  function bodyMimeType(requestOrResponse) {
    const headers2 = requestOrResponse.headersList;
    const mimeType = extractMimeType(headers2);
    if (mimeType === "failure") {
      return null;
    }
    return mimeType;
  }
  body$1 = {
    extractBody: extractBody2,
    safelyExtractBody,
    cloneBody,
    mixinBody,
    streamRegistry,
    hasFinalizationRegistry,
    bodyUnusable
  };
  return body$1;
}
const assert$s = require$$0$3;
const util$F = util$J;
const { channels: channels$6 } = diagnostics$1;
const timers$3 = timers$5;
const {
  RequestContentLengthMismatchError: RequestContentLengthMismatchError$4,
  ResponseContentLengthMismatchError: ResponseContentLengthMismatchError$2,
  RequestAbortedError: RequestAbortedError$g,
  HeadersTimeoutError: HeadersTimeoutError$2,
  HeadersOverflowError: HeadersOverflowError$2,
  SocketError: SocketError$8,
  InformationalError: InformationalError$8,
  BodyTimeoutError: BodyTimeoutError$2,
  HTTPParserError: HTTPParserError$2,
  ResponseExceededMaxSizeError: ResponseExceededMaxSizeError$2
} = errors$2;
const {
  kUrl: kUrl$b,
  kReset: kReset$3,
  kClient: kClient$7,
  kParser: kParser$1,
  kBlocking: kBlocking$1,
  kRunning: kRunning$b,
  kPending: kPending$9,
  kSize: kSize$b,
  kWriting: kWriting$1,
  kQueue: kQueue$7,
  kNoRef: kNoRef$1,
  kKeepAliveDefaultTimeout: kKeepAliveDefaultTimeout$3,
  kHostHeader: kHostHeader$3,
  kPendingIdx: kPendingIdx$5,
  kRunningIdx: kRunningIdx$5,
  kError: kError$5,
  kPipelining: kPipelining$3,
  kSocket: kSocket$3,
  kKeepAliveTimeoutValue: kKeepAliveTimeoutValue$3,
  kMaxHeadersSize: kMaxHeadersSize$3,
  kKeepAliveMaxTimeout: kKeepAliveMaxTimeout$3,
  kKeepAliveTimeoutThreshold: kKeepAliveTimeoutThreshold$3,
  kHeadersTimeout: kHeadersTimeout$3,
  kBodyTimeout: kBodyTimeout$4,
  kStrictContentLength: kStrictContentLength$5,
  kMaxRequests: kMaxRequests$3,
  kCounter: kCounter$3,
  kMaxResponseSize: kMaxResponseSize$3,
  kOnError: kOnError$5,
  kResume: kResume$7,
  kHTTPContext: kHTTPContext$5,
  kClosed: kClosed$4
} = symbols$5;
const constants$9 = constants$b;
const EMPTY_BUF$1 = Buffer.alloc(0);
const FastBuffer$1 = Buffer[Symbol.species];
const removeAllListeners$2 = util$F.removeAllListeners;
let extractBody$3;
async function lazyllhttp$1() {
  const llhttpWasmData = process.env.JEST_WORKER_ID ? requireLlhttpWasm$1() : void 0;
  let mod;
  try {
    mod = await WebAssembly.compile(requireLlhttp_simdWasm$1());
  } catch (e) {
    mod = await WebAssembly.compile(llhttpWasmData || requireLlhttpWasm$1());
  }
  return await WebAssembly.instantiate(mod, {
    env: {
      /**
       * @param {number} p
       * @param {number} at
       * @param {number} len
       * @returns {number}
       */
      wasm_on_url: (p, at, len) => {
        return 0;
      },
      /**
       * @param {number} p
       * @param {number} at
       * @param {number} len
       * @returns {number}
       */
      wasm_on_status: (p, at, len) => {
        assert$s(currentParser$1.ptr === p);
        const start = at - currentBufferPtr$1 + currentBufferRef$1.byteOffset;
        return currentParser$1.onStatus(new FastBuffer$1(currentBufferRef$1.buffer, start, len));
      },
      /**
       * @param {number} p
       * @returns {number}
       */
      wasm_on_message_begin: (p) => {
        assert$s(currentParser$1.ptr === p);
        return currentParser$1.onMessageBegin();
      },
      /**
       * @param {number} p
       * @param {number} at
       * @param {number} len
       * @returns {number}
       */
      wasm_on_header_field: (p, at, len) => {
        assert$s(currentParser$1.ptr === p);
        const start = at - currentBufferPtr$1 + currentBufferRef$1.byteOffset;
        return currentParser$1.onHeaderField(new FastBuffer$1(currentBufferRef$1.buffer, start, len));
      },
      /**
       * @param {number} p
       * @param {number} at
       * @param {number} len
       * @returns {number}
       */
      wasm_on_header_value: (p, at, len) => {
        assert$s(currentParser$1.ptr === p);
        const start = at - currentBufferPtr$1 + currentBufferRef$1.byteOffset;
        return currentParser$1.onHeaderValue(new FastBuffer$1(currentBufferRef$1.buffer, start, len));
      },
      /**
       * @param {number} p
       * @param {number} statusCode
       * @param {0|1} upgrade
       * @param {0|1} shouldKeepAlive
       * @returns {number}
       */
      wasm_on_headers_complete: (p, statusCode, upgrade2, shouldKeepAlive) => {
        assert$s(currentParser$1.ptr === p);
        return currentParser$1.onHeadersComplete(statusCode, upgrade2 === 1, shouldKeepAlive === 1);
      },
      /**
       * @param {number} p
       * @param {number} at
       * @param {number} len
       * @returns {number}
       */
      wasm_on_body: (p, at, len) => {
        assert$s(currentParser$1.ptr === p);
        const start = at - currentBufferPtr$1 + currentBufferRef$1.byteOffset;
        return currentParser$1.onBody(new FastBuffer$1(currentBufferRef$1.buffer, start, len));
      },
      /**
       * @param {number} p
       * @returns {number}
       */
      wasm_on_message_complete: (p) => {
        assert$s(currentParser$1.ptr === p);
        return currentParser$1.onMessageComplete();
      }
    }
  });
}
let llhttpInstance$1 = null;
let llhttpPromise$1 = lazyllhttp$1();
llhttpPromise$1.catch();
let currentParser$1 = null;
let currentBufferRef$1 = null;
let currentBufferSize$1 = 0;
let currentBufferPtr$1 = null;
const USE_NATIVE_TIMER$1 = 0;
const USE_FAST_TIMER$1 = 1;
const TIMEOUT_HEADERS$1 = 2 | USE_FAST_TIMER$1;
const TIMEOUT_BODY$1 = 4 | USE_FAST_TIMER$1;
const TIMEOUT_KEEP_ALIVE$1 = 8 | USE_NATIVE_TIMER$1;
let Parser$1 = class Parser {
  /**
     * @param {import('./client.js')} client
     * @param {import('net').Socket} socket
     * @param {*} llhttp
     */
  constructor(client2, socket, { exports }) {
    this.llhttp = exports;
    this.ptr = this.llhttp.llhttp_alloc(constants$9.TYPE.RESPONSE);
    this.client = client2;
    this.socket = socket;
    this.timeout = null;
    this.timeoutValue = null;
    this.timeoutType = null;
    this.statusCode = 0;
    this.statusText = "";
    this.upgrade = false;
    this.headers = [];
    this.headersSize = 0;
    this.headersMaxSize = client2[kMaxHeadersSize$3];
    this.shouldKeepAlive = false;
    this.paused = false;
    this.resume = this.resume.bind(this);
    this.bytesRead = 0;
    this.keepAlive = "";
    this.contentLength = "";
    this.connection = "";
    this.maxResponseSize = client2[kMaxResponseSize$3];
  }
  setTimeout(delay, type) {
    if (delay !== this.timeoutValue || type & USE_FAST_TIMER$1 ^ this.timeoutType & USE_FAST_TIMER$1) {
      if (this.timeout) {
        timers$3.clearTimeout(this.timeout);
        this.timeout = null;
      }
      if (delay) {
        if (type & USE_FAST_TIMER$1) {
          this.timeout = timers$3.setFastTimeout(onParserTimeout$1, delay, new WeakRef(this));
        } else {
          this.timeout = setTimeout(onParserTimeout$1, delay, new WeakRef(this));
          this.timeout.unref();
        }
      }
      this.timeoutValue = delay;
    } else if (this.timeout) {
      if (this.timeout.refresh) {
        this.timeout.refresh();
      }
    }
    this.timeoutType = type;
  }
  resume() {
    if (this.socket.destroyed || !this.paused) {
      return;
    }
    assert$s(this.ptr != null);
    assert$s(currentParser$1 === null);
    this.llhttp.llhttp_resume(this.ptr);
    assert$s(this.timeoutType === TIMEOUT_BODY$1);
    if (this.timeout) {
      if (this.timeout.refresh) {
        this.timeout.refresh();
      }
    }
    this.paused = false;
    this.execute(this.socket.read() || EMPTY_BUF$1);
    this.readMore();
  }
  readMore() {
    while (!this.paused && this.ptr) {
      const chunk = this.socket.read();
      if (chunk === null) {
        break;
      }
      this.execute(chunk);
    }
  }
  /**
   * @param {Buffer} chunk
   */
  execute(chunk) {
    assert$s(currentParser$1 === null);
    assert$s(this.ptr != null);
    assert$s(!this.paused);
    const { socket, llhttp } = this;
    if (chunk.length > currentBufferSize$1) {
      if (currentBufferPtr$1) {
        llhttp.free(currentBufferPtr$1);
      }
      currentBufferSize$1 = Math.ceil(chunk.length / 4096) * 4096;
      currentBufferPtr$1 = llhttp.malloc(currentBufferSize$1);
    }
    new Uint8Array(llhttp.memory.buffer, currentBufferPtr$1, currentBufferSize$1).set(chunk);
    try {
      let ret;
      try {
        currentBufferRef$1 = chunk;
        currentParser$1 = this;
        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr$1, chunk.length);
      } catch (err) {
        throw err;
      } finally {
        currentParser$1 = null;
        currentBufferRef$1 = null;
      }
      if (ret !== constants$9.ERROR.OK) {
        const data = chunk.subarray(llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr$1);
        if (ret === constants$9.ERROR.PAUSED_UPGRADE) {
          this.onUpgrade(data);
        } else if (ret === constants$9.ERROR.PAUSED) {
          this.paused = true;
          socket.unshift(data);
        } else {
          const ptr = llhttp.llhttp_get_error_reason(this.ptr);
          let message = "";
          if (ptr) {
            const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
            message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
          }
          throw new HTTPParserError$2(message, constants$9.ERROR[ret], data);
        }
      }
    } catch (err) {
      util$F.destroy(socket, err);
    }
  }
  destroy() {
    assert$s(currentParser$1 === null);
    assert$s(this.ptr != null);
    this.llhttp.llhttp_free(this.ptr);
    this.ptr = null;
    this.timeout && timers$3.clearTimeout(this.timeout);
    this.timeout = null;
    this.timeoutValue = null;
    this.timeoutType = null;
    this.paused = false;
  }
  /**
   * @param {Buffer} buf
   * @returns {0}
   */
  onStatus(buf) {
    this.statusText = buf.toString();
    return 0;
  }
  /**
   * @returns {0|-1}
   */
  onMessageBegin() {
    const { socket, client: client2 } = this;
    if (socket.destroyed) {
      return -1;
    }
    const request2 = client2[kQueue$7][client2[kRunningIdx$5]];
    if (!request2) {
      return -1;
    }
    request2.onResponseStarted();
    return 0;
  }
  /**
   * @param {Buffer} buf
   * @returns {number}
   */
  onHeaderField(buf) {
    const len = this.headers.length;
    if ((len & 1) === 0) {
      this.headers.push(buf);
    } else {
      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
    }
    this.trackHeader(buf.length);
    return 0;
  }
  /**
   * @param {Buffer} buf
   * @returns {number}
   */
  onHeaderValue(buf) {
    let len = this.headers.length;
    if ((len & 1) === 1) {
      this.headers.push(buf);
      len += 1;
    } else {
      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
    }
    const key = this.headers[len - 2];
    if (key.length === 10) {
      const headerName = util$F.bufferToLowerCasedHeaderName(key);
      if (headerName === "keep-alive") {
        this.keepAlive += buf.toString();
      } else if (headerName === "connection") {
        this.connection += buf.toString();
      }
    } else if (key.length === 14 && util$F.bufferToLowerCasedHeaderName(key) === "content-length") {
      this.contentLength += buf.toString();
    }
    this.trackHeader(buf.length);
    return 0;
  }
  /**
   * @param {number} len
   */
  trackHeader(len) {
    this.headersSize += len;
    if (this.headersSize >= this.headersMaxSize) {
      util$F.destroy(this.socket, new HeadersOverflowError$2());
    }
  }
  /**
   * @param {Buffer} head
   */
  onUpgrade(head) {
    const { upgrade: upgrade2, client: client2, socket, headers: headers2, statusCode } = this;
    assert$s(upgrade2);
    assert$s(client2[kSocket$3] === socket);
    assert$s(!socket.destroyed);
    assert$s(!this.paused);
    assert$s((headers2.length & 1) === 0);
    const request2 = client2[kQueue$7][client2[kRunningIdx$5]];
    assert$s(request2);
    assert$s(request2.upgrade || request2.method === "CONNECT");
    this.statusCode = 0;
    this.statusText = "";
    this.shouldKeepAlive = false;
    this.headers = [];
    this.headersSize = 0;
    socket.unshift(head);
    socket[kParser$1].destroy();
    socket[kParser$1] = null;
    socket[kClient$7] = null;
    socket[kError$5] = null;
    removeAllListeners$2(socket);
    client2[kSocket$3] = null;
    client2[kHTTPContext$5] = null;
    client2[kQueue$7][client2[kRunningIdx$5]++] = null;
    client2.emit("disconnect", client2[kUrl$b], [client2], new InformationalError$8("upgrade"));
    try {
      request2.onUpgrade(statusCode, headers2, socket);
    } catch (err) {
      util$F.destroy(socket, err);
    }
    client2[kResume$7]();
  }
  /**
   * @param {number} statusCode
   * @param {boolean} upgrade
   * @param {boolean} shouldKeepAlive
   * @returns {number}
   */
  onHeadersComplete(statusCode, upgrade2, shouldKeepAlive) {
    const { client: client2, socket, headers: headers2, statusText } = this;
    if (socket.destroyed) {
      return -1;
    }
    const request2 = client2[kQueue$7][client2[kRunningIdx$5]];
    if (!request2) {
      return -1;
    }
    assert$s(!this.upgrade);
    assert$s(this.statusCode < 200);
    if (statusCode === 100) {
      util$F.destroy(socket, new SocketError$8("bad response", util$F.getSocketInfo(socket)));
      return -1;
    }
    if (upgrade2 && !request2.upgrade) {
      util$F.destroy(socket, new SocketError$8("bad upgrade", util$F.getSocketInfo(socket)));
      return -1;
    }
    assert$s(this.timeoutType === TIMEOUT_HEADERS$1);
    this.statusCode = statusCode;
    this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.
    request2.method === "HEAD" && !socket[kReset$3] && this.connection.toLowerCase() === "keep-alive";
    if (this.statusCode >= 200) {
      const bodyTimeout = request2.bodyTimeout != null ? request2.bodyTimeout : client2[kBodyTimeout$4];
      this.setTimeout(bodyTimeout, TIMEOUT_BODY$1);
    } else if (this.timeout) {
      if (this.timeout.refresh) {
        this.timeout.refresh();
      }
    }
    if (request2.method === "CONNECT") {
      assert$s(client2[kRunning$b] === 1);
      this.upgrade = true;
      return 2;
    }
    if (upgrade2) {
      assert$s(client2[kRunning$b] === 1);
      this.upgrade = true;
      return 2;
    }
    assert$s((this.headers.length & 1) === 0);
    this.headers = [];
    this.headersSize = 0;
    if (this.shouldKeepAlive && client2[kPipelining$3]) {
      const keepAliveTimeout = this.keepAlive ? util$F.parseKeepAliveTimeout(this.keepAlive) : null;
      if (keepAliveTimeout != null) {
        const timeout = Math.min(
          keepAliveTimeout - client2[kKeepAliveTimeoutThreshold$3],
          client2[kKeepAliveMaxTimeout$3]
        );
        if (timeout <= 0) {
          socket[kReset$3] = true;
        } else {
          client2[kKeepAliveTimeoutValue$3] = timeout;
        }
      } else {
        client2[kKeepAliveTimeoutValue$3] = client2[kKeepAliveDefaultTimeout$3];
      }
    } else {
      socket[kReset$3] = true;
    }
    const pause = request2.onHeaders(statusCode, headers2, this.resume, statusText) === false;
    if (request2.aborted) {
      return -1;
    }
    if (request2.method === "HEAD") {
      return 1;
    }
    if (statusCode < 200) {
      return 1;
    }
    if (socket[kBlocking$1]) {
      socket[kBlocking$1] = false;
      client2[kResume$7]();
    }
    return pause ? constants$9.ERROR.PAUSED : 0;
  }
  /**
   * @param {Buffer} buf
   * @returns {number}
   */
  onBody(buf) {
    const { client: client2, socket, statusCode, maxResponseSize } = this;
    if (socket.destroyed) {
      return -1;
    }
    const request2 = client2[kQueue$7][client2[kRunningIdx$5]];
    assert$s(request2);
    assert$s(this.timeoutType === TIMEOUT_BODY$1);
    if (this.timeout) {
      if (this.timeout.refresh) {
        this.timeout.refresh();
      }
    }
    assert$s(statusCode >= 200);
    if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
      util$F.destroy(socket, new ResponseExceededMaxSizeError$2());
      return -1;
    }
    this.bytesRead += buf.length;
    if (request2.onData(buf) === false) {
      return constants$9.ERROR.PAUSED;
    }
    return 0;
  }
  /**
   * @returns {number}
   */
  onMessageComplete() {
    const { client: client2, socket, statusCode, upgrade: upgrade2, headers: headers2, contentLength, bytesRead, shouldKeepAlive } = this;
    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
      return -1;
    }
    if (upgrade2) {
      return 0;
    }
    assert$s(statusCode >= 100);
    assert$s((this.headers.length & 1) === 0);
    const request2 = client2[kQueue$7][client2[kRunningIdx$5]];
    assert$s(request2);
    this.statusCode = 0;
    this.statusText = "";
    this.bytesRead = 0;
    this.contentLength = "";
    this.keepAlive = "";
    this.connection = "";
    this.headers = [];
    this.headersSize = 0;
    if (statusCode < 200) {
      return 0;
    }
    if (request2.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
      util$F.destroy(socket, new ResponseContentLengthMismatchError$2());
      return -1;
    }
    request2.onComplete(headers2);
    client2[kQueue$7][client2[kRunningIdx$5]++] = null;
    if (socket[kWriting$1]) {
      assert$s(client2[kRunning$b] === 0);
      util$F.destroy(socket, new InformationalError$8("reset"));
      return constants$9.ERROR.PAUSED;
    } else if (!shouldKeepAlive) {
      util$F.destroy(socket, new InformationalError$8("reset"));
      return constants$9.ERROR.PAUSED;
    } else if (socket[kReset$3] && client2[kRunning$b] === 0) {
      util$F.destroy(socket, new InformationalError$8("reset"));
      return constants$9.ERROR.PAUSED;
    } else if (client2[kPipelining$3] == null || client2[kPipelining$3] === 1) {
      setImmediate(() => client2[kResume$7]());
    } else {
      client2[kResume$7]();
    }
    return 0;
  }
};
function onParserTimeout$1(parser) {
  const { socket, timeoutType, client: client2, paused } = parser.deref();
  if (timeoutType === TIMEOUT_HEADERS$1) {
    if (!socket[kWriting$1] || socket.writableNeedDrain || client2[kRunning$b] > 1) {
      assert$s(!paused, "cannot be paused while waiting for headers");
      util$F.destroy(socket, new HeadersTimeoutError$2());
    }
  } else if (timeoutType === TIMEOUT_BODY$1) {
    if (!paused) {
      util$F.destroy(socket, new BodyTimeoutError$2());
    }
  } else if (timeoutType === TIMEOUT_KEEP_ALIVE$1) {
    assert$s(client2[kRunning$b] === 0 && client2[kKeepAliveTimeoutValue$3]);
    util$F.destroy(socket, new InformationalError$8("socket idle timeout"));
  }
}
async function connectH1$3(client2, socket) {
  client2[kSocket$3] = socket;
  if (!llhttpInstance$1) {
    const noop2 = () => {
    };
    socket.on("error", noop2);
    llhttpInstance$1 = await llhttpPromise$1;
    llhttpPromise$1 = null;
    socket.off("error", noop2);
  }
  if (socket.errored) {
    throw socket.errored;
  }
  if (socket.destroyed) {
    throw new SocketError$8("destroyed");
  }
  socket[kNoRef$1] = false;
  socket[kWriting$1] = false;
  socket[kReset$3] = false;
  socket[kBlocking$1] = false;
  socket[kParser$1] = new Parser$1(client2, socket, llhttpInstance$1);
  util$F.addListener(socket, "error", onHttpSocketError);
  util$F.addListener(socket, "readable", onHttpSocketReadable);
  util$F.addListener(socket, "end", onHttpSocketEnd);
  util$F.addListener(socket, "close", onHttpSocketClose);
  socket[kClosed$4] = false;
  socket.on("close", onSocketClose$1);
  return {
    version: "h1",
    defaultPipelining: 1,
    write(request2) {
      return writeH1$1(client2, request2);
    },
    resume() {
      resumeH1$1(client2);
    },
    /**
     * @param {Error|undefined} err
     * @param {() => void} callback
     */
    destroy(err, callback) {
      if (socket[kClosed$4]) {
        queueMicrotask(callback);
      } else {
        socket.on("close", callback);
        socket.destroy(err);
      }
    },
    /**
     * @returns {boolean}
     */
    get destroyed() {
      return socket.destroyed;
    },
    /**
     * @param {import('../core/request.js')} request
     * @returns {boolean}
     */
    busy(request2) {
      if (socket[kWriting$1] || socket[kReset$3] || socket[kBlocking$1]) {
        return true;
      }
      if (request2) {
        if (client2[kRunning$b] > 0 && !request2.idempotent) {
          return true;
        }
        if (client2[kRunning$b] > 0 && (request2.upgrade || request2.method === "CONNECT")) {
          return true;
        }
        if (client2[kRunning$b] > 0 && util$F.bodyLength(request2.body) !== 0 && (util$F.isStream(request2.body) || util$F.isAsyncIterable(request2.body) || util$F.isFormDataLike(request2.body))) {
          return true;
        }
      }
      return false;
    }
  };
}
function onHttpSocketError(err) {
  assert$s(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
  const parser = this[kParser$1];
  if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
    parser.onMessageComplete();
    return;
  }
  this[kError$5] = err;
  this[kClient$7][kOnError$5](err);
}
function onHttpSocketReadable() {
  var _a2;
  (_a2 = this[kParser$1]) == null ? void 0 : _a2.readMore();
}
function onHttpSocketEnd() {
  const parser = this[kParser$1];
  if (parser.statusCode && !parser.shouldKeepAlive) {
    parser.onMessageComplete();
    return;
  }
  util$F.destroy(this, new SocketError$8("other side closed", util$F.getSocketInfo(this)));
}
function onHttpSocketClose() {
  const parser = this[kParser$1];
  if (parser) {
    if (!this[kError$5] && parser.statusCode && !parser.shouldKeepAlive) {
      parser.onMessageComplete();
    }
    this[kParser$1].destroy();
    this[kParser$1] = null;
  }
  const err = this[kError$5] || new SocketError$8("closed", util$F.getSocketInfo(this));
  const client2 = this[kClient$7];
  client2[kSocket$3] = null;
  client2[kHTTPContext$5] = null;
  if (client2.destroyed) {
    assert$s(client2[kPending$9] === 0);
    const requests = client2[kQueue$7].splice(client2[kRunningIdx$5]);
    for (let i = 0; i < requests.length; i++) {
      const request2 = requests[i];
      util$F.errorRequest(client2, request2, err);
    }
  } else if (client2[kRunning$b] > 0 && err.code !== "UND_ERR_INFO") {
    const request2 = client2[kQueue$7][client2[kRunningIdx$5]];
    client2[kQueue$7][client2[kRunningIdx$5]++] = null;
    util$F.errorRequest(client2, request2, err);
  }
  client2[kPendingIdx$5] = client2[kRunningIdx$5];
  assert$s(client2[kRunning$b] === 0);
  client2.emit("disconnect", client2[kUrl$b], [client2], err);
  client2[kResume$7]();
}
function onSocketClose$1() {
  this[kClosed$4] = true;
}
function resumeH1$1(client2) {
  const socket = client2[kSocket$3];
  if (socket && !socket.destroyed) {
    if (client2[kSize$b] === 0) {
      if (!socket[kNoRef$1] && socket.unref) {
        socket.unref();
        socket[kNoRef$1] = true;
      }
    } else if (socket[kNoRef$1] && socket.ref) {
      socket.ref();
      socket[kNoRef$1] = false;
    }
    if (client2[kSize$b] === 0) {
      if (socket[kParser$1].timeoutType !== TIMEOUT_KEEP_ALIVE$1) {
        socket[kParser$1].setTimeout(client2[kKeepAliveTimeoutValue$3], TIMEOUT_KEEP_ALIVE$1);
      }
    } else if (client2[kRunning$b] > 0 && socket[kParser$1].statusCode < 200) {
      if (socket[kParser$1].timeoutType !== TIMEOUT_HEADERS$1) {
        const request2 = client2[kQueue$7][client2[kRunningIdx$5]];
        const headersTimeout = request2.headersTimeout != null ? request2.headersTimeout : client2[kHeadersTimeout$3];
        socket[kParser$1].setTimeout(headersTimeout, TIMEOUT_HEADERS$1);
      }
    }
  }
}
function shouldSendContentLength$3(method) {
  return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
}
function writeH1$1(client2, request2) {
  const { method, path: path2, host, upgrade: upgrade2, blocking, reset } = request2;
  let { body: body2, headers: headers2, contentLength } = request2;
  const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH" || method === "QUERY" || method === "PROPFIND" || method === "PROPPATCH";
  if (util$F.isFormDataLike(body2)) {
    if (!extractBody$3) {
      extractBody$3 = requireBody$1().extractBody;
    }
    const [bodyStream, contentType] = extractBody$3(body2);
    if (request2.contentType == null) {
      headers2.push("content-type", contentType);
    }
    body2 = bodyStream.stream;
    contentLength = bodyStream.length;
  } else if (util$F.isBlobLike(body2) && request2.contentType == null && body2.type) {
    headers2.push("content-type", body2.type);
  }
  if (body2 && typeof body2.read === "function") {
    body2.read(0);
  }
  const bodyLength2 = util$F.bodyLength(body2);
  contentLength = bodyLength2 ?? contentLength;
  if (contentLength === null) {
    contentLength = request2.contentLength;
  }
  if (contentLength === 0 && !expectsPayload) {
    contentLength = null;
  }
  if (shouldSendContentLength$3(method) && contentLength > 0 && request2.contentLength !== null && request2.contentLength !== contentLength) {
    if (client2[kStrictContentLength$5]) {
      util$F.errorRequest(client2, request2, new RequestContentLengthMismatchError$4());
      return false;
    }
    process.emitWarning(new RequestContentLengthMismatchError$4());
  }
  const socket = client2[kSocket$3];
  const abort2 = (err) => {
    if (request2.aborted || request2.completed) {
      return;
    }
    util$F.errorRequest(client2, request2, err || new RequestAbortedError$g());
    util$F.destroy(body2);
    util$F.destroy(socket, new InformationalError$8("aborted"));
  };
  try {
    request2.onConnect(abort2);
  } catch (err) {
    util$F.errorRequest(client2, request2, err);
  }
  if (request2.aborted) {
    return false;
  }
  if (method === "HEAD") {
    socket[kReset$3] = true;
  }
  if (upgrade2 || method === "CONNECT") {
    socket[kReset$3] = true;
  }
  if (reset != null) {
    socket[kReset$3] = reset;
  }
  if (client2[kMaxRequests$3] && socket[kCounter$3]++ >= client2[kMaxRequests$3]) {
    socket[kReset$3] = true;
  }
  if (blocking) {
    socket[kBlocking$1] = true;
  }
  let header = `${method} ${path2} HTTP/1.1\r
`;
  if (typeof host === "string") {
    header += `host: ${host}\r
`;
  } else {
    header += client2[kHostHeader$3];
  }
  if (upgrade2) {
    header += `connection: upgrade\r
upgrade: ${upgrade2}\r
`;
  } else if (client2[kPipelining$3] && !socket[kReset$3]) {
    header += "connection: keep-alive\r\n";
  } else {
    header += "connection: close\r\n";
  }
  if (Array.isArray(headers2)) {
    for (let n = 0; n < headers2.length; n += 2) {
      const key = headers2[n + 0];
      const val = headers2[n + 1];
      if (Array.isArray(val)) {
        for (let i = 0; i < val.length; i++) {
          header += `${key}: ${val[i]}\r
`;
        }
      } else {
        header += `${key}: ${val}\r
`;
      }
    }
  }
  if (channels$6.sendHeaders.hasSubscribers) {
    channels$6.sendHeaders.publish({ request: request2, headers: header, socket });
  }
  if (!body2 || bodyLength2 === 0) {
    writeBuffer$3(abort2, null, client2, request2, socket, contentLength, header, expectsPayload);
  } else if (util$F.isBuffer(body2)) {
    writeBuffer$3(abort2, body2, client2, request2, socket, contentLength, header, expectsPayload);
  } else if (util$F.isBlobLike(body2)) {
    if (typeof body2.stream === "function") {
      writeIterable$3(abort2, body2.stream(), client2, request2, socket, contentLength, header, expectsPayload);
    } else {
      writeBlob$3(abort2, body2, client2, request2, socket, contentLength, header, expectsPayload);
    }
  } else if (util$F.isStream(body2)) {
    writeStream$3(abort2, body2, client2, request2, socket, contentLength, header, expectsPayload);
  } else if (util$F.isIterable(body2)) {
    writeIterable$3(abort2, body2, client2, request2, socket, contentLength, header, expectsPayload);
  } else {
    assert$s(false);
  }
  return true;
}
function writeStream$3(abort2, body2, client2, request2, socket, contentLength, header, expectsPayload) {
  assert$s(contentLength !== 0 || client2[kRunning$b] === 0, "stream body cannot be pipelined");
  let finished2 = false;
  const writer = new AsyncWriter$1({ abort: abort2, socket, request: request2, contentLength, client: client2, expectsPayload, header });
  const onData = function(chunk) {
    if (finished2) {
      return;
    }
    try {
      if (!writer.write(chunk) && this.pause) {
        this.pause();
      }
    } catch (err) {
      util$F.destroy(this, err);
    }
  };
  const onDrain = function() {
    if (finished2) {
      return;
    }
    if (body2.resume) {
      body2.resume();
    }
  };
  const onClose = function() {
    queueMicrotask(() => {
      body2.removeListener("error", onFinished);
    });
    if (!finished2) {
      const err = new RequestAbortedError$g();
      queueMicrotask(() => onFinished(err));
    }
  };
  const onFinished = function(err) {
    if (finished2) {
      return;
    }
    finished2 = true;
    assert$s(socket.destroyed || socket[kWriting$1] && client2[kRunning$b] <= 1);
    socket.off("drain", onDrain).off("error", onFinished);
    body2.removeListener("data", onData).removeListener("end", onFinished).removeListener("close", onClose);
    if (!err) {
      try {
        writer.end();
      } catch (er) {
        err = er;
      }
    }
    writer.destroy(err);
    if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
      util$F.destroy(body2, err);
    } else {
      util$F.destroy(body2);
    }
  };
  body2.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onClose);
  if (body2.resume) {
    body2.resume();
  }
  socket.on("drain", onDrain).on("error", onFinished);
  if (body2.errorEmitted ?? body2.errored) {
    setImmediate(() => onFinished(body2.errored));
  } else if (body2.endEmitted ?? body2.readableEnded) {
    setImmediate(() => onFinished(null));
  }
  if (body2.closeEmitted ?? body2.closed) {
    setImmediate(onClose);
  }
}
function writeBuffer$3(abort2, body2, client2, request2, socket, contentLength, header, expectsPayload) {
  try {
    if (!body2) {
      if (contentLength === 0) {
        socket.write(`${header}content-length: 0\r
\r
`, "latin1");
      } else {
        assert$s(contentLength === null, "no body must not have content length");
        socket.write(`${header}\r
`, "latin1");
      }
    } else if (util$F.isBuffer(body2)) {
      assert$s(contentLength === body2.byteLength, "buffer body must have content length");
      socket.cork();
      socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
      socket.write(body2);
      socket.uncork();
      request2.onBodySent(body2);
      if (!expectsPayload && request2.reset !== false) {
        socket[kReset$3] = true;
      }
    }
    request2.onRequestSent();
    client2[kResume$7]();
  } catch (err) {
    abort2(err);
  }
}
async function writeBlob$3(abort2, body2, client2, request2, socket, contentLength, header, expectsPayload) {
  assert$s(contentLength === body2.size, "blob body must have content length");
  try {
    if (contentLength != null && contentLength !== body2.size) {
      throw new RequestContentLengthMismatchError$4();
    }
    const buffer = Buffer.from(await body2.arrayBuffer());
    socket.cork();
    socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
    socket.write(buffer);
    socket.uncork();
    request2.onBodySent(buffer);
    request2.onRequestSent();
    if (!expectsPayload && request2.reset !== false) {
      socket[kReset$3] = true;
    }
    client2[kResume$7]();
  } catch (err) {
    abort2(err);
  }
}
async function writeIterable$3(abort2, body2, client2, request2, socket, contentLength, header, expectsPayload) {
  assert$s(contentLength !== 0 || client2[kRunning$b] === 0, "iterator body cannot be pipelined");
  let callback = null;
  function onDrain() {
    if (callback) {
      const cb = callback;
      callback = null;
      cb();
    }
  }
  const waitForDrain = () => new Promise((resolve2, reject) => {
    assert$s(callback === null);
    if (socket[kError$5]) {
      reject(socket[kError$5]);
    } else {
      callback = resolve2;
    }
  });
  socket.on("close", onDrain).on("drain", onDrain);
  const writer = new AsyncWriter$1({ abort: abort2, socket, request: request2, contentLength, client: client2, expectsPayload, header });
  try {
    for await (const chunk of body2) {
      if (socket[kError$5]) {
        throw socket[kError$5];
      }
      if (!writer.write(chunk)) {
        await waitForDrain();
      }
    }
    writer.end();
  } catch (err) {
    writer.destroy(err);
  } finally {
    socket.off("close", onDrain).off("drain", onDrain);
  }
}
let AsyncWriter$1 = class AsyncWriter {
  /**
   *
   * @param {object} arg
   * @param {AbortCallback} arg.abort
   * @param {import('net').Socket} arg.socket
   * @param {import('../core/request.js')} arg.request
   * @param {number} arg.contentLength
   * @param {import('./client.js')} arg.client
   * @param {boolean} arg.expectsPayload
   * @param {string} arg.header
   */
  constructor({ abort: abort2, socket, request: request2, contentLength, client: client2, expectsPayload, header }) {
    this.socket = socket;
    this.request = request2;
    this.contentLength = contentLength;
    this.client = client2;
    this.bytesWritten = 0;
    this.expectsPayload = expectsPayload;
    this.header = header;
    this.abort = abort2;
    socket[kWriting$1] = true;
  }
  /**
   * @param {Buffer} chunk
   * @returns
   */
  write(chunk) {
    const { socket, request: request2, contentLength, client: client2, bytesWritten, expectsPayload, header } = this;
    if (socket[kError$5]) {
      throw socket[kError$5];
    }
    if (socket.destroyed) {
      return false;
    }
    const len = Buffer.byteLength(chunk);
    if (!len) {
      return true;
    }
    if (contentLength !== null && bytesWritten + len > contentLength) {
      if (client2[kStrictContentLength$5]) {
        throw new RequestContentLengthMismatchError$4();
      }
      process.emitWarning(new RequestContentLengthMismatchError$4());
    }
    socket.cork();
    if (bytesWritten === 0) {
      if (!expectsPayload && request2.reset !== false) {
        socket[kReset$3] = true;
      }
      if (contentLength === null) {
        socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
      } else {
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
      }
    }
    if (contentLength === null) {
      socket.write(`\r
${len.toString(16)}\r
`, "latin1");
    }
    this.bytesWritten += len;
    const ret = socket.write(chunk);
    socket.uncork();
    request2.onBodySent(chunk);
    if (!ret) {
      if (socket[kParser$1].timeout && socket[kParser$1].timeoutType === TIMEOUT_HEADERS$1) {
        if (socket[kParser$1].timeout.refresh) {
          socket[kParser$1].timeout.refresh();
        }
      }
    }
    return ret;
  }
  /**
   * @returns {void}
   */
  end() {
    const { socket, contentLength, client: client2, bytesWritten, expectsPayload, header, request: request2 } = this;
    request2.onRequestSent();
    socket[kWriting$1] = false;
    if (socket[kError$5]) {
      throw socket[kError$5];
    }
    if (socket.destroyed) {
      return;
    }
    if (bytesWritten === 0) {
      if (expectsPayload) {
        socket.write(`${header}content-length: 0\r
\r
`, "latin1");
      } else {
        socket.write(`${header}\r
`, "latin1");
      }
    } else if (contentLength === null) {
      socket.write("\r\n0\r\n\r\n", "latin1");
    }
    if (contentLength !== null && bytesWritten !== contentLength) {
      if (client2[kStrictContentLength$5]) {
        throw new RequestContentLengthMismatchError$4();
      } else {
        process.emitWarning(new RequestContentLengthMismatchError$4());
      }
    }
    if (socket[kParser$1].timeout && socket[kParser$1].timeoutType === TIMEOUT_HEADERS$1) {
      if (socket[kParser$1].timeout.refresh) {
        socket[kParser$1].timeout.refresh();
      }
    }
    client2[kResume$7]();
  }
  /**
   * @param {Error} [err]
   * @returns {void}
   */
  destroy(err) {
    const { socket, client: client2, abort: abort2 } = this;
    socket[kWriting$1] = false;
    if (err) {
      assert$s(client2[kRunning$b] <= 1, "pipeline should only contain this request");
      abort2(err);
    }
  }
};
var clientH1$1 = connectH1$3;
const assert$r = require$$0$3;
const { pipeline: pipeline$3 } = require$$0$4;
const util$E = util$J;
const {
  RequestContentLengthMismatchError: RequestContentLengthMismatchError$3,
  RequestAbortedError: RequestAbortedError$f,
  SocketError: SocketError$7,
  InformationalError: InformationalError$7
} = errors$2;
const {
  kUrl: kUrl$a,
  kReset: kReset$2,
  kClient: kClient$6,
  kRunning: kRunning$a,
  kPending: kPending$8,
  kQueue: kQueue$6,
  kPendingIdx: kPendingIdx$4,
  kRunningIdx: kRunningIdx$4,
  kError: kError$4,
  kSocket: kSocket$2,
  kStrictContentLength: kStrictContentLength$4,
  kOnError: kOnError$4,
  kMaxConcurrentStreams: kMaxConcurrentStreams$3,
  kHTTP2Session: kHTTP2Session$1,
  kResume: kResume$6,
  kSize: kSize$a,
  kHTTPContext: kHTTPContext$4,
  kClosed: kClosed$3,
  kBodyTimeout: kBodyTimeout$3
} = symbols$5;
const { channels: channels$5 } = diagnostics$1;
const kOpenStreams$1 = Symbol("open streams");
let extractBody$2;
let http2$1;
try {
  http2$1 = require("node:http2");
} catch {
  http2$1 = { constants: {} };
}
const {
  constants: {
    HTTP2_HEADER_AUTHORITY: HTTP2_HEADER_AUTHORITY$1,
    HTTP2_HEADER_METHOD: HTTP2_HEADER_METHOD$1,
    HTTP2_HEADER_PATH: HTTP2_HEADER_PATH$1,
    HTTP2_HEADER_SCHEME: HTTP2_HEADER_SCHEME$1,
    HTTP2_HEADER_CONTENT_LENGTH: HTTP2_HEADER_CONTENT_LENGTH$1,
    HTTP2_HEADER_EXPECT: HTTP2_HEADER_EXPECT$1,
    HTTP2_HEADER_STATUS: HTTP2_HEADER_STATUS$1
  }
} = http2$1;
function parseH2Headers$1(headers2) {
  const result = [];
  for (const [name, value] of Object.entries(headers2)) {
    if (Array.isArray(value)) {
      for (const subvalue of value) {
        result.push(Buffer.from(name), Buffer.from(subvalue));
      }
    } else {
      result.push(Buffer.from(name), Buffer.from(value));
    }
  }
  return result;
}
async function connectH2$3(client2, socket) {
  client2[kSocket$2] = socket;
  const session = http2$1.connect(client2[kUrl$a], {
    createConnection: () => socket,
    peerMaxConcurrentStreams: client2[kMaxConcurrentStreams$3],
    settings: {
      // TODO(metcoder95): add support for PUSH
      enablePush: false
    }
  });
  session[kOpenStreams$1] = 0;
  session[kClient$6] = client2;
  session[kSocket$2] = socket;
  session[kHTTP2Session$1] = null;
  util$E.addListener(session, "error", onHttp2SessionError$1);
  util$E.addListener(session, "frameError", onHttp2FrameError$1);
  util$E.addListener(session, "end", onHttp2SessionEnd$1);
  util$E.addListener(session, "goaway", onHttp2SessionGoAway);
  util$E.addListener(session, "close", onHttp2SessionClose);
  session.unref();
  client2[kHTTP2Session$1] = session;
  socket[kHTTP2Session$1] = session;
  util$E.addListener(socket, "error", onHttp2SocketError);
  util$E.addListener(socket, "end", onHttp2SocketEnd);
  util$E.addListener(socket, "close", onHttp2SocketClose);
  socket[kClosed$3] = false;
  socket.on("close", onSocketClose);
  return {
    version: "h2",
    defaultPipelining: Infinity,
    write(request2) {
      return writeH2$1(client2, request2);
    },
    resume() {
      resumeH2$1(client2);
    },
    destroy(err, callback) {
      if (socket[kClosed$3]) {
        queueMicrotask(callback);
      } else {
        socket.destroy(err).on("close", callback);
      }
    },
    get destroyed() {
      return socket.destroyed;
    },
    busy() {
      return false;
    }
  };
}
function resumeH2$1(client2) {
  const socket = client2[kSocket$2];
  if ((socket == null ? void 0 : socket.destroyed) === false) {
    if (client2[kSize$a] === 0 || client2[kMaxConcurrentStreams$3] === 0) {
      socket.unref();
      client2[kHTTP2Session$1].unref();
    } else {
      socket.ref();
      client2[kHTTP2Session$1].ref();
    }
  }
}
function onHttp2SessionError$1(err) {
  assert$r(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
  this[kSocket$2][kError$4] = err;
  this[kClient$6][kOnError$4](err);
}
function onHttp2FrameError$1(type, code, id) {
  if (id === 0) {
    const err = new InformationalError$7(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
    this[kSocket$2][kError$4] = err;
    this[kClient$6][kOnError$4](err);
  }
}
function onHttp2SessionEnd$1() {
  const err = new SocketError$7("other side closed", util$E.getSocketInfo(this[kSocket$2]));
  this.destroy(err);
  util$E.destroy(this[kSocket$2], err);
}
function onHttp2SessionGoAway(errorCode) {
  const err = this[kError$4] || new SocketError$7(`HTTP/2: "GOAWAY" frame received with code ${errorCode}`, util$E.getSocketInfo(this[kSocket$2]));
  const client2 = this[kClient$6];
  client2[kSocket$2] = null;
  client2[kHTTPContext$4] = null;
  this.close();
  this[kHTTP2Session$1] = null;
  util$E.destroy(this[kSocket$2], err);
  if (client2[kRunningIdx$4] < client2[kQueue$6].length) {
    const request2 = client2[kQueue$6][client2[kRunningIdx$4]];
    client2[kQueue$6][client2[kRunningIdx$4]++] = null;
    util$E.errorRequest(client2, request2, err);
    client2[kPendingIdx$4] = client2[kRunningIdx$4];
  }
  assert$r(client2[kRunning$a] === 0);
  client2.emit("disconnect", client2[kUrl$a], [client2], err);
  client2[kResume$6]();
}
function onHttp2SessionClose() {
  const { [kClient$6]: client2 } = this;
  const { [kSocket$2]: socket } = client2;
  const err = this[kSocket$2][kError$4] || this[kError$4] || new SocketError$7("closed", util$E.getSocketInfo(socket));
  client2[kSocket$2] = null;
  client2[kHTTPContext$4] = null;
  if (client2.destroyed) {
    assert$r(client2[kPending$8] === 0);
    const requests = client2[kQueue$6].splice(client2[kRunningIdx$4]);
    for (let i = 0; i < requests.length; i++) {
      const request2 = requests[i];
      util$E.errorRequest(client2, request2, err);
    }
  }
}
function onHttp2SocketClose() {
  const err = this[kError$4] || new SocketError$7("closed", util$E.getSocketInfo(this));
  const client2 = this[kHTTP2Session$1][kClient$6];
  client2[kSocket$2] = null;
  client2[kHTTPContext$4] = null;
  if (this[kHTTP2Session$1] !== null) {
    this[kHTTP2Session$1].destroy(err);
  }
  client2[kPendingIdx$4] = client2[kRunningIdx$4];
  assert$r(client2[kRunning$a] === 0);
  client2.emit("disconnect", client2[kUrl$a], [client2], err);
  client2[kResume$6]();
}
function onHttp2SocketError(err) {
  assert$r(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
  this[kError$4] = err;
  this[kClient$6][kOnError$4](err);
}
function onHttp2SocketEnd() {
  util$E.destroy(this, new SocketError$7("other side closed", util$E.getSocketInfo(this)));
}
function onSocketClose() {
  this[kClosed$3] = true;
}
function shouldSendContentLength$2(method) {
  return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
}
function writeH2$1(client2, request2) {
  const requestTimeout = request2.bodyTimeout ?? client2[kBodyTimeout$3];
  const session = client2[kHTTP2Session$1];
  const { method, path: path2, host, upgrade: upgrade2, expectContinue, signal, headers: reqHeaders } = request2;
  let { body: body2 } = request2;
  if (upgrade2) {
    util$E.errorRequest(client2, request2, new Error("Upgrade not supported for H2"));
    return false;
  }
  const headers2 = {};
  for (let n = 0; n < reqHeaders.length; n += 2) {
    const key = reqHeaders[n + 0];
    const val = reqHeaders[n + 1];
    if (Array.isArray(val)) {
      for (let i = 0; i < val.length; i++) {
        if (headers2[key]) {
          headers2[key] += `,${val[i]}`;
        } else {
          headers2[key] = val[i];
        }
      }
    } else {
      headers2[key] = val;
    }
  }
  let stream2 = null;
  const { hostname, port } = client2[kUrl$a];
  headers2[HTTP2_HEADER_AUTHORITY$1] = host || `${hostname}${port ? `:${port}` : ""}`;
  headers2[HTTP2_HEADER_METHOD$1] = method;
  const abort2 = (err) => {
    if (request2.aborted || request2.completed) {
      return;
    }
    err = err || new RequestAbortedError$f();
    util$E.errorRequest(client2, request2, err);
    if (stream2 != null) {
      stream2.removeAllListeners("data");
      stream2.close();
      client2[kOnError$4](err);
      client2[kResume$6]();
    }
    util$E.destroy(body2, err);
  };
  try {
    request2.onConnect(abort2);
  } catch (err) {
    util$E.errorRequest(client2, request2, err);
  }
  if (request2.aborted) {
    return false;
  }
  if (method === "CONNECT") {
    session.ref();
    stream2 = session.request(headers2, { endStream: false, signal });
    if (!stream2.pending) {
      request2.onUpgrade(null, null, stream2);
      ++session[kOpenStreams$1];
      client2[kQueue$6][client2[kRunningIdx$4]++] = null;
    } else {
      stream2.once("ready", () => {
        request2.onUpgrade(null, null, stream2);
        ++session[kOpenStreams$1];
        client2[kQueue$6][client2[kRunningIdx$4]++] = null;
      });
    }
    stream2.once("close", () => {
      session[kOpenStreams$1] -= 1;
      if (session[kOpenStreams$1] === 0) session.unref();
    });
    stream2.setTimeout(requestTimeout);
    return true;
  }
  headers2[HTTP2_HEADER_PATH$1] = path2;
  headers2[HTTP2_HEADER_SCHEME$1] = "https";
  const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
  if (body2 && typeof body2.read === "function") {
    body2.read(0);
  }
  let contentLength = util$E.bodyLength(body2);
  if (util$E.isFormDataLike(body2)) {
    extractBody$2 ?? (extractBody$2 = requireBody$1().extractBody);
    const [bodyStream, contentType] = extractBody$2(body2);
    headers2["content-type"] = contentType;
    body2 = bodyStream.stream;
    contentLength = bodyStream.length;
  }
  if (contentLength == null) {
    contentLength = request2.contentLength;
  }
  if (contentLength === 0 || !expectsPayload) {
    contentLength = null;
  }
  if (shouldSendContentLength$2(method) && contentLength > 0 && request2.contentLength != null && request2.contentLength !== contentLength) {
    if (client2[kStrictContentLength$4]) {
      util$E.errorRequest(client2, request2, new RequestContentLengthMismatchError$3());
      return false;
    }
    process.emitWarning(new RequestContentLengthMismatchError$3());
  }
  if (contentLength != null) {
    assert$r(body2, "no body must not have content length");
    headers2[HTTP2_HEADER_CONTENT_LENGTH$1] = `${contentLength}`;
  }
  session.ref();
  if (channels$5.sendHeaders.hasSubscribers) {
    let header = "";
    for (const key in headers2) {
      header += `${key}: ${headers2[key]}\r
`;
    }
    channels$5.sendHeaders.publish({ request: request2, headers: header, socket: session[kSocket$2] });
  }
  const shouldEndStream = method === "GET" || method === "HEAD" || body2 === null;
  if (expectContinue) {
    headers2[HTTP2_HEADER_EXPECT$1] = "100-continue";
    stream2 = session.request(headers2, { endStream: shouldEndStream, signal });
    stream2.once("continue", writeBodyH2);
  } else {
    stream2 = session.request(headers2, {
      endStream: shouldEndStream,
      signal
    });
    writeBodyH2();
  }
  ++session[kOpenStreams$1];
  stream2.setTimeout(requestTimeout);
  stream2.once("response", (headers3) => {
    const { [HTTP2_HEADER_STATUS$1]: statusCode, ...realHeaders } = headers3;
    request2.onResponseStarted();
    if (request2.aborted) {
      stream2.removeAllListeners("data");
      return;
    }
    if (request2.onHeaders(Number(statusCode), parseH2Headers$1(realHeaders), stream2.resume.bind(stream2), "") === false) {
      stream2.pause();
    }
  });
  stream2.on("data", (chunk) => {
    if (request2.onData(chunk) === false) {
      stream2.pause();
    }
  });
  stream2.once("end", (err) => {
    var _a2;
    stream2.removeAllListeners("data");
    if (((_a2 = stream2.state) == null ? void 0 : _a2.state) == null || stream2.state.state < 6) {
      if (!request2.aborted && !request2.completed) {
        request2.onComplete({});
      }
      client2[kQueue$6][client2[kRunningIdx$4]++] = null;
      client2[kResume$6]();
    } else {
      --session[kOpenStreams$1];
      if (session[kOpenStreams$1] === 0) {
        session.unref();
      }
      abort2(err ?? new InformationalError$7("HTTP/2: stream half-closed (remote)"));
      client2[kQueue$6][client2[kRunningIdx$4]++] = null;
      client2[kPendingIdx$4] = client2[kRunningIdx$4];
      client2[kResume$6]();
    }
  });
  stream2.once("close", () => {
    stream2.removeAllListeners("data");
    session[kOpenStreams$1] -= 1;
    if (session[kOpenStreams$1] === 0) {
      session.unref();
    }
  });
  stream2.once("error", function(err) {
    stream2.removeAllListeners("data");
    abort2(err);
  });
  stream2.once("frameError", (type, code) => {
    stream2.removeAllListeners("data");
    abort2(new InformationalError$7(`HTTP/2: "frameError" received - type ${type}, code ${code}`));
  });
  stream2.on("aborted", () => {
    stream2.removeAllListeners("data");
  });
  stream2.on("timeout", () => {
    const err = new InformationalError$7(`HTTP/2: "stream timeout after ${requestTimeout}"`);
    stream2.removeAllListeners("data");
    session[kOpenStreams$1] -= 1;
    if (session[kOpenStreams$1] === 0) {
      session.unref();
    }
    abort2(err);
  });
  stream2.once("trailers", (trailers) => {
    if (request2.aborted || request2.completed) {
      return;
    }
    request2.onComplete(trailers);
  });
  return true;
  function writeBodyH2() {
    if (!body2 || contentLength === 0) {
      writeBuffer$2(
        abort2,
        stream2,
        null,
        client2,
        request2,
        client2[kSocket$2],
        contentLength,
        expectsPayload
      );
    } else if (util$E.isBuffer(body2)) {
      writeBuffer$2(
        abort2,
        stream2,
        body2,
        client2,
        request2,
        client2[kSocket$2],
        contentLength,
        expectsPayload
      );
    } else if (util$E.isBlobLike(body2)) {
      if (typeof body2.stream === "function") {
        writeIterable$2(
          abort2,
          stream2,
          body2.stream(),
          client2,
          request2,
          client2[kSocket$2],
          contentLength,
          expectsPayload
        );
      } else {
        writeBlob$2(
          abort2,
          stream2,
          body2,
          client2,
          request2,
          client2[kSocket$2],
          contentLength,
          expectsPayload
        );
      }
    } else if (util$E.isStream(body2)) {
      writeStream$2(
        abort2,
        client2[kSocket$2],
        expectsPayload,
        stream2,
        body2,
        client2,
        request2,
        contentLength
      );
    } else if (util$E.isIterable(body2)) {
      writeIterable$2(
        abort2,
        stream2,
        body2,
        client2,
        request2,
        client2[kSocket$2],
        contentLength,
        expectsPayload
      );
    } else {
      assert$r(false);
    }
  }
}
function writeBuffer$2(abort2, h2stream, body2, client2, request2, socket, contentLength, expectsPayload) {
  try {
    if (body2 != null && util$E.isBuffer(body2)) {
      assert$r(contentLength === body2.byteLength, "buffer body must have content length");
      h2stream.cork();
      h2stream.write(body2);
      h2stream.uncork();
      h2stream.end();
      request2.onBodySent(body2);
    }
    if (!expectsPayload) {
      socket[kReset$2] = true;
    }
    request2.onRequestSent();
    client2[kResume$6]();
  } catch (error) {
    abort2(error);
  }
}
function writeStream$2(abort2, socket, expectsPayload, h2stream, body2, client2, request2, contentLength) {
  assert$r(contentLength !== 0 || client2[kRunning$a] === 0, "stream body cannot be pipelined");
  const pipe = pipeline$3(
    body2,
    h2stream,
    (err) => {
      if (err) {
        util$E.destroy(pipe, err);
        abort2(err);
      } else {
        util$E.removeAllListeners(pipe);
        request2.onRequestSent();
        if (!expectsPayload) {
          socket[kReset$2] = true;
        }
        client2[kResume$6]();
      }
    }
  );
  util$E.addListener(pipe, "data", onPipeData);
  function onPipeData(chunk) {
    request2.onBodySent(chunk);
  }
}
async function writeBlob$2(abort2, h2stream, body2, client2, request2, socket, contentLength, expectsPayload) {
  assert$r(contentLength === body2.size, "blob body must have content length");
  try {
    if (contentLength != null && contentLength !== body2.size) {
      throw new RequestContentLengthMismatchError$3();
    }
    const buffer = Buffer.from(await body2.arrayBuffer());
    h2stream.cork();
    h2stream.write(buffer);
    h2stream.uncork();
    h2stream.end();
    request2.onBodySent(buffer);
    request2.onRequestSent();
    if (!expectsPayload) {
      socket[kReset$2] = true;
    }
    client2[kResume$6]();
  } catch (err) {
    abort2(err);
  }
}
async function writeIterable$2(abort2, h2stream, body2, client2, request2, socket, contentLength, expectsPayload) {
  assert$r(contentLength !== 0 || client2[kRunning$a] === 0, "iterator body cannot be pipelined");
  let callback = null;
  function onDrain() {
    if (callback) {
      const cb = callback;
      callback = null;
      cb();
    }
  }
  const waitForDrain = () => new Promise((resolve2, reject) => {
    assert$r(callback === null);
    if (socket[kError$4]) {
      reject(socket[kError$4]);
    } else {
      callback = resolve2;
    }
  });
  h2stream.on("close", onDrain).on("drain", onDrain);
  try {
    for await (const chunk of body2) {
      if (socket[kError$4]) {
        throw socket[kError$4];
      }
      const res = h2stream.write(chunk);
      request2.onBodySent(chunk);
      if (!res) {
        await waitForDrain();
      }
    }
    h2stream.end();
    request2.onRequestSent();
    if (!expectsPayload) {
      socket[kReset$2] = true;
    }
    client2[kResume$6]();
  } catch (err) {
    abort2(err);
  } finally {
    h2stream.off("close", onDrain).off("drain", onDrain);
  }
}
var clientH2$1 = connectH2$3;
const assert$q = require$$0$3;
const net$4 = require$$0$5;
const http$2 = require$$2$1;
const util$D = util$J;
const { channels: channels$4 } = diagnostics$1;
const Request$2 = request$5;
const DispatcherBase$a = dispatcherBase$1;
const {
  InvalidArgumentError: InvalidArgumentError$J,
  InformationalError: InformationalError$6,
  ClientDestroyedError: ClientDestroyedError$3
} = errors$2;
const buildConnector$7 = connect$6;
const {
  kUrl: kUrl$9,
  kServerName: kServerName$1,
  kClient: kClient$5,
  kBusy: kBusy$3,
  kConnect: kConnect$1,
  kResuming: kResuming$1,
  kRunning: kRunning$9,
  kPending: kPending$7,
  kSize: kSize$9,
  kQueue: kQueue$5,
  kConnected: kConnected$9,
  kConnecting: kConnecting$1,
  kNeedDrain: kNeedDrain$7,
  kKeepAliveDefaultTimeout: kKeepAliveDefaultTimeout$2,
  kHostHeader: kHostHeader$2,
  kPendingIdx: kPendingIdx$3,
  kRunningIdx: kRunningIdx$3,
  kError: kError$3,
  kPipelining: kPipelining$2,
  kKeepAliveTimeoutValue: kKeepAliveTimeoutValue$2,
  kMaxHeadersSize: kMaxHeadersSize$2,
  kKeepAliveMaxTimeout: kKeepAliveMaxTimeout$2,
  kKeepAliveTimeoutThreshold: kKeepAliveTimeoutThreshold$2,
  kHeadersTimeout: kHeadersTimeout$2,
  kBodyTimeout: kBodyTimeout$2,
  kStrictContentLength: kStrictContentLength$3,
  kConnector: kConnector$1,
  kMaxRequests: kMaxRequests$2,
  kCounter: kCounter$2,
  kClose: kClose$e,
  kDestroy: kDestroy$a,
  kDispatch: kDispatch$8,
  kLocalAddress: kLocalAddress$1,
  kMaxResponseSize: kMaxResponseSize$2,
  kOnError: kOnError$3,
  kHTTPContext: kHTTPContext$3,
  kMaxConcurrentStreams: kMaxConcurrentStreams$2,
  kResume: kResume$5
} = symbols$5;
const connectH1$2 = clientH1$1;
const connectH2$2 = clientH2$1;
const kClosedResolve$3 = Symbol("kClosedResolve");
const getDefaultNodeMaxHeaderSize = http$2 && http$2.maxHeaderSize && Number.isInteger(http$2.maxHeaderSize) && http$2.maxHeaderSize > 0 ? () => http$2.maxHeaderSize : () => {
  throw new InvalidArgumentError$J("http module not available or http.maxHeaderSize invalid");
};
const noop$b = () => {
};
function getPipelining$1(client2) {
  var _a2;
  return client2[kPipelining$2] ?? ((_a2 = client2[kHTTPContext$3]) == null ? void 0 : _a2.defaultPipelining) ?? 1;
}
let Client$8 = class Client extends DispatcherBase$a {
  /**
   *
   * @param {string|URL} url
   * @param {import('../../types/client.js').Client.Options} options
   */
  constructor(url, {
    maxHeaderSize,
    headersTimeout,
    socketTimeout,
    requestTimeout,
    connectTimeout,
    bodyTimeout,
    idleTimeout,
    keepAlive,
    keepAliveTimeout,
    maxKeepAliveTimeout,
    keepAliveMaxTimeout,
    keepAliveTimeoutThreshold,
    socketPath,
    pipelining,
    tls: tls2,
    strictContentLength,
    maxCachedSessions,
    connect: connect2,
    maxRequestsPerClient,
    localAddress,
    maxResponseSize,
    autoSelectFamily,
    autoSelectFamilyAttemptTimeout,
    // h2
    maxConcurrentStreams,
    allowH2
  } = {}) {
    if (keepAlive !== void 0) {
      throw new InvalidArgumentError$J("unsupported keepAlive, use pipelining=0 instead");
    }
    if (socketTimeout !== void 0) {
      throw new InvalidArgumentError$J("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
    }
    if (requestTimeout !== void 0) {
      throw new InvalidArgumentError$J("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
    }
    if (idleTimeout !== void 0) {
      throw new InvalidArgumentError$J("unsupported idleTimeout, use keepAliveTimeout instead");
    }
    if (maxKeepAliveTimeout !== void 0) {
      throw new InvalidArgumentError$J("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
    }
    if (maxHeaderSize != null) {
      if (!Number.isInteger(maxHeaderSize) || maxHeaderSize < 1) {
        throw new InvalidArgumentError$J("invalid maxHeaderSize");
      }
    } else {
      maxHeaderSize = getDefaultNodeMaxHeaderSize();
    }
    if (socketPath != null && typeof socketPath !== "string") {
      throw new InvalidArgumentError$J("invalid socketPath");
    }
    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
      throw new InvalidArgumentError$J("invalid connectTimeout");
    }
    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
      throw new InvalidArgumentError$J("invalid keepAliveTimeout");
    }
    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
      throw new InvalidArgumentError$J("invalid keepAliveMaxTimeout");
    }
    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
      throw new InvalidArgumentError$J("invalid keepAliveTimeoutThreshold");
    }
    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
      throw new InvalidArgumentError$J("headersTimeout must be a positive integer or zero");
    }
    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
      throw new InvalidArgumentError$J("bodyTimeout must be a positive integer or zero");
    }
    if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
      throw new InvalidArgumentError$J("connect must be a function or an object");
    }
    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
      throw new InvalidArgumentError$J("maxRequestsPerClient must be a positive number");
    }
    if (localAddress != null && (typeof localAddress !== "string" || net$4.isIP(localAddress) === 0)) {
      throw new InvalidArgumentError$J("localAddress must be valid string IP address");
    }
    if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
      throw new InvalidArgumentError$J("maxResponseSize must be a positive number");
    }
    if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
      throw new InvalidArgumentError$J("autoSelectFamilyAttemptTimeout must be a positive number");
    }
    if (allowH2 != null && typeof allowH2 !== "boolean") {
      throw new InvalidArgumentError$J("allowH2 must be a valid boolean value");
    }
    if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
      throw new InvalidArgumentError$J("maxConcurrentStreams must be a positive integer, greater than 0");
    }
    super();
    if (typeof connect2 !== "function") {
      connect2 = buildConnector$7({
        ...tls2,
        maxCachedSessions,
        allowH2,
        socketPath,
        timeout: connectTimeout,
        ...typeof autoSelectFamily === "boolean" ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
        ...connect2
      });
    }
    this[kUrl$9] = util$D.parseOrigin(url);
    this[kConnector$1] = connect2;
    this[kPipelining$2] = pipelining != null ? pipelining : 1;
    this[kMaxHeadersSize$2] = maxHeaderSize;
    this[kKeepAliveDefaultTimeout$2] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
    this[kKeepAliveMaxTimeout$2] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
    this[kKeepAliveTimeoutThreshold$2] = keepAliveTimeoutThreshold == null ? 2e3 : keepAliveTimeoutThreshold;
    this[kKeepAliveTimeoutValue$2] = this[kKeepAliveDefaultTimeout$2];
    this[kServerName$1] = null;
    this[kLocalAddress$1] = localAddress != null ? localAddress : null;
    this[kResuming$1] = 0;
    this[kNeedDrain$7] = 0;
    this[kHostHeader$2] = `host: ${this[kUrl$9].hostname}${this[kUrl$9].port ? `:${this[kUrl$9].port}` : ""}\r
`;
    this[kBodyTimeout$2] = bodyTimeout != null ? bodyTimeout : 3e5;
    this[kHeadersTimeout$2] = headersTimeout != null ? headersTimeout : 3e5;
    this[kStrictContentLength$3] = strictContentLength == null ? true : strictContentLength;
    this[kMaxRequests$2] = maxRequestsPerClient;
    this[kClosedResolve$3] = null;
    this[kMaxResponseSize$2] = maxResponseSize > -1 ? maxResponseSize : -1;
    this[kMaxConcurrentStreams$2] = maxConcurrentStreams != null ? maxConcurrentStreams : 100;
    this[kHTTPContext$3] = null;
    this[kQueue$5] = [];
    this[kRunningIdx$3] = 0;
    this[kPendingIdx$3] = 0;
    this[kResume$5] = (sync) => resume$2(this, sync);
    this[kOnError$3] = (err) => onError$1(this, err);
  }
  get pipelining() {
    return this[kPipelining$2];
  }
  set pipelining(value) {
    this[kPipelining$2] = value;
    this[kResume$5](true);
  }
  get [kPending$7]() {
    return this[kQueue$5].length - this[kPendingIdx$3];
  }
  get [kRunning$9]() {
    return this[kPendingIdx$3] - this[kRunningIdx$3];
  }
  get [kSize$9]() {
    return this[kQueue$5].length - this[kRunningIdx$3];
  }
  get [kConnected$9]() {
    return !!this[kHTTPContext$3] && !this[kConnecting$1] && !this[kHTTPContext$3].destroyed;
  }
  get [kBusy$3]() {
    var _a2;
    return Boolean(
      ((_a2 = this[kHTTPContext$3]) == null ? void 0 : _a2.busy(null)) || this[kSize$9] >= (getPipelining$1(this) || 1) || this[kPending$7] > 0
    );
  }
  /* istanbul ignore: only used for test */
  [kConnect$1](cb) {
    connect$5(this);
    this.once("connect", cb);
  }
  [kDispatch$8](opts, handler) {
    const origin = opts.origin || this[kUrl$9].origin;
    const request2 = new Request$2(origin, opts, handler);
    this[kQueue$5].push(request2);
    if (this[kResuming$1]) ;
    else if (util$D.bodyLength(request2.body) == null && util$D.isIterable(request2.body)) {
      this[kResuming$1] = 1;
      queueMicrotask(() => resume$2(this));
    } else {
      this[kResume$5](true);
    }
    if (this[kResuming$1] && this[kNeedDrain$7] !== 2 && this[kBusy$3]) {
      this[kNeedDrain$7] = 2;
    }
    return this[kNeedDrain$7] < 2;
  }
  async [kClose$e]() {
    return new Promise((resolve2) => {
      if (this[kSize$9]) {
        this[kClosedResolve$3] = resolve2;
      } else {
        resolve2(null);
      }
    });
  }
  async [kDestroy$a](err) {
    return new Promise((resolve2) => {
      const requests = this[kQueue$5].splice(this[kPendingIdx$3]);
      for (let i = 0; i < requests.length; i++) {
        const request2 = requests[i];
        util$D.errorRequest(this, request2, err);
      }
      const callback = () => {
        if (this[kClosedResolve$3]) {
          this[kClosedResolve$3]();
          this[kClosedResolve$3] = null;
        }
        resolve2(null);
      };
      if (this[kHTTPContext$3]) {
        this[kHTTPContext$3].destroy(err, callback);
        this[kHTTPContext$3] = null;
      } else {
        queueMicrotask(callback);
      }
      this[kResume$5]();
    });
  }
};
function onError$1(client2, err) {
  if (client2[kRunning$9] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
    assert$q(client2[kPendingIdx$3] === client2[kRunningIdx$3]);
    const requests = client2[kQueue$5].splice(client2[kRunningIdx$3]);
    for (let i = 0; i < requests.length; i++) {
      const request2 = requests[i];
      util$D.errorRequest(client2, request2, err);
    }
    assert$q(client2[kSize$9] === 0);
  }
}
async function connect$5(client2) {
  var _a2, _b2, _c2;
  assert$q(!client2[kConnecting$1]);
  assert$q(!client2[kHTTPContext$3]);
  let { host, hostname, protocol, port } = client2[kUrl$9];
  if (hostname[0] === "[") {
    const idx = hostname.indexOf("]");
    assert$q(idx !== -1);
    const ip = hostname.substring(1, idx);
    assert$q(net$4.isIPv6(ip));
    hostname = ip;
  }
  client2[kConnecting$1] = true;
  if (channels$4.beforeConnect.hasSubscribers) {
    channels$4.beforeConnect.publish({
      connectParams: {
        host,
        hostname,
        protocol,
        port,
        version: (_a2 = client2[kHTTPContext$3]) == null ? void 0 : _a2.version,
        servername: client2[kServerName$1],
        localAddress: client2[kLocalAddress$1]
      },
      connector: client2[kConnector$1]
    });
  }
  try {
    const socket = await new Promise((resolve2, reject) => {
      client2[kConnector$1]({
        host,
        hostname,
        protocol,
        port,
        servername: client2[kServerName$1],
        localAddress: client2[kLocalAddress$1]
      }, (err, socket2) => {
        if (err) {
          reject(err);
        } else {
          resolve2(socket2);
        }
      });
    });
    if (client2.destroyed) {
      util$D.destroy(socket.on("error", noop$b), new ClientDestroyedError$3());
      return;
    }
    assert$q(socket);
    try {
      client2[kHTTPContext$3] = socket.alpnProtocol === "h2" ? await connectH2$2(client2, socket) : await connectH1$2(client2, socket);
    } catch (err) {
      socket.destroy().on("error", noop$b);
      throw err;
    }
    client2[kConnecting$1] = false;
    socket[kCounter$2] = 0;
    socket[kMaxRequests$2] = client2[kMaxRequests$2];
    socket[kClient$5] = client2;
    socket[kError$3] = null;
    if (channels$4.connected.hasSubscribers) {
      channels$4.connected.publish({
        connectParams: {
          host,
          hostname,
          protocol,
          port,
          version: (_b2 = client2[kHTTPContext$3]) == null ? void 0 : _b2.version,
          servername: client2[kServerName$1],
          localAddress: client2[kLocalAddress$1]
        },
        connector: client2[kConnector$1],
        socket
      });
    }
    client2.emit("connect", client2[kUrl$9], [client2]);
  } catch (err) {
    if (client2.destroyed) {
      return;
    }
    client2[kConnecting$1] = false;
    if (channels$4.connectError.hasSubscribers) {
      channels$4.connectError.publish({
        connectParams: {
          host,
          hostname,
          protocol,
          port,
          version: (_c2 = client2[kHTTPContext$3]) == null ? void 0 : _c2.version,
          servername: client2[kServerName$1],
          localAddress: client2[kLocalAddress$1]
        },
        connector: client2[kConnector$1],
        error: err
      });
    }
    if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
      assert$q(client2[kRunning$9] === 0);
      while (client2[kPending$7] > 0 && client2[kQueue$5][client2[kPendingIdx$3]].servername === client2[kServerName$1]) {
        const request2 = client2[kQueue$5][client2[kPendingIdx$3]++];
        util$D.errorRequest(client2, request2, err);
      }
    } else {
      onError$1(client2, err);
    }
    client2.emit("connectionError", client2[kUrl$9], [client2], err);
  }
  client2[kResume$5]();
}
function emitDrain$1(client2) {
  client2[kNeedDrain$7] = 0;
  client2.emit("drain", client2[kUrl$9], [client2]);
}
function resume$2(client2, sync) {
  if (client2[kResuming$1] === 2) {
    return;
  }
  client2[kResuming$1] = 2;
  _resume$1(client2, sync);
  client2[kResuming$1] = 0;
  if (client2[kRunningIdx$3] > 256) {
    client2[kQueue$5].splice(0, client2[kRunningIdx$3]);
    client2[kPendingIdx$3] -= client2[kRunningIdx$3];
    client2[kRunningIdx$3] = 0;
  }
}
function _resume$1(client2, sync) {
  var _a2;
  while (true) {
    if (client2.destroyed) {
      assert$q(client2[kPending$7] === 0);
      return;
    }
    if (client2[kClosedResolve$3] && !client2[kSize$9]) {
      client2[kClosedResolve$3]();
      client2[kClosedResolve$3] = null;
      return;
    }
    if (client2[kHTTPContext$3]) {
      client2[kHTTPContext$3].resume();
    }
    if (client2[kBusy$3]) {
      client2[kNeedDrain$7] = 2;
    } else if (client2[kNeedDrain$7] === 2) {
      if (sync) {
        client2[kNeedDrain$7] = 1;
        queueMicrotask(() => emitDrain$1(client2));
      } else {
        emitDrain$1(client2);
      }
      continue;
    }
    if (client2[kPending$7] === 0) {
      return;
    }
    if (client2[kRunning$9] >= (getPipelining$1(client2) || 1)) {
      return;
    }
    const request2 = client2[kQueue$5][client2[kPendingIdx$3]];
    if (client2[kUrl$9].protocol === "https:" && client2[kServerName$1] !== request2.servername) {
      if (client2[kRunning$9] > 0) {
        return;
      }
      client2[kServerName$1] = request2.servername;
      (_a2 = client2[kHTTPContext$3]) == null ? void 0 : _a2.destroy(new InformationalError$6("servername changed"), () => {
        client2[kHTTPContext$3] = null;
        resume$2(client2);
      });
    }
    if (client2[kConnecting$1]) {
      return;
    }
    if (!client2[kHTTPContext$3]) {
      connect$5(client2);
      return;
    }
    if (client2[kHTTPContext$3].destroyed) {
      return;
    }
    if (client2[kHTTPContext$3].busy(request2)) {
      return;
    }
    if (!request2.aborted && client2[kHTTPContext$3].write(request2)) {
      client2[kPendingIdx$3]++;
    } else {
      client2[kQueue$5].splice(client2[kPendingIdx$3], 1);
    }
  }
}
var client$1 = Client$8;
const kSize$8 = 2048;
const kMask$1 = kSize$8 - 1;
let FixedCircularBuffer$1 = class FixedCircularBuffer {
  constructor() {
    this.bottom = 0;
    this.top = 0;
    this.list = new Array(kSize$8).fill(void 0);
    this.next = null;
  }
  /**
   * @returns {boolean}
   */
  isEmpty() {
    return this.top === this.bottom;
  }
  /**
   * @returns {boolean}
   */
  isFull() {
    return (this.top + 1 & kMask$1) === this.bottom;
  }
  /**
   * @param {T} data
   * @returns {void}
   */
  push(data) {
    this.list[this.top] = data;
    this.top = this.top + 1 & kMask$1;
  }
  /**
   * @returns {T|null}
   */
  shift() {
    const nextItem = this.list[this.bottom];
    if (nextItem === void 0) {
      return null;
    }
    this.list[this.bottom] = void 0;
    this.bottom = this.bottom + 1 & kMask$1;
    return nextItem;
  }
};
var fixedQueue$1 = class FixedQueue {
  constructor() {
    this.head = this.tail = new FixedCircularBuffer$1();
  }
  /**
   * @returns {boolean}
   */
  isEmpty() {
    return this.head.isEmpty();
  }
  /**
   * @param {T} data
   */
  push(data) {
    if (this.head.isFull()) {
      this.head = this.head.next = new FixedCircularBuffer$1();
    }
    this.head.push(data);
  }
  /**
   * @returns {T|null}
   */
  shift() {
    const tail = this.tail;
    const next = tail.shift();
    if (tail.isEmpty() && tail.next !== null) {
      this.tail = tail.next;
      tail.next = null;
    }
    return next;
  }
};
const { kFree: kFree$3, kConnected: kConnected$8, kPending: kPending$6, kQueued: kQueued$3, kRunning: kRunning$8, kSize: kSize$7 } = symbols$5;
const kPool$1 = Symbol("pool");
let PoolStats$3 = class PoolStats {
  constructor(pool2) {
    this[kPool$1] = pool2;
  }
  get connected() {
    return this[kPool$1][kConnected$8];
  }
  get free() {
    return this[kPool$1][kFree$3];
  }
  get pending() {
    return this[kPool$1][kPending$6];
  }
  get queued() {
    return this[kPool$1][kQueued$3];
  }
  get running() {
    return this[kPool$1][kRunning$8];
  }
  get size() {
    return this[kPool$1][kSize$7];
  }
};
var poolStats$1 = PoolStats$3;
const DispatcherBase$9 = dispatcherBase$1;
const FixedQueue$1 = fixedQueue$1;
const { kConnected: kConnected$7, kSize: kSize$6, kRunning: kRunning$7, kPending: kPending$5, kQueued: kQueued$2, kBusy: kBusy$2, kFree: kFree$2, kUrl: kUrl$8, kClose: kClose$d, kDestroy: kDestroy$9, kDispatch: kDispatch$7 } = symbols$5;
const PoolStats$2 = poolStats$1;
const kClients$9 = Symbol("clients");
const kNeedDrain$6 = Symbol("needDrain");
const kQueue$4 = Symbol("queue");
const kClosedResolve$2 = Symbol("closed resolve");
const kOnDrain$3 = Symbol("onDrain");
const kOnConnect$3 = Symbol("onConnect");
const kOnDisconnect$3 = Symbol("onDisconnect");
const kOnConnectionError$3 = Symbol("onConnectionError");
const kGetDispatcher$5 = Symbol("get dispatcher");
const kAddClient$5 = Symbol("add client");
const kRemoveClient$3 = Symbol("remove client");
const kStats$1 = Symbol("stats");
let PoolBase$5 = class PoolBase extends DispatcherBase$9 {
  constructor() {
    super();
    this[kQueue$4] = new FixedQueue$1();
    this[kClients$9] = [];
    this[kQueued$2] = 0;
    const pool2 = this;
    this[kOnDrain$3] = function onDrain(origin, targets) {
      const queue2 = pool2[kQueue$4];
      let needDrain = false;
      while (!needDrain) {
        const item = queue2.shift();
        if (!item) {
          break;
        }
        pool2[kQueued$2]--;
        needDrain = !this.dispatch(item.opts, item.handler);
      }
      this[kNeedDrain$6] = needDrain;
      if (!this[kNeedDrain$6] && pool2[kNeedDrain$6]) {
        pool2[kNeedDrain$6] = false;
        pool2.emit("drain", origin, [pool2, ...targets]);
      }
      if (pool2[kClosedResolve$2] && queue2.isEmpty()) {
        Promise.all(pool2[kClients$9].map((c) => c.close())).then(pool2[kClosedResolve$2]);
      }
    };
    this[kOnConnect$3] = (origin, targets) => {
      pool2.emit("connect", origin, [pool2, ...targets]);
    };
    this[kOnDisconnect$3] = (origin, targets, err) => {
      pool2.emit("disconnect", origin, [pool2, ...targets], err);
    };
    this[kOnConnectionError$3] = (origin, targets, err) => {
      pool2.emit("connectionError", origin, [pool2, ...targets], err);
    };
    this[kStats$1] = new PoolStats$2(this);
  }
  get [kBusy$2]() {
    return this[kNeedDrain$6];
  }
  get [kConnected$7]() {
    return this[kClients$9].filter((client2) => client2[kConnected$7]).length;
  }
  get [kFree$2]() {
    return this[kClients$9].filter((client2) => client2[kConnected$7] && !client2[kNeedDrain$6]).length;
  }
  get [kPending$5]() {
    let ret = this[kQueued$2];
    for (const { [kPending$5]: pending } of this[kClients$9]) {
      ret += pending;
    }
    return ret;
  }
  get [kRunning$7]() {
    let ret = 0;
    for (const { [kRunning$7]: running } of this[kClients$9]) {
      ret += running;
    }
    return ret;
  }
  get [kSize$6]() {
    let ret = this[kQueued$2];
    for (const { [kSize$6]: size } of this[kClients$9]) {
      ret += size;
    }
    return ret;
  }
  get stats() {
    return this[kStats$1];
  }
  async [kClose$d]() {
    if (this[kQueue$4].isEmpty()) {
      await Promise.all(this[kClients$9].map((c) => c.close()));
    } else {
      await new Promise((resolve2) => {
        this[kClosedResolve$2] = resolve2;
      });
    }
  }
  async [kDestroy$9](err) {
    while (true) {
      const item = this[kQueue$4].shift();
      if (!item) {
        break;
      }
      item.handler.onError(err);
    }
    await Promise.all(this[kClients$9].map((c) => c.destroy(err)));
  }
  [kDispatch$7](opts, handler) {
    const dispatcher2 = this[kGetDispatcher$5]();
    if (!dispatcher2) {
      this[kNeedDrain$6] = true;
      this[kQueue$4].push({ opts, handler });
      this[kQueued$2]++;
    } else if (!dispatcher2.dispatch(opts, handler)) {
      dispatcher2[kNeedDrain$6] = true;
      this[kNeedDrain$6] = !this[kGetDispatcher$5]();
    }
    return !this[kNeedDrain$6];
  }
  [kAddClient$5](client2) {
    client2.on("drain", this[kOnDrain$3]).on("connect", this[kOnConnect$3]).on("disconnect", this[kOnDisconnect$3]).on("connectionError", this[kOnConnectionError$3]);
    this[kClients$9].push(client2);
    if (this[kNeedDrain$6]) {
      queueMicrotask(() => {
        if (this[kNeedDrain$6]) {
          this[kOnDrain$3](client2[kUrl$8], [this, client2]);
        }
      });
    }
    return this;
  }
  [kRemoveClient$3](client2) {
    client2.close(() => {
      const idx = this[kClients$9].indexOf(client2);
      if (idx !== -1) {
        this[kClients$9].splice(idx, 1);
      }
    });
    this[kNeedDrain$6] = this[kClients$9].some((dispatcher2) => !dispatcher2[kNeedDrain$6] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
  }
};
var poolBase$1 = {
  PoolBase: PoolBase$5,
  kClients: kClients$9,
  kNeedDrain: kNeedDrain$6,
  kAddClient: kAddClient$5,
  kRemoveClient: kRemoveClient$3,
  kGetDispatcher: kGetDispatcher$5
};
const {
  PoolBase: PoolBase$4,
  kClients: kClients$8,
  kNeedDrain: kNeedDrain$5,
  kAddClient: kAddClient$4,
  kGetDispatcher: kGetDispatcher$4
} = poolBase$1;
const Client$7 = client$1;
const {
  InvalidArgumentError: InvalidArgumentError$I
} = errors$2;
const util$C = util$J;
const { kUrl: kUrl$7 } = symbols$5;
const buildConnector$6 = connect$6;
const kOptions$7 = Symbol("options");
const kConnections$1 = Symbol("connections");
const kFactory$7 = Symbol("factory");
function defaultFactory$7(origin, opts) {
  return new Client$7(origin, opts);
}
let Pool$a = class Pool extends PoolBase$4 {
  constructor(origin, {
    connections,
    factory = defaultFactory$7,
    connect: connect2,
    connectTimeout,
    tls: tls2,
    maxCachedSessions,
    socketPath,
    autoSelectFamily,
    autoSelectFamilyAttemptTimeout,
    allowH2,
    ...options
  } = {}) {
    if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
      throw new InvalidArgumentError$I("invalid connections");
    }
    if (typeof factory !== "function") {
      throw new InvalidArgumentError$I("factory must be a function.");
    }
    if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
      throw new InvalidArgumentError$I("connect must be a function or an object");
    }
    super();
    if (typeof connect2 !== "function") {
      connect2 = buildConnector$6({
        ...tls2,
        maxCachedSessions,
        allowH2,
        socketPath,
        timeout: connectTimeout,
        ...typeof autoSelectFamily === "boolean" ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
        ...connect2
      });
    }
    this[kConnections$1] = connections || null;
    this[kUrl$7] = util$C.parseOrigin(origin);
    this[kOptions$7] = { ...util$C.deepClone(options), connect: connect2, allowH2 };
    this[kOptions$7].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
    this[kFactory$7] = factory;
    this.on("connectionError", (origin2, targets, error) => {
      for (const target of targets) {
        const idx = this[kClients$8].indexOf(target);
        if (idx !== -1) {
          this[kClients$8].splice(idx, 1);
        }
      }
    });
  }
  [kGetDispatcher$4]() {
    for (const client2 of this[kClients$8]) {
      if (!client2[kNeedDrain$5]) {
        return client2;
      }
    }
    if (!this[kConnections$1] || this[kClients$8].length < this[kConnections$1]) {
      const dispatcher2 = this[kFactory$7](this[kUrl$7], this[kOptions$7]);
      this[kAddClient$4](dispatcher2);
      return dispatcher2;
    }
  }
};
var pool$1 = Pool$a;
const {
  BalancedPoolMissingUpstreamError: BalancedPoolMissingUpstreamError$2,
  InvalidArgumentError: InvalidArgumentError$H
} = errors$2;
const {
  PoolBase: PoolBase$3,
  kClients: kClients$7,
  kNeedDrain: kNeedDrain$4,
  kAddClient: kAddClient$3,
  kRemoveClient: kRemoveClient$2,
  kGetDispatcher: kGetDispatcher$3
} = poolBase$1;
const Pool$9 = pool$1;
const { kUrl: kUrl$6 } = symbols$5;
const { parseOrigin: parseOrigin$2 } = util$J;
const kFactory$6 = Symbol("factory");
const kOptions$6 = Symbol("options");
const kGreatestCommonDivisor$1 = Symbol("kGreatestCommonDivisor");
const kCurrentWeight$1 = Symbol("kCurrentWeight");
const kIndex$1 = Symbol("kIndex");
const kWeight$1 = Symbol("kWeight");
const kMaxWeightPerServer$1 = Symbol("kMaxWeightPerServer");
const kErrorPenalty$1 = Symbol("kErrorPenalty");
function getGreatestCommonDivisor$1(a, b) {
  if (a === 0) return b;
  while (b !== 0) {
    const t = b;
    b = a % b;
    a = t;
  }
  return a;
}
function defaultFactory$6(origin, opts) {
  return new Pool$9(origin, opts);
}
let BalancedPool$2 = class BalancedPool extends PoolBase$3 {
  constructor(upstreams = [], { factory = defaultFactory$6, ...opts } = {}) {
    if (typeof factory !== "function") {
      throw new InvalidArgumentError$H("factory must be a function.");
    }
    super();
    this[kOptions$6] = opts;
    this[kIndex$1] = -1;
    this[kCurrentWeight$1] = 0;
    this[kMaxWeightPerServer$1] = this[kOptions$6].maxWeightPerServer || 100;
    this[kErrorPenalty$1] = this[kOptions$6].errorPenalty || 15;
    if (!Array.isArray(upstreams)) {
      upstreams = [upstreams];
    }
    this[kFactory$6] = factory;
    for (const upstream of upstreams) {
      this.addUpstream(upstream);
    }
    this._updateBalancedPoolStats();
  }
  addUpstream(upstream) {
    const upstreamOrigin = parseOrigin$2(upstream).origin;
    if (this[kClients$7].find((pool3) => pool3[kUrl$6].origin === upstreamOrigin && pool3.closed !== true && pool3.destroyed !== true)) {
      return this;
    }
    const pool2 = this[kFactory$6](upstreamOrigin, Object.assign({}, this[kOptions$6]));
    this[kAddClient$3](pool2);
    pool2.on("connect", () => {
      pool2[kWeight$1] = Math.min(this[kMaxWeightPerServer$1], pool2[kWeight$1] + this[kErrorPenalty$1]);
    });
    pool2.on("connectionError", () => {
      pool2[kWeight$1] = Math.max(1, pool2[kWeight$1] - this[kErrorPenalty$1]);
      this._updateBalancedPoolStats();
    });
    pool2.on("disconnect", (...args) => {
      const err = args[2];
      if (err && err.code === "UND_ERR_SOCKET") {
        pool2[kWeight$1] = Math.max(1, pool2[kWeight$1] - this[kErrorPenalty$1]);
        this._updateBalancedPoolStats();
      }
    });
    for (const client2 of this[kClients$7]) {
      client2[kWeight$1] = this[kMaxWeightPerServer$1];
    }
    this._updateBalancedPoolStats();
    return this;
  }
  _updateBalancedPoolStats() {
    let result = 0;
    for (let i = 0; i < this[kClients$7].length; i++) {
      result = getGreatestCommonDivisor$1(this[kClients$7][i][kWeight$1], result);
    }
    this[kGreatestCommonDivisor$1] = result;
  }
  removeUpstream(upstream) {
    const upstreamOrigin = parseOrigin$2(upstream).origin;
    const pool2 = this[kClients$7].find((pool3) => pool3[kUrl$6].origin === upstreamOrigin && pool3.closed !== true && pool3.destroyed !== true);
    if (pool2) {
      this[kRemoveClient$2](pool2);
    }
    return this;
  }
  get upstreams() {
    return this[kClients$7].filter((dispatcher2) => dispatcher2.closed !== true && dispatcher2.destroyed !== true).map((p) => p[kUrl$6].origin);
  }
  [kGetDispatcher$3]() {
    if (this[kClients$7].length === 0) {
      throw new BalancedPoolMissingUpstreamError$2();
    }
    const dispatcher2 = this[kClients$7].find((dispatcher3) => !dispatcher3[kNeedDrain$4] && dispatcher3.closed !== true && dispatcher3.destroyed !== true);
    if (!dispatcher2) {
      return;
    }
    const allClientsBusy = this[kClients$7].map((pool2) => pool2[kNeedDrain$4]).reduce((a, b) => a && b, true);
    if (allClientsBusy) {
      return;
    }
    let counter = 0;
    let maxWeightIndex = this[kClients$7].findIndex((pool2) => !pool2[kNeedDrain$4]);
    while (counter++ < this[kClients$7].length) {
      this[kIndex$1] = (this[kIndex$1] + 1) % this[kClients$7].length;
      const pool2 = this[kClients$7][this[kIndex$1]];
      if (pool2[kWeight$1] > this[kClients$7][maxWeightIndex][kWeight$1] && !pool2[kNeedDrain$4]) {
        maxWeightIndex = this[kIndex$1];
      }
      if (this[kIndex$1] === 0) {
        this[kCurrentWeight$1] = this[kCurrentWeight$1] - this[kGreatestCommonDivisor$1];
        if (this[kCurrentWeight$1] <= 0) {
          this[kCurrentWeight$1] = this[kMaxWeightPerServer$1];
        }
      }
      if (pool2[kWeight$1] >= this[kCurrentWeight$1] && !pool2[kNeedDrain$4]) {
        return pool2;
      }
    }
    this[kCurrentWeight$1] = this[kClients$7][maxWeightIndex][kWeight$1];
    this[kIndex$1] = maxWeightIndex;
    return this[kClients$7][maxWeightIndex];
  }
};
var balancedPool$1 = BalancedPool$2;
const { InvalidArgumentError: InvalidArgumentError$G } = errors$2;
const { kClients: kClients$6, kRunning: kRunning$6, kClose: kClose$c, kDestroy: kDestroy$8, kDispatch: kDispatch$6 } = symbols$5;
const DispatcherBase$8 = dispatcherBase$1;
const Pool$8 = pool$1;
const Client$6 = client$1;
const util$B = util$J;
const kOnConnect$2 = Symbol("onConnect");
const kOnDisconnect$2 = Symbol("onDisconnect");
const kOnConnectionError$2 = Symbol("onConnectionError");
const kOnDrain$2 = Symbol("onDrain");
const kFactory$5 = Symbol("factory");
const kOptions$5 = Symbol("options");
function defaultFactory$5(origin, opts) {
  return opts && opts.connections === 1 ? new Client$6(origin, opts) : new Pool$8(origin, opts);
}
let Agent$a = class Agent extends DispatcherBase$8 {
  constructor({ factory = defaultFactory$5, connect: connect2, ...options } = {}) {
    if (typeof factory !== "function") {
      throw new InvalidArgumentError$G("factory must be a function.");
    }
    if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
      throw new InvalidArgumentError$G("connect must be a function or an object");
    }
    super();
    if (connect2 && typeof connect2 !== "function") {
      connect2 = { ...connect2 };
    }
    this[kOptions$5] = { ...util$B.deepClone(options), connect: connect2 };
    this[kFactory$5] = factory;
    this[kClients$6] = /* @__PURE__ */ new Map();
    this[kOnDrain$2] = (origin, targets) => {
      this.emit("drain", origin, [this, ...targets]);
    };
    this[kOnConnect$2] = (origin, targets) => {
      this.emit("connect", origin, [this, ...targets]);
    };
    this[kOnDisconnect$2] = (origin, targets, err) => {
      this.emit("disconnect", origin, [this, ...targets], err);
    };
    this[kOnConnectionError$2] = (origin, targets, err) => {
      this.emit("connectionError", origin, [this, ...targets], err);
    };
  }
  get [kRunning$6]() {
    let ret = 0;
    for (const client2 of this[kClients$6].values()) {
      ret += client2[kRunning$6];
    }
    return ret;
  }
  [kDispatch$6](opts, handler) {
    let key;
    if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
      key = String(opts.origin);
    } else {
      throw new InvalidArgumentError$G("opts.origin must be a non-empty string or URL.");
    }
    let dispatcher2 = this[kClients$6].get(key);
    if (!dispatcher2) {
      dispatcher2 = this[kFactory$5](opts.origin, this[kOptions$5]).on("drain", this[kOnDrain$2]).on("connect", this[kOnConnect$2]).on("disconnect", this[kOnDisconnect$2]).on("connectionError", this[kOnConnectionError$2]);
      this[kClients$6].set(key, dispatcher2);
    }
    return dispatcher2.dispatch(opts, handler);
  }
  async [kClose$c]() {
    const closePromises = [];
    for (const client2 of this[kClients$6].values()) {
      closePromises.push(client2.close());
    }
    this[kClients$6].clear();
    await Promise.all(closePromises);
  }
  async [kDestroy$8](err) {
    const destroyPromises = [];
    for (const client2 of this[kClients$6].values()) {
      destroyPromises.push(client2.destroy(err));
    }
    this[kClients$6].clear();
    await Promise.all(destroyPromises);
  }
};
var agent$3 = Agent$a;
const { kProxy: kProxy$1, kClose: kClose$b, kDestroy: kDestroy$7 } = symbols$5;
const { URL: URL$2 } = require$$1$3;
const Agent$9 = agent$3;
const Pool$7 = pool$1;
const DispatcherBase$7 = dispatcherBase$1;
const { InvalidArgumentError: InvalidArgumentError$F, RequestAbortedError: RequestAbortedError$e, SecureProxyConnectionError: SecureProxyConnectionError$2 } = errors$2;
const buildConnector$5 = connect$6;
const kAgent$3 = Symbol("proxy agent");
const kClient$4 = Symbol("proxy client");
const kProxyHeaders$1 = Symbol("proxy headers");
const kRequestTls$1 = Symbol("request tls settings");
const kProxyTls$1 = Symbol("proxy tls settings");
const kConnectEndpoint$1 = Symbol("connect endpoint function");
function defaultProtocolPort$1(protocol) {
  return protocol === "https:" ? 443 : 80;
}
function defaultFactory$4(origin, opts) {
  return new Pool$7(origin, opts);
}
const noop$a = () => {
};
let ProxyAgent$5 = (_e = class extends DispatcherBase$7 {
  constructor(opts) {
    if (!opts || typeof opts === "object" && !(opts instanceof URL$2) && !opts.uri) {
      throw new InvalidArgumentError$F("Proxy uri is mandatory");
    }
    const { clientFactory = defaultFactory$4 } = opts;
    if (typeof clientFactory !== "function") {
      throw new InvalidArgumentError$F("Proxy opts.clientFactory must be a function.");
    }
    super();
    __privateAdd(this, _ProxyAgent_instances);
    const url = __privateMethod(this, _ProxyAgent_instances, getUrl_fn).call(this, opts);
    const { href, origin, port, protocol, username, password, hostname: proxyHostname } = url;
    this[kProxy$1] = { uri: href, protocol };
    this[kRequestTls$1] = opts.requestTls;
    this[kProxyTls$1] = opts.proxyTls;
    this[kProxyHeaders$1] = opts.headers || {};
    if (opts.auth && opts.token) {
      throw new InvalidArgumentError$F("opts.auth cannot be used in combination with opts.token");
    } else if (opts.auth) {
      this[kProxyHeaders$1]["proxy-authorization"] = `Basic ${opts.auth}`;
    } else if (opts.token) {
      this[kProxyHeaders$1]["proxy-authorization"] = opts.token;
    } else if (username && password) {
      this[kProxyHeaders$1]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
    }
    const connect2 = buildConnector$5({ ...opts.proxyTls });
    this[kConnectEndpoint$1] = buildConnector$5({ ...opts.requestTls });
    this[kClient$4] = clientFactory(url, { connect: connect2 });
    this[kAgent$3] = new Agent$9({
      ...opts,
      connect: async (opts2, callback) => {
        var _a2;
        let requestedPath = opts2.host;
        if (!opts2.port) {
          requestedPath += `:${defaultProtocolPort$1(opts2.protocol)}`;
        }
        try {
          const { socket, statusCode } = await this[kClient$4].connect({
            origin,
            port,
            path: requestedPath,
            signal: opts2.signal,
            headers: {
              ...this[kProxyHeaders$1],
              host: opts2.host
            },
            servername: ((_a2 = this[kProxyTls$1]) == null ? void 0 : _a2.servername) || proxyHostname
          });
          if (statusCode !== 200) {
            socket.on("error", noop$a).destroy();
            callback(new RequestAbortedError$e(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
          }
          if (opts2.protocol !== "https:") {
            callback(null, socket);
            return;
          }
          let servername;
          if (this[kRequestTls$1]) {
            servername = this[kRequestTls$1].servername;
          } else {
            servername = opts2.servername;
          }
          this[kConnectEndpoint$1]({ ...opts2, servername, httpSocket: socket }, callback);
        } catch (err) {
          if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
            callback(new SecureProxyConnectionError$2(err));
          } else {
            callback(err);
          }
        }
      }
    });
  }
  dispatch(opts, handler) {
    const headers2 = buildHeaders$1(opts.headers);
    throwIfProxyAuthIsSent$1(headers2);
    if (headers2 && !("host" in headers2) && !("Host" in headers2)) {
      const { host } = new URL$2(opts.origin);
      headers2.host = host;
    }
    return this[kAgent$3].dispatch(
      {
        ...opts,
        headers: headers2
      },
      handler
    );
  }
  async [kClose$b]() {
    await this[kAgent$3].close();
    await this[kClient$4].close();
  }
  async [kDestroy$7]() {
    await this[kAgent$3].destroy();
    await this[kClient$4].destroy();
  }
}, _ProxyAgent_instances = new WeakSet(), /**
 * @param {import('../types/proxy-agent').ProxyAgent.Options | string | URL} opts
 * @returns {URL}
 */
getUrl_fn = function(opts) {
  if (typeof opts === "string") {
    return new URL$2(opts);
  } else if (opts instanceof URL$2) {
    return opts;
  } else {
    return new URL$2(opts.uri);
  }
}, _e);
function buildHeaders$1(headers2) {
  if (Array.isArray(headers2)) {
    const headersPair = {};
    for (let i = 0; i < headers2.length; i += 2) {
      headersPair[headers2[i]] = headers2[i + 1];
    }
    return headersPair;
  }
  return headers2;
}
function throwIfProxyAuthIsSent$1(headers2) {
  const existProxyAuth = headers2 && Object.keys(headers2).find((key) => key.toLowerCase() === "proxy-authorization");
  if (existProxyAuth) {
    throw new InvalidArgumentError$F("Proxy-Authorization should be sent in ProxyAgent constructor");
  }
}
var proxyAgent$1 = ProxyAgent$5;
const DispatcherBase$6 = dispatcherBase$1;
const { kClose: kClose$a, kDestroy: kDestroy$6, kClosed: kClosed$2, kDestroyed: kDestroyed$3, kDispatch: kDispatch$5, kNoProxyAgent: kNoProxyAgent$1, kHttpProxyAgent: kHttpProxyAgent$1, kHttpsProxyAgent: kHttpsProxyAgent$1 } = symbols$5;
const ProxyAgent$4 = proxyAgent$1;
const Agent$8 = agent$3;
const DEFAULT_PORTS$1 = {
  "http:": 80,
  "https:": 443
};
let EnvHttpProxyAgent$2 = (_f = class extends DispatcherBase$6 {
  constructor(opts = {}) {
    super();
    __privateAdd(this, _EnvHttpProxyAgent_instances);
    __privateAdd(this, _noProxyValue, null);
    __privateAdd(this, _noProxyEntries, null);
    __privateAdd(this, _opts, null);
    __privateSet(this, _opts, opts);
    const { httpProxy, httpsProxy, noProxy, ...agentOpts } = opts;
    this[kNoProxyAgent$1] = new Agent$8(agentOpts);
    const HTTP_PROXY = httpProxy ?? process.env.http_proxy ?? process.env.HTTP_PROXY;
    if (HTTP_PROXY) {
      this[kHttpProxyAgent$1] = new ProxyAgent$4({ ...agentOpts, uri: HTTP_PROXY });
    } else {
      this[kHttpProxyAgent$1] = this[kNoProxyAgent$1];
    }
    const HTTPS_PROXY = httpsProxy ?? process.env.https_proxy ?? process.env.HTTPS_PROXY;
    if (HTTPS_PROXY) {
      this[kHttpsProxyAgent$1] = new ProxyAgent$4({ ...agentOpts, uri: HTTPS_PROXY });
    } else {
      this[kHttpsProxyAgent$1] = this[kHttpProxyAgent$1];
    }
    __privateMethod(this, _EnvHttpProxyAgent_instances, parseNoProxy_fn).call(this);
  }
  [kDispatch$5](opts, handler) {
    const url = new URL(opts.origin);
    const agent2 = __privateMethod(this, _EnvHttpProxyAgent_instances, getProxyAgentForUrl_fn).call(this, url);
    return agent2.dispatch(opts, handler);
  }
  async [kClose$a]() {
    await this[kNoProxyAgent$1].close();
    if (!this[kHttpProxyAgent$1][kClosed$2]) {
      await this[kHttpProxyAgent$1].close();
    }
    if (!this[kHttpsProxyAgent$1][kClosed$2]) {
      await this[kHttpsProxyAgent$1].close();
    }
  }
  async [kDestroy$6](err) {
    await this[kNoProxyAgent$1].destroy(err);
    if (!this[kHttpProxyAgent$1][kDestroyed$3]) {
      await this[kHttpProxyAgent$1].destroy(err);
    }
    if (!this[kHttpsProxyAgent$1][kDestroyed$3]) {
      await this[kHttpsProxyAgent$1].destroy(err);
    }
  }
}, _noProxyValue = new WeakMap(), _noProxyEntries = new WeakMap(), _opts = new WeakMap(), _EnvHttpProxyAgent_instances = new WeakSet(), getProxyAgentForUrl_fn = function(url) {
  let { protocol, host: hostname, port } = url;
  hostname = hostname.replace(/:\d*$/, "").toLowerCase();
  port = Number.parseInt(port, 10) || DEFAULT_PORTS$1[protocol] || 0;
  if (!__privateMethod(this, _EnvHttpProxyAgent_instances, shouldProxy_fn).call(this, hostname, port)) {
    return this[kNoProxyAgent$1];
  }
  if (protocol === "https:") {
    return this[kHttpsProxyAgent$1];
  }
  return this[kHttpProxyAgent$1];
}, shouldProxy_fn = function(hostname, port) {
  if (__privateGet(this, _EnvHttpProxyAgent_instances, noProxyChanged_get)) {
    __privateMethod(this, _EnvHttpProxyAgent_instances, parseNoProxy_fn).call(this);
  }
  if (__privateGet(this, _noProxyEntries).length === 0) {
    return true;
  }
  if (__privateGet(this, _noProxyValue) === "*") {
    return false;
  }
  for (let i = 0; i < __privateGet(this, _noProxyEntries).length; i++) {
    const entry = __privateGet(this, _noProxyEntries)[i];
    if (entry.port && entry.port !== port) {
      continue;
    }
    if (!/^[.*]/.test(entry.hostname)) {
      if (hostname === entry.hostname) {
        return false;
      }
    } else {
      if (hostname.endsWith(entry.hostname.replace(/^\*/, ""))) {
        return false;
      }
    }
  }
  return true;
}, parseNoProxy_fn = function() {
  const noProxyValue = __privateGet(this, _opts).noProxy ?? __privateGet(this, _EnvHttpProxyAgent_instances, noProxyEnv_get);
  const noProxySplit = noProxyValue.split(/[,\s]/);
  const noProxyEntries = [];
  for (let i = 0; i < noProxySplit.length; i++) {
    const entry = noProxySplit[i];
    if (!entry) {
      continue;
    }
    const parsed = entry.match(/^(.+):(\d+)$/);
    noProxyEntries.push({
      hostname: (parsed ? parsed[1] : entry).toLowerCase(),
      port: parsed ? Number.parseInt(parsed[2], 10) : 0
    });
  }
  __privateSet(this, _noProxyValue, noProxyValue);
  __privateSet(this, _noProxyEntries, noProxyEntries);
}, noProxyChanged_get = function() {
  if (__privateGet(this, _opts).noProxy !== void 0) {
    return false;
  }
  return __privateGet(this, _noProxyValue) !== __privateGet(this, _EnvHttpProxyAgent_instances, noProxyEnv_get);
}, noProxyEnv_get = function() {
  return process.env.no_proxy ?? process.env.NO_PROXY ?? "";
}, _f);
var envHttpProxyAgent$1 = EnvHttpProxyAgent$2;
const assert$p = require$$0$3;
const { kRetryHandlerDefaultRetry: kRetryHandlerDefaultRetry$1 } = symbols$5;
const { RequestRetryError: RequestRetryError$2 } = errors$2;
const WrapHandler$1 = wrapHandler;
const {
  isDisturbed: isDisturbed$2,
  parseRangeHeader: parseRangeHeader$2,
  wrapRequestBody: wrapRequestBody$2
} = util$J;
function calculateRetryAfterHeader$1(retryAfter) {
  const retryTime = new Date(retryAfter).getTime();
  return isNaN(retryTime) ? 0 : retryTime - Date.now();
}
let RetryHandler$6 = class RetryHandler {
  constructor(opts, { dispatch, handler }) {
    const { retryOptions, ...dispatchOpts } = opts;
    const {
      // Retry scoped
      retry: retryFn,
      maxRetries,
      maxTimeout,
      minTimeout,
      timeoutFactor,
      // Response scoped
      methods,
      errorCodes,
      retryAfter,
      statusCodes
    } = retryOptions ?? {};
    this.dispatch = dispatch;
    this.handler = WrapHandler$1.wrap(handler);
    this.opts = { ...dispatchOpts, body: wrapRequestBody$2(opts.body) };
    this.retryOpts = {
      retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry$1],
      retryAfter: retryAfter ?? true,
      maxTimeout: maxTimeout ?? 30 * 1e3,
      // 30s,
      minTimeout: minTimeout ?? 500,
      // .5s
      timeoutFactor: timeoutFactor ?? 2,
      maxRetries: maxRetries ?? 5,
      // What errors we should retry
      methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
      // Indicates which errors to retry
      statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
      // List of errors to retry
      errorCodes: errorCodes ?? [
        "ECONNRESET",
        "ECONNREFUSED",
        "ENOTFOUND",
        "ENETDOWN",
        "ENETUNREACH",
        "EHOSTDOWN",
        "EHOSTUNREACH",
        "EPIPE",
        "UND_ERR_SOCKET"
      ]
    };
    this.retryCount = 0;
    this.retryCountCheckpoint = 0;
    this.headersSent = false;
    this.start = 0;
    this.end = null;
    this.etag = null;
  }
  onRequestStart(controller, context) {
    var _a2, _b2;
    if (!this.headersSent) {
      (_b2 = (_a2 = this.handler).onRequestStart) == null ? void 0 : _b2.call(_a2, controller, context);
    }
  }
  onRequestUpgrade(controller, statusCode, headers2, socket) {
    var _a2, _b2;
    (_b2 = (_a2 = this.handler).onRequestUpgrade) == null ? void 0 : _b2.call(_a2, controller, statusCode, headers2, socket);
  }
  static [kRetryHandlerDefaultRetry$1](err, { state, opts }, cb) {
    const { statusCode, code, headers: headers2 } = err;
    const { method, retryOptions } = opts;
    const {
      maxRetries,
      minTimeout,
      maxTimeout,
      timeoutFactor,
      statusCodes,
      errorCodes,
      methods
    } = retryOptions;
    const { counter } = state;
    if (code && code !== "UND_ERR_REQ_RETRY" && !errorCodes.includes(code)) {
      cb(err);
      return;
    }
    if (Array.isArray(methods) && !methods.includes(method)) {
      cb(err);
      return;
    }
    if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
      cb(err);
      return;
    }
    if (counter > maxRetries) {
      cb(err);
      return;
    }
    let retryAfterHeader = headers2 == null ? void 0 : headers2["retry-after"];
    if (retryAfterHeader) {
      retryAfterHeader = Number(retryAfterHeader);
      retryAfterHeader = Number.isNaN(retryAfterHeader) ? calculateRetryAfterHeader$1(headers2["retry-after"]) : retryAfterHeader * 1e3;
    }
    const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(minTimeout * timeoutFactor ** (counter - 1), maxTimeout);
    setTimeout(() => cb(null), retryTimeout);
  }
  onResponseStart(controller, statusCode, headers2, statusMessage) {
    var _a2, _b2, _c2, _d2, _e2, _f2;
    this.retryCount += 1;
    if (statusCode >= 300) {
      if (this.retryOpts.statusCodes.includes(statusCode) === false) {
        this.headersSent = true;
        (_b2 = (_a2 = this.handler).onResponseStart) == null ? void 0 : _b2.call(
          _a2,
          controller,
          statusCode,
          headers2,
          statusMessage
        );
        return;
      } else {
        throw new RequestRetryError$2("Request failed", statusCode, {
          headers: headers2,
          data: {
            count: this.retryCount
          }
        });
      }
    }
    if (this.headersSent) {
      if (statusCode !== 206 && (this.start > 0 || statusCode !== 200)) {
        throw new RequestRetryError$2("server does not support the range header and the payload was partially consumed", statusCode, {
          headers: headers2,
          data: { count: this.retryCount }
        });
      }
      const contentRange = parseRangeHeader$2(headers2["content-range"]);
      if (!contentRange) {
        throw new RequestRetryError$2("Content-Range mismatch", statusCode, {
          headers: headers2,
          data: { count: this.retryCount }
        });
      }
      if (this.etag != null && this.etag !== headers2.etag) {
        throw new RequestRetryError$2("ETag mismatch", statusCode, {
          headers: headers2,
          data: { count: this.retryCount }
        });
      }
      const { start, size, end = size ? size - 1 : null } = contentRange;
      assert$p(this.start === start, "content-range mismatch");
      assert$p(this.end == null || this.end === end, "content-range mismatch");
      return;
    }
    if (this.end == null) {
      if (statusCode === 206) {
        const range = parseRangeHeader$2(headers2["content-range"]);
        if (range == null) {
          this.headersSent = true;
          (_d2 = (_c2 = this.handler).onResponseStart) == null ? void 0 : _d2.call(
            _c2,
            controller,
            statusCode,
            headers2,
            statusMessage
          );
          return;
        }
        const { start, size, end = size ? size - 1 : null } = range;
        assert$p(
          start != null && Number.isFinite(start),
          "content-range mismatch"
        );
        assert$p(end != null && Number.isFinite(end), "invalid content-length");
        this.start = start;
        this.end = end;
      }
      if (this.end == null) {
        const contentLength = headers2["content-length"];
        this.end = contentLength != null ? Number(contentLength) - 1 : null;
      }
      assert$p(Number.isFinite(this.start));
      assert$p(
        this.end == null || Number.isFinite(this.end),
        "invalid content-length"
      );
      this.resume = true;
      this.etag = headers2.etag != null ? headers2.etag : null;
      if (this.etag != null && this.etag[0] === "W" && this.etag[1] === "/") {
        this.etag = null;
      }
      this.headersSent = true;
      (_f2 = (_e2 = this.handler).onResponseStart) == null ? void 0 : _f2.call(
        _e2,
        controller,
        statusCode,
        headers2,
        statusMessage
      );
    } else {
      throw new RequestRetryError$2("Request failed", statusCode, {
        headers: headers2,
        data: { count: this.retryCount }
      });
    }
  }
  onResponseData(controller, chunk) {
    var _a2, _b2;
    this.start += chunk.length;
    (_b2 = (_a2 = this.handler).onResponseData) == null ? void 0 : _b2.call(_a2, controller, chunk);
  }
  onResponseEnd(controller, trailers) {
    var _a2, _b2;
    this.retryCount = 0;
    return (_b2 = (_a2 = this.handler).onResponseEnd) == null ? void 0 : _b2.call(_a2, controller, trailers);
  }
  onResponseError(controller, err) {
    var _a2, _b2;
    if ((controller == null ? void 0 : controller.aborted) || isDisturbed$2(this.opts.body)) {
      (_b2 = (_a2 = this.handler).onResponseError) == null ? void 0 : _b2.call(_a2, controller, err);
      return;
    }
    if (this.retryCount - this.retryCountCheckpoint > 0) {
      this.retryCount = this.retryCountCheckpoint + (this.retryCount - this.retryCountCheckpoint);
    } else {
      this.retryCount += 1;
    }
    this.retryOpts.retry(
      err,
      {
        state: { counter: this.retryCount },
        opts: { retryOptions: this.retryOpts, ...this.opts }
      },
      onRetry.bind(this)
    );
    function onRetry(err2) {
      var _a3, _b3, _c2, _d2;
      if (err2 != null || (controller == null ? void 0 : controller.aborted) || isDisturbed$2(this.opts.body)) {
        return (_b3 = (_a3 = this.handler).onResponseError) == null ? void 0 : _b3.call(_a3, controller, err2);
      }
      if (this.start !== 0) {
        const headers2 = { range: `bytes=${this.start}-${this.end ?? ""}` };
        if (this.etag != null) {
          headers2["if-match"] = this.etag;
        }
        this.opts = {
          ...this.opts,
          headers: {
            ...this.opts.headers,
            ...headers2
          }
        };
      }
      try {
        this.retryCountCheckpoint = this.retryCount;
        this.dispatch(this.opts, this);
      } catch (err3) {
        (_d2 = (_c2 = this.handler).onResponseError) == null ? void 0 : _d2.call(_c2, controller, err3);
      }
    }
  }
};
var retryHandler$1 = RetryHandler$6;
const Dispatcher$6 = dispatcher$1;
const RetryHandler$5 = retryHandler$1;
let RetryAgent$2 = (_g = class extends Dispatcher$6 {
  constructor(agent2, options = {}) {
    super(options);
    __privateAdd(this, _agent, null);
    __privateAdd(this, _options, null);
    __privateSet(this, _agent, agent2);
    __privateSet(this, _options, options);
  }
  dispatch(opts, handler) {
    const retry2 = new RetryHandler$5({
      ...opts,
      retryOptions: __privateGet(this, _options)
    }, {
      dispatch: __privateGet(this, _agent).dispatch.bind(__privateGet(this, _agent)),
      handler
    });
    return __privateGet(this, _agent).dispatch(opts, retry2);
  }
  close() {
    return __privateGet(this, _agent).close();
  }
  destroy() {
    return __privateGet(this, _agent).destroy();
  }
}, _agent = new WeakMap(), _options = new WeakMap(), _g);
var retryAgent$1 = RetryAgent$2;
var api$2 = {};
var apiRequest$1 = { exports: {} };
const assert$o = require$$0$3;
const { Readable: Readable$6 } = require$$0$4;
const { RequestAbortedError: RequestAbortedError$d, NotSupportedError: NotSupportedError$3, InvalidArgumentError: InvalidArgumentError$E, AbortError: AbortError$3 } = errors$2;
const util$A = util$J;
const { ReadableStreamFrom: ReadableStreamFrom$2 } = util$J;
const kConsume$1 = Symbol("kConsume");
const kReading$1 = Symbol("kReading");
const kBody$4 = Symbol("kBody");
const kAbort$1 = Symbol("kAbort");
const kContentType$1 = Symbol("kContentType");
const kContentLength$3 = Symbol("kContentLength");
const kUsed = Symbol("kUsed");
const kBytesRead = Symbol("kBytesRead");
const noop$9 = () => {
};
let BodyReadable$1 = class BodyReadable extends Readable$6 {
  /**
   * @param {object} opts
   * @param {(this: Readable, size: number) => void} opts.resume
   * @param {() => (void | null)} opts.abort
   * @param {string} [opts.contentType = '']
   * @param {number} [opts.contentLength]
   * @param {number} [opts.highWaterMark = 64 * 1024]
   */
  constructor({
    resume: resume2,
    abort: abort2,
    contentType = "",
    contentLength,
    highWaterMark = 64 * 1024
    // Same as nodejs fs streams.
  }) {
    super({
      autoDestroy: true,
      read: resume2,
      highWaterMark
    });
    this._readableState.dataEmitted = false;
    this[kAbort$1] = abort2;
    this[kConsume$1] = null;
    this[kBytesRead] = 0;
    this[kBody$4] = null;
    this[kUsed] = false;
    this[kContentType$1] = contentType;
    this[kContentLength$3] = Number.isFinite(contentLength) ? contentLength : null;
    this[kReading$1] = false;
  }
  /**
   * @param {Error|null} err
   * @param {(error:(Error|null)) => void} callback
   * @returns {void}
   */
  _destroy(err, callback) {
    if (!err && !this._readableState.endEmitted) {
      err = new RequestAbortedError$d();
    }
    if (err) {
      this[kAbort$1]();
    }
    if (!this[kUsed]) {
      setImmediate(() => {
        callback(err);
      });
    } else {
      callback(err);
    }
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => void} listener
   * @returns {this}
   */
  on(event, listener) {
    if (event === "data" || event === "readable") {
      this[kReading$1] = true;
      this[kUsed] = true;
    }
    return super.on(event, listener);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => void} listener
   * @returns {this}
   */
  addListener(event, listener) {
    return this.on(event, listener);
  }
  /**
   * @param {string|symbol} event
   * @param {(...args: any[]) => void} listener
   * @returns {this}
   */
  off(event, listener) {
    const ret = super.off(event, listener);
    if (event === "data" || event === "readable") {
      this[kReading$1] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
    }
    return ret;
  }
  /**
   * @param {string|symbol} event
   * @param {(...args: any[]) => void} listener
   * @returns {this}
   */
  removeListener(event, listener) {
    return this.off(event, listener);
  }
  /**
   * @param {Buffer|null} chunk
   * @returns {boolean}
   */
  push(chunk) {
    this[kBytesRead] += chunk ? chunk.length : 0;
    if (this[kConsume$1] && chunk !== null) {
      consumePush$1(this[kConsume$1], chunk);
      return this[kReading$1] ? super.push(chunk) : true;
    }
    return super.push(chunk);
  }
  /**
   * Consumes and returns the body as a string.
   *
   * @see https://fetch.spec.whatwg.org/#dom-body-text
   * @returns {Promise<string>}
   */
  text() {
    return consume$1(this, "text");
  }
  /**
   * Consumes and returns the body as a JavaScript Object.
   *
   * @see https://fetch.spec.whatwg.org/#dom-body-json
   * @returns {Promise<unknown>}
   */
  json() {
    return consume$1(this, "json");
  }
  /**
   * Consumes and returns the body as a Blob
   *
   * @see https://fetch.spec.whatwg.org/#dom-body-blob
   * @returns {Promise<Blob>}
   */
  blob() {
    return consume$1(this, "blob");
  }
  /**
   * Consumes and returns the body as an Uint8Array.
   *
   * @see https://fetch.spec.whatwg.org/#dom-body-bytes
   * @returns {Promise<Uint8Array>}
   */
  bytes() {
    return consume$1(this, "bytes");
  }
  /**
   * Consumes and returns the body as an ArrayBuffer.
   *
   * @see https://fetch.spec.whatwg.org/#dom-body-arraybuffer
   * @returns {Promise<ArrayBuffer>}
   */
  arrayBuffer() {
    return consume$1(this, "arrayBuffer");
  }
  /**
   * Not implemented
   *
   * @see https://fetch.spec.whatwg.org/#dom-body-formdata
   * @throws {NotSupportedError}
   */
  async formData() {
    throw new NotSupportedError$3();
  }
  /**
   * Returns true if the body is not null and the body has been consumed.
   * Otherwise, returns false.
   *
   * @see https://fetch.spec.whatwg.org/#dom-body-bodyused
   * @readonly
   * @returns {boolean}
   */
  get bodyUsed() {
    return util$A.isDisturbed(this);
  }
  /**
   * @see https://fetch.spec.whatwg.org/#dom-body-body
   * @readonly
   * @returns {ReadableStream}
   */
  get body() {
    if (!this[kBody$4]) {
      this[kBody$4] = ReadableStreamFrom$2(this);
      if (this[kConsume$1]) {
        this[kBody$4].getReader();
        assert$o(this[kBody$4].locked);
      }
    }
    return this[kBody$4];
  }
  /**
   * Dumps the response body by reading `limit` number of bytes.
   * @param {object} opts
   * @param {number} [opts.limit = 131072] Number of bytes to read.
   * @param {AbortSignal} [opts.signal] An AbortSignal to cancel the dump.
   * @returns {Promise<null>}
   */
  async dump(opts) {
    const signal = opts == null ? void 0 : opts.signal;
    if (signal != null && (typeof signal !== "object" || !("aborted" in signal))) {
      throw new InvalidArgumentError$E("signal must be an AbortSignal");
    }
    const limit = (opts == null ? void 0 : opts.limit) && Number.isFinite(opts.limit) ? opts.limit : 128 * 1024;
    signal == null ? void 0 : signal.throwIfAborted();
    if (this._readableState.closeEmitted) {
      return null;
    }
    return await new Promise((resolve2, reject) => {
      if (this[kContentLength$3] && this[kContentLength$3] > limit || this[kBytesRead] > limit) {
        this.destroy(new AbortError$3());
      }
      if (signal) {
        const onAbort = () => {
          this.destroy(signal.reason ?? new AbortError$3());
        };
        signal.addEventListener("abort", onAbort);
        this.on("close", function() {
          signal.removeEventListener("abort", onAbort);
          if (signal.aborted) {
            reject(signal.reason ?? new AbortError$3());
          } else {
            resolve2(null);
          }
        });
      } else {
        this.on("close", resolve2);
      }
      this.on("error", noop$9).on("data", () => {
        if (this[kBytesRead] > limit) {
          this.destroy();
        }
      }).resume();
    });
  }
  /**
   * @param {BufferEncoding} encoding
   * @returns {this}
   */
  setEncoding(encoding2) {
    if (Buffer.isEncoding(encoding2)) {
      this._readableState.encoding = encoding2;
    }
    return this;
  }
};
function isLocked$1(bodyReadable) {
  var _a2;
  return ((_a2 = bodyReadable[kBody$4]) == null ? void 0 : _a2.locked) === true || bodyReadable[kConsume$1] !== null;
}
function isUnusable$1(bodyReadable) {
  return util$A.isDisturbed(bodyReadable) || isLocked$1(bodyReadable);
}
function consume$1(stream2, type) {
  assert$o(!stream2[kConsume$1]);
  return new Promise((resolve2, reject) => {
    if (isUnusable$1(stream2)) {
      const rState = stream2._readableState;
      if (rState.destroyed && rState.closeEmitted === false) {
        stream2.on("error", (err) => {
          reject(err);
        }).on("close", () => {
          reject(new TypeError("unusable"));
        });
      } else {
        reject(rState.errored ?? new TypeError("unusable"));
      }
    } else {
      queueMicrotask(() => {
        stream2[kConsume$1] = {
          type,
          stream: stream2,
          resolve: resolve2,
          reject,
          length: 0,
          body: []
        };
        stream2.on("error", function(err) {
          consumeFinish$1(this[kConsume$1], err);
        }).on("close", function() {
          if (this[kConsume$1].body !== null) {
            consumeFinish$1(this[kConsume$1], new RequestAbortedError$d());
          }
        });
        consumeStart$1(stream2[kConsume$1]);
      });
    }
  });
}
function consumeStart$1(consume2) {
  if (consume2.body === null) {
    return;
  }
  const { _readableState: state } = consume2.stream;
  if (state.bufferIndex) {
    const start = state.bufferIndex;
    const end = state.buffer.length;
    for (let n = start; n < end; n++) {
      consumePush$1(consume2, state.buffer[n]);
    }
  } else {
    for (const chunk of state.buffer) {
      consumePush$1(consume2, chunk);
    }
  }
  if (state.endEmitted) {
    consumeEnd$1(this[kConsume$1], this._readableState.encoding);
  } else {
    consume2.stream.on("end", function() {
      consumeEnd$1(this[kConsume$1], this._readableState.encoding);
    });
  }
  consume2.stream.resume();
  while (consume2.stream.read() != null) {
  }
}
function chunksDecode$2(chunks, length, encoding2) {
  if (chunks.length === 0 || length === 0) {
    return "";
  }
  const buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks, length);
  const bufferLength = buffer.length;
  const start = bufferLength > 2 && buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191 ? 3 : 0;
  if (!encoding2 || encoding2 === "utf8" || encoding2 === "utf-8") {
    return buffer.utf8Slice(start, bufferLength);
  } else {
    return buffer.subarray(start, bufferLength).toString(encoding2);
  }
}
function chunksConcat$1(chunks, length) {
  if (chunks.length === 0 || length === 0) {
    return new Uint8Array(0);
  }
  if (chunks.length === 1) {
    return new Uint8Array(chunks[0]);
  }
  const buffer = new Uint8Array(Buffer.allocUnsafeSlow(length).buffer);
  let offset = 0;
  for (let i = 0; i < chunks.length; ++i) {
    const chunk = chunks[i];
    buffer.set(chunk, offset);
    offset += chunk.length;
  }
  return buffer;
}
function consumeEnd$1(consume2, encoding2) {
  const { type, body: body2, resolve: resolve2, stream: stream2, length } = consume2;
  try {
    if (type === "text") {
      resolve2(chunksDecode$2(body2, length, encoding2));
    } else if (type === "json") {
      resolve2(JSON.parse(chunksDecode$2(body2, length, encoding2)));
    } else if (type === "arrayBuffer") {
      resolve2(chunksConcat$1(body2, length).buffer);
    } else if (type === "blob") {
      resolve2(new Blob(body2, { type: stream2[kContentType$1] }));
    } else if (type === "bytes") {
      resolve2(chunksConcat$1(body2, length));
    }
    consumeFinish$1(consume2);
  } catch (err) {
    stream2.destroy(err);
  }
}
function consumePush$1(consume2, chunk) {
  consume2.length += chunk.length;
  consume2.body.push(chunk);
}
function consumeFinish$1(consume2, err) {
  if (consume2.body === null) {
    return;
  }
  if (err) {
    consume2.reject(err);
  } else {
    consume2.resolve();
  }
  consume2.type = null;
  consume2.stream = null;
  consume2.resolve = null;
  consume2.reject = null;
  consume2.length = 0;
  consume2.body = null;
}
var readable$1 = {
  Readable: BodyReadable$1
};
const assert$n = require$$0$3;
const { AsyncResource: AsyncResource$9 } = require$$1$4;
const { Readable: Readable$5 } = readable$1;
const { InvalidArgumentError: InvalidArgumentError$D, RequestAbortedError: RequestAbortedError$c } = errors$2;
const util$z = util$J;
function noop$8() {
}
let RequestHandler$1 = class RequestHandler extends AsyncResource$9 {
  constructor(opts, callback) {
    if (!opts || typeof opts !== "object") {
      throw new InvalidArgumentError$D("invalid opts");
    }
    const { signal, method, opaque, body: body2, onInfo, responseHeaders, highWaterMark } = opts;
    try {
      if (typeof callback !== "function") {
        throw new InvalidArgumentError$D("invalid callback");
      }
      if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
        throw new InvalidArgumentError$D("invalid highWaterMark");
      }
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError$D("signal must be an EventEmitter or EventTarget");
      }
      if (method === "CONNECT") {
        throw new InvalidArgumentError$D("invalid method");
      }
      if (onInfo && typeof onInfo !== "function") {
        throw new InvalidArgumentError$D("invalid onInfo callback");
      }
      super("UNDICI_REQUEST");
    } catch (err) {
      if (util$z.isStream(body2)) {
        util$z.destroy(body2.on("error", noop$8), err);
      }
      throw err;
    }
    this.method = method;
    this.responseHeaders = responseHeaders || null;
    this.opaque = opaque || null;
    this.callback = callback;
    this.res = null;
    this.abort = null;
    this.body = body2;
    this.trailers = {};
    this.context = null;
    this.onInfo = onInfo || null;
    this.highWaterMark = highWaterMark;
    this.reason = null;
    this.removeAbortListener = null;
    if (signal == null ? void 0 : signal.aborted) {
      this.reason = signal.reason ?? new RequestAbortedError$c();
    } else if (signal) {
      this.removeAbortListener = util$z.addAbortListener(signal, () => {
        this.reason = signal.reason ?? new RequestAbortedError$c();
        if (this.res) {
          util$z.destroy(this.res.on("error", noop$8), this.reason);
        } else if (this.abort) {
          this.abort(this.reason);
        }
      });
    }
  }
  onConnect(abort2, context) {
    if (this.reason) {
      abort2(this.reason);
      return;
    }
    assert$n(this.callback);
    this.abort = abort2;
    this.context = context;
  }
  onHeaders(statusCode, rawHeaders, resume2, statusMessage) {
    const { callback, opaque, abort: abort2, context, responseHeaders, highWaterMark } = this;
    const headers2 = responseHeaders === "raw" ? util$z.parseRawHeaders(rawHeaders) : util$z.parseHeaders(rawHeaders);
    if (statusCode < 200) {
      if (this.onInfo) {
        this.onInfo({ statusCode, headers: headers2 });
      }
      return;
    }
    const parsedHeaders = responseHeaders === "raw" ? util$z.parseHeaders(rawHeaders) : headers2;
    const contentType = parsedHeaders["content-type"];
    const contentLength = parsedHeaders["content-length"];
    const res = new Readable$5({
      resume: resume2,
      abort: abort2,
      contentType,
      contentLength: this.method !== "HEAD" && contentLength ? Number(contentLength) : null,
      highWaterMark
    });
    if (this.removeAbortListener) {
      res.on("close", this.removeAbortListener);
      this.removeAbortListener = null;
    }
    this.callback = null;
    this.res = res;
    if (callback !== null) {
      this.runInAsyncScope(callback, null, null, {
        statusCode,
        headers: headers2,
        trailers: this.trailers,
        opaque,
        body: res,
        context
      });
    }
  }
  onData(chunk) {
    return this.res.push(chunk);
  }
  onComplete(trailers) {
    util$z.parseHeaders(trailers, this.trailers);
    this.res.push(null);
  }
  onError(err) {
    const { res, callback, body: body2, opaque } = this;
    if (callback) {
      this.callback = null;
      queueMicrotask(() => {
        this.runInAsyncScope(callback, null, err, { opaque });
      });
    }
    if (res) {
      this.res = null;
      queueMicrotask(() => {
        util$z.destroy(res.on("error", noop$8), err);
      });
    }
    if (body2) {
      this.body = null;
      if (util$z.isStream(body2)) {
        body2.on("error", noop$8);
        util$z.destroy(body2, err);
      }
    }
    if (this.removeAbortListener) {
      this.removeAbortListener();
      this.removeAbortListener = null;
    }
  }
};
function request$4(opts, callback) {
  if (callback === void 0) {
    return new Promise((resolve2, reject) => {
      request$4.call(this, opts, (err, data) => {
        return err ? reject(err) : resolve2(data);
      });
    });
  }
  try {
    const handler = new RequestHandler$1(opts, callback);
    this.dispatch(opts, handler);
  } catch (err) {
    if (typeof callback !== "function") {
      throw err;
    }
    const opaque = opts == null ? void 0 : opts.opaque;
    queueMicrotask(() => callback(err, { opaque }));
  }
}
apiRequest$1.exports = request$4;
apiRequest$1.exports.RequestHandler = RequestHandler$1;
var apiRequestExports$1 = apiRequest$1.exports;
const { addAbortListener: addAbortListener$2 } = util$J;
const { RequestAbortedError: RequestAbortedError$b } = errors$2;
const kListener$1 = Symbol("kListener");
const kSignal$1 = Symbol("kSignal");
function abort$1(self2) {
  var _a2, _b2;
  if (self2.abort) {
    self2.abort((_a2 = self2[kSignal$1]) == null ? void 0 : _a2.reason);
  } else {
    self2.reason = ((_b2 = self2[kSignal$1]) == null ? void 0 : _b2.reason) ?? new RequestAbortedError$b();
  }
  removeSignal$9(self2);
}
function addSignal$9(self2, signal) {
  self2.reason = null;
  self2[kSignal$1] = null;
  self2[kListener$1] = null;
  if (!signal) {
    return;
  }
  if (signal.aborted) {
    abort$1(self2);
    return;
  }
  self2[kSignal$1] = signal;
  self2[kListener$1] = () => {
    abort$1(self2);
  };
  addAbortListener$2(self2[kSignal$1], self2[kListener$1]);
}
function removeSignal$9(self2) {
  if (!self2[kSignal$1]) {
    return;
  }
  if ("removeEventListener" in self2[kSignal$1]) {
    self2[kSignal$1].removeEventListener("abort", self2[kListener$1]);
  } else {
    self2[kSignal$1].removeListener("abort", self2[kListener$1]);
  }
  self2[kSignal$1] = null;
  self2[kListener$1] = null;
}
var abortSignal$1 = {
  addSignal: addSignal$9,
  removeSignal: removeSignal$9
};
const assert$m = require$$0$3;
const { finished: finished$1 } = require$$0$4;
const { AsyncResource: AsyncResource$8 } = require$$1$4;
const { InvalidArgumentError: InvalidArgumentError$C, InvalidReturnValueError: InvalidReturnValueError$4 } = errors$2;
const util$y = util$J;
const { addSignal: addSignal$8, removeSignal: removeSignal$8 } = abortSignal$1;
function noop$7() {
}
let StreamHandler$1 = class StreamHandler extends AsyncResource$8 {
  constructor(opts, factory, callback) {
    if (!opts || typeof opts !== "object") {
      throw new InvalidArgumentError$C("invalid opts");
    }
    const { signal, method, opaque, body: body2, onInfo, responseHeaders } = opts;
    try {
      if (typeof callback !== "function") {
        throw new InvalidArgumentError$C("invalid callback");
      }
      if (typeof factory !== "function") {
        throw new InvalidArgumentError$C("invalid factory");
      }
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError$C("signal must be an EventEmitter or EventTarget");
      }
      if (method === "CONNECT") {
        throw new InvalidArgumentError$C("invalid method");
      }
      if (onInfo && typeof onInfo !== "function") {
        throw new InvalidArgumentError$C("invalid onInfo callback");
      }
      super("UNDICI_STREAM");
    } catch (err) {
      if (util$y.isStream(body2)) {
        util$y.destroy(body2.on("error", noop$7), err);
      }
      throw err;
    }
    this.responseHeaders = responseHeaders || null;
    this.opaque = opaque || null;
    this.factory = factory;
    this.callback = callback;
    this.res = null;
    this.abort = null;
    this.context = null;
    this.trailers = null;
    this.body = body2;
    this.onInfo = onInfo || null;
    if (util$y.isStream(body2)) {
      body2.on("error", (err) => {
        this.onError(err);
      });
    }
    addSignal$8(this, signal);
  }
  onConnect(abort2, context) {
    if (this.reason) {
      abort2(this.reason);
      return;
    }
    assert$m(this.callback);
    this.abort = abort2;
    this.context = context;
  }
  onHeaders(statusCode, rawHeaders, resume2, statusMessage) {
    var _a2;
    const { factory, opaque, context, responseHeaders } = this;
    const headers2 = responseHeaders === "raw" ? util$y.parseRawHeaders(rawHeaders) : util$y.parseHeaders(rawHeaders);
    if (statusCode < 200) {
      if (this.onInfo) {
        this.onInfo({ statusCode, headers: headers2 });
      }
      return;
    }
    this.factory = null;
    if (factory === null) {
      return;
    }
    const res = this.runInAsyncScope(factory, null, {
      statusCode,
      headers: headers2,
      opaque,
      context
    });
    if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
      throw new InvalidReturnValueError$4("expected Writable");
    }
    finished$1(res, { readable: false }, (err) => {
      const { callback, res: res2, opaque: opaque2, trailers, abort: abort2 } = this;
      this.res = null;
      if (err || !res2.readable) {
        util$y.destroy(res2, err);
      }
      this.callback = null;
      this.runInAsyncScope(callback, null, err || null, { opaque: opaque2, trailers });
      if (err) {
        abort2();
      }
    });
    res.on("drain", resume2);
    this.res = res;
    const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : (_a2 = res._writableState) == null ? void 0 : _a2.needDrain;
    return needDrain !== true;
  }
  onData(chunk) {
    const { res } = this;
    return res ? res.write(chunk) : true;
  }
  onComplete(trailers) {
    const { res } = this;
    removeSignal$8(this);
    if (!res) {
      return;
    }
    this.trailers = util$y.parseHeaders(trailers);
    res.end();
  }
  onError(err) {
    const { res, callback, opaque, body: body2 } = this;
    removeSignal$8(this);
    this.factory = null;
    if (res) {
      this.res = null;
      util$y.destroy(res, err);
    } else if (callback) {
      this.callback = null;
      queueMicrotask(() => {
        this.runInAsyncScope(callback, null, err, { opaque });
      });
    }
    if (body2) {
      this.body = null;
      util$y.destroy(body2, err);
    }
  }
};
function stream$2(opts, factory, callback) {
  if (callback === void 0) {
    return new Promise((resolve2, reject) => {
      stream$2.call(this, opts, factory, (err, data) => {
        return err ? reject(err) : resolve2(data);
      });
    });
  }
  try {
    const handler = new StreamHandler$1(opts, factory, callback);
    this.dispatch(opts, handler);
  } catch (err) {
    if (typeof callback !== "function") {
      throw err;
    }
    const opaque = opts == null ? void 0 : opts.opaque;
    queueMicrotask(() => callback(err, { opaque }));
  }
}
var apiStream$1 = stream$2;
const {
  Readable: Readable$4,
  Duplex: Duplex$1,
  PassThrough: PassThrough$3
} = require$$0$4;
const assert$l = require$$0$3;
const { AsyncResource: AsyncResource$7 } = require$$1$4;
const {
  InvalidArgumentError: InvalidArgumentError$B,
  InvalidReturnValueError: InvalidReturnValueError$3,
  RequestAbortedError: RequestAbortedError$a
} = errors$2;
const util$x = util$J;
const { addSignal: addSignal$7, removeSignal: removeSignal$7 } = abortSignal$1;
function noop$6() {
}
const kResume$4 = Symbol("resume");
let PipelineRequest$1 = class PipelineRequest extends Readable$4 {
  constructor() {
    super({ autoDestroy: true });
    this[kResume$4] = null;
  }
  _read() {
    const { [kResume$4]: resume2 } = this;
    if (resume2) {
      this[kResume$4] = null;
      resume2();
    }
  }
  _destroy(err, callback) {
    this._read();
    callback(err);
  }
};
let PipelineResponse$1 = class PipelineResponse extends Readable$4 {
  constructor(resume2) {
    super({ autoDestroy: true });
    this[kResume$4] = resume2;
  }
  _read() {
    this[kResume$4]();
  }
  _destroy(err, callback) {
    if (!err && !this._readableState.endEmitted) {
      err = new RequestAbortedError$a();
    }
    callback(err);
  }
};
let PipelineHandler$1 = class PipelineHandler extends AsyncResource$7 {
  constructor(opts, handler) {
    if (!opts || typeof opts !== "object") {
      throw new InvalidArgumentError$B("invalid opts");
    }
    if (typeof handler !== "function") {
      throw new InvalidArgumentError$B("invalid handler");
    }
    const { signal, method, opaque, onInfo, responseHeaders } = opts;
    if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
      throw new InvalidArgumentError$B("signal must be an EventEmitter or EventTarget");
    }
    if (method === "CONNECT") {
      throw new InvalidArgumentError$B("invalid method");
    }
    if (onInfo && typeof onInfo !== "function") {
      throw new InvalidArgumentError$B("invalid onInfo callback");
    }
    super("UNDICI_PIPELINE");
    this.opaque = opaque || null;
    this.responseHeaders = responseHeaders || null;
    this.handler = handler;
    this.abort = null;
    this.context = null;
    this.onInfo = onInfo || null;
    this.req = new PipelineRequest$1().on("error", noop$6);
    this.ret = new Duplex$1({
      readableObjectMode: opts.objectMode,
      autoDestroy: true,
      read: () => {
        const { body: body2 } = this;
        if (body2 == null ? void 0 : body2.resume) {
          body2.resume();
        }
      },
      write: (chunk, encoding2, callback) => {
        const { req: req2 } = this;
        if (req2.push(chunk, encoding2) || req2._readableState.destroyed) {
          callback();
        } else {
          req2[kResume$4] = callback;
        }
      },
      destroy: (err, callback) => {
        const { body: body2, req: req2, res, ret, abort: abort2 } = this;
        if (!err && !ret._readableState.endEmitted) {
          err = new RequestAbortedError$a();
        }
        if (abort2 && err) {
          abort2();
        }
        util$x.destroy(body2, err);
        util$x.destroy(req2, err);
        util$x.destroy(res, err);
        removeSignal$7(this);
        callback(err);
      }
    }).on("prefinish", () => {
      const { req: req2 } = this;
      req2.push(null);
    });
    this.res = null;
    addSignal$7(this, signal);
  }
  onConnect(abort2, context) {
    const { res } = this;
    if (this.reason) {
      abort2(this.reason);
      return;
    }
    assert$l(!res, "pipeline cannot be retried");
    this.abort = abort2;
    this.context = context;
  }
  onHeaders(statusCode, rawHeaders, resume2) {
    const { opaque, handler, context } = this;
    if (statusCode < 200) {
      if (this.onInfo) {
        const headers2 = this.responseHeaders === "raw" ? util$x.parseRawHeaders(rawHeaders) : util$x.parseHeaders(rawHeaders);
        this.onInfo({ statusCode, headers: headers2 });
      }
      return;
    }
    this.res = new PipelineResponse$1(resume2);
    let body2;
    try {
      this.handler = null;
      const headers2 = this.responseHeaders === "raw" ? util$x.parseRawHeaders(rawHeaders) : util$x.parseHeaders(rawHeaders);
      body2 = this.runInAsyncScope(handler, null, {
        statusCode,
        headers: headers2,
        opaque,
        body: this.res,
        context
      });
    } catch (err) {
      this.res.on("error", noop$6);
      throw err;
    }
    if (!body2 || typeof body2.on !== "function") {
      throw new InvalidReturnValueError$3("expected Readable");
    }
    body2.on("data", (chunk) => {
      const { ret, body: body3 } = this;
      if (!ret.push(chunk) && body3.pause) {
        body3.pause();
      }
    }).on("error", (err) => {
      const { ret } = this;
      util$x.destroy(ret, err);
    }).on("end", () => {
      const { ret } = this;
      ret.push(null);
    }).on("close", () => {
      const { ret } = this;
      if (!ret._readableState.ended) {
        util$x.destroy(ret, new RequestAbortedError$a());
      }
    });
    this.body = body2;
  }
  onData(chunk) {
    const { res } = this;
    return res.push(chunk);
  }
  onComplete(trailers) {
    const { res } = this;
    res.push(null);
  }
  onError(err) {
    const { ret } = this;
    this.handler = null;
    util$x.destroy(ret, err);
  }
};
function pipeline$2(opts, handler) {
  try {
    const pipelineHandler = new PipelineHandler$1(opts, handler);
    this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
    return pipelineHandler.ret;
  } catch (err) {
    return new PassThrough$3().destroy(err);
  }
}
var apiPipeline$1 = pipeline$2;
const { InvalidArgumentError: InvalidArgumentError$A, SocketError: SocketError$6 } = errors$2;
const { AsyncResource: AsyncResource$6 } = require$$1$4;
const assert$k = require$$0$3;
const util$w = util$J;
const { addSignal: addSignal$6, removeSignal: removeSignal$6 } = abortSignal$1;
let UpgradeHandler$1 = class UpgradeHandler extends AsyncResource$6 {
  constructor(opts, callback) {
    if (!opts || typeof opts !== "object") {
      throw new InvalidArgumentError$A("invalid opts");
    }
    if (typeof callback !== "function") {
      throw new InvalidArgumentError$A("invalid callback");
    }
    const { signal, opaque, responseHeaders } = opts;
    if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
      throw new InvalidArgumentError$A("signal must be an EventEmitter or EventTarget");
    }
    super("UNDICI_UPGRADE");
    this.responseHeaders = responseHeaders || null;
    this.opaque = opaque || null;
    this.callback = callback;
    this.abort = null;
    this.context = null;
    addSignal$6(this, signal);
  }
  onConnect(abort2, context) {
    if (this.reason) {
      abort2(this.reason);
      return;
    }
    assert$k(this.callback);
    this.abort = abort2;
    this.context = null;
  }
  onHeaders() {
    throw new SocketError$6("bad upgrade", null);
  }
  onUpgrade(statusCode, rawHeaders, socket) {
    assert$k(statusCode === 101);
    const { callback, opaque, context } = this;
    removeSignal$6(this);
    this.callback = null;
    const headers2 = this.responseHeaders === "raw" ? util$w.parseRawHeaders(rawHeaders) : util$w.parseHeaders(rawHeaders);
    this.runInAsyncScope(callback, null, null, {
      headers: headers2,
      socket,
      opaque,
      context
    });
  }
  onError(err) {
    const { callback, opaque } = this;
    removeSignal$6(this);
    if (callback) {
      this.callback = null;
      queueMicrotask(() => {
        this.runInAsyncScope(callback, null, err, { opaque });
      });
    }
  }
};
function upgrade$1(opts, callback) {
  if (callback === void 0) {
    return new Promise((resolve2, reject) => {
      upgrade$1.call(this, opts, (err, data) => {
        return err ? reject(err) : resolve2(data);
      });
    });
  }
  try {
    const upgradeHandler = new UpgradeHandler$1(opts, callback);
    const upgradeOpts = {
      ...opts,
      method: opts.method || "GET",
      upgrade: opts.protocol || "Websocket"
    };
    this.dispatch(upgradeOpts, upgradeHandler);
  } catch (err) {
    if (typeof callback !== "function") {
      throw err;
    }
    const opaque = opts == null ? void 0 : opts.opaque;
    queueMicrotask(() => callback(err, { opaque }));
  }
}
var apiUpgrade$1 = upgrade$1;
const assert$j = require$$0$3;
const { AsyncResource: AsyncResource$5 } = require$$1$4;
const { InvalidArgumentError: InvalidArgumentError$z, SocketError: SocketError$5 } = errors$2;
const util$v = util$J;
const { addSignal: addSignal$5, removeSignal: removeSignal$5 } = abortSignal$1;
let ConnectHandler$1 = class ConnectHandler extends AsyncResource$5 {
  constructor(opts, callback) {
    if (!opts || typeof opts !== "object") {
      throw new InvalidArgumentError$z("invalid opts");
    }
    if (typeof callback !== "function") {
      throw new InvalidArgumentError$z("invalid callback");
    }
    const { signal, opaque, responseHeaders } = opts;
    if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
      throw new InvalidArgumentError$z("signal must be an EventEmitter or EventTarget");
    }
    super("UNDICI_CONNECT");
    this.opaque = opaque || null;
    this.responseHeaders = responseHeaders || null;
    this.callback = callback;
    this.abort = null;
    addSignal$5(this, signal);
  }
  onConnect(abort2, context) {
    if (this.reason) {
      abort2(this.reason);
      return;
    }
    assert$j(this.callback);
    this.abort = abort2;
    this.context = context;
  }
  onHeaders() {
    throw new SocketError$5("bad connect", null);
  }
  onUpgrade(statusCode, rawHeaders, socket) {
    const { callback, opaque, context } = this;
    removeSignal$5(this);
    this.callback = null;
    let headers2 = rawHeaders;
    if (headers2 != null) {
      headers2 = this.responseHeaders === "raw" ? util$v.parseRawHeaders(rawHeaders) : util$v.parseHeaders(rawHeaders);
    }
    this.runInAsyncScope(callback, null, null, {
      statusCode,
      headers: headers2,
      socket,
      opaque,
      context
    });
  }
  onError(err) {
    const { callback, opaque } = this;
    removeSignal$5(this);
    if (callback) {
      this.callback = null;
      queueMicrotask(() => {
        this.runInAsyncScope(callback, null, err, { opaque });
      });
    }
  }
};
function connect$4(opts, callback) {
  if (callback === void 0) {
    return new Promise((resolve2, reject) => {
      connect$4.call(this, opts, (err, data) => {
        return err ? reject(err) : resolve2(data);
      });
    });
  }
  try {
    const connectHandler = new ConnectHandler$1(opts, callback);
    const connectOptions = { ...opts, method: "CONNECT" };
    this.dispatch(connectOptions, connectHandler);
  } catch (err) {
    if (typeof callback !== "function") {
      throw err;
    }
    const opaque = opts == null ? void 0 : opts.opaque;
    queueMicrotask(() => callback(err, { opaque }));
  }
}
var apiConnect$1 = connect$4;
api$2.request = apiRequestExports$1;
api$2.stream = apiStream$1;
api$2.pipeline = apiPipeline$1;
api$2.upgrade = apiUpgrade$1;
api$2.connect = apiConnect$1;
const { UndiciError: UndiciError$4 } = errors$2;
let MockNotMatchedError$3 = class MockNotMatchedError extends UndiciError$4 {
  constructor(message) {
    super(message);
    this.name = "MockNotMatchedError";
    this.message = message || "The request does not match any registered mock dispatches";
    this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
  }
};
var mockErrors$2 = {
  MockNotMatchedError: MockNotMatchedError$3
};
var mockSymbols$1 = {
  kAgent: Symbol("agent"),
  kOptions: Symbol("options"),
  kFactory: Symbol("factory"),
  kDispatches: Symbol("dispatches"),
  kDispatchKey: Symbol("dispatch key"),
  kDefaultHeaders: Symbol("default headers"),
  kDefaultTrailers: Symbol("default trailers"),
  kContentLength: Symbol("content length"),
  kMockAgent: Symbol("mock agent"),
  kMockAgentSet: Symbol("mock agent set"),
  kMockAgentGet: Symbol("mock agent get"),
  kMockDispatch: Symbol("mock dispatch"),
  kClose: Symbol("close"),
  kOriginalClose: Symbol("original agent close"),
  kOriginalDispatch: Symbol("original dispatch"),
  kOrigin: Symbol("origin"),
  kIsMockActive: Symbol("is mock active"),
  kNetConnect: Symbol("net connect"),
  kGetNetConnect: Symbol("get net connect"),
  kConnected: Symbol("connected"),
  kIgnoreTrailingSlash: Symbol("ignore trailing slash"),
  kMockAgentMockCallHistoryInstance: Symbol("mock agent mock call history name"),
  kMockAgentRegisterCallHistory: Symbol("mock agent register mock call history"),
  kMockAgentAddCallHistoryLog: Symbol("mock agent add call history log"),
  kMockAgentIsCallHistoryEnabled: Symbol("mock agent is call history enabled"),
  kMockCallHistoryAddLog: Symbol("mock call history add log")
};
const { MockNotMatchedError: MockNotMatchedError$2 } = mockErrors$2;
const {
  kDispatches: kDispatches$9,
  kMockAgent: kMockAgent$5,
  kOriginalDispatch: kOriginalDispatch$5,
  kOrigin: kOrigin$5,
  kGetNetConnect: kGetNetConnect$3
} = mockSymbols$1;
const { serializePathWithQuery: serializePathWithQuery$1 } = util$J;
const { STATUS_CODES: STATUS_CODES$1 } = require$$2$1;
const {
  types: {
    isPromise: isPromise$1
  }
} = require$$0$2;
const { InvalidArgumentError: InvalidArgumentError$y } = errors$2;
function matchValue$3(match, value) {
  if (typeof match === "string") {
    return match === value;
  }
  if (match instanceof RegExp) {
    return match.test(value);
  }
  if (typeof match === "function") {
    return match(value) === true;
  }
  return false;
}
function lowerCaseEntries$1(headers2) {
  return Object.fromEntries(
    Object.entries(headers2).map(([headerName, headerValue]) => {
      return [headerName.toLocaleLowerCase(), headerValue];
    })
  );
}
function getHeaderByName$1(headers2, key) {
  if (Array.isArray(headers2)) {
    for (let i = 0; i < headers2.length; i += 2) {
      if (headers2[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
        return headers2[i + 1];
      }
    }
    return void 0;
  } else if (typeof headers2.get === "function") {
    return headers2.get(key);
  } else {
    return lowerCaseEntries$1(headers2)[key.toLocaleLowerCase()];
  }
}
function buildHeadersFromArray$1(headers2) {
  const clone = headers2.slice();
  const entries = [];
  for (let index = 0; index < clone.length; index += 2) {
    entries.push([clone[index], clone[index + 1]]);
  }
  return Object.fromEntries(entries);
}
function matchHeaders$1(mockDispatch2, headers2) {
  if (typeof mockDispatch2.headers === "function") {
    if (Array.isArray(headers2)) {
      headers2 = buildHeadersFromArray$1(headers2);
    }
    return mockDispatch2.headers(headers2 ? lowerCaseEntries$1(headers2) : {});
  }
  if (typeof mockDispatch2.headers === "undefined") {
    return true;
  }
  if (typeof headers2 !== "object" || typeof mockDispatch2.headers !== "object") {
    return false;
  }
  for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
    const headerValue = getHeaderByName$1(headers2, matchHeaderName);
    if (!matchValue$3(matchHeaderValue, headerValue)) {
      return false;
    }
  }
  return true;
}
function safeUrl$1(path2) {
  if (typeof path2 !== "string") {
    return path2;
  }
  const pathSegments = path2.split("?");
  if (pathSegments.length !== 2) {
    return path2;
  }
  const qp = new URLSearchParams(pathSegments.pop());
  qp.sort();
  return [...pathSegments, qp.toString()].join("?");
}
function matchKey$1(mockDispatch2, { path: path2, method, body: body2, headers: headers2 }) {
  const pathMatch2 = matchValue$3(mockDispatch2.path, path2);
  const methodMatch = matchValue$3(mockDispatch2.method, method);
  const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue$3(mockDispatch2.body, body2) : true;
  const headersMatch = matchHeaders$1(mockDispatch2, headers2);
  return pathMatch2 && methodMatch && bodyMatch && headersMatch;
}
function getResponseData$3(data) {
  if (Buffer.isBuffer(data)) {
    return data;
  } else if (data instanceof Uint8Array) {
    return data;
  } else if (data instanceof ArrayBuffer) {
    return data;
  } else if (typeof data === "object") {
    return JSON.stringify(data);
  } else if (data) {
    return data.toString();
  } else {
    return "";
  }
}
function getMockDispatch$1(mockDispatches, key) {
  const basePath = key.query ? serializePathWithQuery$1(key.path, key.query) : key.path;
  const resolvedPath = typeof basePath === "string" ? safeUrl$1(basePath) : basePath;
  const resolvedPathWithoutTrailingSlash = removeTrailingSlash(resolvedPath);
  let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path: path2, ignoreTrailingSlash }) => {
    return ignoreTrailingSlash ? matchValue$3(removeTrailingSlash(safeUrl$1(path2)), resolvedPathWithoutTrailingSlash) : matchValue$3(safeUrl$1(path2), resolvedPath);
  });
  if (matchedMockDispatches.length === 0) {
    throw new MockNotMatchedError$2(`Mock dispatch not matched for path '${resolvedPath}'`);
  }
  matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue$3(method, key.method));
  if (matchedMockDispatches.length === 0) {
    throw new MockNotMatchedError$2(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`);
  }
  matchedMockDispatches = matchedMockDispatches.filter(({ body: body2 }) => typeof body2 !== "undefined" ? matchValue$3(body2, key.body) : true);
  if (matchedMockDispatches.length === 0) {
    throw new MockNotMatchedError$2(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`);
  }
  matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders$1(mockDispatch2, key.headers));
  if (matchedMockDispatches.length === 0) {
    const headers2 = typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers;
    throw new MockNotMatchedError$2(`Mock dispatch not matched for headers '${headers2}' on path '${resolvedPath}'`);
  }
  return matchedMockDispatches[0];
}
function addMockDispatch$3(mockDispatches, key, data, opts) {
  const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false, ...opts };
  const replyData = typeof data === "function" ? { callback: data } : { ...data };
  const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
  mockDispatches.push(newMockDispatch);
  return newMockDispatch;
}
function deleteMockDispatch$1(mockDispatches, key) {
  const index = mockDispatches.findIndex((dispatch) => {
    if (!dispatch.consumed) {
      return false;
    }
    return matchKey$1(dispatch, key);
  });
  if (index !== -1) {
    mockDispatches.splice(index, 1);
  }
}
function removeTrailingSlash(path2) {
  while (path2.endsWith("/")) {
    path2 = path2.slice(0, -1);
  }
  if (path2.length === 0) {
    path2 = "/";
  }
  return path2;
}
function buildKey$3(opts) {
  const { path: path2, method, body: body2, headers: headers2, query } = opts;
  return {
    path: path2,
    method,
    body: body2,
    headers: headers2,
    query
  };
}
function generateKeyValues$1(data) {
  const keys = Object.keys(data);
  const result = [];
  for (let i = 0; i < keys.length; ++i) {
    const key = keys[i];
    const value = data[key];
    const name = Buffer.from(`${key}`);
    if (Array.isArray(value)) {
      for (let j = 0; j < value.length; ++j) {
        result.push(name, Buffer.from(`${value[j]}`));
      }
    } else {
      result.push(name, Buffer.from(`${value}`));
    }
  }
  return result;
}
function getStatusText$1(statusCode) {
  return STATUS_CODES$1[statusCode] || "unknown";
}
function mockDispatch$1(opts, handler) {
  const key = buildKey$3(opts);
  const mockDispatch2 = getMockDispatch$1(this[kDispatches$9], key);
  mockDispatch2.timesInvoked++;
  if (mockDispatch2.data.callback) {
    mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
  }
  const { data: { statusCode, data, headers: headers2, trailers, error }, delay, persist } = mockDispatch2;
  const { timesInvoked, times } = mockDispatch2;
  mockDispatch2.consumed = !persist && timesInvoked >= times;
  mockDispatch2.pending = timesInvoked < times;
  if (error !== null) {
    deleteMockDispatch$1(this[kDispatches$9], key);
    handler.onError(error);
    return true;
  }
  if (typeof delay === "number" && delay > 0) {
    setTimeout(() => {
      handleReply(this[kDispatches$9]);
    }, delay);
  } else {
    handleReply(this[kDispatches$9]);
  }
  function handleReply(mockDispatches, _data = data) {
    var _a2, _b2, _c2, _d2;
    const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray$1(opts.headers) : opts.headers;
    const body2 = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
    if (isPromise$1(body2)) {
      body2.then((newData) => handleReply(mockDispatches, newData));
      return;
    }
    const responseData = getResponseData$3(body2);
    const responseHeaders = generateKeyValues$1(headers2);
    const responseTrailers = generateKeyValues$1(trailers);
    (_a2 = handler.onConnect) == null ? void 0 : _a2.call(handler, (err) => handler.onError(err), null);
    (_b2 = handler.onHeaders) == null ? void 0 : _b2.call(handler, statusCode, responseHeaders, resume2, getStatusText$1(statusCode));
    (_c2 = handler.onData) == null ? void 0 : _c2.call(handler, Buffer.from(responseData));
    (_d2 = handler.onComplete) == null ? void 0 : _d2.call(handler, responseTrailers);
    deleteMockDispatch$1(mockDispatches, key);
  }
  function resume2() {
  }
  return true;
}
function buildMockDispatch$5() {
  const agent2 = this[kMockAgent$5];
  const origin = this[kOrigin$5];
  const originalDispatch = this[kOriginalDispatch$5];
  return function dispatch(opts, handler) {
    if (agent2.isMockActive) {
      try {
        mockDispatch$1.call(this, opts, handler);
      } catch (error) {
        if (error instanceof MockNotMatchedError$2) {
          const netConnect = agent2[kGetNetConnect$3]();
          if (netConnect === false) {
            throw new MockNotMatchedError$2(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
          }
          if (checkNetConnect$1(netConnect, origin)) {
            originalDispatch.call(this, opts, handler);
          } else {
            throw new MockNotMatchedError$2(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
          }
        } else {
          throw error;
        }
      }
    } else {
      originalDispatch.call(this, opts, handler);
    }
  };
}
function checkNetConnect$1(netConnect, origin) {
  const url = new URL(origin);
  if (netConnect === true) {
    return true;
  } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue$3(matcher, url.host))) {
    return true;
  }
  return false;
}
function buildAndValidateMockOptions$1(opts) {
  if (opts) {
    const { agent: agent2, ...mockOptions } = opts;
    if ("enableCallHistory" in mockOptions && typeof mockOptions.enableCallHistory !== "boolean") {
      throw new InvalidArgumentError$y("options.enableCallHistory must to be a boolean");
    }
    return mockOptions;
  }
}
var mockUtils$1 = {
  getResponseData: getResponseData$3,
  addMockDispatch: addMockDispatch$3,
  buildKey: buildKey$3,
  matchValue: matchValue$3,
  buildMockDispatch: buildMockDispatch$5,
  buildAndValidateMockOptions: buildAndValidateMockOptions$1
};
var mockInterceptor$1 = {};
const { getResponseData: getResponseData$2, buildKey: buildKey$2, addMockDispatch: addMockDispatch$2 } = mockUtils$1;
const {
  kDispatches: kDispatches$8,
  kDispatchKey: kDispatchKey$1,
  kDefaultHeaders: kDefaultHeaders$1,
  kDefaultTrailers: kDefaultTrailers$1,
  kContentLength: kContentLength$2,
  kMockDispatch: kMockDispatch$1,
  kIgnoreTrailingSlash: kIgnoreTrailingSlash$2
} = mockSymbols$1;
const { InvalidArgumentError: InvalidArgumentError$x } = errors$2;
const { serializePathWithQuery } = util$J;
let MockScope$1 = class MockScope {
  constructor(mockDispatch2) {
    this[kMockDispatch$1] = mockDispatch2;
  }
  /**
   * Delay a reply by a set amount in ms.
   */
  delay(waitInMs) {
    if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
      throw new InvalidArgumentError$x("waitInMs must be a valid integer > 0");
    }
    this[kMockDispatch$1].delay = waitInMs;
    return this;
  }
  /**
   * For a defined reply, never mark as consumed.
   */
  persist() {
    this[kMockDispatch$1].persist = true;
    return this;
  }
  /**
   * Allow one to define a reply for a set amount of matching requests.
   */
  times(repeatTimes) {
    if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
      throw new InvalidArgumentError$x("repeatTimes must be a valid integer > 0");
    }
    this[kMockDispatch$1].times = repeatTimes;
    return this;
  }
};
let MockInterceptor$5 = class MockInterceptor {
  constructor(opts, mockDispatches) {
    if (typeof opts !== "object") {
      throw new InvalidArgumentError$x("opts must be an object");
    }
    if (typeof opts.path === "undefined") {
      throw new InvalidArgumentError$x("opts.path must be defined");
    }
    if (typeof opts.method === "undefined") {
      opts.method = "GET";
    }
    if (typeof opts.path === "string") {
      if (opts.query) {
        opts.path = serializePathWithQuery(opts.path, opts.query);
      } else {
        const parsedURL = new URL(opts.path, "data://");
        opts.path = parsedURL.pathname + parsedURL.search;
      }
    }
    if (typeof opts.method === "string") {
      opts.method = opts.method.toUpperCase();
    }
    this[kDispatchKey$1] = buildKey$2(opts);
    this[kDispatches$8] = mockDispatches;
    this[kIgnoreTrailingSlash$2] = opts.ignoreTrailingSlash ?? false;
    this[kDefaultHeaders$1] = {};
    this[kDefaultTrailers$1] = {};
    this[kContentLength$2] = false;
  }
  createMockScopeDispatchData({ statusCode, data, responseOptions }) {
    const responseData = getResponseData$2(data);
    const contentLength = this[kContentLength$2] ? { "content-length": responseData.length } : {};
    const headers2 = { ...this[kDefaultHeaders$1], ...contentLength, ...responseOptions.headers };
    const trailers = { ...this[kDefaultTrailers$1], ...responseOptions.trailers };
    return { statusCode, data, headers: headers2, trailers };
  }
  validateReplyParameters(replyParameters) {
    if (typeof replyParameters.statusCode === "undefined") {
      throw new InvalidArgumentError$x("statusCode must be defined");
    }
    if (typeof replyParameters.responseOptions !== "object" || replyParameters.responseOptions === null) {
      throw new InvalidArgumentError$x("responseOptions must be an object");
    }
  }
  /**
   * Mock an undici request with a defined reply.
   */
  reply(replyOptionsCallbackOrStatusCode) {
    if (typeof replyOptionsCallbackOrStatusCode === "function") {
      const wrappedDefaultsCallback = (opts) => {
        const resolvedData = replyOptionsCallbackOrStatusCode(opts);
        if (typeof resolvedData !== "object" || resolvedData === null) {
          throw new InvalidArgumentError$x("reply options callback must return an object");
        }
        const replyParameters2 = { data: "", responseOptions: {}, ...resolvedData };
        this.validateReplyParameters(replyParameters2);
        return {
          ...this.createMockScopeDispatchData(replyParameters2)
        };
      };
      const newMockDispatch2 = addMockDispatch$2(this[kDispatches$8], this[kDispatchKey$1], wrappedDefaultsCallback, { ignoreTrailingSlash: this[kIgnoreTrailingSlash$2] });
      return new MockScope$1(newMockDispatch2);
    }
    const replyParameters = {
      statusCode: replyOptionsCallbackOrStatusCode,
      data: arguments[1] === void 0 ? "" : arguments[1],
      responseOptions: arguments[2] === void 0 ? {} : arguments[2]
    };
    this.validateReplyParameters(replyParameters);
    const dispatchData = this.createMockScopeDispatchData(replyParameters);
    const newMockDispatch = addMockDispatch$2(this[kDispatches$8], this[kDispatchKey$1], dispatchData, { ignoreTrailingSlash: this[kIgnoreTrailingSlash$2] });
    return new MockScope$1(newMockDispatch);
  }
  /**
   * Mock an undici request with a defined error.
   */
  replyWithError(error) {
    if (typeof error === "undefined") {
      throw new InvalidArgumentError$x("error must be defined");
    }
    const newMockDispatch = addMockDispatch$2(this[kDispatches$8], this[kDispatchKey$1], { error }, { ignoreTrailingSlash: this[kIgnoreTrailingSlash$2] });
    return new MockScope$1(newMockDispatch);
  }
  /**
   * Set default reply headers on the interceptor for subsequent replies
   */
  defaultReplyHeaders(headers2) {
    if (typeof headers2 === "undefined") {
      throw new InvalidArgumentError$x("headers must be defined");
    }
    this[kDefaultHeaders$1] = headers2;
    return this;
  }
  /**
   * Set default reply trailers on the interceptor for subsequent replies
   */
  defaultReplyTrailers(trailers) {
    if (typeof trailers === "undefined") {
      throw new InvalidArgumentError$x("trailers must be defined");
    }
    this[kDefaultTrailers$1] = trailers;
    return this;
  }
  /**
   * Set reply content length header for replies on the interceptor
   */
  replyContentLength() {
    this[kContentLength$2] = true;
    return this;
  }
};
mockInterceptor$1.MockInterceptor = MockInterceptor$5;
mockInterceptor$1.MockScope = MockScope$1;
const { promisify: promisify$3 } = require$$0$2;
const Client$5 = client$1;
const { buildMockDispatch: buildMockDispatch$4 } = mockUtils$1;
const {
  kDispatches: kDispatches$7,
  kMockAgent: kMockAgent$4,
  kClose: kClose$9,
  kOriginalClose: kOriginalClose$3,
  kOrigin: kOrigin$4,
  kOriginalDispatch: kOriginalDispatch$4,
  kConnected: kConnected$6,
  kIgnoreTrailingSlash: kIgnoreTrailingSlash$1
} = mockSymbols$1;
const { MockInterceptor: MockInterceptor$4 } = mockInterceptor$1;
const Symbols$3 = symbols$5;
const { InvalidArgumentError: InvalidArgumentError$w } = errors$2;
let MockClient$4 = class MockClient extends Client$5 {
  constructor(origin, opts) {
    if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
      throw new InvalidArgumentError$w("Argument opts.agent must implement Agent");
    }
    super(origin, opts);
    this[kMockAgent$4] = opts.agent;
    this[kOrigin$4] = origin;
    this[kIgnoreTrailingSlash$1] = opts.ignoreTrailingSlash ?? false;
    this[kDispatches$7] = [];
    this[kConnected$6] = 1;
    this[kOriginalDispatch$4] = this.dispatch;
    this[kOriginalClose$3] = this.close.bind(this);
    this.dispatch = buildMockDispatch$4.call(this);
    this.close = this[kClose$9];
  }
  get [Symbols$3.kConnected]() {
    return this[kConnected$6];
  }
  /**
   * Sets up the base interceptor for mocking replies from undici.
   */
  intercept(opts) {
    return new MockInterceptor$4(
      opts && { ignoreTrailingSlash: this[kIgnoreTrailingSlash$1], ...opts },
      this[kDispatches$7]
    );
  }
  async [kClose$9]() {
    await promisify$3(this[kOriginalClose$3])();
    this[kConnected$6] = 0;
    this[kMockAgent$4][Symbols$3.kClients].delete(this[kOrigin$4]);
  }
};
var mockClient$1 = MockClient$4;
var mockCallHistory = {};
const { kMockCallHistoryAddLog: kMockCallHistoryAddLog$1 } = mockSymbols$1;
const { InvalidArgumentError: InvalidArgumentError$v } = errors$2;
function handleFilterCallsWithOptions(criteria, options, handler, store2) {
  switch (options.operator) {
    case "OR":
      store2.push(...handler(criteria));
      return store2;
    case "AND":
      return handler.call({ logs: store2 }, criteria);
    default:
      throw new InvalidArgumentError$v("options.operator must to be a case insensitive string equal to 'OR' or 'AND'");
  }
}
function buildAndValidateFilterCallsOptions(options = {}) {
  const finalOptions = {};
  if ("operator" in options) {
    if (typeof options.operator !== "string" || options.operator.toUpperCase() !== "OR" && options.operator.toUpperCase() !== "AND") {
      throw new InvalidArgumentError$v("options.operator must to be a case insensitive string equal to 'OR' or 'AND'");
    }
    return {
      ...finalOptions,
      operator: options.operator.toUpperCase()
    };
  }
  return finalOptions;
}
function makeFilterCalls(parameterName) {
  return (parameterValue) => {
    if (typeof parameterValue === "string" || parameterValue == null) {
      return this.logs.filter((log) => {
        return log[parameterName] === parameterValue;
      });
    }
    if (parameterValue instanceof RegExp) {
      return this.logs.filter((log) => {
        return parameterValue.test(log[parameterName]);
      });
    }
    throw new InvalidArgumentError$v(`${parameterName} parameter should be one of string, regexp, undefined or null`);
  };
}
function computeUrlWithMaybeSearchParameters(requestInit) {
  try {
    const url = new URL(requestInit.path, requestInit.origin);
    if (url.search.length !== 0) {
      return url;
    }
    url.search = new URLSearchParams(requestInit.query).toString();
    return url;
  } catch (error) {
    throw new InvalidArgumentError$v("An error occurred when computing MockCallHistoryLog.url", { cause: error });
  }
}
class MockCallHistoryLog {
  constructor(requestInit = {}) {
    this.body = requestInit.body;
    this.headers = requestInit.headers;
    this.method = requestInit.method;
    const url = computeUrlWithMaybeSearchParameters(requestInit);
    this.fullUrl = url.toString();
    this.origin = url.origin;
    this.path = url.pathname;
    this.searchParams = Object.fromEntries(url.searchParams);
    this.protocol = url.protocol;
    this.host = url.host;
    this.port = url.port;
    this.hash = url.hash;
  }
  toMap() {
    return /* @__PURE__ */ new Map(
      [
        ["protocol", this.protocol],
        ["host", this.host],
        ["port", this.port],
        ["origin", this.origin],
        ["path", this.path],
        ["hash", this.hash],
        ["searchParams", this.searchParams],
        ["fullUrl", this.fullUrl],
        ["method", this.method],
        ["body", this.body],
        ["headers", this.headers]
      ]
    );
  }
  toString() {
    const options = { betweenKeyValueSeparator: "->", betweenPairSeparator: "|" };
    let result = "";
    this.toMap().forEach((value, key) => {
      if (typeof value === "string" || value === void 0 || value === null) {
        result = `${result}${key}${options.betweenKeyValueSeparator}${value}${options.betweenPairSeparator}`;
      }
      if (typeof value === "object" && value !== null || Array.isArray(value)) {
        result = `${result}${key}${options.betweenKeyValueSeparator}${JSON.stringify(value)}${options.betweenPairSeparator}`;
      }
    });
    return result.slice(0, -1);
  }
}
let MockCallHistory$1 = class MockCallHistory {
  constructor() {
    __publicField(this, "logs", []);
    __publicField(this, "filterCallsByProtocol", makeFilterCalls.call(this, "protocol"));
    __publicField(this, "filterCallsByHost", makeFilterCalls.call(this, "host"));
    __publicField(this, "filterCallsByPort", makeFilterCalls.call(this, "port"));
    __publicField(this, "filterCallsByOrigin", makeFilterCalls.call(this, "origin"));
    __publicField(this, "filterCallsByPath", makeFilterCalls.call(this, "path"));
    __publicField(this, "filterCallsByHash", makeFilterCalls.call(this, "hash"));
    __publicField(this, "filterCallsByFullUrl", makeFilterCalls.call(this, "fullUrl"));
    __publicField(this, "filterCallsByMethod", makeFilterCalls.call(this, "method"));
  }
  calls() {
    return this.logs;
  }
  firstCall() {
    return this.logs.at(0);
  }
  lastCall() {
    return this.logs.at(-1);
  }
  nthCall(number) {
    if (typeof number !== "number") {
      throw new InvalidArgumentError$v("nthCall must be called with a number");
    }
    if (!Number.isInteger(number)) {
      throw new InvalidArgumentError$v("nthCall must be called with an integer");
    }
    if (Math.sign(number) !== 1) {
      throw new InvalidArgumentError$v("nthCall must be called with a positive value. use firstCall or lastCall instead");
    }
    return this.logs.at(number - 1);
  }
  filterCalls(criteria, options) {
    if (this.logs.length === 0) {
      return this.logs;
    }
    if (typeof criteria === "function") {
      return this.logs.filter(criteria);
    }
    if (criteria instanceof RegExp) {
      return this.logs.filter((log) => {
        return criteria.test(log.toString());
      });
    }
    if (typeof criteria === "object" && criteria !== null) {
      if (Object.keys(criteria).length === 0) {
        return this.logs;
      }
      const finalOptions = { operator: "OR", ...buildAndValidateFilterCallsOptions(options) };
      let maybeDuplicatedLogsFiltered = [];
      if ("protocol" in criteria) {
        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.protocol, finalOptions, this.filterCallsByProtocol, maybeDuplicatedLogsFiltered);
      }
      if ("host" in criteria) {
        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.host, finalOptions, this.filterCallsByHost, maybeDuplicatedLogsFiltered);
      }
      if ("port" in criteria) {
        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.port, finalOptions, this.filterCallsByPort, maybeDuplicatedLogsFiltered);
      }
      if ("origin" in criteria) {
        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.origin, finalOptions, this.filterCallsByOrigin, maybeDuplicatedLogsFiltered);
      }
      if ("path" in criteria) {
        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.path, finalOptions, this.filterCallsByPath, maybeDuplicatedLogsFiltered);
      }
      if ("hash" in criteria) {
        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.hash, finalOptions, this.filterCallsByHash, maybeDuplicatedLogsFiltered);
      }
      if ("fullUrl" in criteria) {
        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.fullUrl, finalOptions, this.filterCallsByFullUrl, maybeDuplicatedLogsFiltered);
      }
      if ("method" in criteria) {
        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.method, finalOptions, this.filterCallsByMethod, maybeDuplicatedLogsFiltered);
      }
      const uniqLogsFiltered = [...new Set(maybeDuplicatedLogsFiltered)];
      return uniqLogsFiltered;
    }
    throw new InvalidArgumentError$v("criteria parameter should be one of function, regexp, or object");
  }
  clear() {
    this.logs = [];
  }
  [kMockCallHistoryAddLog$1](requestInit) {
    const log = new MockCallHistoryLog(requestInit);
    this.logs.push(log);
    return log;
  }
  *[Symbol.iterator]() {
    for (const log of this.calls()) {
      yield log;
    }
  }
};
mockCallHistory.MockCallHistory = MockCallHistory$1;
mockCallHistory.MockCallHistoryLog = MockCallHistoryLog;
const { promisify: promisify$2 } = require$$0$2;
const Pool$6 = pool$1;
const { buildMockDispatch: buildMockDispatch$3 } = mockUtils$1;
const {
  kDispatches: kDispatches$6,
  kMockAgent: kMockAgent$3,
  kClose: kClose$8,
  kOriginalClose: kOriginalClose$2,
  kOrigin: kOrigin$3,
  kOriginalDispatch: kOriginalDispatch$3,
  kConnected: kConnected$5,
  kIgnoreTrailingSlash
} = mockSymbols$1;
const { MockInterceptor: MockInterceptor$3 } = mockInterceptor$1;
const Symbols$2 = symbols$5;
const { InvalidArgumentError: InvalidArgumentError$u } = errors$2;
let MockPool$4 = class MockPool extends Pool$6 {
  constructor(origin, opts) {
    if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
      throw new InvalidArgumentError$u("Argument opts.agent must implement Agent");
    }
    super(origin, opts);
    this[kMockAgent$3] = opts.agent;
    this[kOrigin$3] = origin;
    this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false;
    this[kDispatches$6] = [];
    this[kConnected$5] = 1;
    this[kOriginalDispatch$3] = this.dispatch;
    this[kOriginalClose$2] = this.close.bind(this);
    this.dispatch = buildMockDispatch$3.call(this);
    this.close = this[kClose$8];
  }
  get [Symbols$2.kConnected]() {
    return this[kConnected$5];
  }
  /**
   * Sets up the base interceptor for mocking replies from undici.
   */
  intercept(opts) {
    return new MockInterceptor$3(
      opts && { ignoreTrailingSlash: this[kIgnoreTrailingSlash], ...opts },
      this[kDispatches$6]
    );
  }
  async [kClose$8]() {
    await promisify$2(this[kOriginalClose$2])();
    this[kConnected$5] = 0;
    this[kMockAgent$3][Symbols$2.kClients].delete(this[kOrigin$3]);
  }
};
var mockPool$1 = MockPool$4;
const { Transform: Transform$1 } = require$$0$4;
const { Console: Console$1 } = require$$1$5;
const PERSISTENT$1 = process.versions.icu ? "✅" : "Y ";
const NOT_PERSISTENT$1 = process.versions.icu ? "❌" : "N ";
var pendingInterceptorsFormatter$1 = class PendingInterceptorsFormatter {
  constructor({ disableColors } = {}) {
    this.transform = new Transform$1({
      transform(chunk, _enc, cb) {
        cb(null, chunk);
      }
    });
    this.logger = new Console$1({
      stdout: this.transform,
      inspectOptions: {
        colors: !disableColors && !process.env.CI
      }
    });
  }
  format(pendingInterceptors) {
    const withPrettyHeaders = pendingInterceptors.map(
      ({ method, path: path2, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
        Method: method,
        Origin: origin,
        Path: path2,
        "Status code": statusCode,
        Persistent: persist ? PERSISTENT$1 : NOT_PERSISTENT$1,
        Invocations: timesInvoked,
        Remaining: persist ? Infinity : times - timesInvoked
      })
    );
    this.logger.table(withPrettyHeaders);
    return this.transform.read().toString();
  }
};
const { kClients: kClients$5 } = symbols$5;
const Agent$7 = agent$3;
const {
  kAgent: kAgent$2,
  kMockAgentSet: kMockAgentSet$1,
  kMockAgentGet: kMockAgentGet$1,
  kDispatches: kDispatches$5,
  kIsMockActive: kIsMockActive$1,
  kNetConnect: kNetConnect$1,
  kGetNetConnect: kGetNetConnect$2,
  kOptions: kOptions$4,
  kFactory: kFactory$4,
  kMockAgentRegisterCallHistory,
  kMockAgentIsCallHistoryEnabled,
  kMockAgentAddCallHistoryLog,
  kMockAgentMockCallHistoryInstance,
  kMockCallHistoryAddLog
} = mockSymbols$1;
const MockClient$3 = mockClient$1;
const MockPool$3 = mockPool$1;
const { matchValue: matchValue$2, buildAndValidateMockOptions } = mockUtils$1;
const { InvalidArgumentError: InvalidArgumentError$t, UndiciError: UndiciError$3 } = errors$2;
const Dispatcher$5 = dispatcher$1;
const PendingInterceptorsFormatter$1 = pendingInterceptorsFormatter$1;
const { MockCallHistory: MockCallHistory2 } = mockCallHistory;
let MockAgent$2 = class MockAgent extends Dispatcher$5 {
  constructor(opts) {
    super(opts);
    const mockOptions = buildAndValidateMockOptions(opts);
    this[kNetConnect$1] = true;
    this[kIsMockActive$1] = true;
    this[kMockAgentIsCallHistoryEnabled] = (mockOptions == null ? void 0 : mockOptions.enableCallHistory) ?? false;
    if ((opts == null ? void 0 : opts.agent) && typeof opts.agent.dispatch !== "function") {
      throw new InvalidArgumentError$t("Argument opts.agent must implement Agent");
    }
    const agent2 = (opts == null ? void 0 : opts.agent) ? opts.agent : new Agent$7(opts);
    this[kAgent$2] = agent2;
    this[kClients$5] = agent2[kClients$5];
    this[kOptions$4] = mockOptions;
    if (this[kMockAgentIsCallHistoryEnabled]) {
      this[kMockAgentRegisterCallHistory]();
    }
  }
  get(origin) {
    let dispatcher2 = this[kMockAgentGet$1](origin);
    if (!dispatcher2) {
      dispatcher2 = this[kFactory$4](origin);
      this[kMockAgentSet$1](origin, dispatcher2);
    }
    return dispatcher2;
  }
  dispatch(opts, handler) {
    this.get(opts.origin);
    this[kMockAgentAddCallHistoryLog](opts);
    return this[kAgent$2].dispatch(opts, handler);
  }
  async close() {
    this.clearCallHistory();
    await this[kAgent$2].close();
    this[kClients$5].clear();
  }
  deactivate() {
    this[kIsMockActive$1] = false;
  }
  activate() {
    this[kIsMockActive$1] = true;
  }
  enableNetConnect(matcher) {
    if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
      if (Array.isArray(this[kNetConnect$1])) {
        this[kNetConnect$1].push(matcher);
      } else {
        this[kNetConnect$1] = [matcher];
      }
    } else if (typeof matcher === "undefined") {
      this[kNetConnect$1] = true;
    } else {
      throw new InvalidArgumentError$t("Unsupported matcher. Must be one of String|Function|RegExp.");
    }
  }
  disableNetConnect() {
    this[kNetConnect$1] = false;
  }
  enableCallHistory() {
    this[kMockAgentIsCallHistoryEnabled] = true;
    return this;
  }
  disableCallHistory() {
    this[kMockAgentIsCallHistoryEnabled] = false;
    return this;
  }
  getCallHistory() {
    return this[kMockAgentMockCallHistoryInstance];
  }
  clearCallHistory() {
    if (this[kMockAgentMockCallHistoryInstance] !== void 0) {
      this[kMockAgentMockCallHistoryInstance].clear();
    }
  }
  // This is required to bypass issues caused by using global symbols - see:
  // https://github.com/nodejs/undici/issues/1447
  get isMockActive() {
    return this[kIsMockActive$1];
  }
  [kMockAgentRegisterCallHistory]() {
    if (this[kMockAgentMockCallHistoryInstance] === void 0) {
      this[kMockAgentMockCallHistoryInstance] = new MockCallHistory2();
    }
  }
  [kMockAgentAddCallHistoryLog](opts) {
    if (this[kMockAgentIsCallHistoryEnabled]) {
      this[kMockAgentRegisterCallHistory]();
      this[kMockAgentMockCallHistoryInstance][kMockCallHistoryAddLog](opts);
    }
  }
  [kMockAgentSet$1](origin, dispatcher2) {
    this[kClients$5].set(origin, dispatcher2);
  }
  [kFactory$4](origin) {
    const mockOptions = Object.assign({ agent: this }, this[kOptions$4]);
    return this[kOptions$4] && this[kOptions$4].connections === 1 ? new MockClient$3(origin, mockOptions) : new MockPool$3(origin, mockOptions);
  }
  [kMockAgentGet$1](origin) {
    const client2 = this[kClients$5].get(origin);
    if (client2) {
      return client2;
    }
    if (typeof origin !== "string") {
      const dispatcher2 = this[kFactory$4]("http://localhost:9999");
      this[kMockAgentSet$1](origin, dispatcher2);
      return dispatcher2;
    }
    for (const [keyMatcher, nonExplicitDispatcher] of Array.from(this[kClients$5])) {
      if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue$2(keyMatcher, origin)) {
        const dispatcher2 = this[kFactory$4](origin);
        this[kMockAgentSet$1](origin, dispatcher2);
        dispatcher2[kDispatches$5] = nonExplicitDispatcher[kDispatches$5];
        return dispatcher2;
      }
    }
  }
  [kGetNetConnect$2]() {
    return this[kNetConnect$1];
  }
  pendingInterceptors() {
    const mockAgentClients = this[kClients$5];
    return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope[kDispatches$5].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
  }
  assertNoPendingInterceptors({ pendingInterceptorsFormatter: pendingInterceptorsFormatter2 = new PendingInterceptorsFormatter$1() } = {}) {
    const pending = this.pendingInterceptors();
    if (pending.length === 0) {
      return;
    }
    throw new UndiciError$3(
      pending.length === 1 ? `1 interceptor is pending:

${pendingInterceptorsFormatter2.format(pending)}`.trim() : `${pending.length} interceptors are pending:

${pendingInterceptorsFormatter2.format(pending)}`.trim()
    );
  }
};
var mockAgent$1 = MockAgent$2;
const globalDispatcher$1 = Symbol.for("undici.globalDispatcher.1");
const { InvalidArgumentError: InvalidArgumentError$s } = errors$2;
const Agent$6 = agent$3;
if (getGlobalDispatcher$2() === void 0) {
  setGlobalDispatcher$2(new Agent$6());
}
function setGlobalDispatcher$2(agent2) {
  if (!agent2 || typeof agent2.dispatch !== "function") {
    throw new InvalidArgumentError$s("Argument agent must implement Agent");
  }
  Object.defineProperty(globalThis, globalDispatcher$1, {
    value: agent2,
    writable: true,
    enumerable: false,
    configurable: false
  });
}
function getGlobalDispatcher$2() {
  return globalThis[globalDispatcher$1];
}
var global$3 = {
  setGlobalDispatcher: setGlobalDispatcher$2,
  getGlobalDispatcher: getGlobalDispatcher$2
};
const assert$i = require$$0$3;
const WrapHandler = wrapHandler;
var decoratorHandler$1 = (_h = class {
  constructor(handler) {
    __privateAdd(this, _handler3);
    __privateAdd(this, _onCompleteCalled, false);
    __privateAdd(this, _onErrorCalled, false);
    __privateAdd(this, _onResponseStartCalled, false);
    if (typeof handler !== "object" || handler === null) {
      throw new TypeError("handler must be an object");
    }
    __privateSet(this, _handler3, WrapHandler.wrap(handler));
  }
  onRequestStart(...args) {
    var _a2, _b2;
    (_b2 = (_a2 = __privateGet(this, _handler3)).onRequestStart) == null ? void 0 : _b2.call(_a2, ...args);
  }
  onRequestUpgrade(...args) {
    var _a2, _b2;
    assert$i(!__privateGet(this, _onCompleteCalled));
    assert$i(!__privateGet(this, _onErrorCalled));
    return (_b2 = (_a2 = __privateGet(this, _handler3)).onRequestUpgrade) == null ? void 0 : _b2.call(_a2, ...args);
  }
  onResponseStart(...args) {
    var _a2, _b2;
    assert$i(!__privateGet(this, _onCompleteCalled));
    assert$i(!__privateGet(this, _onErrorCalled));
    assert$i(!__privateGet(this, _onResponseStartCalled));
    __privateSet(this, _onResponseStartCalled, true);
    return (_b2 = (_a2 = __privateGet(this, _handler3)).onResponseStart) == null ? void 0 : _b2.call(_a2, ...args);
  }
  onResponseData(...args) {
    var _a2, _b2;
    assert$i(!__privateGet(this, _onCompleteCalled));
    assert$i(!__privateGet(this, _onErrorCalled));
    return (_b2 = (_a2 = __privateGet(this, _handler3)).onResponseData) == null ? void 0 : _b2.call(_a2, ...args);
  }
  onResponseEnd(...args) {
    var _a2, _b2;
    assert$i(!__privateGet(this, _onCompleteCalled));
    assert$i(!__privateGet(this, _onErrorCalled));
    __privateSet(this, _onCompleteCalled, true);
    return (_b2 = (_a2 = __privateGet(this, _handler3)).onResponseEnd) == null ? void 0 : _b2.call(_a2, ...args);
  }
  onResponseError(...args) {
    var _a2, _b2;
    __privateSet(this, _onErrorCalled, true);
    return (_b2 = (_a2 = __privateGet(this, _handler3)).onResponseError) == null ? void 0 : _b2.call(_a2, ...args);
  }
  /**
   * @deprecated
   */
  onBodySent() {
  }
}, _handler3 = new WeakMap(), _onCompleteCalled = new WeakMap(), _onErrorCalled = new WeakMap(), _onResponseStartCalled = new WeakMap(), _h);
const util$u = util$J;
const { kBodyUsed: kBodyUsed$2 } = symbols$5;
const assert$h = require$$0$3;
const { InvalidArgumentError: InvalidArgumentError$r } = errors$2;
const EE$2 = require$$8$1;
const redirectableStatusCodes$1 = [300, 301, 302, 303, 307, 308];
const kBody$3 = Symbol("body");
const noop$5 = () => {
};
let BodyAsyncIterable$2 = class BodyAsyncIterable2 {
  constructor(body2) {
    this[kBody$3] = body2;
    this[kBodyUsed$2] = false;
  }
  async *[Symbol.asyncIterator]() {
    assert$h(!this[kBodyUsed$2], "disturbed");
    this[kBodyUsed$2] = true;
    yield* this[kBody$3];
  }
};
let RedirectHandler$5 = class RedirectHandler {
  static buildDispatch(dispatcher2, maxRedirections) {
    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
      throw new InvalidArgumentError$r("maxRedirections must be a positive number");
    }
    const dispatch = dispatcher2.dispatch.bind(dispatcher2);
    return (opts, originalHandler) => dispatch(opts, new RedirectHandler(dispatch, maxRedirections, opts, originalHandler));
  }
  constructor(dispatch, maxRedirections, opts, handler) {
    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
      throw new InvalidArgumentError$r("maxRedirections must be a positive number");
    }
    this.dispatch = dispatch;
    this.location = null;
    this.opts = { ...opts, maxRedirections: 0 };
    this.maxRedirections = maxRedirections;
    this.handler = handler;
    this.history = [];
    if (util$u.isStream(this.opts.body)) {
      if (util$u.bodyLength(this.opts.body) === 0) {
        this.opts.body.on("data", function() {
          assert$h(false);
        });
      }
      if (typeof this.opts.body.readableDidRead !== "boolean") {
        this.opts.body[kBodyUsed$2] = false;
        EE$2.prototype.on.call(this.opts.body, "data", function() {
          this[kBodyUsed$2] = true;
        });
      }
    } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
      this.opts.body = new BodyAsyncIterable$2(this.opts.body);
    } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util$u.isIterable(this.opts.body) && !util$u.isFormDataLike(this.opts.body)) {
      this.opts.body = new BodyAsyncIterable$2(this.opts.body);
    }
  }
  onRequestStart(controller, context) {
    var _a2, _b2;
    (_b2 = (_a2 = this.handler).onRequestStart) == null ? void 0 : _b2.call(_a2, controller, { ...context, history: this.history });
  }
  onRequestUpgrade(controller, statusCode, headers2, socket) {
    var _a2, _b2;
    (_b2 = (_a2 = this.handler).onRequestUpgrade) == null ? void 0 : _b2.call(_a2, controller, statusCode, headers2, socket);
  }
  onResponseStart(controller, statusCode, headers2, statusMessage) {
    var _a2, _b2;
    if (this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {
      throw new Error("max redirects");
    }
    if ((statusCode === 301 || statusCode === 302) && this.opts.method === "POST") {
      this.opts.method = "GET";
      if (util$u.isStream(this.opts.body)) {
        util$u.destroy(this.opts.body.on("error", noop$5));
      }
      this.opts.body = null;
    }
    if (statusCode === 303 && this.opts.method !== "HEAD") {
      this.opts.method = "GET";
      if (util$u.isStream(this.opts.body)) {
        util$u.destroy(this.opts.body.on("error", noop$5));
      }
      this.opts.body = null;
    }
    this.location = this.history.length >= this.maxRedirections || util$u.isDisturbed(this.opts.body) || redirectableStatusCodes$1.indexOf(statusCode) === -1 ? null : headers2.location;
    if (this.opts.origin) {
      this.history.push(new URL(this.opts.path, this.opts.origin));
    }
    if (!this.location) {
      (_b2 = (_a2 = this.handler).onResponseStart) == null ? void 0 : _b2.call(_a2, controller, statusCode, headers2, statusMessage);
      return;
    }
    const { origin, pathname, search } = util$u.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
    const path2 = search ? `${pathname}${search}` : pathname;
    this.opts.headers = cleanRequestHeaders$1(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
    this.opts.path = path2;
    this.opts.origin = origin;
    this.opts.maxRedirections = 0;
    this.opts.query = null;
  }
  onResponseData(controller, chunk) {
    var _a2, _b2;
    if (this.location) ;
    else {
      (_b2 = (_a2 = this.handler).onResponseData) == null ? void 0 : _b2.call(_a2, controller, chunk);
    }
  }
  onResponseEnd(controller, trailers) {
    if (this.location) {
      this.dispatch(this.opts, this);
    } else {
      this.handler.onResponseEnd(controller, trailers);
    }
  }
  onResponseError(controller, error) {
    var _a2, _b2;
    (_b2 = (_a2 = this.handler).onResponseError) == null ? void 0 : _b2.call(_a2, controller, error);
  }
};
function shouldRemoveHeader$1(header, removeContent, unknownOrigin) {
  if (header.length === 4) {
    return util$u.headerNameToString(header) === "host";
  }
  if (removeContent && util$u.headerNameToString(header).startsWith("content-")) {
    return true;
  }
  if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
    const name = util$u.headerNameToString(header);
    return name === "authorization" || name === "cookie" || name === "proxy-authorization";
  }
  return false;
}
function cleanRequestHeaders$1(headers2, removeContent, unknownOrigin) {
  const ret = [];
  if (Array.isArray(headers2)) {
    for (let i = 0; i < headers2.length; i += 2) {
      if (!shouldRemoveHeader$1(headers2[i], removeContent, unknownOrigin)) {
        ret.push(headers2[i], headers2[i + 1]);
      }
    }
  } else if (headers2 && typeof headers2 === "object") {
    const entries = typeof headers2[Symbol.iterator] === "function" ? headers2 : Object.entries(headers2);
    for (const [key, value] of entries) {
      if (!shouldRemoveHeader$1(key, removeContent, unknownOrigin)) {
        ret.push(key, value);
      }
    }
  } else {
    assert$h(headers2 == null, "headers must be an object or an array");
  }
  return ret;
}
var redirectHandler$1 = RedirectHandler$5;
const RedirectHandler$4 = redirectHandler$1;
function createRedirectInterceptor$4({ maxRedirections: defaultMaxRedirections } = {}) {
  return (dispatch) => {
    return function Intercept(opts, handler) {
      const { maxRedirections = defaultMaxRedirections, ...rest } = opts;
      if (maxRedirections == null || maxRedirections === 0) {
        return dispatch(opts, handler);
      }
      const dispatchOpts = { ...rest, maxRedirections: 0 };
      const redirectHandler2 = new RedirectHandler$4(dispatch, maxRedirections, dispatchOpts, handler);
      return dispatch(dispatchOpts, redirectHandler2);
    };
  };
}
var redirect$1 = createRedirectInterceptor$4;
const DecoratorHandler$5 = decoratorHandler$1;
const { ResponseError: ResponseError$1 } = errors$2;
class ResponseErrorHandler extends DecoratorHandler$5 {
  constructor(_opts5, { handler }) {
    super(handler);
    __privateAdd(this, _ResponseErrorHandler_instances);
    __privateAdd(this, _statusCode);
    __privateAdd(this, _contentType);
    __privateAdd(this, _decoder);
    __privateAdd(this, _headers);
    __privateAdd(this, _body);
  }
  onRequestStart(controller, context) {
    __privateSet(this, _statusCode, 0);
    __privateSet(this, _contentType, null);
    __privateSet(this, _decoder, null);
    __privateSet(this, _headers, null);
    __privateSet(this, _body, "");
    return super.onRequestStart(controller, context);
  }
  onResponseStart(controller, statusCode, headers2, statusMessage) {
    __privateSet(this, _statusCode, statusCode);
    __privateSet(this, _headers, headers2);
    __privateSet(this, _contentType, headers2["content-type"]);
    if (__privateGet(this, _statusCode) < 400) {
      return super.onResponseStart(controller, statusCode, headers2, statusMessage);
    }
    if (__privateMethod(this, _ResponseErrorHandler_instances, checkContentType_fn).call(this, "application/json") || __privateMethod(this, _ResponseErrorHandler_instances, checkContentType_fn).call(this, "text/plain")) {
      __privateSet(this, _decoder, new TextDecoder("utf-8"));
    }
  }
  onResponseData(controller, chunk) {
    var _a2;
    if (__privateGet(this, _statusCode) < 400) {
      return super.onResponseData(controller, chunk);
    }
    __privateSet(this, _body, __privateGet(this, _body) + (((_a2 = __privateGet(this, _decoder)) == null ? void 0 : _a2.decode(chunk, { stream: true })) ?? ""));
  }
  onResponseEnd(controller, trailers) {
    var _a2;
    if (__privateGet(this, _statusCode) >= 400) {
      __privateSet(this, _body, __privateGet(this, _body) + (((_a2 = __privateGet(this, _decoder)) == null ? void 0 : _a2.decode(void 0, { stream: false })) ?? ""));
      if (__privateMethod(this, _ResponseErrorHandler_instances, checkContentType_fn).call(this, "application/json")) {
        try {
          __privateSet(this, _body, JSON.parse(__privateGet(this, _body)));
        } catch {
        }
      }
      let err;
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      try {
        err = new ResponseError$1("Response Error", __privateGet(this, _statusCode), {
          body: __privateGet(this, _body),
          headers: __privateGet(this, _headers)
        });
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
      super.onResponseError(controller, err);
    } else {
      super.onResponseEnd(controller, trailers);
    }
  }
  onResponseError(controller, err) {
    super.onResponseError(controller, err);
  }
}
_statusCode = new WeakMap();
_contentType = new WeakMap();
_decoder = new WeakMap();
_headers = new WeakMap();
_body = new WeakMap();
_ResponseErrorHandler_instances = new WeakSet();
checkContentType_fn = function(contentType) {
  return (__privateGet(this, _contentType) ?? "").indexOf(contentType) === 0;
};
var responseError = () => {
  return (dispatch) => {
    return function Intercept(opts, handler) {
      return dispatch(opts, new ResponseErrorHandler(opts, { handler }));
    };
  };
};
const RetryHandler$4 = retryHandler$1;
var retry$1 = (globalOpts) => {
  return (dispatch) => {
    return function retryInterceptor(opts, handler) {
      return dispatch(
        opts,
        new RetryHandler$4(
          { ...opts, retryOptions: { ...globalOpts, ...opts.retryOptions } },
          {
            handler,
            dispatch
          }
        )
      );
    };
  };
};
const { InvalidArgumentError: InvalidArgumentError$q, RequestAbortedError: RequestAbortedError$9 } = errors$2;
const DecoratorHandler$4 = decoratorHandler$1;
let DumpHandler$1 = (_i = class extends DecoratorHandler$4 {
  constructor({ maxSize, signal }, handler) {
    if (maxSize != null && (!Number.isFinite(maxSize) || maxSize < 1)) {
      throw new InvalidArgumentError$q("maxSize must be a number greater than 0");
    }
    super(handler);
    __privateAdd(this, _DumpHandler_instances);
    __privateAdd(this, _maxSize, 1024 * 1024);
    __privateAdd(this, _dumped, false);
    __privateAdd(this, _size, 0);
    __privateAdd(this, _controller2, null);
    __publicField(this, "aborted", false);
    __publicField(this, "reason", false);
    __privateSet(this, _maxSize, maxSize ?? __privateGet(this, _maxSize));
  }
  onRequestStart(controller, context) {
    controller.abort = __privateMethod(this, _DumpHandler_instances, abort_fn).bind(this);
    __privateSet(this, _controller2, controller);
    return super.onRequestStart(controller, context);
  }
  onResponseStart(controller, statusCode, headers2, statusMessage) {
    const contentLength = headers2["content-length"];
    if (contentLength != null && contentLength > __privateGet(this, _maxSize)) {
      throw new RequestAbortedError$9(
        `Response size (${contentLength}) larger than maxSize (${__privateGet(this, _maxSize)})`
      );
    }
    if (this.aborted === true) {
      return true;
    }
    return super.onResponseStart(controller, statusCode, headers2, statusMessage);
  }
  onResponseError(controller, err) {
    if (__privateGet(this, _dumped)) {
      return;
    }
    err = __privateGet(this, _controller2).reason ?? err;
    super.onResponseError(controller, err);
  }
  onResponseData(controller, chunk) {
    __privateSet(this, _size, __privateGet(this, _size) + chunk.length);
    if (__privateGet(this, _size) >= __privateGet(this, _maxSize)) {
      __privateSet(this, _dumped, true);
      if (this.aborted === true) {
        super.onResponseError(controller, this.reason);
      } else {
        super.onResponseEnd(controller, {});
      }
    }
    return true;
  }
  onResponseEnd(controller, trailers) {
    if (__privateGet(this, _dumped)) {
      return;
    }
    if (__privateGet(this, _controller2).aborted === true) {
      super.onResponseError(controller, this.reason);
      return;
    }
    super.onResponseEnd(controller, trailers);
  }
}, _maxSize = new WeakMap(), _dumped = new WeakMap(), _size = new WeakMap(), _controller2 = new WeakMap(), _DumpHandler_instances = new WeakSet(), abort_fn = function(reason) {
  this.aborted = true;
  this.reason = reason;
}, _i);
function createDumpInterceptor$1({ maxSize: defaultMaxSize } = {
  maxSize: 1024 * 1024
}) {
  return (dispatch) => {
    return function Intercept(opts, handler) {
      const { dumpMaxSize = defaultMaxSize } = opts;
      const dumpHandler = new DumpHandler$1({ maxSize: dumpMaxSize, signal: opts.signal }, handler);
      return dispatch(opts, dumpHandler);
    };
  };
}
var dump$1 = createDumpInterceptor$1;
const { isIP: isIP$1 } = require$$0$5;
const { lookup: lookup$1 } = require$$1$6;
const DecoratorHandler$3 = decoratorHandler$1;
const { InvalidArgumentError: InvalidArgumentError$p, InformationalError: InformationalError$5 } = errors$2;
const maxInt$1 = Math.pow(2, 31) - 1;
let DNSInstance$1 = (_j = class {
  constructor(opts) {
    __privateAdd(this, _DNSInstance_instances);
    __privateAdd(this, _maxTTL, 0);
    __privateAdd(this, _maxItems, 0);
    __privateAdd(this, _records, /* @__PURE__ */ new Map());
    __publicField(this, "dualStack", true);
    __publicField(this, "affinity", null);
    __publicField(this, "lookup", null);
    __publicField(this, "pick", null);
    __privateSet(this, _maxTTL, opts.maxTTL);
    __privateSet(this, _maxItems, opts.maxItems);
    this.dualStack = opts.dualStack;
    this.affinity = opts.affinity;
    this.lookup = opts.lookup ?? __privateMethod(this, _DNSInstance_instances, defaultLookup_fn);
    this.pick = opts.pick ?? __privateMethod(this, _DNSInstance_instances, defaultPick_fn);
  }
  get full() {
    return __privateGet(this, _records).size === __privateGet(this, _maxItems);
  }
  runLookup(origin, opts, cb) {
    const ips = __privateGet(this, _records).get(origin.hostname);
    if (ips == null && this.full) {
      cb(null, origin);
      return;
    }
    const newOpts = {
      affinity: this.affinity,
      dualStack: this.dualStack,
      lookup: this.lookup,
      pick: this.pick,
      ...opts.dns,
      maxTTL: __privateGet(this, _maxTTL),
      maxItems: __privateGet(this, _maxItems)
    };
    if (ips == null) {
      this.lookup(origin, newOpts, (err, addresses) => {
        if (err || addresses == null || addresses.length === 0) {
          cb(err ?? new InformationalError$5("No DNS entries found"));
          return;
        }
        this.setRecords(origin, addresses);
        const records = __privateGet(this, _records).get(origin.hostname);
        const ip = this.pick(
          origin,
          records,
          newOpts.affinity
        );
        let port;
        if (typeof ip.port === "number") {
          port = `:${ip.port}`;
        } else if (origin.port !== "") {
          port = `:${origin.port}`;
        } else {
          port = "";
        }
        cb(
          null,
          new URL(`${origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`)
        );
      });
    } else {
      const ip = this.pick(
        origin,
        ips,
        newOpts.affinity
      );
      if (ip == null) {
        __privateGet(this, _records).delete(origin.hostname);
        this.runLookup(origin, opts, cb);
        return;
      }
      let port;
      if (typeof ip.port === "number") {
        port = `:${ip.port}`;
      } else if (origin.port !== "") {
        port = `:${origin.port}`;
      } else {
        port = "";
      }
      cb(
        null,
        new URL(`${origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`)
      );
    }
  }
  pickFamily(origin, ipFamily) {
    var _a2;
    const records = (_a2 = __privateGet(this, _records).get(origin.hostname)) == null ? void 0 : _a2.records;
    if (!records) {
      return null;
    }
    const family = records[ipFamily];
    if (!family) {
      return null;
    }
    if (family.offset == null || family.offset === maxInt$1) {
      family.offset = 0;
    } else {
      family.offset++;
    }
    const position = family.offset % family.ips.length;
    const ip = family.ips[position] ?? null;
    if (ip == null) {
      return ip;
    }
    if (Date.now() - ip.timestamp > ip.ttl) {
      family.ips.splice(position, 1);
    }
    return ip;
  }
  setRecords(origin, addresses) {
    const timestamp = Date.now();
    const records = { records: { 4: null, 6: null } };
    for (const record of addresses) {
      record.timestamp = timestamp;
      if (typeof record.ttl === "number") {
        record.ttl = Math.min(record.ttl, __privateGet(this, _maxTTL));
      } else {
        record.ttl = __privateGet(this, _maxTTL);
      }
      const familyRecords = records.records[record.family] ?? { ips: [] };
      familyRecords.ips.push(record);
      records.records[record.family] = familyRecords;
    }
    __privateGet(this, _records).set(origin.hostname, records);
  }
  deleteRecords(origin) {
    __privateGet(this, _records).delete(origin.hostname);
  }
  getHandler(meta, opts) {
    return new DNSDispatchHandler$1(this, meta, opts);
  }
}, _maxTTL = new WeakMap(), _maxItems = new WeakMap(), _records = new WeakMap(), _DNSInstance_instances = new WeakSet(), defaultLookup_fn = function(origin, opts, cb) {
  lookup$1(
    origin.hostname,
    {
      all: true,
      family: this.dualStack === false ? this.affinity : 0,
      order: "ipv4first"
    },
    (err, addresses) => {
      if (err) {
        return cb(err);
      }
      const results = /* @__PURE__ */ new Map();
      for (const addr of addresses) {
        results.set(`${addr.address}:${addr.family}`, addr);
      }
      cb(null, results.values());
    }
  );
}, defaultPick_fn = function(origin, hostnameRecords, affinity) {
  let ip = null;
  const { records, offset } = hostnameRecords;
  let family;
  if (this.dualStack) {
    if (affinity == null) {
      if (offset == null || offset === maxInt$1) {
        hostnameRecords.offset = 0;
        affinity = 4;
      } else {
        hostnameRecords.offset++;
        affinity = (hostnameRecords.offset & 1) === 1 ? 6 : 4;
      }
    }
    if (records[affinity] != null && records[affinity].ips.length > 0) {
      family = records[affinity];
    } else {
      family = records[affinity === 4 ? 6 : 4];
    }
  } else {
    family = records[affinity];
  }
  if (family == null || family.ips.length === 0) {
    return ip;
  }
  if (family.offset == null || family.offset === maxInt$1) {
    family.offset = 0;
  } else {
    family.offset++;
  }
  const position = family.offset % family.ips.length;
  ip = family.ips[position] ?? null;
  if (ip == null) {
    return ip;
  }
  if (Date.now() - ip.timestamp > ip.ttl) {
    family.ips.splice(position, 1);
    return this.pick(origin, hostnameRecords, affinity);
  }
  return ip;
}, _j);
let DNSDispatchHandler$1 = (_k = class extends DecoratorHandler$3 {
  constructor(state, { origin, handler, dispatch, newOrigin }, opts) {
    super(handler);
    __privateAdd(this, _state, null);
    __privateAdd(this, _opts2, null);
    __privateAdd(this, _dispatch, null);
    __privateAdd(this, _origin, null);
    __privateAdd(this, _controller3, null);
    __privateAdd(this, _newOrigin, null);
    __privateAdd(this, _firstTry, true);
    __privateSet(this, _origin, origin);
    __privateSet(this, _newOrigin, newOrigin);
    __privateSet(this, _opts2, { ...opts });
    __privateSet(this, _state, state);
    __privateSet(this, _dispatch, dispatch);
  }
  onResponseError(controller, err) {
    switch (err.code) {
      case "ETIMEDOUT":
      case "ECONNREFUSED": {
        if (__privateGet(this, _state).dualStack) {
          if (!__privateGet(this, _firstTry)) {
            super.onResponseError(controller, err);
            return;
          }
          __privateSet(this, _firstTry, false);
          const otherFamily = __privateGet(this, _newOrigin).hostname[0] === "[" ? 4 : 6;
          const ip = __privateGet(this, _state).pickFamily(__privateGet(this, _origin), otherFamily);
          if (ip == null) {
            super.onResponseError(controller, err);
            return;
          }
          let port;
          if (typeof ip.port === "number") {
            port = `:${ip.port}`;
          } else if (__privateGet(this, _origin).port !== "") {
            port = `:${__privateGet(this, _origin).port}`;
          } else {
            port = "";
          }
          const dispatchOpts = {
            ...__privateGet(this, _opts2),
            origin: `${__privateGet(this, _origin).protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`
          };
          __privateGet(this, _dispatch).call(this, dispatchOpts, this);
          return;
        }
        super.onResponseError(controller, err);
        break;
      }
      case "ENOTFOUND":
        __privateGet(this, _state).deleteRecords(__privateGet(this, _origin));
        super.onResponseError(controller, err);
        break;
      default:
        super.onResponseError(controller, err);
        break;
    }
  }
}, _state = new WeakMap(), _opts2 = new WeakMap(), _dispatch = new WeakMap(), _origin = new WeakMap(), _controller3 = new WeakMap(), _newOrigin = new WeakMap(), _firstTry = new WeakMap(), _k);
var dns$1 = (interceptorOpts) => {
  if ((interceptorOpts == null ? void 0 : interceptorOpts.maxTTL) != null && (typeof (interceptorOpts == null ? void 0 : interceptorOpts.maxTTL) !== "number" || (interceptorOpts == null ? void 0 : interceptorOpts.maxTTL) < 0)) {
    throw new InvalidArgumentError$p("Invalid maxTTL. Must be a positive number");
  }
  if ((interceptorOpts == null ? void 0 : interceptorOpts.maxItems) != null && (typeof (interceptorOpts == null ? void 0 : interceptorOpts.maxItems) !== "number" || (interceptorOpts == null ? void 0 : interceptorOpts.maxItems) < 1)) {
    throw new InvalidArgumentError$p(
      "Invalid maxItems. Must be a positive number and greater than zero"
    );
  }
  if ((interceptorOpts == null ? void 0 : interceptorOpts.affinity) != null && (interceptorOpts == null ? void 0 : interceptorOpts.affinity) !== 4 && (interceptorOpts == null ? void 0 : interceptorOpts.affinity) !== 6) {
    throw new InvalidArgumentError$p("Invalid affinity. Must be either 4 or 6");
  }
  if ((interceptorOpts == null ? void 0 : interceptorOpts.dualStack) != null && typeof (interceptorOpts == null ? void 0 : interceptorOpts.dualStack) !== "boolean") {
    throw new InvalidArgumentError$p("Invalid dualStack. Must be a boolean");
  }
  if ((interceptorOpts == null ? void 0 : interceptorOpts.lookup) != null && typeof (interceptorOpts == null ? void 0 : interceptorOpts.lookup) !== "function") {
    throw new InvalidArgumentError$p("Invalid lookup. Must be a function");
  }
  if ((interceptorOpts == null ? void 0 : interceptorOpts.pick) != null && typeof (interceptorOpts == null ? void 0 : interceptorOpts.pick) !== "function") {
    throw new InvalidArgumentError$p("Invalid pick. Must be a function");
  }
  const dualStack = (interceptorOpts == null ? void 0 : interceptorOpts.dualStack) ?? true;
  let affinity;
  if (dualStack) {
    affinity = (interceptorOpts == null ? void 0 : interceptorOpts.affinity) ?? null;
  } else {
    affinity = (interceptorOpts == null ? void 0 : interceptorOpts.affinity) ?? 4;
  }
  const opts = {
    maxTTL: (interceptorOpts == null ? void 0 : interceptorOpts.maxTTL) ?? 1e4,
    // Expressed in ms
    lookup: (interceptorOpts == null ? void 0 : interceptorOpts.lookup) ?? null,
    pick: (interceptorOpts == null ? void 0 : interceptorOpts.pick) ?? null,
    dualStack,
    affinity,
    maxItems: (interceptorOpts == null ? void 0 : interceptorOpts.maxItems) ?? Infinity
  };
  const instance = new DNSInstance$1(opts);
  return (dispatch) => {
    return function dnsInterceptor(origDispatchOpts, handler) {
      const origin = origDispatchOpts.origin.constructor === URL ? origDispatchOpts.origin : new URL(origDispatchOpts.origin);
      if (isIP$1(origin.hostname) !== 0) {
        return dispatch(origDispatchOpts, handler);
      }
      instance.runLookup(origin, origDispatchOpts, (err, newOrigin) => {
        if (err) {
          return handler.onResponseError(null, err);
        }
        const dispatchOpts = {
          ...origDispatchOpts,
          servername: origin.hostname,
          // For SNI on TLS
          origin: newOrigin.origin,
          headers: {
            host: origin.host,
            ...origDispatchOpts.headers
          }
        };
        dispatch(
          dispatchOpts,
          instance.getHandler(
            { origin, dispatch, handler, newOrigin },
            origDispatchOpts
          )
        );
      });
      return true;
    };
  };
};
const {
  safeHTTPMethods
} = util$J;
function makeCacheKey$1(opts) {
  if (!opts.origin) {
    throw new Error("opts.origin is undefined");
  }
  let headers2;
  if (opts.headers == null) {
    headers2 = {};
  } else if (typeof opts.headers[Symbol.iterator] === "function") {
    headers2 = {};
    for (const x of opts.headers) {
      if (!Array.isArray(x)) {
        throw new Error("opts.headers is not a valid header map");
      }
      const [key, val] = x;
      if (typeof key !== "string" || typeof val !== "string") {
        throw new Error("opts.headers is not a valid header map");
      }
      headers2[key.toLowerCase()] = val;
    }
  } else if (typeof opts.headers === "object") {
    headers2 = {};
    for (const key of Object.keys(opts.headers)) {
      headers2[key.toLowerCase()] = opts.headers[key];
    }
  } else {
    throw new Error("opts.headers is not an object");
  }
  return {
    origin: opts.origin.toString(),
    method: opts.method,
    path: opts.path,
    headers: headers2
  };
}
function assertCacheKey$2(key) {
  if (typeof key !== "object") {
    throw new TypeError(`expected key to be object, got ${typeof key}`);
  }
  for (const property of ["origin", "method", "path"]) {
    if (typeof key[property] !== "string") {
      throw new TypeError(`expected key.${property} to be string, got ${typeof key[property]}`);
    }
  }
  if (key.headers !== void 0 && typeof key.headers !== "object") {
    throw new TypeError(`expected headers to be object, got ${typeof key}`);
  }
}
function assertCacheValue$2(value) {
  if (typeof value !== "object") {
    throw new TypeError(`expected value to be object, got ${typeof value}`);
  }
  for (const property of ["statusCode", "cachedAt", "staleAt", "deleteAt"]) {
    if (typeof value[property] !== "number") {
      throw new TypeError(`expected value.${property} to be number, got ${typeof value[property]}`);
    }
  }
  if (typeof value.statusMessage !== "string") {
    throw new TypeError(`expected value.statusMessage to be string, got ${typeof value.statusMessage}`);
  }
  if (value.headers != null && typeof value.headers !== "object") {
    throw new TypeError(`expected value.rawHeaders to be object, got ${typeof value.headers}`);
  }
  if (value.vary !== void 0 && typeof value.vary !== "object") {
    throw new TypeError(`expected value.vary to be object, got ${typeof value.vary}`);
  }
  if (value.etag !== void 0 && typeof value.etag !== "string") {
    throw new TypeError(`expected value.etag to be string, got ${typeof value.etag}`);
  }
}
function parseCacheControlHeader$2(header) {
  const output = {};
  let directives;
  if (Array.isArray(header)) {
    directives = [];
    for (const directive of header) {
      directives.push(...directive.split(","));
    }
  } else {
    directives = header.split(",");
  }
  for (let i = 0; i < directives.length; i++) {
    const directive = directives[i].toLowerCase();
    const keyValueDelimiter = directive.indexOf("=");
    let key;
    let value;
    if (keyValueDelimiter !== -1) {
      key = directive.substring(0, keyValueDelimiter).trimStart();
      value = directive.substring(keyValueDelimiter + 1);
    } else {
      key = directive.trim();
    }
    switch (key) {
      case "min-fresh":
      case "max-stale":
      case "max-age":
      case "s-maxage":
      case "stale-while-revalidate":
      case "stale-if-error": {
        if (value === void 0 || value[0] === " ") {
          continue;
        }
        if (value.length >= 2 && value[0] === '"' && value[value.length - 1] === '"') {
          value = value.substring(1, value.length - 1);
        }
        const parsedValue = parseInt(value, 10);
        if (parsedValue !== parsedValue) {
          continue;
        }
        if (key === "max-age" && key in output && output[key] >= parsedValue) {
          continue;
        }
        output[key] = parsedValue;
        break;
      }
      case "private":
      case "no-cache": {
        if (value) {
          if (value[0] === '"') {
            const headers2 = [value.substring(1)];
            let foundEndingQuote = value[value.length - 1] === '"';
            if (!foundEndingQuote) {
              for (let j = i + 1; j < directives.length; j++) {
                const nextPart = directives[j];
                const nextPartLength = nextPart.length;
                headers2.push(nextPart.trim());
                if (nextPartLength !== 0 && nextPart[nextPartLength - 1] === '"') {
                  foundEndingQuote = true;
                  break;
                }
              }
            }
            if (foundEndingQuote) {
              let lastHeader = headers2[headers2.length - 1];
              if (lastHeader[lastHeader.length - 1] === '"') {
                lastHeader = lastHeader.substring(0, lastHeader.length - 1);
                headers2[headers2.length - 1] = lastHeader;
              }
              if (key in output) {
                output[key] = output[key].concat(headers2);
              } else {
                output[key] = headers2;
              }
            }
          } else {
            if (key in output) {
              output[key] = output[key].concat(value);
            } else {
              output[key] = [value];
            }
          }
          break;
        }
      }
      case "public":
      case "no-store":
      case "must-revalidate":
      case "proxy-revalidate":
      case "immutable":
      case "no-transform":
      case "must-understand":
      case "only-if-cached":
        if (value) {
          continue;
        }
        output[key] = true;
        break;
      default:
        continue;
    }
  }
  return output;
}
function parseVaryHeader$1(varyHeader, headers2) {
  if (typeof varyHeader === "string" && varyHeader.includes("*")) {
    return headers2;
  }
  const output = (
    /** @type {Record<string, string | string[] | null>} */
    {}
  );
  const varyingHeaders = typeof varyHeader === "string" ? varyHeader.split(",") : varyHeader;
  for (const header of varyingHeaders) {
    const trimmedHeader = header.trim().toLowerCase();
    output[trimmedHeader] = headers2[trimmedHeader] ?? null;
  }
  return output;
}
function isEtagUsable$1(etag) {
  if (etag.length <= 2) {
    return false;
  }
  if (etag[0] === '"' && etag[etag.length - 1] === '"') {
    return !(etag[1] === '"' || etag.startsWith('"W/'));
  }
  if (etag.startsWith('W/"') && etag[etag.length - 1] === '"') {
    return etag.length !== 4;
  }
  return false;
}
function assertCacheStore$1(store2, name = "CacheStore") {
  if (typeof store2 !== "object" || store2 === null) {
    throw new TypeError(`expected type of ${name} to be a CacheStore, got ${store2 === null ? "null" : typeof store2}`);
  }
  for (const fn of ["get", "createWriteStream", "delete"]) {
    if (typeof store2[fn] !== "function") {
      throw new TypeError(`${name} needs to have a \`${fn}()\` function`);
    }
  }
}
function assertCacheMethods$1(methods, name = "CacheMethods") {
  if (!Array.isArray(methods)) {
    throw new TypeError(`expected type of ${name} needs to be an array, got ${methods === null ? "null" : typeof methods}`);
  }
  if (methods.length === 0) {
    throw new TypeError(`${name} needs to have at least one method`);
  }
  for (const method of methods) {
    if (!safeHTTPMethods.includes(method)) {
      throw new TypeError(`element of ${name}-array needs to be one of following values: ${safeHTTPMethods.join(", ")}, got ${method}`);
    }
  }
}
var cache$4 = {
  makeCacheKey: makeCacheKey$1,
  assertCacheKey: assertCacheKey$2,
  assertCacheValue: assertCacheValue$2,
  parseCacheControlHeader: parseCacheControlHeader$2,
  parseVaryHeader: parseVaryHeader$1,
  isEtagUsable: isEtagUsable$1,
  assertCacheMethods: assertCacheMethods$1,
  assertCacheStore: assertCacheStore$1
};
const IMF_DAYS = ["mon", "tue", "wed", "thu", "fri", "sat", "sun"];
const IMF_SPACES = [4, 7, 11, 16, 25];
const IMF_MONTHS = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
const IMF_COLONS = [19, 22];
const ASCTIME_SPACES = [3, 7, 10, 19];
const RFC850_DAYS = ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"];
function parseHttpDate$1(date2, now) {
  date2 = date2.toLowerCase();
  switch (date2[3]) {
    case ",":
      return parseImfDate(date2);
    case " ":
      return parseAscTimeDate(date2);
    default:
      return parseRfc850Date(date2, now);
  }
}
function parseImfDate(date2) {
  if (date2.length !== 29) {
    return void 0;
  }
  if (!date2.endsWith("gmt")) {
    return void 0;
  }
  for (const spaceInx of IMF_SPACES) {
    if (date2[spaceInx] !== " ") {
      return void 0;
    }
  }
  for (const colonIdx of IMF_COLONS) {
    if (date2[colonIdx] !== ":") {
      return void 0;
    }
  }
  const dayName = date2.substring(0, 3);
  if (!IMF_DAYS.includes(dayName)) {
    return void 0;
  }
  const dayString = date2.substring(5, 7);
  const day = Number.parseInt(dayString);
  if (isNaN(day) || day < 10 && dayString[0] !== "0") {
    return void 0;
  }
  const month = date2.substring(8, 11);
  const monthIdx = IMF_MONTHS.indexOf(month);
  if (monthIdx === -1) {
    return void 0;
  }
  const year = Number.parseInt(date2.substring(12, 16));
  if (isNaN(year)) {
    return void 0;
  }
  const hourString = date2.substring(17, 19);
  const hour = Number.parseInt(hourString);
  if (isNaN(hour) || hour < 10 && hourString[0] !== "0") {
    return void 0;
  }
  const minuteString = date2.substring(20, 22);
  const minute = Number.parseInt(minuteString);
  if (isNaN(minute) || minute < 10 && minuteString[0] !== "0") {
    return void 0;
  }
  const secondString = date2.substring(23, 25);
  const second = Number.parseInt(secondString);
  if (isNaN(second) || second < 10 && secondString[0] !== "0") {
    return void 0;
  }
  return new Date(Date.UTC(year, monthIdx, day, hour, minute, second));
}
function parseAscTimeDate(date2) {
  if (date2.length !== 24) {
    return void 0;
  }
  for (const spaceIdx of ASCTIME_SPACES) {
    if (date2[spaceIdx] !== " ") {
      return void 0;
    }
  }
  const dayName = date2.substring(0, 3);
  if (!IMF_DAYS.includes(dayName)) {
    return void 0;
  }
  const month = date2.substring(4, 7);
  const monthIdx = IMF_MONTHS.indexOf(month);
  if (monthIdx === -1) {
    return void 0;
  }
  const dayString = date2.substring(8, 10);
  const day = Number.parseInt(dayString);
  if (isNaN(day) || day < 10 && dayString[0] !== " ") {
    return void 0;
  }
  const hourString = date2.substring(11, 13);
  const hour = Number.parseInt(hourString);
  if (isNaN(hour) || hour < 10 && hourString[0] !== "0") {
    return void 0;
  }
  const minuteString = date2.substring(14, 16);
  const minute = Number.parseInt(minuteString);
  if (isNaN(minute) || minute < 10 && minuteString[0] !== "0") {
    return void 0;
  }
  const secondString = date2.substring(17, 19);
  const second = Number.parseInt(secondString);
  if (isNaN(second) || second < 10 && secondString[0] !== "0") {
    return void 0;
  }
  const year = Number.parseInt(date2.substring(20, 24));
  if (isNaN(year)) {
    return void 0;
  }
  return new Date(Date.UTC(year, monthIdx, day, hour, minute, second));
}
function parseRfc850Date(date2, now = /* @__PURE__ */ new Date()) {
  if (!date2.endsWith("gmt")) {
    return void 0;
  }
  const commaIndex = date2.indexOf(",");
  if (commaIndex === -1) {
    return void 0;
  }
  if (date2.length - commaIndex - 1 !== 23) {
    return void 0;
  }
  const dayName = date2.substring(0, commaIndex);
  if (!RFC850_DAYS.includes(dayName)) {
    return void 0;
  }
  if (date2[commaIndex + 1] !== " " || date2[commaIndex + 4] !== "-" || date2[commaIndex + 8] !== "-" || date2[commaIndex + 11] !== " " || date2[commaIndex + 14] !== ":" || date2[commaIndex + 17] !== ":" || date2[commaIndex + 20] !== " ") {
    return void 0;
  }
  const dayString = date2.substring(commaIndex + 2, commaIndex + 4);
  const day = Number.parseInt(dayString);
  if (isNaN(day) || day < 10 && dayString[0] !== "0") {
    return void 0;
  }
  const month = date2.substring(commaIndex + 5, commaIndex + 8);
  const monthIdx = IMF_MONTHS.indexOf(month);
  if (monthIdx === -1) {
    return void 0;
  }
  let year = Number.parseInt(date2.substring(commaIndex + 9, commaIndex + 11));
  if (isNaN(year)) {
    return void 0;
  }
  const currentYear = now.getUTCFullYear();
  const currentDecade = currentYear % 100;
  const currentCentury = Math.floor(currentYear / 100);
  if (year > currentDecade && year - currentDecade >= 50) {
    year += (currentCentury - 1) * 100;
  } else {
    year += currentCentury * 100;
  }
  const hourString = date2.substring(commaIndex + 12, commaIndex + 14);
  const hour = Number.parseInt(hourString);
  if (isNaN(hour) || hour < 10 && hourString[0] !== "0") {
    return void 0;
  }
  const minuteString = date2.substring(commaIndex + 15, commaIndex + 17);
  const minute = Number.parseInt(minuteString);
  if (isNaN(minute) || minute < 10 && minuteString[0] !== "0") {
    return void 0;
  }
  const secondString = date2.substring(commaIndex + 18, commaIndex + 20);
  const second = Number.parseInt(secondString);
  if (isNaN(second) || second < 10 && secondString[0] !== "0") {
    return void 0;
  }
  return new Date(Date.UTC(year, monthIdx, day, hour, minute, second));
}
var date = {
  parseHttpDate: parseHttpDate$1
};
const util$t = util$J;
const {
  parseCacheControlHeader: parseCacheControlHeader$1,
  parseVaryHeader,
  isEtagUsable
} = cache$4;
const { parseHttpDate } = date;
function noop$4() {
}
const HEURISTICALLY_CACHEABLE_STATUS_CODES = [
  200,
  203,
  204,
  206,
  300,
  301,
  308,
  404,
  405,
  410,
  414,
  501
];
const MAX_RESPONSE_AGE = 2147483647e3;
let CacheHandler$1 = (_l = class {
  /**
   * @param {import('../../types/cache-interceptor.d.ts').default.CacheHandlerOptions} opts
   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} cacheKey
   * @param {import('../../types/dispatcher.d.ts').default.DispatchHandler} handler
   */
  constructor({ store: store2, type, cacheByDefault }, cacheKey, handler) {
    /**
     * @type {import('../../types/cache-interceptor.d.ts').default.CacheKey}
     */
    __privateAdd(this, _cacheKey);
    /**
     * @type {import('../../types/cache-interceptor.d.ts').default.CacheHandlerOptions['type']}
     */
    __privateAdd(this, _cacheType);
    /**
     * @type {number | undefined}
     */
    __privateAdd(this, _cacheByDefault);
    /**
     * @type {import('../../types/cache-interceptor.d.ts').default.CacheStore}
     */
    __privateAdd(this, _store);
    /**
     * @type {import('../../types/dispatcher.d.ts').default.DispatchHandler}
     */
    __privateAdd(this, _handler4);
    /**
     * @type {import('node:stream').Writable | undefined}
     */
    __privateAdd(this, _writeStream);
    __privateSet(this, _store, store2);
    __privateSet(this, _cacheType, type);
    __privateSet(this, _cacheByDefault, cacheByDefault);
    __privateSet(this, _cacheKey, cacheKey);
    __privateSet(this, _handler4, handler);
  }
  onRequestStart(controller, context) {
    var _a2, _b2, _c2;
    (_a2 = __privateGet(this, _writeStream)) == null ? void 0 : _a2.destroy();
    __privateSet(this, _writeStream, void 0);
    (_c2 = (_b2 = __privateGet(this, _handler4)).onRequestStart) == null ? void 0 : _c2.call(_b2, controller, context);
  }
  onRequestUpgrade(controller, statusCode, headers2, socket) {
    var _a2, _b2;
    (_b2 = (_a2 = __privateGet(this, _handler4)).onRequestUpgrade) == null ? void 0 : _b2.call(_a2, controller, statusCode, headers2, socket);
  }
  /**
   * @param {import('../../types/dispatcher.d.ts').default.DispatchController} controller
   * @param {number} statusCode
   * @param {import('../../types/header.d.ts').IncomingHttpHeaders} resHeaders
   * @param {string} statusMessage
   */
  onResponseStart(controller, statusCode, resHeaders, statusMessage) {
    var _a2, _b2;
    const downstreamOnHeaders = () => {
      var _a3, _b3;
      return (_b3 = (_a3 = __privateGet(this, _handler4)).onResponseStart) == null ? void 0 : _b3.call(
        _a3,
        controller,
        statusCode,
        resHeaders,
        statusMessage
      );
    };
    if (!util$t.safeHTTPMethods.includes(__privateGet(this, _cacheKey).method) && statusCode >= 200 && statusCode <= 399) {
      try {
        (_b2 = (_a2 = __privateGet(this, _store).delete(__privateGet(this, _cacheKey))) == null ? void 0 : _a2.catch) == null ? void 0 : _b2.call(_a2, noop$4);
      } catch {
      }
      return downstreamOnHeaders();
    }
    const cacheControlHeader = resHeaders["cache-control"];
    const heuristicallyCacheable = resHeaders["last-modified"] && HEURISTICALLY_CACHEABLE_STATUS_CODES.includes(statusCode);
    if (!cacheControlHeader && !resHeaders["expires"] && !heuristicallyCacheable && !__privateGet(this, _cacheByDefault)) {
      return downstreamOnHeaders();
    }
    const cacheControlDirectives = cacheControlHeader ? parseCacheControlHeader$1(cacheControlHeader) : {};
    if (!canCacheResponse(__privateGet(this, _cacheType), statusCode, resHeaders, cacheControlDirectives)) {
      return downstreamOnHeaders();
    }
    const now = Date.now();
    const resAge = resHeaders.age ? getAge(resHeaders.age) : void 0;
    if (resAge && resAge >= MAX_RESPONSE_AGE) {
      return downstreamOnHeaders();
    }
    const resDate = typeof resHeaders.date === "string" ? parseHttpDate(resHeaders.date) : void 0;
    const staleAt = determineStaleAt(__privateGet(this, _cacheType), now, resAge, resHeaders, resDate, cacheControlDirectives) ?? __privateGet(this, _cacheByDefault);
    if (staleAt === void 0 || resAge && resAge > staleAt) {
      return downstreamOnHeaders();
    }
    const baseTime = resDate ? resDate.getTime() : now;
    const absoluteStaleAt = staleAt + baseTime;
    if (now >= absoluteStaleAt) {
      return downstreamOnHeaders();
    }
    let varyDirectives;
    if (__privateGet(this, _cacheKey).headers && resHeaders.vary) {
      varyDirectives = parseVaryHeader(resHeaders.vary, __privateGet(this, _cacheKey).headers);
      if (!varyDirectives) {
        return downstreamOnHeaders();
      }
    }
    const deleteAt = determineDeleteAt(baseTime, cacheControlDirectives, absoluteStaleAt);
    const strippedHeaders = stripNecessaryHeaders(resHeaders, cacheControlDirectives);
    const value = {
      statusCode,
      statusMessage,
      headers: strippedHeaders,
      vary: varyDirectives,
      cacheControlDirectives,
      cachedAt: resAge ? now - resAge : now,
      staleAt: absoluteStaleAt,
      deleteAt
    };
    if (typeof resHeaders.etag === "string" && isEtagUsable(resHeaders.etag)) {
      value.etag = resHeaders.etag;
    }
    __privateSet(this, _writeStream, __privateGet(this, _store).createWriteStream(__privateGet(this, _cacheKey), value));
    if (!__privateGet(this, _writeStream)) {
      return downstreamOnHeaders();
    }
    const handler = this;
    __privateGet(this, _writeStream).on("drain", () => controller.resume()).on("error", function() {
      __privateSet(handler, _writeStream, void 0);
      __privateGet(handler, _store).delete(__privateGet(handler, _cacheKey));
    }).on("close", function() {
      if (__privateGet(handler, _writeStream) === this) {
        __privateSet(handler, _writeStream, void 0);
      }
      controller.resume();
    });
    return downstreamOnHeaders();
  }
  onResponseData(controller, chunk) {
    var _a2, _b2, _c2;
    if (((_a2 = __privateGet(this, _writeStream)) == null ? void 0 : _a2.write(chunk)) === false) {
      controller.pause();
    }
    (_c2 = (_b2 = __privateGet(this, _handler4)).onResponseData) == null ? void 0 : _c2.call(_b2, controller, chunk);
  }
  onResponseEnd(controller, trailers) {
    var _a2, _b2, _c2;
    (_a2 = __privateGet(this, _writeStream)) == null ? void 0 : _a2.end();
    (_c2 = (_b2 = __privateGet(this, _handler4)).onResponseEnd) == null ? void 0 : _c2.call(_b2, controller, trailers);
  }
  onResponseError(controller, err) {
    var _a2, _b2, _c2;
    (_a2 = __privateGet(this, _writeStream)) == null ? void 0 : _a2.destroy(err);
    __privateSet(this, _writeStream, void 0);
    (_c2 = (_b2 = __privateGet(this, _handler4)).onResponseError) == null ? void 0 : _c2.call(_b2, controller, err);
  }
}, _cacheKey = new WeakMap(), _cacheType = new WeakMap(), _cacheByDefault = new WeakMap(), _store = new WeakMap(), _handler4 = new WeakMap(), _writeStream = new WeakMap(), _l);
function canCacheResponse(cacheType, statusCode, resHeaders, cacheControlDirectives) {
  var _a2;
  if (statusCode !== 200 && statusCode !== 307) {
    return false;
  }
  if (cacheControlDirectives["no-store"]) {
    return false;
  }
  if (cacheType === "shared" && cacheControlDirectives.private === true) {
    return false;
  }
  if ((_a2 = resHeaders.vary) == null ? void 0 : _a2.includes("*")) {
    return false;
  }
  if (resHeaders.authorization) {
    if (!cacheControlDirectives.public || typeof resHeaders.authorization !== "string") {
      return false;
    }
    if (Array.isArray(cacheControlDirectives["no-cache"]) && cacheControlDirectives["no-cache"].includes("authorization")) {
      return false;
    }
    if (Array.isArray(cacheControlDirectives["private"]) && cacheControlDirectives["private"].includes("authorization")) {
      return false;
    }
  }
  return true;
}
function getAge(ageHeader) {
  const age = parseInt(Array.isArray(ageHeader) ? ageHeader[0] : ageHeader);
  return isNaN(age) ? void 0 : age * 1e3;
}
function determineStaleAt(cacheType, now, age, resHeaders, responseDate, cacheControlDirectives) {
  if (cacheType === "shared") {
    const sMaxAge = cacheControlDirectives["s-maxage"];
    if (sMaxAge !== void 0) {
      return sMaxAge > 0 ? sMaxAge * 1e3 : void 0;
    }
  }
  const maxAge = cacheControlDirectives["max-age"];
  if (maxAge !== void 0) {
    return maxAge > 0 ? maxAge * 1e3 : void 0;
  }
  if (typeof resHeaders.expires === "string") {
    const expiresDate = parseHttpDate(resHeaders.expires);
    if (expiresDate) {
      if (now >= expiresDate.getTime()) {
        return void 0;
      }
      if (responseDate) {
        if (responseDate >= expiresDate) {
          return void 0;
        }
        if (age !== void 0 && age > expiresDate - responseDate) {
          return void 0;
        }
      }
      return expiresDate.getTime() - now;
    }
  }
  if (typeof resHeaders["last-modified"] === "string") {
    const lastModified = new Date(resHeaders["last-modified"]);
    if (isValidDate(lastModified)) {
      if (lastModified.getTime() >= now) {
        return void 0;
      }
      const responseAge = now - lastModified.getTime();
      return responseAge * 0.1;
    }
  }
  if (cacheControlDirectives.immutable) {
    return 31536e3;
  }
  return void 0;
}
function determineDeleteAt(now, cacheControlDirectives, staleAt) {
  let staleWhileRevalidate = -Infinity;
  let staleIfError = -Infinity;
  let immutable = -Infinity;
  if (cacheControlDirectives["stale-while-revalidate"]) {
    staleWhileRevalidate = staleAt + cacheControlDirectives["stale-while-revalidate"] * 1e3;
  }
  if (cacheControlDirectives["stale-if-error"]) {
    staleIfError = staleAt + cacheControlDirectives["stale-if-error"] * 1e3;
  }
  if (staleWhileRevalidate === -Infinity && staleIfError === -Infinity) {
    immutable = now + 31536e6;
  }
  return Math.max(staleAt, staleWhileRevalidate, staleIfError, immutable);
}
function stripNecessaryHeaders(resHeaders, cacheControlDirectives) {
  const headersToRemove = [
    "connection",
    "proxy-authenticate",
    "proxy-authentication-info",
    "proxy-authorization",
    "proxy-connection",
    "te",
    "transfer-encoding",
    "upgrade",
    // We'll add age back when serving it
    "age"
  ];
  if (resHeaders["connection"]) {
    if (Array.isArray(resHeaders["connection"])) {
      headersToRemove.push(...resHeaders["connection"].map((header) => header.trim()));
    } else {
      headersToRemove.push(...resHeaders["connection"].split(",").map((header) => header.trim()));
    }
  }
  if (Array.isArray(cacheControlDirectives["no-cache"])) {
    headersToRemove.push(...cacheControlDirectives["no-cache"]);
  }
  if (Array.isArray(cacheControlDirectives["private"])) {
    headersToRemove.push(...cacheControlDirectives["private"]);
  }
  let strippedHeaders;
  for (const headerName of headersToRemove) {
    if (resHeaders[headerName]) {
      strippedHeaders ?? (strippedHeaders = { ...resHeaders });
      delete strippedHeaders[headerName];
    }
  }
  return strippedHeaders ?? resHeaders;
}
function isValidDate(date2) {
  return date2 instanceof Date && Number.isFinite(date2.valueOf());
}
var cacheHandler = CacheHandler$1;
const { Writable: Writable$1 } = require$$0$4;
const { assertCacheKey: assertCacheKey$1, assertCacheValue: assertCacheValue$1 } = cache$4;
let MemoryCacheStore$1 = (_m = class {
  /**
   * @param {import('../../types/cache-interceptor.d.ts').default.MemoryCacheStoreOpts | undefined} [opts]
   */
  constructor(opts) {
    __privateAdd(this, _maxCount, Infinity);
    __privateAdd(this, _maxSize2, Infinity);
    __privateAdd(this, _maxEntrySize, Infinity);
    __privateAdd(this, _size2, 0);
    __privateAdd(this, _count, 0);
    __privateAdd(this, _entries, /* @__PURE__ */ new Map());
    if (opts) {
      if (typeof opts !== "object") {
        throw new TypeError("MemoryCacheStore options must be an object");
      }
      if (opts.maxCount !== void 0) {
        if (typeof opts.maxCount !== "number" || !Number.isInteger(opts.maxCount) || opts.maxCount < 0) {
          throw new TypeError("MemoryCacheStore options.maxCount must be a non-negative integer");
        }
        __privateSet(this, _maxCount, opts.maxCount);
      }
      if (opts.maxSize !== void 0) {
        if (typeof opts.maxSize !== "number" || !Number.isInteger(opts.maxSize) || opts.maxSize < 0) {
          throw new TypeError("MemoryCacheStore options.maxSize must be a non-negative integer");
        }
        __privateSet(this, _maxSize2, opts.maxSize);
      }
      if (opts.maxEntrySize !== void 0) {
        if (typeof opts.maxEntrySize !== "number" || !Number.isInteger(opts.maxEntrySize) || opts.maxEntrySize < 0) {
          throw new TypeError("MemoryCacheStore options.maxEntrySize must be a non-negative integer");
        }
        __privateSet(this, _maxEntrySize, opts.maxEntrySize);
      }
    }
  }
  /**
   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} req
   * @returns {import('../../types/cache-interceptor.d.ts').default.GetResult | undefined}
   */
  get(key) {
    var _a2;
    assertCacheKey$1(key);
    const topLevelKey = `${key.origin}:${key.path}`;
    const now = Date.now();
    const entry = (_a2 = __privateGet(this, _entries).get(topLevelKey)) == null ? void 0 : _a2.find((entry2) => entry2.deleteAt > now && entry2.method === key.method && (entry2.vary == null || Object.keys(entry2.vary).every((headerName) => {
      if (entry2.vary[headerName] === null) {
        return key.headers[headerName] === void 0;
      }
      return entry2.vary[headerName] === key.headers[headerName];
    })));
    return entry == null ? void 0 : {
      statusMessage: entry.statusMessage,
      statusCode: entry.statusCode,
      headers: entry.headers,
      body: entry.body,
      vary: entry.vary ? entry.vary : void 0,
      etag: entry.etag,
      cacheControlDirectives: entry.cacheControlDirectives,
      cachedAt: entry.cachedAt,
      staleAt: entry.staleAt,
      deleteAt: entry.deleteAt
    };
  }
  /**
   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
   * @param {import('../../types/cache-interceptor.d.ts').default.CacheValue} val
   * @returns {Writable | undefined}
   */
  createWriteStream(key, val) {
    assertCacheKey$1(key);
    assertCacheValue$1(val);
    const topLevelKey = `${key.origin}:${key.path}`;
    const store2 = this;
    const entry = { ...key, ...val, body: [], size: 0 };
    return new Writable$1({
      write(chunk, encoding2, callback) {
        if (typeof chunk === "string") {
          chunk = Buffer.from(chunk, encoding2);
        }
        entry.size += chunk.byteLength;
        if (entry.size >= __privateGet(store2, _maxEntrySize)) {
          this.destroy();
        } else {
          entry.body.push(chunk);
        }
        callback(null);
      },
      final(callback) {
        let entries = __privateGet(store2, _entries).get(topLevelKey);
        if (!entries) {
          entries = [];
          __privateGet(store2, _entries).set(topLevelKey, entries);
        }
        entries.push(entry);
        __privateSet(store2, _size2, __privateGet(store2, _size2) + entry.size);
        __privateSet(store2, _count, __privateGet(store2, _count) + 1);
        if (__privateGet(store2, _size2) > __privateGet(store2, _maxSize2) || __privateGet(store2, _count) > __privateGet(store2, _maxCount)) {
          for (const [key2, entries2] of __privateGet(store2, _entries)) {
            for (const entry2 of entries2.splice(0, entries2.length / 2)) {
              __privateSet(store2, _size2, __privateGet(store2, _size2) - entry2.size);
              __privateSet(store2, _count, __privateGet(store2, _count) - 1);
            }
            if (entries2.length === 0) {
              __privateGet(store2, _entries).delete(key2);
            }
          }
        }
        callback(null);
      }
    });
  }
  /**
   * @param {CacheKey} key
   */
  delete(key) {
    if (typeof key !== "object") {
      throw new TypeError(`expected key to be object, got ${typeof key}`);
    }
    const topLevelKey = `${key.origin}:${key.path}`;
    for (const entry of __privateGet(this, _entries).get(topLevelKey) ?? []) {
      __privateSet(this, _size2, __privateGet(this, _size2) - entry.size);
      __privateSet(this, _count, __privateGet(this, _count) - 1);
    }
    __privateGet(this, _entries).delete(topLevelKey);
  }
}, _maxCount = new WeakMap(), _maxSize2 = new WeakMap(), _maxEntrySize = new WeakMap(), _size2 = new WeakMap(), _count = new WeakMap(), _entries = new WeakMap(), _m);
var memoryCacheStore = MemoryCacheStore$1;
const assert$g = require$$0$3;
let CacheRevalidationHandler$1 = (_n = class {
  /**
   * @param {(boolean) => void} callback Function to call if the cached value is valid
   * @param {import('../../types/dispatcher.d.ts').default.DispatchHandlers} handler
   * @param {boolean} allowErrorStatusCodes
   */
  constructor(callback, handler, allowErrorStatusCodes) {
    __privateAdd(this, _successful, false);
    /**
     * @type {((boolean, any) => void) | null}
     */
    __privateAdd(this, _callback);
    /**
     * @type {(import('../../types/dispatcher.d.ts').default.DispatchHandler)}
     */
    __privateAdd(this, _handler5);
    __privateAdd(this, _context);
    /**
     * @type {boolean}
     */
    __privateAdd(this, _allowErrorStatusCodes);
    if (typeof callback !== "function") {
      throw new TypeError("callback must be a function");
    }
    __privateSet(this, _callback, callback);
    __privateSet(this, _handler5, handler);
    __privateSet(this, _allowErrorStatusCodes, allowErrorStatusCodes);
  }
  onRequestStart(_, context) {
    __privateSet(this, _successful, false);
    __privateSet(this, _context, context);
  }
  onRequestUpgrade(controller, statusCode, headers2, socket) {
    var _a2, _b2;
    (_b2 = (_a2 = __privateGet(this, _handler5)).onRequestUpgrade) == null ? void 0 : _b2.call(_a2, controller, statusCode, headers2, socket);
  }
  onResponseStart(controller, statusCode, headers2, statusMessage) {
    var _a2, _b2, _c2, _d2;
    assert$g(__privateGet(this, _callback) != null);
    __privateSet(this, _successful, statusCode === 304 || __privateGet(this, _allowErrorStatusCodes) && statusCode >= 500 && statusCode <= 504);
    __privateGet(this, _callback).call(this, __privateGet(this, _successful), __privateGet(this, _context));
    __privateSet(this, _callback, null);
    if (__privateGet(this, _successful)) {
      return true;
    }
    (_b2 = (_a2 = __privateGet(this, _handler5)).onRequestStart) == null ? void 0 : _b2.call(_a2, controller, __privateGet(this, _context));
    (_d2 = (_c2 = __privateGet(this, _handler5)).onResponseStart) == null ? void 0 : _d2.call(
      _c2,
      controller,
      statusCode,
      headers2,
      statusMessage
    );
  }
  onResponseData(controller, chunk) {
    var _a2, _b2;
    if (__privateGet(this, _successful)) {
      return;
    }
    return (_b2 = (_a2 = __privateGet(this, _handler5)).onResponseData) == null ? void 0 : _b2.call(_a2, controller, chunk);
  }
  onResponseEnd(controller, trailers) {
    var _a2, _b2;
    if (__privateGet(this, _successful)) {
      return;
    }
    (_b2 = (_a2 = __privateGet(this, _handler5)).onResponseEnd) == null ? void 0 : _b2.call(_a2, controller, trailers);
  }
  onResponseError(controller, err) {
    if (__privateGet(this, _successful)) {
      return;
    }
    if (__privateGet(this, _callback)) {
      __privateGet(this, _callback).call(this, false);
      __privateSet(this, _callback, null);
    }
    if (typeof __privateGet(this, _handler5).onResponseError === "function") {
      __privateGet(this, _handler5).onResponseError(controller, err);
    } else {
      throw err;
    }
  }
}, _successful = new WeakMap(), _callback = new WeakMap(), _handler5 = new WeakMap(), _context = new WeakMap(), _allowErrorStatusCodes = new WeakMap(), _n);
var cacheRevalidationHandler = CacheRevalidationHandler$1;
const assert$f = require$$0$3;
const { Readable: Readable$3 } = require$$0$4;
const util$s = util$J;
const CacheHandler = cacheHandler;
const MemoryCacheStore = memoryCacheStore;
const CacheRevalidationHandler = cacheRevalidationHandler;
const { assertCacheStore, assertCacheMethods, makeCacheKey, parseCacheControlHeader } = cache$4;
const { AbortError: AbortError$2 } = errors$2;
function needsRevalidation(result, cacheControlDirectives) {
  if (cacheControlDirectives == null ? void 0 : cacheControlDirectives["no-cache"]) {
    return true;
  }
  const now = Date.now();
  if (now > result.staleAt) {
    if (cacheControlDirectives == null ? void 0 : cacheControlDirectives["max-stale"]) {
      const gracePeriod = result.staleAt + cacheControlDirectives["max-stale"] * 1e3;
      return now > gracePeriod;
    }
    return true;
  }
  if (cacheControlDirectives == null ? void 0 : cacheControlDirectives["min-fresh"]) {
    const timeLeftTillStale = result.staleAt - now;
    const threshold = cacheControlDirectives["min-fresh"] * 1e3;
    return timeLeftTillStale <= threshold;
  }
  return false;
}
function handleUncachedResponse(dispatch, globalOpts, cacheKey, handler, opts, reqCacheControl) {
  if (reqCacheControl == null ? void 0 : reqCacheControl["only-if-cached"]) {
    let aborted = false;
    try {
      if (typeof handler.onConnect === "function") {
        handler.onConnect(() => {
          aborted = true;
        });
        if (aborted) {
          return;
        }
      }
      if (typeof handler.onHeaders === "function") {
        handler.onHeaders(504, [], () => {
        }, "Gateway Timeout");
        if (aborted) {
          return;
        }
      }
      if (typeof handler.onComplete === "function") {
        handler.onComplete([]);
      }
    } catch (err) {
      if (typeof handler.onError === "function") {
        handler.onError(err);
      }
    }
    return true;
  }
  return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler));
}
function sendCachedValue(handler, opts, result, age, context, isStale) {
  var _a2, _b2;
  const stream2 = util$s.isStream(result.body) ? result.body : Readable$3.from(result.body ?? []);
  assert$f(!stream2.destroyed, "stream should not be destroyed");
  assert$f(!stream2.readableDidRead, "stream should not be readableDidRead");
  const controller = {
    resume() {
      stream2.resume();
    },
    pause() {
      stream2.pause();
    },
    get paused() {
      return stream2.isPaused();
    },
    get aborted() {
      return stream2.destroyed;
    },
    get reason() {
      return stream2.errored;
    },
    abort(reason) {
      stream2.destroy(reason ?? new AbortError$2());
    }
  };
  stream2.on("error", function(err) {
    if (!this.readableEnded) {
      if (typeof handler.onResponseError === "function") {
        handler.onResponseError(controller, err);
      } else {
        throw err;
      }
    }
  }).on("close", function() {
    var _a3;
    if (!this.errored) {
      (_a3 = handler.onResponseEnd) == null ? void 0 : _a3.call(handler, controller, {});
    }
  });
  (_a2 = handler.onRequestStart) == null ? void 0 : _a2.call(handler, controller, context);
  if (stream2.destroyed) {
    return;
  }
  const headers2 = { ...result.headers, age: String(age) };
  if (isStale) {
    headers2.warning = '110 - "response is stale"';
  }
  (_b2 = handler.onResponseStart) == null ? void 0 : _b2.call(handler, controller, result.statusCode, headers2, result.statusMessage);
  if (opts.method === "HEAD") {
    stream2.destroy();
  } else {
    stream2.on("data", function(chunk) {
      var _a3;
      (_a3 = handler.onResponseData) == null ? void 0 : _a3.call(handler, controller, chunk);
    });
  }
}
function handleResult(dispatch, globalOpts, cacheKey, handler, opts, reqCacheControl, result) {
  if (!result) {
    return handleUncachedResponse(dispatch, globalOpts, cacheKey, handler, opts, reqCacheControl);
  }
  const now = Date.now();
  if (now > result.deleteAt) {
    return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler));
  }
  const age = Math.round((now - result.cachedAt) / 1e3);
  if ((reqCacheControl == null ? void 0 : reqCacheControl["max-age"]) && age >= reqCacheControl["max-age"]) {
    return dispatch(opts, handler);
  }
  if (needsRevalidation(result, reqCacheControl)) {
    if (util$s.isStream(opts.body) && util$s.bodyLength(opts.body) !== 0) {
      return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler));
    }
    let withinStaleIfErrorThreshold = false;
    const staleIfErrorExpiry = result.cacheControlDirectives["stale-if-error"] ?? (reqCacheControl == null ? void 0 : reqCacheControl["stale-if-error"]);
    if (staleIfErrorExpiry) {
      withinStaleIfErrorThreshold = now < result.staleAt + staleIfErrorExpiry * 1e3;
    }
    let headers2 = {
      ...opts.headers,
      "if-modified-since": new Date(result.cachedAt).toUTCString()
    };
    if (result.etag) {
      headers2["if-none-match"] = result.etag;
    }
    if (result.vary) {
      headers2 = {
        ...headers2,
        ...result.vary
      };
    }
    return dispatch(
      {
        ...opts,
        headers: headers2
      },
      new CacheRevalidationHandler(
        (success, context) => {
          if (success) {
            sendCachedValue(handler, opts, result, age, context, true);
          } else if (util$s.isStream(result.body)) {
            result.body.on("error", () => {
            }).destroy();
          }
        },
        new CacheHandler(globalOpts, cacheKey, handler),
        withinStaleIfErrorThreshold
      )
    );
  }
  if (util$s.isStream(opts.body)) {
    opts.body.on("error", () => {
    }).destroy();
  }
  sendCachedValue(handler, opts, result, age, null, false);
}
var cache$3 = (opts = {}) => {
  const {
    store: store2 = new MemoryCacheStore(),
    methods = ["GET"],
    cacheByDefault = void 0,
    type = "shared"
  } = opts;
  if (typeof opts !== "object" || opts === null) {
    throw new TypeError(`expected type of opts to be an Object, got ${opts === null ? "null" : typeof opts}`);
  }
  assertCacheStore(store2, "opts.store");
  assertCacheMethods(methods, "opts.methods");
  if (typeof cacheByDefault !== "undefined" && typeof cacheByDefault !== "number") {
    throw new TypeError(`exepcted opts.cacheByDefault to be number or undefined, got ${typeof cacheByDefault}`);
  }
  if (typeof type !== "undefined" && type !== "shared" && type !== "private") {
    throw new TypeError(`exepcted opts.type to be shared, private, or undefined, got ${typeof type}`);
  }
  const globalOpts = {
    store: store2,
    methods,
    cacheByDefault,
    type
  };
  const safeMethodsToNotCache = util$s.safeHTTPMethods.filter((method) => methods.includes(method) === false);
  return (dispatch) => {
    return (opts2, handler) => {
      var _a2;
      if (!opts2.origin || safeMethodsToNotCache.includes(opts2.method)) {
        return dispatch(opts2, handler);
      }
      const reqCacheControl = ((_a2 = opts2.headers) == null ? void 0 : _a2["cache-control"]) ? parseCacheControlHeader(opts2.headers["cache-control"]) : void 0;
      if (reqCacheControl == null ? void 0 : reqCacheControl["no-store"]) {
        return dispatch(opts2, handler);
      }
      const cacheKey = makeCacheKey(opts2);
      const result = store2.get(cacheKey);
      if (result && typeof result.then === "function") {
        result.then((result2) => {
          handleResult(
            dispatch,
            globalOpts,
            cacheKey,
            handler,
            opts2,
            reqCacheControl,
            result2
          );
        });
      } else {
        handleResult(
          dispatch,
          globalOpts,
          cacheKey,
          handler,
          opts2,
          reqCacheControl,
          result
        );
      }
      return true;
    };
  };
};
const __viteBrowserExternal_node_sqlite = new Proxy({}, {
  get(_, key) {
    throw new Error(`Module "node:sqlite" has been externalized for browser compatibility. Cannot access "node:sqlite.${key}" in client code.  See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
  }
});
const __viteBrowserExternal_node_sqlite$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal_node_sqlite
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal_node_sqlite$1);
const { Writable } = require$$0$7;
const { assertCacheKey, assertCacheValue } = cache$4;
let DatabaseSync;
const VERSION = 3;
const MAX_ENTRY_SIZE = 2 * 1e3 * 1e3 * 1e3;
var sqliteCacheStore = (_o = class {
  /**
   * @param {import('../../types/cache-interceptor.d.ts').default.SqliteCacheStoreOpts | undefined} opts
   */
  constructor(opts) {
    __privateAdd(this, _SqliteCacheStore_instances);
    __privateAdd(this, _maxEntrySize2, MAX_ENTRY_SIZE);
    __privateAdd(this, _maxCount2, Infinity);
    /**
     * @type {import('node:sqlite').DatabaseSync}
     */
    __privateAdd(this, _db);
    /**
     * @type {import('node:sqlite').StatementSync}
     */
    __privateAdd(this, _getValuesQuery);
    /**
     * @type {import('node:sqlite').StatementSync}
     */
    __privateAdd(this, _updateValueQuery);
    /**
     * @type {import('node:sqlite').StatementSync}
     */
    __privateAdd(this, _insertValueQuery);
    /**
     * @type {import('node:sqlite').StatementSync}
     */
    __privateAdd(this, _deleteExpiredValuesQuery);
    /**
     * @type {import('node:sqlite').StatementSync}
     */
    __privateAdd(this, _deleteByUrlQuery);
    /**
     * @type {import('node:sqlite').StatementSync}
     */
    __privateAdd(this, _countEntriesQuery);
    /**
     * @type {import('node:sqlite').StatementSync | null}
     */
    __privateAdd(this, _deleteOldValuesQuery);
    if (opts) {
      if (typeof opts !== "object") {
        throw new TypeError("SqliteCacheStore options must be an object");
      }
      if (opts.maxEntrySize !== void 0) {
        if (typeof opts.maxEntrySize !== "number" || !Number.isInteger(opts.maxEntrySize) || opts.maxEntrySize < 0) {
          throw new TypeError("SqliteCacheStore options.maxEntrySize must be a non-negative integer");
        }
        if (opts.maxEntrySize > MAX_ENTRY_SIZE) {
          throw new TypeError("SqliteCacheStore options.maxEntrySize must be less than 2gb");
        }
        __privateSet(this, _maxEntrySize2, opts.maxEntrySize);
      }
      if (opts.maxCount !== void 0) {
        if (typeof opts.maxCount !== "number" || !Number.isInteger(opts.maxCount) || opts.maxCount < 0) {
          throw new TypeError("SqliteCacheStore options.maxCount must be a non-negative integer");
        }
        __privateSet(this, _maxCount2, opts.maxCount);
      }
    }
    if (!DatabaseSync) {
      DatabaseSync = require$$2.DatabaseSync;
    }
    __privateSet(this, _db, new DatabaseSync((opts == null ? void 0 : opts.location) ?? ":memory:"));
    __privateGet(this, _db).exec(`
      CREATE TABLE IF NOT EXISTS cacheInterceptorV${VERSION} (
        -- Data specific to us
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        url TEXT NOT NULL,
        method TEXT NOT NULL,

        -- Data returned to the interceptor
        body BUF NULL,
        deleteAt INTEGER NOT NULL,
        statusCode INTEGER NOT NULL,
        statusMessage TEXT NOT NULL,
        headers TEXT NULL,
        cacheControlDirectives TEXT NULL,
        etag TEXT NULL,
        vary TEXT NULL,
        cachedAt INTEGER NOT NULL,
        staleAt INTEGER NOT NULL
      );

      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${VERSION}_url ON cacheInterceptorV${VERSION}(url);
      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${VERSION}_method ON cacheInterceptorV${VERSION}(method);
      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${VERSION}_deleteAt ON cacheInterceptorV${VERSION}(deleteAt);
    `);
    __privateSet(this, _getValuesQuery, __privateGet(this, _db).prepare(`
      SELECT
        id,
        body,
        deleteAt,
        statusCode,
        statusMessage,
        headers,
        etag,
        cacheControlDirectives,
        vary,
        cachedAt,
        staleAt
      FROM cacheInterceptorV${VERSION}
      WHERE
        url = ?
        AND method = ?
      ORDER BY
        deleteAt ASC
    `));
    __privateSet(this, _updateValueQuery, __privateGet(this, _db).prepare(`
      UPDATE cacheInterceptorV${VERSION} SET
        body = ?,
        deleteAt = ?,
        statusCode = ?,
        statusMessage = ?,
        headers = ?,
        etag = ?,
        cacheControlDirectives = ?,
        cachedAt = ?,
        staleAt = ?
      WHERE
        id = ?
    `));
    __privateSet(this, _insertValueQuery, __privateGet(this, _db).prepare(`
      INSERT INTO cacheInterceptorV${VERSION} (
        url,
        method,
        body,
        deleteAt,
        statusCode,
        statusMessage,
        headers,
        etag,
        cacheControlDirectives,
        vary,
        cachedAt,
        staleAt
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `));
    __privateSet(this, _deleteByUrlQuery, __privateGet(this, _db).prepare(
      `DELETE FROM cacheInterceptorV${VERSION} WHERE url = ?`
    ));
    __privateSet(this, _countEntriesQuery, __privateGet(this, _db).prepare(
      `SELECT COUNT(*) AS total FROM cacheInterceptorV${VERSION}`
    ));
    __privateSet(this, _deleteExpiredValuesQuery, __privateGet(this, _db).prepare(
      `DELETE FROM cacheInterceptorV${VERSION} WHERE deleteAt <= ?`
    ));
    __privateSet(this, _deleteOldValuesQuery, __privateGet(this, _maxCount2) === Infinity ? null : __privateGet(this, _db).prepare(`
        DELETE FROM cacheInterceptorV${VERSION}
        WHERE id IN (
          SELECT
            id
          FROM cacheInterceptorV${VERSION}
          ORDER BY cachedAt DESC
          LIMIT ?
        )
      `));
  }
  close() {
    __privateGet(this, _db).close();
  }
  /**
   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
   * @returns {(import('../../types/cache-interceptor.d.ts').default.GetResult & { body?: Buffer }) | undefined}
   */
  get(key) {
    assertCacheKey(key);
    const value = __privateMethod(this, _SqliteCacheStore_instances, findValue_fn).call(this, key);
    return value ? {
      body: value.body ? Buffer.from(value.body.buffer, value.body.byteOffset, value.body.byteLength) : void 0,
      statusCode: value.statusCode,
      statusMessage: value.statusMessage,
      headers: value.headers ? JSON.parse(value.headers) : void 0,
      etag: value.etag ? value.etag : void 0,
      vary: value.vary ? JSON.parse(value.vary) : void 0,
      cacheControlDirectives: value.cacheControlDirectives ? JSON.parse(value.cacheControlDirectives) : void 0,
      cachedAt: value.cachedAt,
      staleAt: value.staleAt,
      deleteAt: value.deleteAt
    } : void 0;
  }
  /**
   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
   * @param {import('../../types/cache-interceptor.d.ts').default.CacheValue & { body: null | Buffer | Array<Buffer>}} value
   */
  set(key, value) {
    assertCacheKey(key);
    const url = __privateMethod(this, _SqliteCacheStore_instances, makeValueUrl_fn).call(this, key);
    const body2 = Array.isArray(value.body) ? Buffer.concat(value.body) : value.body;
    const size = body2 == null ? void 0 : body2.byteLength;
    if (size && size > __privateGet(this, _maxEntrySize2)) {
      return;
    }
    const existingValue = __privateMethod(this, _SqliteCacheStore_instances, findValue_fn).call(this, key, true);
    if (existingValue) {
      __privateGet(this, _updateValueQuery).run(
        body2,
        value.deleteAt,
        value.statusCode,
        value.statusMessage,
        value.headers ? JSON.stringify(value.headers) : null,
        value.etag ? value.etag : null,
        value.cacheControlDirectives ? JSON.stringify(value.cacheControlDirectives) : null,
        value.cachedAt,
        value.staleAt,
        existingValue.id
      );
    } else {
      __privateMethod(this, _SqliteCacheStore_instances, prune_fn).call(this);
      __privateGet(this, _insertValueQuery).run(
        url,
        key.method,
        body2,
        value.deleteAt,
        value.statusCode,
        value.statusMessage,
        value.headers ? JSON.stringify(value.headers) : null,
        value.etag ? value.etag : null,
        value.cacheControlDirectives ? JSON.stringify(value.cacheControlDirectives) : null,
        value.vary ? JSON.stringify(value.vary) : null,
        value.cachedAt,
        value.staleAt
      );
    }
  }
  /**
   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
   * @param {import('../../types/cache-interceptor.d.ts').default.CacheValue} value
   * @returns {Writable | undefined}
   */
  createWriteStream(key, value) {
    assertCacheKey(key);
    assertCacheValue(value);
    let size = 0;
    const body2 = [];
    const store2 = this;
    return new Writable({
      decodeStrings: true,
      write(chunk, encoding2, callback) {
        size += chunk.byteLength;
        if (size < __privateGet(store2, _maxEntrySize2)) {
          body2.push(chunk);
        } else {
          this.destroy();
        }
        callback();
      },
      final(callback) {
        store2.set(key, { ...value, body: body2 });
        callback();
      }
    });
  }
  /**
   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
   */
  delete(key) {
    if (typeof key !== "object") {
      throw new TypeError(`expected key to be object, got ${typeof key}`);
    }
    __privateGet(this, _deleteByUrlQuery).run(__privateMethod(this, _SqliteCacheStore_instances, makeValueUrl_fn).call(this, key));
  }
  /**
   * Counts the number of rows in the cache
   * @returns {Number}
   */
  get size() {
    const { total } = __privateGet(this, _countEntriesQuery).get();
    return total;
  }
}, _maxEntrySize2 = new WeakMap(), _maxCount2 = new WeakMap(), _db = new WeakMap(), _getValuesQuery = new WeakMap(), _updateValueQuery = new WeakMap(), _insertValueQuery = new WeakMap(), _deleteExpiredValuesQuery = new WeakMap(), _deleteByUrlQuery = new WeakMap(), _countEntriesQuery = new WeakMap(), _deleteOldValuesQuery = new WeakMap(), _SqliteCacheStore_instances = new WeakSet(), prune_fn = function() {
  var _a2;
  if (this.size <= __privateGet(this, _maxCount2)) {
    return 0;
  }
  {
    const removed = __privateGet(this, _deleteExpiredValuesQuery).run(Date.now()).changes;
    if (removed) {
      return removed;
    }
  }
  {
    const removed = (_a2 = __privateGet(this, _deleteOldValuesQuery)) == null ? void 0 : _a2.run(Math.max(Math.floor(__privateGet(this, _maxCount2) * 0.1), 1)).changes;
    if (removed) {
      return removed;
    }
  }
  return 0;
}, /**
 * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
 * @returns {string}
 */
makeValueUrl_fn = function(key) {
  return `${key.origin}/${key.path}`;
}, /**
 * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
 * @param {boolean} [canBeExpired=false]
 * @returns {SqliteStoreValue | undefined}
 */
findValue_fn = function(key, canBeExpired = false) {
  const url = __privateMethod(this, _SqliteCacheStore_instances, makeValueUrl_fn).call(this, key);
  const { headers: headers2, method } = key;
  const values = __privateGet(this, _getValuesQuery).all(url, method);
  if (values.length === 0) {
    return void 0;
  }
  const now = Date.now();
  for (const value of values) {
    if (now >= value.deleteAt && !canBeExpired) {
      return void 0;
    }
    let matches = true;
    if (value.vary) {
      const vary = JSON.parse(value.vary);
      for (const header in vary) {
        if (!headerValueEquals(headers2[header], vary[header])) {
          matches = false;
          break;
        }
      }
    }
    if (matches) {
      return value;
    }
  }
  return void 0;
}, _o);
function headerValueEquals(lhs, rhs) {
  if (lhs == null && rhs == null) {
    return true;
  }
  if (lhs == null && rhs != null || lhs != null && rhs == null) {
    return false;
  }
  if (Array.isArray(lhs) && Array.isArray(rhs)) {
    if (lhs.length !== rhs.length) {
      return false;
    }
    return lhs.every((x, i) => x === rhs[i]);
  }
  return lhs === rhs;
}
var headers$1;
var hasRequiredHeaders$1;
function requireHeaders$1() {
  var _guard, _headersList;
  if (hasRequiredHeaders$1) return headers$1;
  hasRequiredHeaders$1 = 1;
  const { kConstruct: kConstruct2 } = symbols$5;
  const { kEnumerableProperty: kEnumerableProperty2 } = util$J;
  const {
    iteratorMixin,
    isValidHeaderName,
    isValidHeaderValue: isValidHeaderValue2
  } = requireUtil$a();
  const { webidl } = requireWebidl$1();
  const assert2 = require$$0$3;
  const util2 = require$$0$2;
  function isHTTPWhiteSpaceCharCode(code) {
    return code === 10 || code === 13 || code === 9 || code === 32;
  }
  function headerValueNormalize(potentialValue) {
    let i = 0;
    let j = potentialValue.length;
    while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j;
    while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i;
    return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
  }
  function fill(headers2, object) {
    if (Array.isArray(object)) {
      for (let i = 0; i < object.length; ++i) {
        const header = object[i];
        if (header.length !== 2) {
          throw webidl.errors.exception({
            header: "Headers constructor",
            message: `expected name/value pair to be length 2, found ${header.length}.`
          });
        }
        appendHeader(headers2, header[0], header[1]);
      }
    } else if (typeof object === "object" && object !== null) {
      const keys = Object.keys(object);
      for (let i = 0; i < keys.length; ++i) {
        appendHeader(headers2, keys[i], object[keys[i]]);
      }
    } else {
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    }
  }
  function appendHeader(headers2, name, value) {
    value = headerValueNormalize(value);
    if (!isValidHeaderName(name)) {
      throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value: name,
        type: "header name"
      });
    } else if (!isValidHeaderValue2(value)) {
      throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value,
        type: "header value"
      });
    }
    if (getHeadersGuard(headers2) === "immutable") {
      throw new TypeError("immutable");
    }
    return getHeadersList(headers2).append(name, value, false);
  }
  function headersListSortAndCombine(target) {
    const headersList = getHeadersList(target);
    if (!headersList) {
      return [];
    }
    if (headersList.sortedMap) {
      return headersList.sortedMap;
    }
    const headers2 = [];
    const names = headersList.toSortedArray();
    const cookies2 = headersList.cookies;
    if (cookies2 === null || cookies2.length === 1) {
      return headersList.sortedMap = names;
    }
    for (let i = 0; i < names.length; ++i) {
      const { 0: name, 1: value } = names[i];
      if (name === "set-cookie") {
        for (let j = 0; j < cookies2.length; ++j) {
          headers2.push([name, cookies2[j]]);
        }
      } else {
        headers2.push([name, value]);
      }
    }
    return headersList.sortedMap = headers2;
  }
  function compareHeaderName(a, b) {
    return a[0] < b[0] ? -1 : 1;
  }
  class HeadersList {
    constructor(init) {
      /** @type {[string, string][]|null} */
      __publicField(this, "cookies", null);
      __publicField(this, "sortedMap");
      __publicField(this, "headersMap");
      if (init instanceof HeadersList) {
        this.headersMap = new Map(init.headersMap);
        this.sortedMap = init.sortedMap;
        this.cookies = init.cookies === null ? null : [...init.cookies];
      } else {
        this.headersMap = new Map(init);
        this.sortedMap = null;
      }
    }
    /**
     * @see https://fetch.spec.whatwg.org/#header-list-contains
     * @param {string} name
     * @param {boolean} isLowerCase
     */
    contains(name, isLowerCase) {
      return this.headersMap.has(isLowerCase ? name : name.toLowerCase());
    }
    clear() {
      this.headersMap.clear();
      this.sortedMap = null;
      this.cookies = null;
    }
    /**
     * @see https://fetch.spec.whatwg.org/#concept-header-list-append
     * @param {string} name
     * @param {string} value
     * @param {boolean} isLowerCase
     */
    append(name, value, isLowerCase) {
      this.sortedMap = null;
      const lowercaseName = isLowerCase ? name : name.toLowerCase();
      const exists = this.headersMap.get(lowercaseName);
      if (exists) {
        const delimiter = lowercaseName === "cookie" ? "; " : ", ";
        this.headersMap.set(lowercaseName, {
          name: exists.name,
          value: `${exists.value}${delimiter}${value}`
        });
      } else {
        this.headersMap.set(lowercaseName, { name, value });
      }
      if (lowercaseName === "set-cookie") {
        (this.cookies ?? (this.cookies = [])).push(value);
      }
    }
    /**
     * @see https://fetch.spec.whatwg.org/#concept-header-list-set
     * @param {string} name
     * @param {string} value
     * @param {boolean} isLowerCase
     */
    set(name, value, isLowerCase) {
      this.sortedMap = null;
      const lowercaseName = isLowerCase ? name : name.toLowerCase();
      if (lowercaseName === "set-cookie") {
        this.cookies = [value];
      }
      this.headersMap.set(lowercaseName, { name, value });
    }
    /**
     * @see https://fetch.spec.whatwg.org/#concept-header-list-delete
     * @param {string} name
     * @param {boolean} isLowerCase
     */
    delete(name, isLowerCase) {
      this.sortedMap = null;
      if (!isLowerCase) name = name.toLowerCase();
      if (name === "set-cookie") {
        this.cookies = null;
      }
      this.headersMap.delete(name);
    }
    /**
     * @see https://fetch.spec.whatwg.org/#concept-header-list-get
     * @param {string} name
     * @param {boolean} isLowerCase
     * @returns {string | null}
     */
    get(name, isLowerCase) {
      var _a2;
      return ((_a2 = this.headersMap.get(isLowerCase ? name : name.toLowerCase())) == null ? void 0 : _a2.value) ?? null;
    }
    *[Symbol.iterator]() {
      for (const { 0: name, 1: { value } } of this.headersMap) {
        yield [name, value];
      }
    }
    get entries() {
      const headers2 = {};
      if (this.headersMap.size !== 0) {
        for (const { name, value } of this.headersMap.values()) {
          headers2[name] = value;
        }
      }
      return headers2;
    }
    rawValues() {
      return this.headersMap.values();
    }
    get entriesList() {
      const headers2 = [];
      if (this.headersMap.size !== 0) {
        for (const { 0: lowerName, 1: { name, value } } of this.headersMap) {
          if (lowerName === "set-cookie") {
            for (const cookie2 of this.cookies) {
              headers2.push([name, cookie2]);
            }
          } else {
            headers2.push([name, value]);
          }
        }
      }
      return headers2;
    }
    // https://fetch.spec.whatwg.org/#convert-header-names-to-a-sorted-lowercase-set
    toSortedArray() {
      const size = this.headersMap.size;
      const array = new Array(size);
      if (size <= 32) {
        if (size === 0) {
          return array;
        }
        const iterator = this.headersMap[Symbol.iterator]();
        const firstValue = iterator.next().value;
        array[0] = [firstValue[0], firstValue[1].value];
        assert2(firstValue[1].value !== null);
        for (let i = 1, j = 0, right = 0, left = 0, pivot = 0, x, value; i < size; ++i) {
          value = iterator.next().value;
          x = array[i] = [value[0], value[1].value];
          assert2(x[1] !== null);
          left = 0;
          right = i;
          while (left < right) {
            pivot = left + (right - left >> 1);
            if (array[pivot][0] <= x[0]) {
              left = pivot + 1;
            } else {
              right = pivot;
            }
          }
          if (i !== pivot) {
            j = i;
            while (j > left) {
              array[j] = array[--j];
            }
            array[left] = x;
          }
        }
        if (!iterator.next().done) {
          throw new TypeError("Unreachable");
        }
        return array;
      } else {
        let i = 0;
        for (const { 0: name, 1: { value } } of this.headersMap) {
          array[i++] = [name, value];
          assert2(value !== null);
        }
        return array.sort(compareHeaderName);
      }
    }
  }
  const _Headers = class _Headers {
    /**
     * @param {HeadersInit|Symbol} [init]
     * @returns
     */
    constructor(init = void 0) {
      __privateAdd(this, _guard);
      /**
       * @type {HeadersList}
       */
      __privateAdd(this, _headersList);
      webidl.util.markAsUncloneable(this);
      if (init === kConstruct2) {
        return;
      }
      __privateSet(this, _headersList, new HeadersList());
      __privateSet(this, _guard, "none");
      if (init !== void 0) {
        init = webidl.converters.HeadersInit(init, "Headers constructor", "init");
        fill(this, init);
      }
    }
    // https://fetch.spec.whatwg.org/#dom-headers-append
    append(name, value) {
      webidl.brandCheck(this, _Headers);
      webidl.argumentLengthCheck(arguments, 2, "Headers.append");
      const prefix = "Headers.append";
      name = webidl.converters.ByteString(name, prefix, "name");
      value = webidl.converters.ByteString(value, prefix, "value");
      return appendHeader(this, name, value);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-delete
    delete(name) {
      webidl.brandCheck(this, _Headers);
      webidl.argumentLengthCheck(arguments, 1, "Headers.delete");
      const prefix = "Headers.delete";
      name = webidl.converters.ByteString(name, prefix, "name");
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.delete",
          value: name,
          type: "header name"
        });
      }
      if (__privateGet(this, _guard) === "immutable") {
        throw new TypeError("immutable");
      }
      if (!__privateGet(this, _headersList).contains(name, false)) {
        return;
      }
      __privateGet(this, _headersList).delete(name, false);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-get
    get(name) {
      webidl.brandCheck(this, _Headers);
      webidl.argumentLengthCheck(arguments, 1, "Headers.get");
      const prefix = "Headers.get";
      name = webidl.converters.ByteString(name, prefix, "name");
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value: name,
          type: "header name"
        });
      }
      return __privateGet(this, _headersList).get(name, false);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-has
    has(name) {
      webidl.brandCheck(this, _Headers);
      webidl.argumentLengthCheck(arguments, 1, "Headers.has");
      const prefix = "Headers.has";
      name = webidl.converters.ByteString(name, prefix, "name");
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value: name,
          type: "header name"
        });
      }
      return __privateGet(this, _headersList).contains(name, false);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-set
    set(name, value) {
      webidl.brandCheck(this, _Headers);
      webidl.argumentLengthCheck(arguments, 2, "Headers.set");
      const prefix = "Headers.set";
      name = webidl.converters.ByteString(name, prefix, "name");
      value = webidl.converters.ByteString(value, prefix, "value");
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue2(value)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value,
          type: "header value"
        });
      }
      if (__privateGet(this, _guard) === "immutable") {
        throw new TypeError("immutable");
      }
      __privateGet(this, _headersList).set(name, value, false);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
    getSetCookie() {
      webidl.brandCheck(this, _Headers);
      const list = __privateGet(this, _headersList).cookies;
      if (list) {
        return [...list];
      }
      return [];
    }
    [util2.inspect.custom](depth, options) {
      options.depth ?? (options.depth = depth);
      return `Headers ${util2.formatWithOptions(options, __privateGet(this, _headersList).entries)}`;
    }
    static getHeadersGuard(o) {
      return __privateGet(o, _guard);
    }
    static setHeadersGuard(o, guard) {
      __privateSet(o, _guard, guard);
    }
    /**
     * @param {Headers} o
     */
    static getHeadersList(o) {
      return __privateGet(o, _headersList);
    }
    /**
     * @param {Headers} target
     * @param {HeadersList} list
     */
    static setHeadersList(target, list) {
      __privateSet(target, _headersList, list);
    }
  };
  _guard = new WeakMap();
  _headersList = new WeakMap();
  let Headers = _Headers;
  const { getHeadersGuard, setHeadersGuard, getHeadersList, setHeadersList } = Headers;
  Reflect.deleteProperty(Headers, "getHeadersGuard");
  Reflect.deleteProperty(Headers, "setHeadersGuard");
  Reflect.deleteProperty(Headers, "getHeadersList");
  Reflect.deleteProperty(Headers, "setHeadersList");
  iteratorMixin("Headers", Headers, headersListSortAndCombine, 0, 1);
  Object.defineProperties(Headers.prototype, {
    append: kEnumerableProperty2,
    delete: kEnumerableProperty2,
    get: kEnumerableProperty2,
    has: kEnumerableProperty2,
    set: kEnumerableProperty2,
    getSetCookie: kEnumerableProperty2,
    [Symbol.toStringTag]: {
      value: "Headers",
      configurable: true
    },
    [util2.inspect.custom]: {
      enumerable: false
    }
  });
  webidl.converters.HeadersInit = function(V, prefix, argument) {
    if (webidl.util.Type(V) === webidl.util.Types.OBJECT) {
      const iterator = Reflect.get(V, Symbol.iterator);
      if (!util2.types.isProxy(V) && iterator === Headers.prototype.entries) {
        try {
          return getHeadersList(V).entriesList;
        } catch {
        }
      }
      if (typeof iterator === "function") {
        return webidl.converters["sequence<sequence<ByteString>>"](V, prefix, argument, iterator.bind(V));
      }
      return webidl.converters["record<ByteString, ByteString>"](V, prefix, argument);
    }
    throw webidl.errors.conversionFailed({
      prefix: "Headers constructor",
      argument: "Argument 1",
      types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
    });
  };
  headers$1 = {
    fill,
    // for test.
    compareHeaderName,
    Headers,
    HeadersList,
    getHeadersGuard,
    setHeadersGuard,
    setHeadersList,
    getHeadersList
  };
  return headers$1;
}
var response$1;
var hasRequiredResponse$1;
function requireResponse$1() {
  var _headers2, _state3;
  if (hasRequiredResponse$1) return response$1;
  hasRequiredResponse$1 = 1;
  const { Headers, HeadersList, fill, getHeadersGuard, setHeadersGuard, setHeadersList } = requireHeaders$1();
  const { extractBody: extractBody2, cloneBody, mixinBody, hasFinalizationRegistry, streamRegistry, bodyUnusable } = requireBody$1();
  const util2 = util$J;
  const nodeUtil2 = require$$0$2;
  const { kEnumerableProperty: kEnumerableProperty2 } = util2;
  const {
    isValidReasonPhrase,
    isCancelled,
    isAborted,
    serializeJavascriptValueToJSONString,
    isErrorLike,
    isomorphicEncode,
    environmentSettingsObject: relevantRealm
  } = requireUtil$a();
  const {
    redirectStatusSet,
    nullBodyStatus
  } = requireConstants$5();
  const { webidl } = requireWebidl$1();
  const { URLSerializer } = requireDataUrl$1();
  const { kConstruct: kConstruct2 } = symbols$5;
  const assert2 = require$$0$3;
  const { types } = require$$0$2;
  const textEncoder = new TextEncoder("utf-8");
  const _Response = class _Response {
    // https://fetch.spec.whatwg.org/#dom-response
    constructor(body2 = null, init = void 0) {
      /** @type {Headers} */
      __privateAdd(this, _headers2);
      __privateAdd(this, _state3);
      webidl.util.markAsUncloneable(this);
      if (body2 === kConstruct2) {
        return;
      }
      if (body2 !== null) {
        body2 = webidl.converters.BodyInit(body2);
      }
      init = webidl.converters.ResponseInit(init);
      __privateSet(this, _state3, makeResponse({}));
      __privateSet(this, _headers2, new Headers(kConstruct2));
      setHeadersGuard(__privateGet(this, _headers2), "response");
      setHeadersList(__privateGet(this, _headers2), __privateGet(this, _state3).headersList);
      let bodyWithType = null;
      if (body2 != null) {
        const [extractedBody, type] = extractBody2(body2);
        bodyWithType = { body: extractedBody, type };
      }
      initializeResponse(this, init, bodyWithType);
    }
    // Creates network error Response.
    static error() {
      const responseObject = fromInnerResponse(makeNetworkError(), "immutable");
      return responseObject;
    }
    // https://fetch.spec.whatwg.org/#dom-response-json
    static json(data, init = void 0) {
      webidl.argumentLengthCheck(arguments, 1, "Response.json");
      if (init !== null) {
        init = webidl.converters.ResponseInit(init);
      }
      const bytes = textEncoder.encode(
        serializeJavascriptValueToJSONString(data)
      );
      const body2 = extractBody2(bytes);
      const responseObject = fromInnerResponse(makeResponse({}), "response");
      initializeResponse(responseObject, init, { body: body2[0], type: "application/json" });
      return responseObject;
    }
    // Creates a redirect Response that redirects to url with status status.
    static redirect(url, status = 302) {
      webidl.argumentLengthCheck(arguments, 1, "Response.redirect");
      url = webidl.converters.USVString(url);
      status = webidl.converters["unsigned short"](status);
      let parsedURL;
      try {
        parsedURL = new URL(url, relevantRealm.settingsObject.baseUrl);
      } catch (err) {
        throw new TypeError(`Failed to parse URL from ${url}`, { cause: err });
      }
      if (!redirectStatusSet.has(status)) {
        throw new RangeError(`Invalid status code ${status}`);
      }
      const responseObject = fromInnerResponse(makeResponse({}), "immutable");
      __privateGet(responseObject, _state3).status = status;
      const value = isomorphicEncode(URLSerializer(parsedURL));
      __privateGet(responseObject, _state3).headersList.append("location", value, true);
      return responseObject;
    }
    // Returns response’s type, e.g., "cors".
    get type() {
      webidl.brandCheck(this, _Response);
      return __privateGet(this, _state3).type;
    }
    // Returns response’s URL, if it has one; otherwise the empty string.
    get url() {
      webidl.brandCheck(this, _Response);
      const urlList = __privateGet(this, _state3).urlList;
      const url = urlList[urlList.length - 1] ?? null;
      if (url === null) {
        return "";
      }
      return URLSerializer(url, true);
    }
    // Returns whether response was obtained through a redirect.
    get redirected() {
      webidl.brandCheck(this, _Response);
      return __privateGet(this, _state3).urlList.length > 1;
    }
    // Returns response’s status.
    get status() {
      webidl.brandCheck(this, _Response);
      return __privateGet(this, _state3).status;
    }
    // Returns whether response’s status is an ok status.
    get ok() {
      webidl.brandCheck(this, _Response);
      return __privateGet(this, _state3).status >= 200 && __privateGet(this, _state3).status <= 299;
    }
    // Returns response’s status message.
    get statusText() {
      webidl.brandCheck(this, _Response);
      return __privateGet(this, _state3).statusText;
    }
    // Returns response’s headers as Headers.
    get headers() {
      webidl.brandCheck(this, _Response);
      return __privateGet(this, _headers2);
    }
    get body() {
      webidl.brandCheck(this, _Response);
      return __privateGet(this, _state3).body ? __privateGet(this, _state3).body.stream : null;
    }
    get bodyUsed() {
      webidl.brandCheck(this, _Response);
      return !!__privateGet(this, _state3).body && util2.isDisturbed(__privateGet(this, _state3).body.stream);
    }
    // Returns a clone of response.
    clone() {
      webidl.brandCheck(this, _Response);
      if (bodyUnusable(__privateGet(this, _state3))) {
        throw webidl.errors.exception({
          header: "Response.clone",
          message: "Body has already been consumed."
        });
      }
      const clonedResponse = cloneResponse(__privateGet(this, _state3));
      return fromInnerResponse(clonedResponse, getHeadersGuard(__privateGet(this, _headers2)));
    }
    [nodeUtil2.inspect.custom](depth, options) {
      if (options.depth === null) {
        options.depth = 2;
      }
      options.colors ?? (options.colors = true);
      const properties = {
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        body: this.body,
        bodyUsed: this.bodyUsed,
        ok: this.ok,
        redirected: this.redirected,
        type: this.type,
        url: this.url
      };
      return `Response ${nodeUtil2.formatWithOptions(options, properties)}`;
    }
    /**
     * @param {Response} response
     */
    static getResponseHeaders(response2) {
      return __privateGet(response2, _headers2);
    }
    /**
     * @param {Response} response
     * @param {Headers} newHeaders
     */
    static setResponseHeaders(response2, newHeaders) {
      __privateSet(response2, _headers2, newHeaders);
    }
    /**
     * @param {Response} response
     */
    static getResponseState(response2) {
      return __privateGet(response2, _state3);
    }
    /**
     * @param {Response} response
     * @param {any} newState
     */
    static setResponseState(response2, newState) {
      __privateSet(response2, _state3, newState);
    }
  };
  _headers2 = new WeakMap();
  _state3 = new WeakMap();
  let Response = _Response;
  const { getResponseHeaders, setResponseHeaders, getResponseState, setResponseState } = Response;
  Reflect.deleteProperty(Response, "getResponseHeaders");
  Reflect.deleteProperty(Response, "setResponseHeaders");
  Reflect.deleteProperty(Response, "getResponseState");
  Reflect.deleteProperty(Response, "setResponseState");
  mixinBody(Response, getResponseState);
  Object.defineProperties(Response.prototype, {
    type: kEnumerableProperty2,
    url: kEnumerableProperty2,
    status: kEnumerableProperty2,
    ok: kEnumerableProperty2,
    redirected: kEnumerableProperty2,
    statusText: kEnumerableProperty2,
    headers: kEnumerableProperty2,
    clone: kEnumerableProperty2,
    body: kEnumerableProperty2,
    bodyUsed: kEnumerableProperty2,
    [Symbol.toStringTag]: {
      value: "Response",
      configurable: true
    }
  });
  Object.defineProperties(Response, {
    json: kEnumerableProperty2,
    redirect: kEnumerableProperty2,
    error: kEnumerableProperty2
  });
  function cloneResponse(response2) {
    if (response2.internalResponse) {
      return filterResponse(
        cloneResponse(response2.internalResponse),
        response2.type
      );
    }
    const newResponse = makeResponse({ ...response2, body: null });
    if (response2.body != null) {
      newResponse.body = cloneBody(newResponse, response2.body);
    }
    return newResponse;
  }
  function makeResponse(init) {
    return {
      aborted: false,
      rangeRequested: false,
      timingAllowPassed: false,
      requestIncludesCredentials: false,
      type: "default",
      status: 200,
      timingInfo: null,
      cacheState: "",
      statusText: "",
      ...init,
      headersList: (init == null ? void 0 : init.headersList) ? new HeadersList(init == null ? void 0 : init.headersList) : new HeadersList(),
      urlList: (init == null ? void 0 : init.urlList) ? [...init.urlList] : []
    };
  }
  function makeNetworkError(reason) {
    const isError = isErrorLike(reason);
    return makeResponse({
      type: "error",
      status: 0,
      error: isError ? reason : new Error(reason ? String(reason) : reason),
      aborted: reason && reason.name === "AbortError"
    });
  }
  function isNetworkError(response2) {
    return (
      // A network error is a response whose type is "error",
      response2.type === "error" && // status is 0
      response2.status === 0
    );
  }
  function makeFilteredResponse(response2, state) {
    state = {
      internalResponse: response2,
      ...state
    };
    return new Proxy(response2, {
      get(target, p) {
        return p in state ? state[p] : target[p];
      },
      set(target, p, value) {
        assert2(!(p in state));
        target[p] = value;
        return true;
      }
    });
  }
  function filterResponse(response2, type) {
    if (type === "basic") {
      return makeFilteredResponse(response2, {
        type: "basic",
        headersList: response2.headersList
      });
    } else if (type === "cors") {
      return makeFilteredResponse(response2, {
        type: "cors",
        headersList: response2.headersList
      });
    } else if (type === "opaque") {
      return makeFilteredResponse(response2, {
        type: "opaque",
        urlList: Object.freeze([]),
        status: 0,
        statusText: "",
        body: null
      });
    } else if (type === "opaqueredirect") {
      return makeFilteredResponse(response2, {
        type: "opaqueredirect",
        status: 0,
        statusText: "",
        headersList: [],
        body: null
      });
    } else {
      assert2(false);
    }
  }
  function makeAppropriateNetworkError(fetchParams, err = null) {
    assert2(isCancelled(fetchParams));
    return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException("Request was cancelled."), { cause: err }));
  }
  function initializeResponse(response2, init, body2) {
    if (init.status !== null && (init.status < 200 || init.status > 599)) {
      throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
    }
    if ("statusText" in init && init.statusText != null) {
      if (!isValidReasonPhrase(String(init.statusText))) {
        throw new TypeError("Invalid statusText");
      }
    }
    if ("status" in init && init.status != null) {
      getResponseState(response2).status = init.status;
    }
    if ("statusText" in init && init.statusText != null) {
      getResponseState(response2).statusText = init.statusText;
    }
    if ("headers" in init && init.headers != null) {
      fill(getResponseHeaders(response2), init.headers);
    }
    if (body2) {
      if (nullBodyStatus.includes(response2.status)) {
        throw webidl.errors.exception({
          header: "Response constructor",
          message: `Invalid response status code ${response2.status}`
        });
      }
      getResponseState(response2).body = body2.body;
      if (body2.type != null && !getResponseState(response2).headersList.contains("content-type", true)) {
        getResponseState(response2).headersList.append("content-type", body2.type, true);
      }
    }
  }
  function fromInnerResponse(innerResponse, guard) {
    var _a2;
    const response2 = new Response(kConstruct2);
    setResponseState(response2, innerResponse);
    const headers2 = new Headers(kConstruct2);
    setResponseHeaders(response2, headers2);
    setHeadersList(headers2, innerResponse.headersList);
    setHeadersGuard(headers2, guard);
    if (hasFinalizationRegistry && ((_a2 = innerResponse.body) == null ? void 0 : _a2.stream)) {
      streamRegistry.register(response2, new WeakRef(innerResponse.body.stream));
    }
    return response2;
  }
  webidl.converters.XMLHttpRequestBodyInit = function(V, prefix, name) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V, prefix, name);
    }
    if (webidl.is.Blob(V)) {
      return V;
    }
    if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {
      return V;
    }
    if (webidl.is.FormData(V)) {
      return V;
    }
    if (webidl.is.URLSearchParams(V)) {
      return V;
    }
    return webidl.converters.DOMString(V, prefix, name);
  };
  webidl.converters.BodyInit = function(V, prefix, argument) {
    if (webidl.is.ReadableStream(V)) {
      return V;
    }
    if (V == null ? void 0 : V[Symbol.asyncIterator]) {
      return V;
    }
    return webidl.converters.XMLHttpRequestBodyInit(V, prefix, argument);
  };
  webidl.converters.ResponseInit = webidl.dictionaryConverter([
    {
      key: "status",
      converter: webidl.converters["unsigned short"],
      defaultValue: () => 200
    },
    {
      key: "statusText",
      converter: webidl.converters.ByteString,
      defaultValue: () => ""
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    }
  ]);
  webidl.is.Response = webidl.util.MakeTypeAssertion(Response);
  response$1 = {
    isNetworkError,
    makeNetworkError,
    makeResponse,
    makeAppropriateNetworkError,
    filterResponse,
    Response,
    cloneResponse,
    fromInnerResponse,
    getResponseState
  };
  return response$1;
}
var dispatcherWeakref$1;
var hasRequiredDispatcherWeakref$1;
function requireDispatcherWeakref$1() {
  if (hasRequiredDispatcherWeakref$1) return dispatcherWeakref$1;
  hasRequiredDispatcherWeakref$1 = 1;
  const { kConnected: kConnected2, kSize: kSize2 } = symbols$5;
  class CompatWeakRef {
    constructor(value) {
      this.value = value;
    }
    deref() {
      return this.value[kConnected2] === 0 && this.value[kSize2] === 0 ? void 0 : this.value;
    }
  }
  class CompatFinalizer {
    constructor(finalizer) {
      this.finalizer = finalizer;
    }
    register(dispatcher2, key) {
      if (dispatcher2.on) {
        dispatcher2.on("disconnect", () => {
          if (dispatcher2[kConnected2] === 0 && dispatcher2[kSize2] === 0) {
            this.finalizer(key);
          }
        });
      }
    }
    unregister(key) {
    }
  }
  dispatcherWeakref$1 = function() {
    if (process.env.NODE_V8_COVERAGE && process.version.startsWith("v18")) {
      process._rawDebug("Using compatibility WeakRef and FinalizationRegistry");
      return {
        WeakRef: CompatWeakRef,
        FinalizationRegistry: CompatFinalizer
      };
    }
    return { WeakRef, FinalizationRegistry };
  };
  return dispatcherWeakref$1;
}
var request$3;
var hasRequiredRequest$1;
function requireRequest$1() {
  var _signal, _dispatcher2, _headers2, _state3;
  if (hasRequiredRequest$1) return request$3;
  hasRequiredRequest$1 = 1;
  const { extractBody: extractBody2, mixinBody, cloneBody, bodyUnusable } = requireBody$1();
  const { Headers, fill: fillHeaders, HeadersList, setHeadersGuard, getHeadersGuard, setHeadersList, getHeadersList } = requireHeaders$1();
  const { FinalizationRegistry: FinalizationRegistry2 } = requireDispatcherWeakref$1()();
  const util2 = util$J;
  const nodeUtil2 = require$$0$2;
  const {
    isValidHTTPToken: isValidHTTPToken2,
    sameOrigin,
    environmentSettingsObject
  } = requireUtil$a();
  const {
    forbiddenMethodsSet,
    corsSafeListedMethodsSet,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    requestDuplex
  } = requireConstants$5();
  const { kEnumerableProperty: kEnumerableProperty2, normalizedMethodRecordsBase: normalizedMethodRecordsBase2, normalizedMethodRecords: normalizedMethodRecords2 } = util2;
  const { webidl } = requireWebidl$1();
  const { URLSerializer } = requireDataUrl$1();
  const { kConstruct: kConstruct2 } = symbols$5;
  const assert2 = require$$0$3;
  const { getMaxListeners, setMaxListeners, defaultMaxListeners } = require$$8$1;
  const kAbortController = Symbol("abortController");
  const requestFinalizer = new FinalizationRegistry2(({ signal, abort: abort2 }) => {
    signal.removeEventListener("abort", abort2);
  });
  const dependentControllerMap = /* @__PURE__ */ new WeakMap();
  let abortSignalHasEventHandlerLeakWarning;
  try {
    abortSignalHasEventHandlerLeakWarning = getMaxListeners(new AbortController().signal) > 0;
  } catch {
    abortSignalHasEventHandlerLeakWarning = false;
  }
  function buildAbort(acRef) {
    return abort2;
    function abort2() {
      const ac = acRef.deref();
      if (ac !== void 0) {
        requestFinalizer.unregister(abort2);
        this.removeEventListener("abort", abort2);
        ac.abort(this.reason);
        const controllerList = dependentControllerMap.get(ac.signal);
        if (controllerList !== void 0) {
          if (controllerList.size !== 0) {
            for (const ref of controllerList) {
              const ctrl = ref.deref();
              if (ctrl !== void 0) {
                ctrl.abort(this.reason);
              }
            }
            controllerList.clear();
          }
          dependentControllerMap.delete(ac.signal);
        }
      }
    }
  }
  let patchMethodWarning = false;
  const _Request = class _Request {
    // https://fetch.spec.whatwg.org/#dom-request
    constructor(input, init = void 0) {
      /** @type {AbortSignal} */
      __privateAdd(this, _signal);
      /** @type {import('../../dispatcher/dispatcher')} */
      __privateAdd(this, _dispatcher2);
      /** @type {Headers} */
      __privateAdd(this, _headers2);
      __privateAdd(this, _state3);
      var _a2, _b2;
      webidl.util.markAsUncloneable(this);
      if (input === kConstruct2) {
        return;
      }
      const prefix = "Request constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      input = webidl.converters.RequestInfo(input, prefix, "input");
      init = webidl.converters.RequestInit(init, prefix, "init");
      let request2 = null;
      let fallbackMode = null;
      const baseUrl = environmentSettingsObject.settingsObject.baseUrl;
      let signal = null;
      if (typeof input === "string") {
        __privateSet(this, _dispatcher2, init.dispatcher);
        let parsedURL;
        try {
          parsedURL = new URL(input, baseUrl);
        } catch (err) {
          throw new TypeError("Failed to parse URL from " + input, { cause: err });
        }
        if (parsedURL.username || parsedURL.password) {
          throw new TypeError(
            "Request cannot be constructed from a URL that includes credentials: " + input
          );
        }
        request2 = makeRequest({ urlList: [parsedURL] });
        fallbackMode = "cors";
      } else {
        assert2(webidl.is.Request(input));
        request2 = __privateGet(input, _state3);
        signal = __privateGet(input, _signal);
        __privateSet(this, _dispatcher2, init.dispatcher || __privateGet(input, _dispatcher2));
      }
      const origin = environmentSettingsObject.settingsObject.origin;
      let window2 = "client";
      if (((_b2 = (_a2 = request2.window) == null ? void 0 : _a2.constructor) == null ? void 0 : _b2.name) === "EnvironmentSettingsObject" && sameOrigin(request2.window, origin)) {
        window2 = request2.window;
      }
      if (init.window != null) {
        throw new TypeError(`'window' option '${window2}' must be null`);
      }
      if ("window" in init) {
        window2 = "no-window";
      }
      request2 = makeRequest({
        // URL request’s URL.
        // undici implementation note: this is set as the first item in request's urlList in makeRequest
        // method request’s method.
        method: request2.method,
        // header list A copy of request’s header list.
        // undici implementation note: headersList is cloned in makeRequest
        headersList: request2.headersList,
        // unsafe-request flag Set.
        unsafeRequest: request2.unsafeRequest,
        // client This’s relevant settings object.
        client: environmentSettingsObject.settingsObject,
        // window window.
        window: window2,
        // priority request’s priority.
        priority: request2.priority,
        // origin request’s origin. The propagation of the origin is only significant for navigation requests
        // being handled by a service worker. In this scenario a request can have an origin that is different
        // from the current client.
        origin: request2.origin,
        // referrer request’s referrer.
        referrer: request2.referrer,
        // referrer policy request’s referrer policy.
        referrerPolicy: request2.referrerPolicy,
        // mode request’s mode.
        mode: request2.mode,
        // credentials mode request’s credentials mode.
        credentials: request2.credentials,
        // cache mode request’s cache mode.
        cache: request2.cache,
        // redirect mode request’s redirect mode.
        redirect: request2.redirect,
        // integrity metadata request’s integrity metadata.
        integrity: request2.integrity,
        // keepalive request’s keepalive.
        keepalive: request2.keepalive,
        // reload-navigation flag request’s reload-navigation flag.
        reloadNavigation: request2.reloadNavigation,
        // history-navigation flag request’s history-navigation flag.
        historyNavigation: request2.historyNavigation,
        // URL list A clone of request’s URL list.
        urlList: [...request2.urlList]
      });
      const initHasKey = Object.keys(init).length !== 0;
      if (initHasKey) {
        if (request2.mode === "navigate") {
          request2.mode = "same-origin";
        }
        request2.reloadNavigation = false;
        request2.historyNavigation = false;
        request2.origin = "client";
        request2.referrer = "client";
        request2.referrerPolicy = "";
        request2.url = request2.urlList[request2.urlList.length - 1];
        request2.urlList = [request2.url];
      }
      if (init.referrer !== void 0) {
        const referrer = init.referrer;
        if (referrer === "") {
          request2.referrer = "no-referrer";
        } else {
          let parsedReferrer;
          try {
            parsedReferrer = new URL(referrer, baseUrl);
          } catch (err) {
            throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
          }
          if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, environmentSettingsObject.settingsObject.baseUrl)) {
            request2.referrer = "client";
          } else {
            request2.referrer = parsedReferrer;
          }
        }
      }
      if (init.referrerPolicy !== void 0) {
        request2.referrerPolicy = init.referrerPolicy;
      }
      let mode;
      if (init.mode !== void 0) {
        mode = init.mode;
      } else {
        mode = fallbackMode;
      }
      if (mode === "navigate") {
        throw webidl.errors.exception({
          header: "Request constructor",
          message: "invalid request mode navigate."
        });
      }
      if (mode != null) {
        request2.mode = mode;
      }
      if (init.credentials !== void 0) {
        request2.credentials = init.credentials;
      }
      if (init.cache !== void 0) {
        request2.cache = init.cache;
      }
      if (request2.cache === "only-if-cached" && request2.mode !== "same-origin") {
        throw new TypeError(
          "'only-if-cached' can be set only with 'same-origin' mode"
        );
      }
      if (init.redirect !== void 0) {
        request2.redirect = init.redirect;
      }
      if (init.integrity != null) {
        request2.integrity = String(init.integrity);
      }
      if (init.keepalive !== void 0) {
        request2.keepalive = Boolean(init.keepalive);
      }
      if (init.method !== void 0) {
        let method = init.method;
        const mayBeNormalized = normalizedMethodRecords2[method];
        if (mayBeNormalized !== void 0) {
          request2.method = mayBeNormalized;
        } else {
          if (!isValidHTTPToken2(method)) {
            throw new TypeError(`'${method}' is not a valid HTTP method.`);
          }
          const upperCase = method.toUpperCase();
          if (forbiddenMethodsSet.has(upperCase)) {
            throw new TypeError(`'${method}' HTTP method is unsupported.`);
          }
          method = normalizedMethodRecordsBase2[upperCase] ?? method;
          request2.method = method;
        }
        if (!patchMethodWarning && request2.method === "patch") {
          process.emitWarning("Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.", {
            code: "UNDICI-FETCH-patch"
          });
          patchMethodWarning = true;
        }
      }
      if (init.signal !== void 0) {
        signal = init.signal;
      }
      __privateSet(this, _state3, request2);
      const ac = new AbortController();
      __privateSet(this, _signal, ac.signal);
      if (signal != null) {
        if (signal.aborted) {
          ac.abort(signal.reason);
        } else {
          this[kAbortController] = ac;
          const acRef = new WeakRef(ac);
          const abort2 = buildAbort(acRef);
          if (abortSignalHasEventHandlerLeakWarning && getMaxListeners(signal) === defaultMaxListeners) {
            setMaxListeners(1500, signal);
          }
          util2.addAbortListener(signal, abort2);
          requestFinalizer.register(ac, { signal, abort: abort2 }, abort2);
        }
      }
      __privateSet(this, _headers2, new Headers(kConstruct2));
      setHeadersList(__privateGet(this, _headers2), request2.headersList);
      setHeadersGuard(__privateGet(this, _headers2), "request");
      if (mode === "no-cors") {
        if (!corsSafeListedMethodsSet.has(request2.method)) {
          throw new TypeError(
            `'${request2.method} is unsupported in no-cors mode.`
          );
        }
        setHeadersGuard(__privateGet(this, _headers2), "request-no-cors");
      }
      if (initHasKey) {
        const headersList = getHeadersList(__privateGet(this, _headers2));
        const headers2 = init.headers !== void 0 ? init.headers : new HeadersList(headersList);
        headersList.clear();
        if (headers2 instanceof HeadersList) {
          for (const { name, value } of headers2.rawValues()) {
            headersList.append(name, value, false);
          }
          headersList.cookies = headers2.cookies;
        } else {
          fillHeaders(__privateGet(this, _headers2), headers2);
        }
      }
      const inputBody = webidl.is.Request(input) ? __privateGet(input, _state3).body : null;
      if ((init.body != null || inputBody != null) && (request2.method === "GET" || request2.method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body.");
      }
      let initBody = null;
      if (init.body != null) {
        const [extractedBody, contentType] = extractBody2(
          init.body,
          request2.keepalive
        );
        initBody = extractedBody;
        if (contentType && !getHeadersList(__privateGet(this, _headers2)).contains("content-type", true)) {
          __privateGet(this, _headers2).append("content-type", contentType, true);
        }
      }
      const inputOrInitBody = initBody ?? inputBody;
      if (inputOrInitBody != null && inputOrInitBody.source == null) {
        if (initBody != null && init.duplex == null) {
          throw new TypeError("RequestInit: duplex option is required when sending a body.");
        }
        if (request2.mode !== "same-origin" && request2.mode !== "cors") {
          throw new TypeError(
            'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
          );
        }
        request2.useCORSPreflightFlag = true;
      }
      let finalBody = inputOrInitBody;
      if (initBody == null && inputBody != null) {
        if (bodyUnusable(__privateGet(input, _state3))) {
          throw new TypeError(
            "Cannot construct a Request with a Request object that has already been used."
          );
        }
        const identityTransform = new TransformStream();
        inputBody.stream.pipeThrough(identityTransform);
        finalBody = {
          source: inputBody.source,
          length: inputBody.length,
          stream: identityTransform.readable
        };
      }
      __privateGet(this, _state3).body = finalBody;
    }
    // Returns request’s HTTP method, which is "GET" by default.
    get method() {
      webidl.brandCheck(this, _Request);
      return __privateGet(this, _state3).method;
    }
    // Returns the URL of request as a string.
    get url() {
      webidl.brandCheck(this, _Request);
      return URLSerializer(__privateGet(this, _state3).url);
    }
    // Returns a Headers object consisting of the headers associated with request.
    // Note that headers added in the network layer by the user agent will not
    // be accounted for in this object, e.g., the "Host" header.
    get headers() {
      webidl.brandCheck(this, _Request);
      return __privateGet(this, _headers2);
    }
    // Returns the kind of resource requested by request, e.g., "document"
    // or "script".
    get destination() {
      webidl.brandCheck(this, _Request);
      return __privateGet(this, _state3).destination;
    }
    // Returns the referrer of request. Its value can be a same-origin URL if
    // explicitly set in init, the empty string to indicate no referrer, and
    // "about:client" when defaulting to the global’s default. This is used
    // during fetching to determine the value of the `Referer` header of the
    // request being made.
    get referrer() {
      webidl.brandCheck(this, _Request);
      if (__privateGet(this, _state3).referrer === "no-referrer") {
        return "";
      }
      if (__privateGet(this, _state3).referrer === "client") {
        return "about:client";
      }
      return __privateGet(this, _state3).referrer.toString();
    }
    // Returns the referrer policy associated with request.
    // This is used during fetching to compute the value of the request’s
    // referrer.
    get referrerPolicy() {
      webidl.brandCheck(this, _Request);
      return __privateGet(this, _state3).referrerPolicy;
    }
    // Returns the mode associated with request, which is a string indicating
    // whether the request will use CORS, or will be restricted to same-origin
    // URLs.
    get mode() {
      webidl.brandCheck(this, _Request);
      return __privateGet(this, _state3).mode;
    }
    // Returns the credentials mode associated with request,
    // which is a string indicating whether credentials will be sent with the
    // request always, never, or only when sent to a same-origin URL.
    get credentials() {
      webidl.brandCheck(this, _Request);
      return __privateGet(this, _state3).credentials;
    }
    // Returns the cache mode associated with request,
    // which is a string indicating how the request will
    // interact with the browser’s cache when fetching.
    get cache() {
      webidl.brandCheck(this, _Request);
      return __privateGet(this, _state3).cache;
    }
    // Returns the redirect mode associated with request,
    // which is a string indicating how redirects for the
    // request will be handled during fetching. A request
    // will follow redirects by default.
    get redirect() {
      webidl.brandCheck(this, _Request);
      return __privateGet(this, _state3).redirect;
    }
    // Returns request’s subresource integrity metadata, which is a
    // cryptographic hash of the resource being fetched. Its value
    // consists of multiple hashes separated by whitespace. [SRI]
    get integrity() {
      webidl.brandCheck(this, _Request);
      return __privateGet(this, _state3).integrity;
    }
    // Returns a boolean indicating whether or not request can outlive the
    // global in which it was created.
    get keepalive() {
      webidl.brandCheck(this, _Request);
      return __privateGet(this, _state3).keepalive;
    }
    // Returns a boolean indicating whether or not request is for a reload
    // navigation.
    get isReloadNavigation() {
      webidl.brandCheck(this, _Request);
      return __privateGet(this, _state3).reloadNavigation;
    }
    // Returns a boolean indicating whether or not request is for a history
    // navigation (a.k.a. back-forward navigation).
    get isHistoryNavigation() {
      webidl.brandCheck(this, _Request);
      return __privateGet(this, _state3).historyNavigation;
    }
    // Returns the signal associated with request, which is an AbortSignal
    // object indicating whether or not request has been aborted, and its
    // abort event handler.
    get signal() {
      webidl.brandCheck(this, _Request);
      return __privateGet(this, _signal);
    }
    get body() {
      webidl.brandCheck(this, _Request);
      return __privateGet(this, _state3).body ? __privateGet(this, _state3).body.stream : null;
    }
    get bodyUsed() {
      webidl.brandCheck(this, _Request);
      return !!__privateGet(this, _state3).body && util2.isDisturbed(__privateGet(this, _state3).body.stream);
    }
    get duplex() {
      webidl.brandCheck(this, _Request);
      return "half";
    }
    // Returns a clone of request.
    clone() {
      webidl.brandCheck(this, _Request);
      if (bodyUnusable(__privateGet(this, _state3))) {
        throw new TypeError("unusable");
      }
      const clonedRequest = cloneRequest(__privateGet(this, _state3));
      const ac = new AbortController();
      if (this.signal.aborted) {
        ac.abort(this.signal.reason);
      } else {
        let list = dependentControllerMap.get(this.signal);
        if (list === void 0) {
          list = /* @__PURE__ */ new Set();
          dependentControllerMap.set(this.signal, list);
        }
        const acRef = new WeakRef(ac);
        list.add(acRef);
        util2.addAbortListener(
          ac.signal,
          buildAbort(acRef)
        );
      }
      return fromInnerRequest(clonedRequest, __privateGet(this, _dispatcher2), ac.signal, getHeadersGuard(__privateGet(this, _headers2)));
    }
    [nodeUtil2.inspect.custom](depth, options) {
      if (options.depth === null) {
        options.depth = 2;
      }
      options.colors ?? (options.colors = true);
      const properties = {
        method: this.method,
        url: this.url,
        headers: this.headers,
        destination: this.destination,
        referrer: this.referrer,
        referrerPolicy: this.referrerPolicy,
        mode: this.mode,
        credentials: this.credentials,
        cache: this.cache,
        redirect: this.redirect,
        integrity: this.integrity,
        keepalive: this.keepalive,
        isReloadNavigation: this.isReloadNavigation,
        isHistoryNavigation: this.isHistoryNavigation,
        signal: this.signal
      };
      return `Request ${nodeUtil2.formatWithOptions(options, properties)}`;
    }
    /**
     * @param {Request} request
     * @param {AbortSignal} newSignal
     */
    static setRequestSignal(request2, newSignal) {
      __privateSet(request2, _signal, newSignal);
      return request2;
    }
    /**
     * @param {Request} request
     */
    static getRequestDispatcher(request2) {
      return __privateGet(request2, _dispatcher2);
    }
    /**
     * @param {Request} request
     * @param {import('../../dispatcher/dispatcher')} newDispatcher
     */
    static setRequestDispatcher(request2, newDispatcher) {
      __privateSet(request2, _dispatcher2, newDispatcher);
    }
    /**
     * @param {Request} request
     * @param {Headers} newHeaders
     */
    static setRequestHeaders(request2, newHeaders) {
      __privateSet(request2, _headers2, newHeaders);
    }
    /**
     * @param {Request} request
     */
    static getRequestState(request2) {
      return __privateGet(request2, _state3);
    }
    /**
     * @param {Request} request
     * @param {any} newState
     */
    static setRequestState(request2, newState) {
      __privateSet(request2, _state3, newState);
    }
  };
  _signal = new WeakMap();
  _dispatcher2 = new WeakMap();
  _headers2 = new WeakMap();
  _state3 = new WeakMap();
  let Request4 = _Request;
  const { setRequestSignal, getRequestDispatcher, setRequestDispatcher, setRequestHeaders, getRequestState, setRequestState } = Request4;
  Reflect.deleteProperty(Request4, "setRequestSignal");
  Reflect.deleteProperty(Request4, "getRequestDispatcher");
  Reflect.deleteProperty(Request4, "setRequestDispatcher");
  Reflect.deleteProperty(Request4, "setRequestHeaders");
  Reflect.deleteProperty(Request4, "getRequestState");
  Reflect.deleteProperty(Request4, "setRequestState");
  mixinBody(Request4, getRequestState);
  function makeRequest(init) {
    return {
      method: init.method ?? "GET",
      localURLsOnly: init.localURLsOnly ?? false,
      unsafeRequest: init.unsafeRequest ?? false,
      body: init.body ?? null,
      client: init.client ?? null,
      reservedClient: init.reservedClient ?? null,
      replacesClientId: init.replacesClientId ?? "",
      window: init.window ?? "client",
      keepalive: init.keepalive ?? false,
      serviceWorkers: init.serviceWorkers ?? "all",
      initiator: init.initiator ?? "",
      destination: init.destination ?? "",
      priority: init.priority ?? null,
      origin: init.origin ?? "client",
      policyContainer: init.policyContainer ?? "client",
      referrer: init.referrer ?? "client",
      referrerPolicy: init.referrerPolicy ?? "",
      mode: init.mode ?? "no-cors",
      useCORSPreflightFlag: init.useCORSPreflightFlag ?? false,
      credentials: init.credentials ?? "same-origin",
      useCredentials: init.useCredentials ?? false,
      cache: init.cache ?? "default",
      redirect: init.redirect ?? "follow",
      integrity: init.integrity ?? "",
      cryptoGraphicsNonceMetadata: init.cryptoGraphicsNonceMetadata ?? "",
      parserMetadata: init.parserMetadata ?? "",
      reloadNavigation: init.reloadNavigation ?? false,
      historyNavigation: init.historyNavigation ?? false,
      userActivation: init.userActivation ?? false,
      taintedOrigin: init.taintedOrigin ?? false,
      redirectCount: init.redirectCount ?? 0,
      responseTainting: init.responseTainting ?? "basic",
      preventNoCacheCacheControlHeaderModification: init.preventNoCacheCacheControlHeaderModification ?? false,
      done: init.done ?? false,
      timingAllowFailed: init.timingAllowFailed ?? false,
      urlList: init.urlList,
      url: init.urlList[0],
      headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
    };
  }
  function cloneRequest(request2) {
    const newRequest = makeRequest({ ...request2, body: null });
    if (request2.body != null) {
      newRequest.body = cloneBody(newRequest, request2.body);
    }
    return newRequest;
  }
  function fromInnerRequest(innerRequest, dispatcher2, signal, guard) {
    const request2 = new Request4(kConstruct2);
    setRequestState(request2, innerRequest);
    setRequestDispatcher(request2, dispatcher2);
    setRequestSignal(request2, signal);
    const headers2 = new Headers(kConstruct2);
    setRequestHeaders(request2, headers2);
    setHeadersList(headers2, innerRequest.headersList);
    setHeadersGuard(headers2, guard);
    return request2;
  }
  Object.defineProperties(Request4.prototype, {
    method: kEnumerableProperty2,
    url: kEnumerableProperty2,
    headers: kEnumerableProperty2,
    redirect: kEnumerableProperty2,
    clone: kEnumerableProperty2,
    signal: kEnumerableProperty2,
    duplex: kEnumerableProperty2,
    destination: kEnumerableProperty2,
    body: kEnumerableProperty2,
    bodyUsed: kEnumerableProperty2,
    isHistoryNavigation: kEnumerableProperty2,
    isReloadNavigation: kEnumerableProperty2,
    keepalive: kEnumerableProperty2,
    integrity: kEnumerableProperty2,
    cache: kEnumerableProperty2,
    credentials: kEnumerableProperty2,
    attribute: kEnumerableProperty2,
    referrerPolicy: kEnumerableProperty2,
    referrer: kEnumerableProperty2,
    mode: kEnumerableProperty2,
    [Symbol.toStringTag]: {
      value: "Request",
      configurable: true
    }
  });
  webidl.is.Request = webidl.util.MakeTypeAssertion(Request4);
  webidl.converters.RequestInfo = function(V, prefix, argument) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V);
    }
    if (webidl.is.Request(V)) {
      return V;
    }
    return webidl.converters.USVString(V);
  };
  webidl.converters.RequestInit = webidl.dictionaryConverter([
    {
      key: "method",
      converter: webidl.converters.ByteString
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    },
    {
      key: "body",
      converter: webidl.nullableConverter(
        webidl.converters.BodyInit
      )
    },
    {
      key: "referrer",
      converter: webidl.converters.USVString
    },
    {
      key: "referrerPolicy",
      converter: webidl.converters.DOMString,
      // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
      allowedValues: referrerPolicy
    },
    {
      key: "mode",
      converter: webidl.converters.DOMString,
      // https://fetch.spec.whatwg.org/#concept-request-mode
      allowedValues: requestMode
    },
    {
      key: "credentials",
      converter: webidl.converters.DOMString,
      // https://fetch.spec.whatwg.org/#requestcredentials
      allowedValues: requestCredentials
    },
    {
      key: "cache",
      converter: webidl.converters.DOMString,
      // https://fetch.spec.whatwg.org/#requestcache
      allowedValues: requestCache
    },
    {
      key: "redirect",
      converter: webidl.converters.DOMString,
      // https://fetch.spec.whatwg.org/#requestredirect
      allowedValues: requestRedirect
    },
    {
      key: "integrity",
      converter: webidl.converters.DOMString
    },
    {
      key: "keepalive",
      converter: webidl.converters.boolean
    },
    {
      key: "signal",
      converter: webidl.nullableConverter(
        (signal) => webidl.converters.AbortSignal(
          signal,
          "RequestInit",
          "signal"
        )
      )
    },
    {
      key: "window",
      converter: webidl.converters.any
    },
    {
      key: "duplex",
      converter: webidl.converters.DOMString,
      allowedValues: requestDuplex
    },
    {
      key: "dispatcher",
      // undici specific option
      converter: webidl.converters.any
    }
  ]);
  request$3 = {
    Request: Request4,
    makeRequest,
    fromInnerRequest,
    cloneRequest,
    getRequestDispatcher,
    getRequestState
  };
  return request$3;
}
var fetch_1$1;
var hasRequiredFetch$1;
function requireFetch$1() {
  if (hasRequiredFetch$1) return fetch_1$1;
  hasRequiredFetch$1 = 1;
  const {
    makeNetworkError,
    makeAppropriateNetworkError,
    filterResponse,
    makeResponse,
    fromInnerResponse,
    getResponseState
  } = requireResponse$1();
  const { HeadersList } = requireHeaders$1();
  const { Request: Request4, cloneRequest, getRequestDispatcher, getRequestState } = requireRequest$1();
  const zlib = require$$1$2;
  const {
    bytesMatch,
    makePolicyContainer,
    clonePolicyContainer,
    requestBadPort,
    TAOCheck,
    appendRequestOriginHeader,
    responseLocationURL,
    requestCurrentURL,
    setRequestReferrerPolicyOnRedirect,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    createOpaqueTimingInfo,
    appendFetchMetadata,
    corsCheck,
    crossOriginResourcePolicyCheck,
    determineRequestsReferrer,
    coarsenedSharedCurrentTime,
    createDeferredPromise,
    sameOrigin,
    isCancelled,
    isAborted,
    isErrorLike,
    fullyReadBody,
    readableStreamClose,
    isomorphicEncode,
    urlIsLocal,
    urlIsHttpHttpsScheme,
    urlHasHttpsScheme,
    clampAndCoarsenConnectionTimingInfo,
    simpleRangeHeaderValue,
    buildContentRange,
    createInflate,
    extractMimeType
  } = requireUtil$a();
  const assert2 = require$$0$3;
  const { safelyExtractBody, extractBody: extractBody2 } = requireBody$1();
  const {
    redirectStatusSet,
    nullBodyStatus,
    safeMethodsSet,
    requestBodyHeader,
    subresourceSet
  } = requireConstants$5();
  const EE2 = require$$8$1;
  const { Readable: Readable2, pipeline: pipeline2, finished: finished2, isErrored: isErrored2, isReadable: isReadable2 } = require$$0$4;
  const { addAbortListener: addAbortListener2, bufferToLowerCasedHeaderName: bufferToLowerCasedHeaderName2 } = util$J;
  const { dataURLProcessor, serializeAMimeType: serializeAMimeType2, minimizeSupportedMimeType } = requireDataUrl$1();
  const { getGlobalDispatcher: getGlobalDispatcher2 } = global$3;
  const { webidl } = requireWebidl$1();
  const { STATUS_CODES: STATUS_CODES2 } = require$$2$1;
  const GET_OR_HEAD = ["GET", "HEAD"];
  const defaultUserAgent = typeof __UNDICI_IS_NODE__ !== "undefined" || typeof esbuildDetection !== "undefined" ? "node" : "undici";
  let resolveObjectURL;
  class Fetch extends EE2 {
    constructor(dispatcher2) {
      super();
      this.dispatcher = dispatcher2;
      this.connection = null;
      this.dump = false;
      this.state = "ongoing";
    }
    terminate(reason) {
      var _a2;
      if (this.state !== "ongoing") {
        return;
      }
      this.state = "terminated";
      (_a2 = this.connection) == null ? void 0 : _a2.destroy(reason);
      this.emit("terminated", reason);
    }
    // https://fetch.spec.whatwg.org/#fetch-controller-abort
    abort(error) {
      var _a2;
      if (this.state !== "ongoing") {
        return;
      }
      this.state = "aborted";
      if (!error) {
        error = new DOMException("The operation was aborted.", "AbortError");
      }
      this.serializedAbortReason = error;
      (_a2 = this.connection) == null ? void 0 : _a2.destroy(error);
      this.emit("terminated", error);
    }
  }
  function handleFetchDone(response2) {
    finalizeAndReportTiming(response2, "fetch");
  }
  function fetch2(input, init = void 0) {
    var _a2;
    webidl.argumentLengthCheck(arguments, 1, "globalThis.fetch");
    let p = createDeferredPromise();
    let requestObject;
    try {
      requestObject = new Request4(input, init);
    } catch (e) {
      p.reject(e);
      return p.promise;
    }
    const request2 = getRequestState(requestObject);
    if (requestObject.signal.aborted) {
      abortFetch(p, request2, null, requestObject.signal.reason);
      return p.promise;
    }
    const globalObject = request2.client.globalObject;
    if (((_a2 = globalObject == null ? void 0 : globalObject.constructor) == null ? void 0 : _a2.name) === "ServiceWorkerGlobalScope") {
      request2.serviceWorkers = "none";
    }
    let responseObject = null;
    let locallyAborted = false;
    let controller = null;
    addAbortListener2(
      requestObject.signal,
      () => {
        locallyAborted = true;
        assert2(controller != null);
        controller.abort(requestObject.signal.reason);
        const realResponse = responseObject == null ? void 0 : responseObject.deref();
        abortFetch(p, request2, realResponse, requestObject.signal.reason);
      }
    );
    const processResponse = (response2) => {
      if (locallyAborted) {
        return;
      }
      if (response2.aborted) {
        abortFetch(p, request2, responseObject, controller.serializedAbortReason);
        return;
      }
      if (response2.type === "error") {
        p.reject(new TypeError("fetch failed", { cause: response2.error }));
        return;
      }
      responseObject = new WeakRef(fromInnerResponse(response2, "immutable"));
      p.resolve(responseObject.deref());
      p = null;
    };
    controller = fetching({
      request: request2,
      processResponseEndOfBody: handleFetchDone,
      processResponse,
      dispatcher: getRequestDispatcher(requestObject)
      // undici
    });
    return p.promise;
  }
  function finalizeAndReportTiming(response2, initiatorType = "other") {
    var _a2;
    if (response2.type === "error" && response2.aborted) {
      return;
    }
    if (!((_a2 = response2.urlList) == null ? void 0 : _a2.length)) {
      return;
    }
    const originalURL = response2.urlList[0];
    let timingInfo = response2.timingInfo;
    let cacheState = response2.cacheState;
    if (!urlIsHttpHttpsScheme(originalURL)) {
      return;
    }
    if (timingInfo === null) {
      return;
    }
    if (!response2.timingAllowPassed) {
      timingInfo = createOpaqueTimingInfo({
        startTime: timingInfo.startTime
      });
      cacheState = "";
    }
    timingInfo.endTime = coarsenedSharedCurrentTime();
    response2.timingInfo = timingInfo;
    markResourceTiming(
      timingInfo,
      originalURL.href,
      initiatorType,
      globalThis,
      cacheState
    );
  }
  const markResourceTiming = performance.markResourceTiming;
  function abortFetch(p, request2, responseObject, error) {
    var _a2, _b2;
    if (p) {
      p.reject(error);
    }
    if (((_a2 = request2.body) == null ? void 0 : _a2.stream) != null && isReadable2(request2.body.stream)) {
      request2.body.stream.cancel(error).catch((err) => {
        if (err.code === "ERR_INVALID_STATE") {
          return;
        }
        throw err;
      });
    }
    if (responseObject == null) {
      return;
    }
    const response2 = getResponseState(responseObject);
    if (((_b2 = response2.body) == null ? void 0 : _b2.stream) != null && isReadable2(response2.body.stream)) {
      response2.body.stream.cancel(error).catch((err) => {
        if (err.code === "ERR_INVALID_STATE") {
          return;
        }
        throw err;
      });
    }
  }
  function fetching({
    request: request2,
    processRequestBodyChunkLength,
    processRequestEndOfBody,
    processResponse,
    processResponseEndOfBody,
    processResponseConsumeBody,
    useParallelQueue = false,
    dispatcher: dispatcher2 = getGlobalDispatcher2()
    // undici
  }) {
    var _a2, _b2, _c2;
    assert2(dispatcher2);
    let taskDestination = null;
    let crossOriginIsolatedCapability = false;
    if (request2.client != null) {
      taskDestination = request2.client.globalObject;
      crossOriginIsolatedCapability = request2.client.crossOriginIsolatedCapability;
    }
    const currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
    const timingInfo = createOpaqueTimingInfo({
      startTime: currentTime
    });
    const fetchParams = {
      controller: new Fetch(dispatcher2),
      request: request2,
      timingInfo,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseConsumeBody,
      processResponseEndOfBody,
      taskDestination,
      crossOriginIsolatedCapability
    };
    assert2(!request2.body || request2.body.stream);
    if (request2.window === "client") {
      request2.window = ((_c2 = (_b2 = (_a2 = request2.client) == null ? void 0 : _a2.globalObject) == null ? void 0 : _b2.constructor) == null ? void 0 : _c2.name) === "Window" ? request2.client : "no-window";
    }
    if (request2.origin === "client") {
      request2.origin = request2.client.origin;
    }
    if (request2.policyContainer === "client") {
      if (request2.client != null) {
        request2.policyContainer = clonePolicyContainer(
          request2.client.policyContainer
        );
      } else {
        request2.policyContainer = makePolicyContainer();
      }
    }
    if (!request2.headersList.contains("accept", true)) {
      const value = "*/*";
      request2.headersList.append("accept", value, true);
    }
    if (!request2.headersList.contains("accept-language", true)) {
      request2.headersList.append("accept-language", "*", true);
    }
    if (request2.priority === null) ;
    if (subresourceSet.has(request2.destination)) ;
    mainFetch(fetchParams).catch((err) => {
      fetchParams.controller.terminate(err);
    });
    return fetchParams.controller;
  }
  async function mainFetch(fetchParams, recursive = false) {
    const request2 = fetchParams.request;
    let response2 = null;
    if (request2.localURLsOnly && !urlIsLocal(requestCurrentURL(request2))) {
      response2 = makeNetworkError("local URLs only");
    }
    tryUpgradeRequestToAPotentiallyTrustworthyURL(request2);
    if (requestBadPort(request2) === "blocked") {
      response2 = makeNetworkError("bad port");
    }
    if (request2.referrerPolicy === "") {
      request2.referrerPolicy = request2.policyContainer.referrerPolicy;
    }
    if (request2.referrer !== "no-referrer") {
      request2.referrer = determineRequestsReferrer(request2);
    }
    if (response2 === null) {
      const currentURL = requestCurrentURL(request2);
      if (
        // - request’s current URL’s origin is same origin with request’s origin,
        //   and request’s response tainting is "basic"
        sameOrigin(currentURL, request2.url) && request2.responseTainting === "basic" || // request’s current URL’s scheme is "data"
        currentURL.protocol === "data:" || // - request’s mode is "navigate" or "websocket"
        (request2.mode === "navigate" || request2.mode === "websocket")
      ) {
        request2.responseTainting = "basic";
        response2 = await schemeFetch(fetchParams);
      } else if (request2.mode === "same-origin") {
        response2 = makeNetworkError('request mode cannot be "same-origin"');
      } else if (request2.mode === "no-cors") {
        if (request2.redirect !== "follow") {
          response2 = makeNetworkError(
            'redirect mode cannot be "follow" for "no-cors" request'
          );
        } else {
          request2.responseTainting = "opaque";
          response2 = await schemeFetch(fetchParams);
        }
      } else if (!urlIsHttpHttpsScheme(requestCurrentURL(request2))) {
        response2 = makeNetworkError("URL scheme must be a HTTP(S) scheme");
      } else {
        request2.responseTainting = "cors";
        response2 = await httpFetch(fetchParams);
      }
    }
    if (recursive) {
      return response2;
    }
    if (response2.status !== 0 && !response2.internalResponse) {
      if (request2.responseTainting === "cors") ;
      if (request2.responseTainting === "basic") {
        response2 = filterResponse(response2, "basic");
      } else if (request2.responseTainting === "cors") {
        response2 = filterResponse(response2, "cors");
      } else if (request2.responseTainting === "opaque") {
        response2 = filterResponse(response2, "opaque");
      } else {
        assert2(false);
      }
    }
    let internalResponse = response2.status === 0 ? response2 : response2.internalResponse;
    if (internalResponse.urlList.length === 0) {
      internalResponse.urlList.push(...request2.urlList);
    }
    if (!request2.timingAllowFailed) {
      response2.timingAllowPassed = true;
    }
    if (response2.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request2.headers.contains("range", true)) {
      response2 = internalResponse = makeNetworkError();
    }
    if (response2.status !== 0 && (request2.method === "HEAD" || request2.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
      internalResponse.body = null;
      fetchParams.controller.dump = true;
    }
    if (request2.integrity) {
      const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
      if (request2.responseTainting === "opaque" || response2.body == null) {
        processBodyError(response2.error);
        return;
      }
      const processBody = (bytes) => {
        if (!bytesMatch(bytes, request2.integrity)) {
          processBodyError("integrity mismatch");
          return;
        }
        response2.body = safelyExtractBody(bytes)[0];
        fetchFinale(fetchParams, response2);
      };
      await fullyReadBody(response2.body, processBody, processBodyError);
    } else {
      fetchFinale(fetchParams, response2);
    }
  }
  function schemeFetch(fetchParams) {
    if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
      return Promise.resolve(makeAppropriateNetworkError(fetchParams));
    }
    const { request: request2 } = fetchParams;
    const { protocol: scheme } = requestCurrentURL(request2);
    switch (scheme) {
      case "about:": {
        return Promise.resolve(makeNetworkError("about scheme is not supported"));
      }
      case "blob:": {
        if (!resolveObjectURL) {
          resolveObjectURL = require$$0$1.resolveObjectURL;
        }
        const blobURLEntry = requestCurrentURL(request2);
        if (blobURLEntry.search.length !== 0) {
          return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
        }
        const blob = resolveObjectURL(blobURLEntry.toString());
        if (request2.method !== "GET" || !webidl.is.Blob(blob)) {
          return Promise.resolve(makeNetworkError("invalid method"));
        }
        const response2 = makeResponse();
        const fullLength = blob.size;
        const serializedFullLength = isomorphicEncode(`${fullLength}`);
        const type = blob.type;
        if (!request2.headersList.contains("range", true)) {
          const bodyWithType = extractBody2(blob);
          response2.statusText = "OK";
          response2.body = bodyWithType[0];
          response2.headersList.set("content-length", serializedFullLength, true);
          response2.headersList.set("content-type", type, true);
        } else {
          response2.rangeRequested = true;
          const rangeHeader = request2.headersList.get("range", true);
          const rangeValue = simpleRangeHeaderValue(rangeHeader, true);
          if (rangeValue === "failure") {
            return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
          }
          let { rangeStartValue: rangeStart, rangeEndValue: rangeEnd } = rangeValue;
          if (rangeStart === null) {
            rangeStart = fullLength - rangeEnd;
            rangeEnd = rangeStart + rangeEnd - 1;
          } else {
            if (rangeStart >= fullLength) {
              return Promise.resolve(makeNetworkError("Range start is greater than the blob's size."));
            }
            if (rangeEnd === null || rangeEnd >= fullLength) {
              rangeEnd = fullLength - 1;
            }
          }
          const slicedBlob = blob.slice(rangeStart, rangeEnd, type);
          const slicedBodyWithType = extractBody2(slicedBlob);
          response2.body = slicedBodyWithType[0];
          const serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`);
          const contentRange = buildContentRange(rangeStart, rangeEnd, fullLength);
          response2.status = 206;
          response2.statusText = "Partial Content";
          response2.headersList.set("content-length", serializedSlicedLength, true);
          response2.headersList.set("content-type", type, true);
          response2.headersList.set("content-range", contentRange, true);
        }
        return Promise.resolve(response2);
      }
      case "data:": {
        const currentURL = requestCurrentURL(request2);
        const dataURLStruct = dataURLProcessor(currentURL);
        if (dataURLStruct === "failure") {
          return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
        }
        const mimeType = serializeAMimeType2(dataURLStruct.mimeType);
        return Promise.resolve(makeResponse({
          statusText: "OK",
          headersList: [
            ["content-type", { name: "Content-Type", value: mimeType }]
          ],
          body: safelyExtractBody(dataURLStruct.body)[0]
        }));
      }
      case "file:": {
        return Promise.resolve(makeNetworkError("not implemented... yet..."));
      }
      case "http:":
      case "https:": {
        return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
      }
      default: {
        return Promise.resolve(makeNetworkError("unknown scheme"));
      }
    }
  }
  function finalizeResponse(fetchParams, response2) {
    fetchParams.request.done = true;
    if (fetchParams.processResponseDone != null) {
      queueMicrotask(() => fetchParams.processResponseDone(response2));
    }
  }
  function fetchFinale(fetchParams, response2) {
    let timingInfo = fetchParams.timingInfo;
    const processResponseEndOfBody = () => {
      const unsafeEndTime = Date.now();
      if (fetchParams.request.destination === "document") {
        fetchParams.controller.fullTimingInfo = timingInfo;
      }
      fetchParams.controller.reportTimingSteps = () => {
        if (fetchParams.request.url.protocol !== "https:") {
          return;
        }
        timingInfo.endTime = unsafeEndTime;
        let cacheState = response2.cacheState;
        const bodyInfo = response2.bodyInfo;
        if (!response2.timingAllowPassed) {
          timingInfo = createOpaqueTimingInfo(timingInfo);
          cacheState = "";
        }
        let responseStatus = 0;
        if (fetchParams.request.mode !== "navigator" || !response2.hasCrossOriginRedirects) {
          responseStatus = response2.status;
          const mimeType = extractMimeType(response2.headersList);
          if (mimeType !== "failure") {
            bodyInfo.contentType = minimizeSupportedMimeType(mimeType);
          }
        }
        if (fetchParams.request.initiatorType != null) {
          markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus);
        }
      };
      const processResponseEndOfBodyTask = () => {
        fetchParams.request.done = true;
        if (fetchParams.processResponseEndOfBody != null) {
          queueMicrotask(() => fetchParams.processResponseEndOfBody(response2));
        }
        if (fetchParams.request.initiatorType != null) {
          fetchParams.controller.reportTimingSteps();
        }
      };
      queueMicrotask(() => processResponseEndOfBodyTask());
    };
    if (fetchParams.processResponse != null) {
      queueMicrotask(() => {
        fetchParams.processResponse(response2);
        fetchParams.processResponse = null;
      });
    }
    const internalResponse = response2.type === "error" ? response2 : response2.internalResponse ?? response2;
    if (internalResponse.body == null) {
      processResponseEndOfBody();
    } else {
      finished2(internalResponse.body.stream, () => {
        processResponseEndOfBody();
      });
    }
  }
  async function httpFetch(fetchParams) {
    const request2 = fetchParams.request;
    let response2 = null;
    let actualResponse = null;
    const timingInfo = fetchParams.timingInfo;
    if (request2.serviceWorkers === "all") ;
    if (response2 === null) {
      if (request2.redirect === "follow") {
        request2.serviceWorkers = "none";
      }
      actualResponse = response2 = await httpNetworkOrCacheFetch(fetchParams);
      if (request2.responseTainting === "cors" && corsCheck(request2, response2) === "failure") {
        return makeNetworkError("cors failure");
      }
      if (TAOCheck(request2, response2) === "failure") {
        request2.timingAllowFailed = true;
      }
    }
    if ((request2.responseTainting === "opaque" || response2.type === "opaque") && crossOriginResourcePolicyCheck(
      request2.origin,
      request2.client,
      request2.destination,
      actualResponse
    ) === "blocked") {
      return makeNetworkError("blocked");
    }
    if (redirectStatusSet.has(actualResponse.status)) {
      if (request2.redirect !== "manual") {
        fetchParams.controller.connection.destroy(void 0, false);
      }
      if (request2.redirect === "error") {
        response2 = makeNetworkError("unexpected redirect");
      } else if (request2.redirect === "manual") {
        response2 = actualResponse;
      } else if (request2.redirect === "follow") {
        response2 = await httpRedirectFetch(fetchParams, response2);
      } else {
        assert2(false);
      }
    }
    response2.timingInfo = timingInfo;
    return response2;
  }
  function httpRedirectFetch(fetchParams, response2) {
    const request2 = fetchParams.request;
    const actualResponse = response2.internalResponse ? response2.internalResponse : response2;
    let locationURL;
    try {
      locationURL = responseLocationURL(
        actualResponse,
        requestCurrentURL(request2).hash
      );
      if (locationURL == null) {
        return response2;
      }
    } catch (err) {
      return Promise.resolve(makeNetworkError(err));
    }
    if (!urlIsHttpHttpsScheme(locationURL)) {
      return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
    }
    if (request2.redirectCount === 20) {
      return Promise.resolve(makeNetworkError("redirect count exceeded"));
    }
    request2.redirectCount += 1;
    if (request2.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request2, locationURL)) {
      return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
    }
    if (request2.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
      return Promise.resolve(makeNetworkError(
        'URL cannot contain credentials for request mode "cors"'
      ));
    }
    if (actualResponse.status !== 303 && request2.body != null && request2.body.source == null) {
      return Promise.resolve(makeNetworkError());
    }
    if ([301, 302].includes(actualResponse.status) && request2.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request2.method)) {
      request2.method = "GET";
      request2.body = null;
      for (const headerName of requestBodyHeader) {
        request2.headersList.delete(headerName);
      }
    }
    if (!sameOrigin(requestCurrentURL(request2), locationURL)) {
      request2.headersList.delete("authorization", true);
      request2.headersList.delete("proxy-authorization", true);
      request2.headersList.delete("cookie", true);
      request2.headersList.delete("host", true);
    }
    if (request2.body != null) {
      assert2(request2.body.source != null);
      request2.body = safelyExtractBody(request2.body.source)[0];
    }
    const timingInfo = fetchParams.timingInfo;
    timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
    if (timingInfo.redirectStartTime === 0) {
      timingInfo.redirectStartTime = timingInfo.startTime;
    }
    request2.urlList.push(locationURL);
    setRequestReferrerPolicyOnRedirect(request2, actualResponse);
    return mainFetch(fetchParams, true);
  }
  async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
    const request2 = fetchParams.request;
    let httpFetchParams = null;
    let httpRequest = null;
    let response2 = null;
    if (request2.window === "no-window" && request2.redirect === "error") {
      httpFetchParams = fetchParams;
      httpRequest = request2;
    } else {
      httpRequest = cloneRequest(request2);
      httpFetchParams = { ...fetchParams };
      httpFetchParams.request = httpRequest;
    }
    const includeCredentials = request2.credentials === "include" || request2.credentials === "same-origin" && request2.responseTainting === "basic";
    const contentLength = httpRequest.body ? httpRequest.body.length : null;
    let contentLengthHeaderValue = null;
    if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
      contentLengthHeaderValue = "0";
    }
    if (contentLength != null) {
      contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
    }
    if (contentLengthHeaderValue != null) {
      httpRequest.headersList.append("content-length", contentLengthHeaderValue, true);
    }
    if (contentLength != null && httpRequest.keepalive) ;
    if (webidl.is.URL(httpRequest.referrer)) {
      httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href), true);
    }
    appendRequestOriginHeader(httpRequest);
    appendFetchMetadata(httpRequest);
    if (!httpRequest.headersList.contains("user-agent", true)) {
      httpRequest.headersList.append("user-agent", defaultUserAgent, true);
    }
    if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since", true) || httpRequest.headersList.contains("if-none-match", true) || httpRequest.headersList.contains("if-unmodified-since", true) || httpRequest.headersList.contains("if-match", true) || httpRequest.headersList.contains("if-range", true))) {
      httpRequest.cache = "no-store";
    }
    if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control", true)) {
      httpRequest.headersList.append("cache-control", "max-age=0", true);
    }
    if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
      if (!httpRequest.headersList.contains("pragma", true)) {
        httpRequest.headersList.append("pragma", "no-cache", true);
      }
      if (!httpRequest.headersList.contains("cache-control", true)) {
        httpRequest.headersList.append("cache-control", "no-cache", true);
      }
    }
    if (httpRequest.headersList.contains("range", true)) {
      httpRequest.headersList.append("accept-encoding", "identity", true);
    }
    if (!httpRequest.headersList.contains("accept-encoding", true)) {
      if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
        httpRequest.headersList.append("accept-encoding", "br, gzip, deflate", true);
      } else {
        httpRequest.headersList.append("accept-encoding", "gzip, deflate", true);
      }
    }
    httpRequest.headersList.delete("host", true);
    {
      httpRequest.cache = "no-store";
    }
    if (httpRequest.cache !== "no-store" && httpRequest.cache !== "reload") ;
    if (response2 == null) {
      if (httpRequest.cache === "only-if-cached") {
        return makeNetworkError("only if cached");
      }
      const forwardResponse = await httpNetworkFetch(
        httpFetchParams,
        includeCredentials,
        isNewConnectionFetch
      );
      if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) ;
      if (response2 == null) {
        response2 = forwardResponse;
      }
    }
    response2.urlList = [...httpRequest.urlList];
    if (httpRequest.headersList.contains("range", true)) {
      response2.rangeRequested = true;
    }
    response2.requestIncludesCredentials = includeCredentials;
    if (response2.status === 407) {
      if (request2.window === "no-window") {
        return makeNetworkError();
      }
      if (isCancelled(fetchParams)) {
        return makeAppropriateNetworkError(fetchParams);
      }
      return makeNetworkError("proxy authentication required");
    }
    if (
      // response’s status is 421
      response2.status === 421 && // isNewConnectionFetch is false
      !isNewConnectionFetch && // request’s body is null, or request’s body is non-null and request’s body’s source is non-null
      (request2.body == null || request2.body.source != null)
    ) {
      if (isCancelled(fetchParams)) {
        return makeAppropriateNetworkError(fetchParams);
      }
      fetchParams.controller.connection.destroy();
      response2 = await httpNetworkOrCacheFetch(
        fetchParams,
        isAuthenticationFetch,
        true
      );
    }
    return response2;
  }
  async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
    assert2(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
    fetchParams.controller.connection = {
      abort: null,
      destroyed: false,
      destroy(err, abort2 = true) {
        var _a2;
        if (!this.destroyed) {
          this.destroyed = true;
          if (abort2) {
            (_a2 = this.abort) == null ? void 0 : _a2.call(this, err ?? new DOMException("The operation was aborted.", "AbortError"));
          }
        }
      }
    };
    const request2 = fetchParams.request;
    let response2 = null;
    const timingInfo = fetchParams.timingInfo;
    {
      request2.cache = "no-store";
    }
    if (request2.mode === "websocket") ;
    let requestBody = null;
    if (request2.body == null && fetchParams.processRequestEndOfBody) {
      queueMicrotask(() => fetchParams.processRequestEndOfBody());
    } else if (request2.body != null) {
      const processBodyChunk = async function* (bytes) {
        var _a2;
        if (isCancelled(fetchParams)) {
          return;
        }
        yield bytes;
        (_a2 = fetchParams.processRequestBodyChunkLength) == null ? void 0 : _a2.call(fetchParams, bytes.byteLength);
      };
      const processEndOfBody = () => {
        if (isCancelled(fetchParams)) {
          return;
        }
        if (fetchParams.processRequestEndOfBody) {
          fetchParams.processRequestEndOfBody();
        }
      };
      const processBodyError = (e) => {
        if (isCancelled(fetchParams)) {
          return;
        }
        if (e.name === "AbortError") {
          fetchParams.controller.abort();
        } else {
          fetchParams.controller.terminate(e);
        }
      };
      requestBody = async function* () {
        try {
          for await (const bytes of request2.body.stream) {
            yield* processBodyChunk(bytes);
          }
          processEndOfBody();
        } catch (err) {
          processBodyError(err);
        }
      }();
    }
    try {
      const { body: body2, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
      if (socket) {
        response2 = makeResponse({ status, statusText, headersList, socket });
      } else {
        const iterator = body2[Symbol.asyncIterator]();
        fetchParams.controller.next = () => iterator.next();
        response2 = makeResponse({ status, statusText, headersList });
      }
    } catch (err) {
      if (err.name === "AbortError") {
        fetchParams.controller.connection.destroy();
        return makeAppropriateNetworkError(fetchParams, err);
      }
      return makeNetworkError(err);
    }
    const pullAlgorithm = () => {
      return fetchParams.controller.resume();
    };
    const cancelAlgorithm = (reason) => {
      if (!isCancelled(fetchParams)) {
        fetchParams.controller.abort(reason);
      }
    };
    const stream2 = new ReadableStream(
      {
        async start(controller) {
          fetchParams.controller.controller = controller;
        },
        async pull(controller) {
          await pullAlgorithm();
        },
        async cancel(reason) {
          await cancelAlgorithm(reason);
        },
        type: "bytes"
      }
    );
    response2.body = { stream: stream2, source: null, length: null };
    if (!fetchParams.controller.resume) {
      fetchParams.controller.on("terminated", onAborted);
    }
    fetchParams.controller.resume = async () => {
      while (true) {
        let bytes;
        let isFailure;
        try {
          const { done, value } = await fetchParams.controller.next();
          if (isAborted(fetchParams)) {
            break;
          }
          bytes = done ? void 0 : value;
        } catch (err) {
          if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
            bytes = void 0;
          } else {
            bytes = err;
            isFailure = true;
          }
        }
        if (bytes === void 0) {
          readableStreamClose(fetchParams.controller.controller);
          finalizeResponse(fetchParams, response2);
          return;
        }
        timingInfo.decodedBodySize += (bytes == null ? void 0 : bytes.byteLength) ?? 0;
        if (isFailure) {
          fetchParams.controller.terminate(bytes);
          return;
        }
        const buffer = new Uint8Array(bytes);
        if (buffer.byteLength) {
          fetchParams.controller.controller.enqueue(buffer);
        }
        if (isErrored2(stream2)) {
          fetchParams.controller.terminate();
          return;
        }
        if (fetchParams.controller.controller.desiredSize <= 0) {
          return;
        }
      }
    };
    function onAborted(reason) {
      if (isAborted(fetchParams)) {
        response2.aborted = true;
        if (isReadable2(stream2)) {
          fetchParams.controller.controller.error(
            fetchParams.controller.serializedAbortReason
          );
        }
      } else {
        if (isReadable2(stream2)) {
          fetchParams.controller.controller.error(new TypeError("terminated", {
            cause: isErrorLike(reason) ? reason : void 0
          }));
        }
      }
      fetchParams.controller.connection.destroy();
    }
    return response2;
    function dispatch({ body: body2 }) {
      const url = requestCurrentURL(request2);
      const agent2 = fetchParams.controller.dispatcher;
      return new Promise((resolve2, reject) => agent2.dispatch(
        {
          path: url.pathname + url.search,
          origin: url.origin,
          method: request2.method,
          body: agent2.isMockActive ? request2.body && (request2.body.source || request2.body.stream) : body2,
          headers: request2.headersList.entries,
          maxRedirections: 0,
          upgrade: request2.mode === "websocket" ? "websocket" : void 0
        },
        {
          body: null,
          abort: null,
          onConnect(abort2) {
            const { connection: connection2 } = fetchParams.controller;
            timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(void 0, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability);
            if (connection2.destroyed) {
              abort2(new DOMException("The operation was aborted.", "AbortError"));
            } else {
              fetchParams.controller.on("terminated", abort2);
              this.abort = connection2.abort = abort2;
            }
            timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
          },
          onResponseStarted() {
            timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
          },
          onHeaders(status, rawHeaders, resume2, statusText) {
            if (status < 200) {
              return;
            }
            let codings = [];
            let location = "";
            const headersList = new HeadersList();
            for (let i = 0; i < rawHeaders.length; i += 2) {
              headersList.append(bufferToLowerCasedHeaderName2(rawHeaders[i]), rawHeaders[i + 1].toString("latin1"), true);
            }
            const contentEncoding = headersList.get("content-encoding", true);
            if (contentEncoding) {
              codings = contentEncoding.toLowerCase().split(",").map((x) => x.trim());
            }
            location = headersList.get("location", true);
            this.body = new Readable2({ read: resume2 });
            const decoders = [];
            const willFollow = location && request2.redirect === "follow" && redirectStatusSet.has(status);
            if (codings.length !== 0 && request2.method !== "HEAD" && request2.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
              for (let i = codings.length - 1; i >= 0; --i) {
                const coding = codings[i];
                if (coding === "x-gzip" || coding === "gzip") {
                  decoders.push(zlib.createGunzip({
                    // Be less strict when decoding compressed responses, since sometimes
                    // servers send slightly invalid responses that are still accepted
                    // by common browsers.
                    // Always using Z_SYNC_FLUSH is what cURL does.
                    flush: zlib.constants.Z_SYNC_FLUSH,
                    finishFlush: zlib.constants.Z_SYNC_FLUSH
                  }));
                } else if (coding === "deflate") {
                  decoders.push(createInflate({
                    flush: zlib.constants.Z_SYNC_FLUSH,
                    finishFlush: zlib.constants.Z_SYNC_FLUSH
                  }));
                } else if (coding === "br") {
                  decoders.push(zlib.createBrotliDecompress({
                    flush: zlib.constants.BROTLI_OPERATION_FLUSH,
                    finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
                  }));
                } else {
                  decoders.length = 0;
                  break;
                }
              }
            }
            const onError2 = this.onError.bind(this);
            resolve2({
              status,
              statusText,
              headersList,
              body: decoders.length ? pipeline2(this.body, ...decoders, (err) => {
                if (err) {
                  this.onError(err);
                }
              }).on("error", onError2) : this.body.on("error", onError2)
            });
            return true;
          },
          onData(chunk) {
            if (fetchParams.controller.dump) {
              return;
            }
            const bytes = chunk;
            timingInfo.encodedBodySize += bytes.byteLength;
            return this.body.push(bytes);
          },
          onComplete() {
            if (this.abort) {
              fetchParams.controller.off("terminated", this.abort);
            }
            fetchParams.controller.ended = true;
            this.body.push(null);
          },
          onError(error) {
            var _a2;
            if (this.abort) {
              fetchParams.controller.off("terminated", this.abort);
            }
            (_a2 = this.body) == null ? void 0 : _a2.destroy(error);
            fetchParams.controller.terminate(error);
            reject(error);
          },
          onUpgrade(status, rawHeaders, socket) {
            if (status !== 101) {
              return;
            }
            const headersList = new HeadersList();
            for (let i = 0; i < rawHeaders.length; i += 2) {
              headersList.append(bufferToLowerCasedHeaderName2(rawHeaders[i]), rawHeaders[i + 1].toString("latin1"), true);
            }
            resolve2({
              status,
              statusText: STATUS_CODES2[status],
              headersList,
              socket
            });
            return true;
          }
        }
      ));
    }
  }
  fetch_1$1 = {
    fetch: fetch2,
    Fetch,
    fetching,
    finalizeAndReportTiming
  };
  return fetch_1$1;
}
var util$r;
var hasRequiredUtil$9;
function requireUtil$9() {
  if (hasRequiredUtil$9) return util$r;
  hasRequiredUtil$9 = 1;
  const assert2 = require$$0$3;
  const { URLSerializer } = requireDataUrl$1();
  const { isValidHeaderName } = requireUtil$a();
  function urlEquals(A, B, excludeFragment = false) {
    const serializedA = URLSerializer(A, excludeFragment);
    const serializedB = URLSerializer(B, excludeFragment);
    return serializedA === serializedB;
  }
  function getFieldValues(header) {
    assert2(header !== null);
    const values = [];
    for (let value of header.split(",")) {
      value = value.trim();
      if (isValidHeaderName(value)) {
        values.push(value);
      }
    }
    return values;
  }
  util$r = {
    urlEquals,
    getFieldValues
  };
  return util$r;
}
var cache$2;
var hasRequiredCache$1;
function requireCache$1() {
  var _relevantRequestResponseList, _Cache_instances, batchCacheOperations_fn, queryCache_fn, requestMatchesCachedItem_fn, internalMatchAll_fn;
  if (hasRequiredCache$1) return cache$2;
  hasRequiredCache$1 = 1;
  const { kConstruct: kConstruct2 } = symbols$5;
  const { urlEquals, getFieldValues } = requireUtil$9();
  const { kEnumerableProperty: kEnumerableProperty2, isDisturbed: isDisturbed2 } = util$J;
  const { webidl } = requireWebidl$1();
  const { cloneResponse, fromInnerResponse, getResponseState } = requireResponse$1();
  const { Request: Request4, fromInnerRequest, getRequestState } = requireRequest$1();
  const { fetching } = requireFetch$1();
  const { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = requireUtil$a();
  const assert2 = require$$0$3;
  const _Cache = class _Cache {
    constructor() {
      __privateAdd(this, _Cache_instances);
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
       * @type {requestResponseList}
       */
      __privateAdd(this, _relevantRequestResponseList);
      if (arguments[0] !== kConstruct2) {
        webidl.illegalConstructor();
      }
      webidl.util.markAsUncloneable(this);
      __privateSet(this, _relevantRequestResponseList, arguments[1]);
    }
    async match(request2, options = {}) {
      webidl.brandCheck(this, _Cache);
      const prefix = "Cache.match";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      request2 = webidl.converters.RequestInfo(request2, prefix, "request");
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      const p = __privateMethod(this, _Cache_instances, internalMatchAll_fn).call(this, request2, options, 1);
      if (p.length === 0) {
        return;
      }
      return p[0];
    }
    async matchAll(request2 = void 0, options = {}) {
      webidl.brandCheck(this, _Cache);
      const prefix = "Cache.matchAll";
      if (request2 !== void 0) request2 = webidl.converters.RequestInfo(request2, prefix, "request");
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      return __privateMethod(this, _Cache_instances, internalMatchAll_fn).call(this, request2, options);
    }
    async add(request2) {
      webidl.brandCheck(this, _Cache);
      const prefix = "Cache.add";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      request2 = webidl.converters.RequestInfo(request2, prefix, "request");
      const requests = [request2];
      const responseArrayPromise = this.addAll(requests);
      return await responseArrayPromise;
    }
    async addAll(requests) {
      webidl.brandCheck(this, _Cache);
      const prefix = "Cache.addAll";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      const responsePromises = [];
      const requestList = [];
      for (let request2 of requests) {
        if (request2 === void 0) {
          throw webidl.errors.conversionFailed({
            prefix,
            argument: "Argument 1",
            types: ["undefined is not allowed"]
          });
        }
        request2 = webidl.converters.RequestInfo(request2);
        if (typeof request2 === "string") {
          continue;
        }
        const r = getRequestState(request2);
        if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
          throw webidl.errors.exception({
            header: prefix,
            message: "Expected http/s scheme when method is not GET."
          });
        }
      }
      const fetchControllers = [];
      for (const request2 of requests) {
        const r = getRequestState(new Request4(request2));
        if (!urlIsHttpHttpsScheme(r.url)) {
          throw webidl.errors.exception({
            header: prefix,
            message: "Expected http/s scheme."
          });
        }
        r.initiator = "fetch";
        r.destination = "subresource";
        requestList.push(r);
        const responsePromise = createDeferredPromise();
        fetchControllers.push(fetching({
          request: r,
          processResponse(response2) {
            if (response2.type === "error" || response2.status === 206 || response2.status < 200 || response2.status > 299) {
              responsePromise.reject(webidl.errors.exception({
                header: "Cache.addAll",
                message: "Received an invalid status code or the request failed."
              }));
            } else if (response2.headersList.contains("vary")) {
              const fieldValues = getFieldValues(response2.headersList.get("vary"));
              for (const fieldValue of fieldValues) {
                if (fieldValue === "*") {
                  responsePromise.reject(webidl.errors.exception({
                    header: "Cache.addAll",
                    message: "invalid vary field value"
                  }));
                  for (const controller of fetchControllers) {
                    controller.abort();
                  }
                  return;
                }
              }
            }
          },
          processResponseEndOfBody(response2) {
            if (response2.aborted) {
              responsePromise.reject(new DOMException("aborted", "AbortError"));
              return;
            }
            responsePromise.resolve(response2);
          }
        }));
        responsePromises.push(responsePromise.promise);
      }
      const p = Promise.all(responsePromises);
      const responses = await p;
      const operations = [];
      let index = 0;
      for (const response2 of responses) {
        const operation = {
          type: "put",
          // 7.3.2
          request: requestList[index],
          // 7.3.3
          response: response2
          // 7.3.4
        };
        operations.push(operation);
        index++;
      }
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      try {
        __privateMethod(this, _Cache_instances, batchCacheOperations_fn).call(this, operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve(void 0);
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async put(request2, response2) {
      webidl.brandCheck(this, _Cache);
      const prefix = "Cache.put";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      request2 = webidl.converters.RequestInfo(request2, prefix, "request");
      response2 = webidl.converters.Response(response2, prefix, "response");
      let innerRequest = null;
      if (webidl.is.Request(request2)) {
        innerRequest = getRequestState(request2);
      } else {
        innerRequest = getRequestState(new Request4(request2));
      }
      if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
        throw webidl.errors.exception({
          header: prefix,
          message: "Expected an http/s scheme when method is not GET"
        });
      }
      const innerResponse = getResponseState(response2);
      if (innerResponse.status === 206) {
        throw webidl.errors.exception({
          header: prefix,
          message: "Got 206 status"
        });
      }
      if (innerResponse.headersList.contains("vary")) {
        const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
        for (const fieldValue of fieldValues) {
          if (fieldValue === "*") {
            throw webidl.errors.exception({
              header: prefix,
              message: "Got * vary field value"
            });
          }
        }
      }
      if (innerResponse.body && (isDisturbed2(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
        throw webidl.errors.exception({
          header: prefix,
          message: "Response body is locked or disturbed"
        });
      }
      const clonedResponse = cloneResponse(innerResponse);
      const bodyReadPromise = createDeferredPromise();
      if (innerResponse.body != null) {
        const stream2 = innerResponse.body.stream;
        const reader = stream2.getReader();
        readAllBytes(reader, bodyReadPromise.resolve, bodyReadPromise.reject);
      } else {
        bodyReadPromise.resolve(void 0);
      }
      const operations = [];
      const operation = {
        type: "put",
        // 14.
        request: innerRequest,
        // 15.
        response: clonedResponse
        // 16.
      };
      operations.push(operation);
      const bytes = await bodyReadPromise.promise;
      if (clonedResponse.body != null) {
        clonedResponse.body.source = bytes;
      }
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      try {
        __privateMethod(this, _Cache_instances, batchCacheOperations_fn).call(this, operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve();
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async delete(request2, options = {}) {
      webidl.brandCheck(this, _Cache);
      const prefix = "Cache.delete";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      request2 = webidl.converters.RequestInfo(request2, prefix, "request");
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      let r = null;
      if (webidl.is.Request(request2)) {
        r = getRequestState(request2);
        if (r.method !== "GET" && !options.ignoreMethod) {
          return false;
        }
      } else {
        assert2(typeof request2 === "string");
        r = getRequestState(new Request4(request2));
      }
      const operations = [];
      const operation = {
        type: "delete",
        request: r,
        options
      };
      operations.push(operation);
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      let requestResponses;
      try {
        requestResponses = __privateMethod(this, _Cache_instances, batchCacheOperations_fn).call(this, operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve(!!(requestResponses == null ? void 0 : requestResponses.length));
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
     * @param {any} request
     * @param {import('../../types/cache').CacheQueryOptions} options
     * @returns {Promise<readonly Request[]>}
     */
    async keys(request2 = void 0, options = {}) {
      webidl.brandCheck(this, _Cache);
      const prefix = "Cache.keys";
      if (request2 !== void 0) request2 = webidl.converters.RequestInfo(request2, prefix, "request");
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      let r = null;
      if (request2 !== void 0) {
        if (webidl.is.Request(request2)) {
          r = getRequestState(request2);
          if (r.method !== "GET" && !options.ignoreMethod) {
            return [];
          }
        } else if (typeof request2 === "string") {
          r = getRequestState(new Request4(request2));
        }
      }
      const promise = createDeferredPromise();
      const requests = [];
      if (request2 === void 0) {
        for (const requestResponse of __privateGet(this, _relevantRequestResponseList)) {
          requests.push(requestResponse[0]);
        }
      } else {
        const requestResponses = __privateMethod(this, _Cache_instances, queryCache_fn).call(this, r, options);
        for (const requestResponse of requestResponses) {
          requests.push(requestResponse[0]);
        }
      }
      queueMicrotask(() => {
        const requestList = [];
        for (const request3 of requests) {
          const requestObject = fromInnerRequest(
            request3,
            void 0,
            new AbortController().signal,
            "immutable"
          );
          requestList.push(requestObject);
        }
        promise.resolve(Object.freeze(requestList));
      });
      return promise.promise;
    }
  };
  _relevantRequestResponseList = new WeakMap();
  _Cache_instances = new WeakSet();
  /**
   * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
   * @param {CacheBatchOperation[]} operations
   * @returns {requestResponseList}
   */
  batchCacheOperations_fn = function(operations) {
    const cache2 = __privateGet(this, _relevantRequestResponseList);
    const backupCache = [...cache2];
    const addedItems = [];
    const resultList = [];
    try {
      for (const operation of operations) {
        if (operation.type !== "delete" && operation.type !== "put") {
          throw webidl.errors.exception({
            header: "Cache.#batchCacheOperations",
            message: 'operation type does not match "delete" or "put"'
          });
        }
        if (operation.type === "delete" && operation.response != null) {
          throw webidl.errors.exception({
            header: "Cache.#batchCacheOperations",
            message: "delete operation should not have an associated response"
          });
        }
        if (__privateMethod(this, _Cache_instances, queryCache_fn).call(this, operation.request, operation.options, addedItems).length) {
          throw new DOMException("???", "InvalidStateError");
        }
        let requestResponses;
        if (operation.type === "delete") {
          requestResponses = __privateMethod(this, _Cache_instances, queryCache_fn).call(this, operation.request, operation.options);
          if (requestResponses.length === 0) {
            return [];
          }
          for (const requestResponse of requestResponses) {
            const idx = cache2.indexOf(requestResponse);
            assert2(idx !== -1);
            cache2.splice(idx, 1);
          }
        } else if (operation.type === "put") {
          if (operation.response == null) {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "put operation should have an associated response"
            });
          }
          const r = operation.request;
          if (!urlIsHttpHttpsScheme(r.url)) {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "expected http or https scheme"
            });
          }
          if (r.method !== "GET") {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "not get method"
            });
          }
          if (operation.options != null) {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "options must not be defined"
            });
          }
          requestResponses = __privateMethod(this, _Cache_instances, queryCache_fn).call(this, operation.request);
          for (const requestResponse of requestResponses) {
            const idx = cache2.indexOf(requestResponse);
            assert2(idx !== -1);
            cache2.splice(idx, 1);
          }
          cache2.push([operation.request, operation.response]);
          addedItems.push([operation.request, operation.response]);
        }
        resultList.push([operation.request, operation.response]);
      }
      return resultList;
    } catch (e) {
      __privateGet(this, _relevantRequestResponseList).length = 0;
      __privateSet(this, _relevantRequestResponseList, backupCache);
      throw e;
    }
  };
  /**
   * @see https://w3c.github.io/ServiceWorker/#query-cache
   * @param {any} requestQuery
   * @param {import('../../types/cache').CacheQueryOptions} options
   * @param {requestResponseList} targetStorage
   * @returns {requestResponseList}
   */
  queryCache_fn = function(requestQuery, options, targetStorage) {
    const resultList = [];
    const storage = targetStorage ?? __privateGet(this, _relevantRequestResponseList);
    for (const requestResponse of storage) {
      const [cachedRequest, cachedResponse] = requestResponse;
      if (__privateMethod(this, _Cache_instances, requestMatchesCachedItem_fn).call(this, requestQuery, cachedRequest, cachedResponse, options)) {
        resultList.push(requestResponse);
      }
    }
    return resultList;
  };
  /**
   * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
   * @param {any} requestQuery
   * @param {any} request
   * @param {any | null} response
   * @param {import('../../types/cache').CacheQueryOptions | undefined} options
   * @returns {boolean}
   */
  requestMatchesCachedItem_fn = function(requestQuery, request2, response2 = null, options) {
    const queryURL = new URL(requestQuery.url);
    const cachedURL = new URL(request2.url);
    if (options == null ? void 0 : options.ignoreSearch) {
      cachedURL.search = "";
      queryURL.search = "";
    }
    if (!urlEquals(queryURL, cachedURL, true)) {
      return false;
    }
    if (response2 == null || (options == null ? void 0 : options.ignoreVary) || !response2.headersList.contains("vary")) {
      return true;
    }
    const fieldValues = getFieldValues(response2.headersList.get("vary"));
    for (const fieldValue of fieldValues) {
      if (fieldValue === "*") {
        return false;
      }
      const requestValue = request2.headersList.get(fieldValue);
      const queryValue = requestQuery.headersList.get(fieldValue);
      if (requestValue !== queryValue) {
        return false;
      }
    }
    return true;
  };
  internalMatchAll_fn = function(request2, options, maxResponses = Infinity) {
    let r = null;
    if (request2 !== void 0) {
      if (webidl.is.Request(request2)) {
        r = getRequestState(request2);
        if (r.method !== "GET" && !options.ignoreMethod) {
          return [];
        }
      } else if (typeof request2 === "string") {
        r = getRequestState(new Request4(request2));
      }
    }
    const responses = [];
    if (request2 === void 0) {
      for (const requestResponse of __privateGet(this, _relevantRequestResponseList)) {
        responses.push(requestResponse[1]);
      }
    } else {
      const requestResponses = __privateMethod(this, _Cache_instances, queryCache_fn).call(this, r, options);
      for (const requestResponse of requestResponses) {
        responses.push(requestResponse[1]);
      }
    }
    const responseList = [];
    for (const response2 of responses) {
      const responseObject = fromInnerResponse(response2, "immutable");
      responseList.push(responseObject.clone());
      if (responseList.length >= maxResponses) {
        break;
      }
    }
    return Object.freeze(responseList);
  };
  let Cache2 = _Cache;
  Object.defineProperties(Cache2.prototype, {
    [Symbol.toStringTag]: {
      value: "Cache",
      configurable: true
    },
    match: kEnumerableProperty2,
    matchAll: kEnumerableProperty2,
    add: kEnumerableProperty2,
    addAll: kEnumerableProperty2,
    put: kEnumerableProperty2,
    delete: kEnumerableProperty2,
    keys: kEnumerableProperty2
  });
  const cacheQueryOptionConverters = [
    {
      key: "ignoreSearch",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "ignoreMethod",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "ignoreVary",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    }
  ];
  webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
  webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
    ...cacheQueryOptionConverters,
    {
      key: "cacheName",
      converter: webidl.converters.DOMString
    }
  ]);
  webidl.converters.Response = webidl.interfaceConverter(
    webidl.is.Response,
    "Response"
  );
  webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(
    webidl.converters.RequestInfo
  );
  cache$2 = {
    Cache: Cache2
  };
  return cache$2;
}
var cachestorage$1;
var hasRequiredCachestorage$1;
function requireCachestorage$1() {
  var _caches;
  if (hasRequiredCachestorage$1) return cachestorage$1;
  hasRequiredCachestorage$1 = 1;
  const { Cache: Cache2 } = requireCache$1();
  const { webidl } = requireWebidl$1();
  const { kEnumerableProperty: kEnumerableProperty2 } = util$J;
  const { kConstruct: kConstruct2 } = symbols$5;
  const _CacheStorage = class _CacheStorage {
    constructor() {
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
       * @type {Map<string, import('./cache').requestResponseList}
       */
      __privateAdd(this, _caches, /* @__PURE__ */ new Map());
      if (arguments[0] !== kConstruct2) {
        webidl.illegalConstructor();
      }
      webidl.util.markAsUncloneable(this);
    }
    async match(request2, options = {}) {
      webidl.brandCheck(this, _CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, "CacheStorage.match");
      request2 = webidl.converters.RequestInfo(request2);
      options = webidl.converters.MultiCacheQueryOptions(options);
      if (options.cacheName != null) {
        if (__privateGet(this, _caches).has(options.cacheName)) {
          const cacheList = __privateGet(this, _caches).get(options.cacheName);
          const cache2 = new Cache2(kConstruct2, cacheList);
          return await cache2.match(request2, options);
        }
      } else {
        for (const cacheList of __privateGet(this, _caches).values()) {
          const cache2 = new Cache2(kConstruct2, cacheList);
          const response2 = await cache2.match(request2, options);
          if (response2 !== void 0) {
            return response2;
          }
        }
      }
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
     * @param {string} cacheName
     * @returns {Promise<boolean>}
     */
    async has(cacheName) {
      webidl.brandCheck(this, _CacheStorage);
      const prefix = "CacheStorage.has";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
      return __privateGet(this, _caches).has(cacheName);
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
     * @param {string} cacheName
     * @returns {Promise<Cache>}
     */
    async open(cacheName) {
      webidl.brandCheck(this, _CacheStorage);
      const prefix = "CacheStorage.open";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
      if (__privateGet(this, _caches).has(cacheName)) {
        const cache3 = __privateGet(this, _caches).get(cacheName);
        return new Cache2(kConstruct2, cache3);
      }
      const cache2 = [];
      __privateGet(this, _caches).set(cacheName, cache2);
      return new Cache2(kConstruct2, cache2);
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
     * @param {string} cacheName
     * @returns {Promise<boolean>}
     */
    async delete(cacheName) {
      webidl.brandCheck(this, _CacheStorage);
      const prefix = "CacheStorage.delete";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
      return __privateGet(this, _caches).delete(cacheName);
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
     * @returns {Promise<string[]>}
     */
    async keys() {
      webidl.brandCheck(this, _CacheStorage);
      const keys = __privateGet(this, _caches).keys();
      return [...keys];
    }
  };
  _caches = new WeakMap();
  let CacheStorage2 = _CacheStorage;
  Object.defineProperties(CacheStorage2.prototype, {
    [Symbol.toStringTag]: {
      value: "CacheStorage",
      configurable: true
    },
    match: kEnumerableProperty2,
    has: kEnumerableProperty2,
    open: kEnumerableProperty2,
    delete: kEnumerableProperty2,
    keys: kEnumerableProperty2
  });
  cachestorage$1 = {
    CacheStorage: CacheStorage2
  };
  return cachestorage$1;
}
var constants$8;
var hasRequiredConstants$4;
function requireConstants$4() {
  if (hasRequiredConstants$4) return constants$8;
  hasRequiredConstants$4 = 1;
  const maxAttributeValueSize = 1024;
  const maxNameValuePairSize = 4096;
  constants$8 = {
    maxAttributeValueSize,
    maxNameValuePairSize
  };
  return constants$8;
}
var util$q;
var hasRequiredUtil$8;
function requireUtil$8() {
  if (hasRequiredUtil$8) return util$q;
  hasRequiredUtil$8 = 1;
  function isCTLExcludingHtab(value) {
    for (let i = 0; i < value.length; ++i) {
      const code = value.charCodeAt(i);
      if (code >= 0 && code <= 8 || code >= 10 && code <= 31 || code === 127) {
        return true;
      }
    }
    return false;
  }
  function validateCookieName(name) {
    for (let i = 0; i < name.length; ++i) {
      const code = name.charCodeAt(i);
      if (code < 33 || // exclude CTLs (0-31), SP and HT
      code > 126 || // exclude non-ascii and DEL
      code === 34 || // "
      code === 40 || // (
      code === 41 || // )
      code === 60 || // <
      code === 62 || // >
      code === 64 || // @
      code === 44 || // ,
      code === 59 || // ;
      code === 58 || // :
      code === 92 || // \
      code === 47 || // /
      code === 91 || // [
      code === 93 || // ]
      code === 63 || // ?
      code === 61 || // =
      code === 123 || // {
      code === 125) {
        throw new Error("Invalid cookie name");
      }
    }
  }
  function validateCookieValue(value) {
    let len = value.length;
    let i = 0;
    if (value[0] === '"') {
      if (len === 1 || value[len - 1] !== '"') {
        throw new Error("Invalid cookie value");
      }
      --len;
      ++i;
    }
    while (i < len) {
      const code = value.charCodeAt(i++);
      if (code < 33 || // exclude CTLs (0-31)
      code > 126 || // non-ascii and DEL (127)
      code === 34 || // "
      code === 44 || // ,
      code === 59 || // ;
      code === 92) {
        throw new Error("Invalid cookie value");
      }
    }
  }
  function validateCookiePath(path2) {
    for (let i = 0; i < path2.length; ++i) {
      const code = path2.charCodeAt(i);
      if (code < 32 || // exclude CTLs (0-31)
      code === 127 || // DEL
      code === 59) {
        throw new Error("Invalid cookie path");
      }
    }
  }
  function validateCookieDomain(domain) {
    if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
      throw new Error("Invalid cookie domain");
    }
  }
  const IMFDays = [
    "Sun",
    "Mon",
    "Tue",
    "Wed",
    "Thu",
    "Fri",
    "Sat"
  ];
  const IMFMonths = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  const IMFPaddedNumbers = Array(61).fill(0).map((_, i) => i.toString().padStart(2, "0"));
  function toIMFDate(date2) {
    if (typeof date2 === "number") {
      date2 = new Date(date2);
    }
    return `${IMFDays[date2.getUTCDay()]}, ${IMFPaddedNumbers[date2.getUTCDate()]} ${IMFMonths[date2.getUTCMonth()]} ${date2.getUTCFullYear()} ${IMFPaddedNumbers[date2.getUTCHours()]}:${IMFPaddedNumbers[date2.getUTCMinutes()]}:${IMFPaddedNumbers[date2.getUTCSeconds()]} GMT`;
  }
  function validateCookieMaxAge(maxAge) {
    if (maxAge < 0) {
      throw new Error("Invalid cookie max-age");
    }
  }
  function stringify2(cookie2) {
    if (cookie2.name.length === 0) {
      return null;
    }
    validateCookieName(cookie2.name);
    validateCookieValue(cookie2.value);
    const out = [`${cookie2.name}=${cookie2.value}`];
    if (cookie2.name.startsWith("__Secure-")) {
      cookie2.secure = true;
    }
    if (cookie2.name.startsWith("__Host-")) {
      cookie2.secure = true;
      cookie2.domain = null;
      cookie2.path = "/";
    }
    if (cookie2.secure) {
      out.push("Secure");
    }
    if (cookie2.httpOnly) {
      out.push("HttpOnly");
    }
    if (typeof cookie2.maxAge === "number") {
      validateCookieMaxAge(cookie2.maxAge);
      out.push(`Max-Age=${cookie2.maxAge}`);
    }
    if (cookie2.domain) {
      validateCookieDomain(cookie2.domain);
      out.push(`Domain=${cookie2.domain}`);
    }
    if (cookie2.path) {
      validateCookiePath(cookie2.path);
      out.push(`Path=${cookie2.path}`);
    }
    if (cookie2.expires && cookie2.expires.toString() !== "Invalid Date") {
      out.push(`Expires=${toIMFDate(cookie2.expires)}`);
    }
    if (cookie2.sameSite) {
      out.push(`SameSite=${cookie2.sameSite}`);
    }
    for (const part of cookie2.unparsed) {
      if (!part.includes("=")) {
        throw new Error("Invalid unparsed");
      }
      const [key, ...value] = part.split("=");
      out.push(`${key.trim()}=${value.join("=")}`);
    }
    return out.join("; ");
  }
  util$q = {
    isCTLExcludingHtab,
    validateCookieName,
    validateCookiePath,
    validateCookieValue,
    toIMFDate,
    stringify: stringify2
  };
  return util$q;
}
var parse$3;
var hasRequiredParse$1;
function requireParse$1() {
  if (hasRequiredParse$1) return parse$3;
  hasRequiredParse$1 = 1;
  const { maxNameValuePairSize, maxAttributeValueSize } = requireConstants$4();
  const { isCTLExcludingHtab } = requireUtil$8();
  const { collectASequenceOfCodePointsFast } = requireDataUrl$1();
  const assert2 = require$$0$3;
  const { unescape } = require$$7;
  function parseSetCookie(header) {
    if (isCTLExcludingHtab(header)) {
      return null;
    }
    let nameValuePair = "";
    let unparsedAttributes = "";
    let name = "";
    let value = "";
    if (header.includes(";")) {
      const position = { position: 0 };
      nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
      unparsedAttributes = header.slice(position.position);
    } else {
      nameValuePair = header;
    }
    if (!nameValuePair.includes("=")) {
      value = nameValuePair;
    } else {
      const position = { position: 0 };
      name = collectASequenceOfCodePointsFast(
        "=",
        nameValuePair,
        position
      );
      value = nameValuePair.slice(position.position + 1);
    }
    name = name.trim();
    value = value.trim();
    if (name.length + value.length > maxNameValuePairSize) {
      return null;
    }
    return {
      name,
      value: unescape(value),
      ...parseUnparsedAttributes(unparsedAttributes)
    };
  }
  function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
    if (unparsedAttributes.length === 0) {
      return cookieAttributeList;
    }
    assert2(unparsedAttributes[0] === ";");
    unparsedAttributes = unparsedAttributes.slice(1);
    let cookieAv = "";
    if (unparsedAttributes.includes(";")) {
      cookieAv = collectASequenceOfCodePointsFast(
        ";",
        unparsedAttributes,
        { position: 0 }
      );
      unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
    } else {
      cookieAv = unparsedAttributes;
      unparsedAttributes = "";
    }
    let attributeName = "";
    let attributeValue = "";
    if (cookieAv.includes("=")) {
      const position = { position: 0 };
      attributeName = collectASequenceOfCodePointsFast(
        "=",
        cookieAv,
        position
      );
      attributeValue = cookieAv.slice(position.position + 1);
    } else {
      attributeName = cookieAv;
    }
    attributeName = attributeName.trim();
    attributeValue = attributeValue.trim();
    if (attributeValue.length > maxAttributeValueSize) {
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    const attributeNameLowercase = attributeName.toLowerCase();
    if (attributeNameLowercase === "expires") {
      const expiryTime = new Date(attributeValue);
      cookieAttributeList.expires = expiryTime;
    } else if (attributeNameLowercase === "max-age") {
      const charCode = attributeValue.charCodeAt(0);
      if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      if (!/^\d+$/.test(attributeValue)) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const deltaSeconds = Number(attributeValue);
      cookieAttributeList.maxAge = deltaSeconds;
    } else if (attributeNameLowercase === "domain") {
      let cookieDomain = attributeValue;
      if (cookieDomain[0] === ".") {
        cookieDomain = cookieDomain.slice(1);
      }
      cookieDomain = cookieDomain.toLowerCase();
      cookieAttributeList.domain = cookieDomain;
    } else if (attributeNameLowercase === "path") {
      let cookiePath = "";
      if (attributeValue.length === 0 || attributeValue[0] !== "/") {
        cookiePath = "/";
      } else {
        cookiePath = attributeValue;
      }
      cookieAttributeList.path = cookiePath;
    } else if (attributeNameLowercase === "secure") {
      cookieAttributeList.secure = true;
    } else if (attributeNameLowercase === "httponly") {
      cookieAttributeList.httpOnly = true;
    } else if (attributeNameLowercase === "samesite") {
      let enforcement = "Default";
      const attributeValueLowercase = attributeValue.toLowerCase();
      if (attributeValueLowercase.includes("none")) {
        enforcement = "None";
      }
      if (attributeValueLowercase.includes("strict")) {
        enforcement = "Strict";
      }
      if (attributeValueLowercase.includes("lax")) {
        enforcement = "Lax";
      }
      cookieAttributeList.sameSite = enforcement;
    } else {
      cookieAttributeList.unparsed ?? (cookieAttributeList.unparsed = []);
      cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
    }
    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
  }
  parse$3 = {
    parseSetCookie,
    parseUnparsedAttributes
  };
  return parse$3;
}
var cookies$1;
var hasRequiredCookies$1;
function requireCookies$1() {
  if (hasRequiredCookies$1) return cookies$1;
  hasRequiredCookies$1 = 1;
  const { parseSetCookie } = requireParse$1();
  const { stringify: stringify2 } = requireUtil$8();
  const { webidl } = requireWebidl$1();
  const { Headers } = requireHeaders$1();
  const brandChecks = webidl.brandCheckMultiple([Headers, globalThis.Headers].filter(Boolean));
  function getCookies2(headers2) {
    webidl.argumentLengthCheck(arguments, 1, "getCookies");
    brandChecks(headers2);
    const cookie2 = headers2.get("cookie");
    const out = {};
    if (!cookie2) {
      return out;
    }
    for (const piece of cookie2.split(";")) {
      const [name, ...value] = piece.split("=");
      out[name.trim()] = value.join("=");
    }
    return out;
  }
  function deleteCookie2(headers2, name, attributes) {
    brandChecks(headers2);
    const prefix = "deleteCookie";
    webidl.argumentLengthCheck(arguments, 2, prefix);
    name = webidl.converters.DOMString(name, prefix, "name");
    attributes = webidl.converters.DeleteCookieAttributes(attributes);
    setCookie2(headers2, {
      name,
      value: "",
      expires: /* @__PURE__ */ new Date(0),
      ...attributes
    });
  }
  function getSetCookies2(headers2) {
    webidl.argumentLengthCheck(arguments, 1, "getSetCookies");
    brandChecks(headers2);
    const cookies2 = headers2.getSetCookie();
    if (!cookies2) {
      return [];
    }
    return cookies2.map((pair) => parseSetCookie(pair));
  }
  function parseCookie(cookie2) {
    cookie2 = webidl.converters.DOMString(cookie2);
    return parseSetCookie(cookie2);
  }
  function setCookie2(headers2, cookie2) {
    webidl.argumentLengthCheck(arguments, 2, "setCookie");
    brandChecks(headers2);
    cookie2 = webidl.converters.Cookie(cookie2);
    const str = stringify2(cookie2);
    if (str) {
      headers2.append("set-cookie", str, true);
    }
  }
  webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: () => null
    }
  ]);
  webidl.converters.Cookie = webidl.dictionaryConverter([
    {
      converter: webidl.converters.DOMString,
      key: "name"
    },
    {
      converter: webidl.converters.DOMString,
      key: "value"
    },
    {
      converter: webidl.nullableConverter((value) => {
        if (typeof value === "number") {
          return webidl.converters["unsigned long long"](value);
        }
        return new Date(value);
      }),
      key: "expires",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters["long long"]),
      key: "maxAge",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "secure",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "httpOnly",
      defaultValue: () => null
    },
    {
      converter: webidl.converters.USVString,
      key: "sameSite",
      allowedValues: ["Strict", "Lax", "None"]
    },
    {
      converter: webidl.sequenceConverter(webidl.converters.DOMString),
      key: "unparsed",
      defaultValue: () => new Array(0)
    }
  ]);
  cookies$1 = {
    getCookies: getCookies2,
    deleteCookie: deleteCookie2,
    getSetCookies: getSetCookies2,
    setCookie: setCookie2,
    parseCookie
  };
  return cookies$1;
}
var events$1;
var hasRequiredEvents$1;
function requireEvents$1() {
  var _eventInit, _eventInit2, _eventInit3;
  if (hasRequiredEvents$1) return events$1;
  hasRequiredEvents$1 = 1;
  const { webidl } = requireWebidl$1();
  const { kEnumerableProperty: kEnumerableProperty2 } = util$J;
  const { kConstruct: kConstruct2 } = symbols$5;
  const _MessageEvent = class _MessageEvent extends Event {
    constructor(type, eventInitDict = {}) {
      var __super = (...args) => {
        super(...args);
        __privateAdd(this, _eventInit);
        return this;
      };
      if (type === kConstruct2) {
        __super(arguments[1], arguments[2]);
        webidl.util.markAsUncloneable(this);
        return;
      }
      const prefix = "MessageEvent constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      type = webidl.converters.DOMString(type, prefix, "type");
      eventInitDict = webidl.converters.MessageEventInit(eventInitDict, prefix, "eventInitDict");
      __super(type, eventInitDict);
      __privateSet(this, _eventInit, eventInitDict);
      webidl.util.markAsUncloneable(this);
    }
    get data() {
      webidl.brandCheck(this, _MessageEvent);
      return __privateGet(this, _eventInit).data;
    }
    get origin() {
      webidl.brandCheck(this, _MessageEvent);
      return __privateGet(this, _eventInit).origin;
    }
    get lastEventId() {
      webidl.brandCheck(this, _MessageEvent);
      return __privateGet(this, _eventInit).lastEventId;
    }
    get source() {
      webidl.brandCheck(this, _MessageEvent);
      return __privateGet(this, _eventInit).source;
    }
    get ports() {
      webidl.brandCheck(this, _MessageEvent);
      if (!Object.isFrozen(__privateGet(this, _eventInit).ports)) {
        Object.freeze(__privateGet(this, _eventInit).ports);
      }
      return __privateGet(this, _eventInit).ports;
    }
    initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
      webidl.brandCheck(this, _MessageEvent);
      webidl.argumentLengthCheck(arguments, 1, "MessageEvent.initMessageEvent");
      return new _MessageEvent(type, {
        bubbles,
        cancelable,
        data,
        origin,
        lastEventId,
        source,
        ports
      });
    }
    static createFastMessageEvent(type, init) {
      var _a2, _b2, _c2, _d2, _e2;
      const messageEvent = new _MessageEvent(kConstruct2, type, init);
      __privateSet(messageEvent, _eventInit, init);
      (_a2 = __privateGet(messageEvent, _eventInit)).data ?? (_a2.data = null);
      (_b2 = __privateGet(messageEvent, _eventInit)).origin ?? (_b2.origin = "");
      (_c2 = __privateGet(messageEvent, _eventInit)).lastEventId ?? (_c2.lastEventId = "");
      (_d2 = __privateGet(messageEvent, _eventInit)).source ?? (_d2.source = null);
      (_e2 = __privateGet(messageEvent, _eventInit)).ports ?? (_e2.ports = []);
      return messageEvent;
    }
  };
  _eventInit = new WeakMap();
  let MessageEvent2 = _MessageEvent;
  const { createFastMessageEvent } = MessageEvent2;
  delete MessageEvent2.createFastMessageEvent;
  const _CloseEvent = class _CloseEvent extends Event {
    constructor(type, eventInitDict = {}) {
      const prefix = "CloseEvent constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      type = webidl.converters.DOMString(type, prefix, "type");
      eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
      super(type, eventInitDict);
      __privateAdd(this, _eventInit2);
      __privateSet(this, _eventInit2, eventInitDict);
      webidl.util.markAsUncloneable(this);
    }
    get wasClean() {
      webidl.brandCheck(this, _CloseEvent);
      return __privateGet(this, _eventInit2).wasClean;
    }
    get code() {
      webidl.brandCheck(this, _CloseEvent);
      return __privateGet(this, _eventInit2).code;
    }
    get reason() {
      webidl.brandCheck(this, _CloseEvent);
      return __privateGet(this, _eventInit2).reason;
    }
  };
  _eventInit2 = new WeakMap();
  let CloseEvent2 = _CloseEvent;
  const _ErrorEvent = class _ErrorEvent extends Event {
    constructor(type, eventInitDict) {
      const prefix = "ErrorEvent constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      super(type, eventInitDict);
      __privateAdd(this, _eventInit3);
      webidl.util.markAsUncloneable(this);
      type = webidl.converters.DOMString(type, prefix, "type");
      eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
      __privateSet(this, _eventInit3, eventInitDict);
    }
    get message() {
      webidl.brandCheck(this, _ErrorEvent);
      return __privateGet(this, _eventInit3).message;
    }
    get filename() {
      webidl.brandCheck(this, _ErrorEvent);
      return __privateGet(this, _eventInit3).filename;
    }
    get lineno() {
      webidl.brandCheck(this, _ErrorEvent);
      return __privateGet(this, _eventInit3).lineno;
    }
    get colno() {
      webidl.brandCheck(this, _ErrorEvent);
      return __privateGet(this, _eventInit3).colno;
    }
    get error() {
      webidl.brandCheck(this, _ErrorEvent);
      return __privateGet(this, _eventInit3).error;
    }
  };
  _eventInit3 = new WeakMap();
  let ErrorEvent2 = _ErrorEvent;
  Object.defineProperties(MessageEvent2.prototype, {
    [Symbol.toStringTag]: {
      value: "MessageEvent",
      configurable: true
    },
    data: kEnumerableProperty2,
    origin: kEnumerableProperty2,
    lastEventId: kEnumerableProperty2,
    source: kEnumerableProperty2,
    ports: kEnumerableProperty2,
    initMessageEvent: kEnumerableProperty2
  });
  Object.defineProperties(CloseEvent2.prototype, {
    [Symbol.toStringTag]: {
      value: "CloseEvent",
      configurable: true
    },
    reason: kEnumerableProperty2,
    code: kEnumerableProperty2,
    wasClean: kEnumerableProperty2
  });
  Object.defineProperties(ErrorEvent2.prototype, {
    [Symbol.toStringTag]: {
      value: "ErrorEvent",
      configurable: true
    },
    message: kEnumerableProperty2,
    filename: kEnumerableProperty2,
    lineno: kEnumerableProperty2,
    colno: kEnumerableProperty2,
    error: kEnumerableProperty2
  });
  webidl.converters.MessagePort = webidl.interfaceConverter(
    webidl.is.MessagePort,
    "MessagePort"
  );
  webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(
    webidl.converters.MessagePort
  );
  const eventInit = [
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    }
  ];
  webidl.converters.MessageEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "data",
      converter: webidl.converters.any,
      defaultValue: () => null
    },
    {
      key: "origin",
      converter: webidl.converters.USVString,
      defaultValue: () => ""
    },
    {
      key: "lastEventId",
      converter: webidl.converters.DOMString,
      defaultValue: () => ""
    },
    {
      key: "source",
      // Node doesn't implement WindowProxy or ServiceWorker, so the only
      // valid value for source is a MessagePort.
      converter: webidl.nullableConverter(webidl.converters.MessagePort),
      defaultValue: () => null
    },
    {
      key: "ports",
      converter: webidl.converters["sequence<MessagePort>"],
      defaultValue: () => new Array(0)
    }
  ]);
  webidl.converters.CloseEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "wasClean",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "code",
      converter: webidl.converters["unsigned short"],
      defaultValue: () => 0
    },
    {
      key: "reason",
      converter: webidl.converters.USVString,
      defaultValue: () => ""
    }
  ]);
  webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "message",
      converter: webidl.converters.DOMString,
      defaultValue: () => ""
    },
    {
      key: "filename",
      converter: webidl.converters.USVString,
      defaultValue: () => ""
    },
    {
      key: "lineno",
      converter: webidl.converters["unsigned long"],
      defaultValue: () => 0
    },
    {
      key: "colno",
      converter: webidl.converters["unsigned long"],
      defaultValue: () => 0
    },
    {
      key: "error",
      converter: webidl.converters.any
    }
  ]);
  events$1 = {
    MessageEvent: MessageEvent2,
    CloseEvent: CloseEvent2,
    ErrorEvent: ErrorEvent2,
    createFastMessageEvent
  };
  return events$1;
}
var constants$7;
var hasRequiredConstants$3;
function requireConstants$3() {
  if (hasRequiredConstants$3) return constants$7;
  hasRequiredConstants$3 = 1;
  const uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
  const staticPropertyDescriptors = {
    enumerable: true,
    writable: false,
    configurable: false
  };
  const states = {
    CONNECTING: 0,
    OPEN: 1,
    CLOSING: 2,
    CLOSED: 3
  };
  const sentCloseFrameState = {
    SENT: 1,
    RECEIVED: 2
  };
  const opcodes = {
    CONTINUATION: 0,
    TEXT: 1,
    BINARY: 2,
    CLOSE: 8,
    PING: 9,
    PONG: 10
  };
  const maxUnsigned16Bit = 65535;
  const parserStates = {
    INFO: 0,
    PAYLOADLENGTH_16: 2,
    PAYLOADLENGTH_64: 3,
    READ_DATA: 4
  };
  const emptyBuffer = Buffer.allocUnsafe(0);
  const sendHints = {
    text: 1,
    typedArray: 2,
    arrayBuffer: 3,
    blob: 4
  };
  constants$7 = {
    uid,
    sentCloseFrameState,
    staticPropertyDescriptors,
    states,
    opcodes,
    maxUnsigned16Bit,
    parserStates,
    emptyBuffer,
    sendHints
  };
  return constants$7;
}
var util$p;
var hasRequiredUtil$7;
function requireUtil$7() {
  if (hasRequiredUtil$7) return util$p;
  hasRequiredUtil$7 = 1;
  const { states, opcodes } = requireConstants$3();
  const { isUtf8 } = require$$0$1;
  const { collectASequenceOfCodePointsFast, removeHTTPWhitespace } = requireDataUrl$1();
  function isConnecting(readyState) {
    return readyState === states.CONNECTING;
  }
  function isEstablished(readyState) {
    return readyState === states.OPEN;
  }
  function isClosing(readyState) {
    return readyState === states.CLOSING;
  }
  function isClosed(readyState) {
    return readyState === states.CLOSED;
  }
  function fireEvent(e, target, eventFactory = (type, init) => new Event(type, init), eventInitDict = {}) {
    const event = eventFactory(e, eventInitDict);
    target.dispatchEvent(event);
  }
  function websocketMessageReceived(handler, type, data) {
    handler.onMessage(type, data);
  }
  function toArrayBuffer(buffer) {
    if (buffer.byteLength === buffer.buffer.byteLength) {
      return buffer.buffer;
    }
    return new Uint8Array(buffer).buffer;
  }
  function isValidSubprotocol(protocol) {
    if (protocol.length === 0) {
      return false;
    }
    for (let i = 0; i < protocol.length; ++i) {
      const code = protocol.charCodeAt(i);
      if (code < 33 || // CTL, contains SP (0x20) and HT (0x09)
      code > 126 || code === 34 || // "
      code === 40 || // (
      code === 41 || // )
      code === 44 || // ,
      code === 47 || // /
      code === 58 || // :
      code === 59 || // ;
      code === 60 || // <
      code === 61 || // =
      code === 62 || // >
      code === 63 || // ?
      code === 64 || // @
      code === 91 || // [
      code === 92 || // \
      code === 93 || // ]
      code === 123 || // {
      code === 125) {
        return false;
      }
    }
    return true;
  }
  function isValidStatusCode(code) {
    if (code >= 1e3 && code < 1015) {
      return code !== 1004 && // reserved
      code !== 1005 && // "MUST NOT be set as a status code"
      code !== 1006;
    }
    return code >= 3e3 && code <= 4999;
  }
  function isControlFrame(opcode) {
    return opcode === opcodes.CLOSE || opcode === opcodes.PING || opcode === opcodes.PONG;
  }
  function isContinuationFrame(opcode) {
    return opcode === opcodes.CONTINUATION;
  }
  function isTextBinaryFrame(opcode) {
    return opcode === opcodes.TEXT || opcode === opcodes.BINARY;
  }
  function isValidOpcode(opcode) {
    return isTextBinaryFrame(opcode) || isContinuationFrame(opcode) || isControlFrame(opcode);
  }
  function parseExtensions(extensions) {
    const position = { position: 0 };
    const extensionList = /* @__PURE__ */ new Map();
    while (position.position < extensions.length) {
      const pair = collectASequenceOfCodePointsFast(";", extensions, position);
      const [name, value = ""] = pair.split("=");
      extensionList.set(
        removeHTTPWhitespace(name, true, false),
        removeHTTPWhitespace(value, false, true)
      );
      position.position++;
    }
    return extensionList;
  }
  function isValidClientWindowBits(value) {
    for (let i = 0; i < value.length; i++) {
      const byte = value.charCodeAt(i);
      if (byte < 48 || byte > 57) {
        return false;
      }
    }
    return true;
  }
  function getURLRecord(url, baseURL) {
    let urlRecord;
    try {
      urlRecord = new URL(url, baseURL);
    } catch (e) {
      throw new DOMException(e, "SyntaxError");
    }
    if (urlRecord.protocol === "http:") {
      urlRecord.protocol = "ws:";
    } else if (urlRecord.protocol === "https:") {
      urlRecord.protocol = "wss:";
    }
    if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
      throw new DOMException("expected a ws: or wss: url", "SyntaxError");
    }
    if (urlRecord.hash.length || urlRecord.href.endsWith("#")) {
      throw new DOMException("hash", "SyntaxError");
    }
    return urlRecord;
  }
  function validateCloseCodeAndReason(code, reason) {
    if (code !== null) {
      if (code !== 1e3 && (code < 3e3 || code > 4999)) {
        throw new DOMException("invalid code", "InvalidAccessError");
      }
    }
    if (reason !== null) {
      const reasonBytesLength = Buffer.byteLength(reason);
      if (reasonBytesLength > 123) {
        throw new DOMException(`Reason must be less than 123 bytes; received ${reasonBytesLength}`, "SyntaxError");
      }
    }
  }
  const utf8Decode = (() => {
    if (typeof process.versions.icu === "string") {
      const fatalDecoder = new TextDecoder("utf-8", { fatal: true });
      return fatalDecoder.decode.bind(fatalDecoder);
    }
    return function(buffer) {
      if (isUtf8(buffer)) {
        return buffer.toString("utf-8");
      }
      throw new TypeError("Invalid utf-8 received.");
    };
  })();
  util$p = {
    isConnecting,
    isEstablished,
    isClosing,
    isClosed,
    fireEvent,
    isValidSubprotocol,
    isValidStatusCode,
    websocketMessageReceived,
    utf8Decode,
    isControlFrame,
    isContinuationFrame,
    isTextBinaryFrame,
    isValidOpcode,
    parseExtensions,
    isValidClientWindowBits,
    toArrayBuffer,
    getURLRecord,
    validateCloseCodeAndReason
  };
  return util$p;
}
var frame$1;
var hasRequiredFrame$1;
function requireFrame$1() {
  if (hasRequiredFrame$1) return frame$1;
  hasRequiredFrame$1 = 1;
  const { maxUnsigned16Bit, opcodes } = requireConstants$3();
  const BUFFER_SIZE = 8 * 1024;
  let crypto2;
  let buffer = null;
  let bufIdx = BUFFER_SIZE;
  try {
    crypto2 = require("node:crypto");
  } catch {
    crypto2 = {
      // not full compatibility, but minimum.
      randomFillSync: function randomFillSync(buffer2, _offset, _size4) {
        for (let i = 0; i < buffer2.length; ++i) {
          buffer2[i] = Math.random() * 255 | 0;
        }
        return buffer2;
      }
    };
  }
  function generateMask() {
    if (bufIdx === BUFFER_SIZE) {
      bufIdx = 0;
      crypto2.randomFillSync(buffer ?? (buffer = Buffer.allocUnsafeSlow(BUFFER_SIZE)), 0, BUFFER_SIZE);
    }
    return [buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++]];
  }
  class WebsocketFrameSend {
    /**
     * @param {Buffer|undefined} data
     */
    constructor(data) {
      this.frameData = data;
    }
    createFrame(opcode) {
      const frameData = this.frameData;
      const maskKey = generateMask();
      const bodyLength2 = (frameData == null ? void 0 : frameData.byteLength) ?? 0;
      let payloadLength = bodyLength2;
      let offset = 6;
      if (bodyLength2 > maxUnsigned16Bit) {
        offset += 8;
        payloadLength = 127;
      } else if (bodyLength2 > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const buffer2 = Buffer.allocUnsafe(bodyLength2 + offset);
      buffer2[0] = buffer2[1] = 0;
      buffer2[0] |= 128;
      buffer2[0] = (buffer2[0] & 240) + opcode;
      /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
      buffer2[offset - 4] = maskKey[0];
      buffer2[offset - 3] = maskKey[1];
      buffer2[offset - 2] = maskKey[2];
      buffer2[offset - 1] = maskKey[3];
      buffer2[1] = payloadLength;
      if (payloadLength === 126) {
        buffer2.writeUInt16BE(bodyLength2, 2);
      } else if (payloadLength === 127) {
        buffer2[2] = buffer2[3] = 0;
        buffer2.writeUIntBE(bodyLength2, 4, 6);
      }
      buffer2[1] |= 128;
      for (let i = 0; i < bodyLength2; ++i) {
        buffer2[offset + i] = frameData[i] ^ maskKey[i & 3];
      }
      return buffer2;
    }
    /**
     * @param {Uint8Array} buffer
     */
    static createFastTextFrame(buffer2) {
      const maskKey = generateMask();
      const bodyLength2 = buffer2.length;
      for (let i = 0; i < bodyLength2; ++i) {
        buffer2[i] ^= maskKey[i & 3];
      }
      let payloadLength = bodyLength2;
      let offset = 6;
      if (bodyLength2 > maxUnsigned16Bit) {
        offset += 8;
        payloadLength = 127;
      } else if (bodyLength2 > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const head = Buffer.allocUnsafeSlow(offset);
      head[0] = 128 | opcodes.TEXT;
      head[1] = payloadLength | 128;
      head[offset - 4] = maskKey[0];
      head[offset - 3] = maskKey[1];
      head[offset - 2] = maskKey[2];
      head[offset - 1] = maskKey[3];
      if (payloadLength === 126) {
        head.writeUInt16BE(bodyLength2, 2);
      } else if (payloadLength === 127) {
        head[2] = head[3] = 0;
        head.writeUIntBE(bodyLength2, 4, 6);
      }
      return [head, buffer2];
    }
  }
  frame$1 = {
    WebsocketFrameSend
  };
  return frame$1;
}
var connection$1;
var hasRequiredConnection$1;
function requireConnection$1() {
  if (hasRequiredConnection$1) return connection$1;
  hasRequiredConnection$1 = 1;
  const { uid, states, sentCloseFrameState, emptyBuffer, opcodes } = requireConstants$3();
  const { parseExtensions, isClosed, isClosing, isEstablished, validateCloseCodeAndReason } = requireUtil$7();
  const { channels: channels2 } = diagnostics$1;
  const { makeRequest } = requireRequest$1();
  const { fetching } = requireFetch$1();
  const { Headers, getHeadersList } = requireHeaders$1();
  const { getDecodeSplit } = requireUtil$a();
  const { WebsocketFrameSend } = requireFrame$1();
  const assert2 = require$$0$3;
  let crypto2;
  try {
    crypto2 = require("node:crypto");
  } catch {
  }
  function establishWebSocketConnection(url, protocols, client2, handler, options) {
    const requestURL = url;
    requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
    const request2 = makeRequest({
      urlList: [requestURL],
      client: client2,
      serviceWorkers: "none",
      referrer: "no-referrer",
      mode: "websocket",
      credentials: "include",
      cache: "no-store",
      redirect: "error"
    });
    if (options.headers) {
      const headersList = getHeadersList(new Headers(options.headers));
      request2.headersList = headersList;
    }
    const keyValue = crypto2.randomBytes(16).toString("base64");
    request2.headersList.append("sec-websocket-key", keyValue, true);
    request2.headersList.append("sec-websocket-version", "13", true);
    for (const protocol of protocols) {
      request2.headersList.append("sec-websocket-protocol", protocol, true);
    }
    const permessageDeflate2 = "permessage-deflate; client_max_window_bits";
    request2.headersList.append("sec-websocket-extensions", permessageDeflate2, true);
    const controller = fetching({
      request: request2,
      useParallelQueue: true,
      dispatcher: options.dispatcher,
      processResponse(response2) {
        var _a2, _b2;
        if (response2.type === "error") {
          handler.readyState = states.CLOSED;
        }
        if (response2.type === "error" || response2.status !== 101) {
          failWebsocketConnection(handler, 1002, "Received network error or non-101 status code.");
          return;
        }
        if (protocols.length !== 0 && !response2.headersList.get("Sec-WebSocket-Protocol")) {
          failWebsocketConnection(handler, 1002, "Server did not respond with sent protocols.");
          return;
        }
        if (((_a2 = response2.headersList.get("Upgrade")) == null ? void 0 : _a2.toLowerCase()) !== "websocket") {
          failWebsocketConnection(handler, 1002, 'Server did not set Upgrade header to "websocket".');
          return;
        }
        if (((_b2 = response2.headersList.get("Connection")) == null ? void 0 : _b2.toLowerCase()) !== "upgrade") {
          failWebsocketConnection(handler, 1002, 'Server did not set Connection header to "upgrade".');
          return;
        }
        const secWSAccept = response2.headersList.get("Sec-WebSocket-Accept");
        const digest = crypto2.createHash("sha1").update(keyValue + uid).digest("base64");
        if (secWSAccept !== digest) {
          failWebsocketConnection(handler, 1002, "Incorrect hash received in Sec-WebSocket-Accept header.");
          return;
        }
        const secExtension = response2.headersList.get("Sec-WebSocket-Extensions");
        let extensions;
        if (secExtension !== null) {
          extensions = parseExtensions(secExtension);
          if (!extensions.has("permessage-deflate")) {
            failWebsocketConnection(handler, 1002, "Sec-WebSocket-Extensions header does not match.");
            return;
          }
        }
        const secProtocol = response2.headersList.get("Sec-WebSocket-Protocol");
        if (secProtocol !== null) {
          const requestProtocols = getDecodeSplit("sec-websocket-protocol", request2.headersList);
          if (!requestProtocols.includes(secProtocol)) {
            failWebsocketConnection(handler, 1002, "Protocol was not set in the opening handshake.");
            return;
          }
        }
        response2.socket.on("data", handler.onSocketData);
        response2.socket.on("close", handler.onSocketClose);
        response2.socket.on("error", handler.onSocketError);
        if (channels2.open.hasSubscribers) {
          channels2.open.publish({
            address: response2.socket.address(),
            protocol: secProtocol,
            extensions: secExtension
          });
        }
        handler.wasEverConnected = true;
        handler.onConnectionEstablished(response2, extensions);
      }
    });
    return controller;
  }
  function closeWebSocketConnection(object, code, reason, validate2 = false) {
    code ?? (code = null);
    reason ?? (reason = "");
    if (validate2) validateCloseCodeAndReason(code, reason);
    if (isClosed(object.readyState) || isClosing(object.readyState)) ;
    else if (!isEstablished(object.readyState)) {
      failWebsocketConnection(object);
      object.readyState = states.CLOSING;
    } else if (!object.closeState.has(sentCloseFrameState.SENT) && !object.closeState.has(sentCloseFrameState.RECEIVED)) {
      const frame2 = new WebsocketFrameSend();
      if (reason.length !== 0 && code === null) {
        code = 1e3;
      }
      assert2(code === null || Number.isInteger(code));
      if (code === null && reason.length === 0) {
        frame2.frameData = emptyBuffer;
      } else if (code !== null && reason === null) {
        frame2.frameData = Buffer.allocUnsafe(2);
        frame2.frameData.writeUInt16BE(code, 0);
      } else if (code !== null && reason !== null) {
        frame2.frameData = Buffer.allocUnsafe(2 + Buffer.byteLength(reason));
        frame2.frameData.writeUInt16BE(code, 0);
        frame2.frameData.write(reason, 2, "utf-8");
      } else {
        frame2.frameData = emptyBuffer;
      }
      object.socket.write(frame2.createFrame(opcodes.CLOSE));
      object.closeState.add(sentCloseFrameState.SENT);
      object.readyState = states.CLOSING;
    } else {
      object.readyState = states.CLOSING;
    }
  }
  function failWebsocketConnection(handler, code, reason) {
    var _a2;
    if (isEstablished(handler.readyState)) {
      closeWebSocketConnection(handler, code, reason, false);
    }
    handler.controller.abort();
    if (((_a2 = handler.socket) == null ? void 0 : _a2.destroyed) === false) {
      handler.socket.destroy();
    }
    handler.onFail(code, reason);
  }
  connection$1 = {
    establishWebSocketConnection,
    failWebsocketConnection,
    closeWebSocketConnection
  };
  return connection$1;
}
var permessageDeflate$1;
var hasRequiredPermessageDeflate$1;
function requirePermessageDeflate$1() {
  var _inflate, _options3;
  if (hasRequiredPermessageDeflate$1) return permessageDeflate$1;
  hasRequiredPermessageDeflate$1 = 1;
  const { createInflateRaw, Z_DEFAULT_WINDOWBITS } = require$$1$2;
  const { isValidClientWindowBits } = requireUtil$7();
  const tail = Buffer.from([0, 0, 255, 255]);
  const kBuffer = Symbol("kBuffer");
  const kLength = Symbol("kLength");
  class PerMessageDeflate {
    constructor(extensions) {
      /** @type {import('node:zlib').InflateRaw} */
      __privateAdd(this, _inflate);
      __privateAdd(this, _options3, {});
      __privateGet(this, _options3).serverNoContextTakeover = extensions.has("server_no_context_takeover");
      __privateGet(this, _options3).serverMaxWindowBits = extensions.get("server_max_window_bits");
    }
    decompress(chunk, fin, callback) {
      if (!__privateGet(this, _inflate)) {
        let windowBits = Z_DEFAULT_WINDOWBITS;
        if (__privateGet(this, _options3).serverMaxWindowBits) {
          if (!isValidClientWindowBits(__privateGet(this, _options3).serverMaxWindowBits)) {
            callback(new Error("Invalid server_max_window_bits"));
            return;
          }
          windowBits = Number.parseInt(__privateGet(this, _options3).serverMaxWindowBits);
        }
        __privateSet(this, _inflate, createInflateRaw({ windowBits }));
        __privateGet(this, _inflate)[kBuffer] = [];
        __privateGet(this, _inflate)[kLength] = 0;
        __privateGet(this, _inflate).on("data", (data) => {
          __privateGet(this, _inflate)[kBuffer].push(data);
          __privateGet(this, _inflate)[kLength] += data.length;
        });
        __privateGet(this, _inflate).on("error", (err) => {
          __privateSet(this, _inflate, null);
          callback(err);
        });
      }
      __privateGet(this, _inflate).write(chunk);
      if (fin) {
        __privateGet(this, _inflate).write(tail);
      }
      __privateGet(this, _inflate).flush(() => {
        const full = Buffer.concat(__privateGet(this, _inflate)[kBuffer], __privateGet(this, _inflate)[kLength]);
        __privateGet(this, _inflate)[kBuffer].length = 0;
        __privateGet(this, _inflate)[kLength] = 0;
        callback(null, full);
      });
    }
  }
  _inflate = new WeakMap();
  _options3 = new WeakMap();
  permessageDeflate$1 = { PerMessageDeflate };
  return permessageDeflate$1;
}
var receiver$1;
var hasRequiredReceiver$1;
function requireReceiver$1() {
  var _buffers, _fragmentsBytes, _byteOffset, _loop, _state3, _info, _fragments, _extensions, _handler9;
  if (hasRequiredReceiver$1) return receiver$1;
  hasRequiredReceiver$1 = 1;
  const { Writable: Writable2 } = require$$0$4;
  const assert2 = require$$0$3;
  const { parserStates, opcodes, states, emptyBuffer, sentCloseFrameState } = requireConstants$3();
  const { channels: channels2 } = diagnostics$1;
  const {
    isValidStatusCode,
    isValidOpcode,
    websocketMessageReceived,
    utf8Decode,
    isControlFrame,
    isTextBinaryFrame,
    isContinuationFrame
  } = requireUtil$7();
  const { failWebsocketConnection } = requireConnection$1();
  const { WebsocketFrameSend } = requireFrame$1();
  const { PerMessageDeflate } = requirePermessageDeflate$1();
  class ByteParser extends Writable2 {
    constructor(handler, extensions) {
      super();
      __privateAdd(this, _buffers, []);
      __privateAdd(this, _fragmentsBytes, 0);
      __privateAdd(this, _byteOffset, 0);
      __privateAdd(this, _loop, false);
      __privateAdd(this, _state3, parserStates.INFO);
      __privateAdd(this, _info, {});
      __privateAdd(this, _fragments, []);
      /** @type {Map<string, PerMessageDeflate>} */
      __privateAdd(this, _extensions);
      /** @type {import('./websocket').Handler} */
      __privateAdd(this, _handler9);
      __privateSet(this, _handler9, handler);
      __privateSet(this, _extensions, extensions == null ? /* @__PURE__ */ new Map() : extensions);
      if (__privateGet(this, _extensions).has("permessage-deflate")) {
        __privateGet(this, _extensions).set("permessage-deflate", new PerMessageDeflate(extensions));
      }
    }
    /**
     * @param {Buffer} chunk
     * @param {() => void} callback
     */
    _write(chunk, _, callback) {
      __privateGet(this, _buffers).push(chunk);
      __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) + chunk.length);
      __privateSet(this, _loop, true);
      this.run(callback);
    }
    /**
     * Runs whenever a new chunk is received.
     * Callback is called whenever there are no more chunks buffering,
     * or not enough bytes are buffered to parse.
     */
    run(callback) {
      while (__privateGet(this, _loop)) {
        if (__privateGet(this, _state3) === parserStates.INFO) {
          if (__privateGet(this, _byteOffset) < 2) {
            return callback();
          }
          const buffer = this.consume(2);
          const fin = (buffer[0] & 128) !== 0;
          const opcode = buffer[0] & 15;
          const masked = (buffer[1] & 128) === 128;
          const fragmented = !fin && opcode !== opcodes.CONTINUATION;
          const payloadLength = buffer[1] & 127;
          const rsv1 = buffer[0] & 64;
          const rsv2 = buffer[0] & 32;
          const rsv3 = buffer[0] & 16;
          if (!isValidOpcode(opcode)) {
            failWebsocketConnection(__privateGet(this, _handler9), 1002, "Invalid opcode received");
            return callback();
          }
          if (masked) {
            failWebsocketConnection(__privateGet(this, _handler9), 1002, "Frame cannot be masked");
            return callback();
          }
          if (rsv1 !== 0 && !__privateGet(this, _extensions).has("permessage-deflate")) {
            failWebsocketConnection(__privateGet(this, _handler9), 1002, "Expected RSV1 to be clear.");
            return;
          }
          if (rsv2 !== 0 || rsv3 !== 0) {
            failWebsocketConnection(__privateGet(this, _handler9), 1002, "RSV1, RSV2, RSV3 must be clear");
            return;
          }
          if (fragmented && !isTextBinaryFrame(opcode)) {
            failWebsocketConnection(__privateGet(this, _handler9), 1002, "Invalid frame type was fragmented.");
            return;
          }
          if (isTextBinaryFrame(opcode) && __privateGet(this, _fragments).length > 0) {
            failWebsocketConnection(__privateGet(this, _handler9), 1002, "Expected continuation frame");
            return;
          }
          if (__privateGet(this, _info).fragmented && fragmented) {
            failWebsocketConnection(__privateGet(this, _handler9), 1002, "Fragmented frame exceeded 125 bytes.");
            return;
          }
          if ((payloadLength > 125 || fragmented) && isControlFrame(opcode)) {
            failWebsocketConnection(__privateGet(this, _handler9), 1002, "Control frame either too large or fragmented");
            return;
          }
          if (isContinuationFrame(opcode) && __privateGet(this, _fragments).length === 0 && !__privateGet(this, _info).compressed) {
            failWebsocketConnection(__privateGet(this, _handler9), 1002, "Unexpected continuation frame");
            return;
          }
          if (payloadLength <= 125) {
            __privateGet(this, _info).payloadLength = payloadLength;
            __privateSet(this, _state3, parserStates.READ_DATA);
          } else if (payloadLength === 126) {
            __privateSet(this, _state3, parserStates.PAYLOADLENGTH_16);
          } else if (payloadLength === 127) {
            __privateSet(this, _state3, parserStates.PAYLOADLENGTH_64);
          }
          if (isTextBinaryFrame(opcode)) {
            __privateGet(this, _info).binaryType = opcode;
            __privateGet(this, _info).compressed = rsv1 !== 0;
          }
          __privateGet(this, _info).opcode = opcode;
          __privateGet(this, _info).masked = masked;
          __privateGet(this, _info).fin = fin;
          __privateGet(this, _info).fragmented = fragmented;
        } else if (__privateGet(this, _state3) === parserStates.PAYLOADLENGTH_16) {
          if (__privateGet(this, _byteOffset) < 2) {
            return callback();
          }
          const buffer = this.consume(2);
          __privateGet(this, _info).payloadLength = buffer.readUInt16BE(0);
          __privateSet(this, _state3, parserStates.READ_DATA);
        } else if (__privateGet(this, _state3) === parserStates.PAYLOADLENGTH_64) {
          if (__privateGet(this, _byteOffset) < 8) {
            return callback();
          }
          const buffer = this.consume(8);
          const upper = buffer.readUInt32BE(0);
          if (upper > 2 ** 31 - 1) {
            failWebsocketConnection(__privateGet(this, _handler9), 1009, "Received payload length > 2^31 bytes.");
            return;
          }
          const lower = buffer.readUInt32BE(4);
          __privateGet(this, _info).payloadLength = (upper << 8) + lower;
          __privateSet(this, _state3, parserStates.READ_DATA);
        } else if (__privateGet(this, _state3) === parserStates.READ_DATA) {
          if (__privateGet(this, _byteOffset) < __privateGet(this, _info).payloadLength) {
            return callback();
          }
          const body2 = this.consume(__privateGet(this, _info).payloadLength);
          if (isControlFrame(__privateGet(this, _info).opcode)) {
            __privateSet(this, _loop, this.parseControlFrame(body2));
            __privateSet(this, _state3, parserStates.INFO);
          } else {
            if (!__privateGet(this, _info).compressed) {
              this.writeFragments(body2);
              if (!__privateGet(this, _info).fragmented && __privateGet(this, _info).fin) {
                websocketMessageReceived(__privateGet(this, _handler9), __privateGet(this, _info).binaryType, this.consumeFragments());
              }
              __privateSet(this, _state3, parserStates.INFO);
            } else {
              __privateGet(this, _extensions).get("permessage-deflate").decompress(body2, __privateGet(this, _info).fin, (error, data) => {
                if (error) {
                  failWebsocketConnection(__privateGet(this, _handler9), 1007, error.message);
                  return;
                }
                this.writeFragments(data);
                if (!__privateGet(this, _info).fin) {
                  __privateSet(this, _state3, parserStates.INFO);
                  __privateSet(this, _loop, true);
                  this.run(callback);
                  return;
                }
                websocketMessageReceived(__privateGet(this, _handler9), __privateGet(this, _info).binaryType, this.consumeFragments());
                __privateSet(this, _loop, true);
                __privateSet(this, _state3, parserStates.INFO);
                this.run(callback);
              });
              __privateSet(this, _loop, false);
              break;
            }
          }
        }
      }
    }
    /**
     * Take n bytes from the buffered Buffers
     * @param {number} n
     * @returns {Buffer}
     */
    consume(n) {
      if (n > __privateGet(this, _byteOffset)) {
        throw new Error("Called consume() before buffers satiated.");
      } else if (n === 0) {
        return emptyBuffer;
      }
      __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) - n);
      const first = __privateGet(this, _buffers)[0];
      if (first.length > n) {
        __privateGet(this, _buffers)[0] = first.subarray(n, first.length);
        return first.subarray(0, n);
      } else if (first.length === n) {
        return __privateGet(this, _buffers).shift();
      } else {
        let offset = 0;
        const buffer = Buffer.allocUnsafeSlow(n);
        while (offset !== n) {
          const next = __privateGet(this, _buffers)[0];
          const length = next.length;
          if (length + offset === n) {
            buffer.set(__privateGet(this, _buffers).shift(), offset);
            break;
          } else if (length + offset > n) {
            buffer.set(next.subarray(0, n - offset), offset);
            __privateGet(this, _buffers)[0] = next.subarray(n - offset);
            break;
          } else {
            buffer.set(__privateGet(this, _buffers).shift(), offset);
            offset += length;
          }
        }
        return buffer;
      }
    }
    writeFragments(fragment) {
      __privateSet(this, _fragmentsBytes, __privateGet(this, _fragmentsBytes) + fragment.length);
      __privateGet(this, _fragments).push(fragment);
    }
    consumeFragments() {
      const fragments = __privateGet(this, _fragments);
      if (fragments.length === 1) {
        __privateSet(this, _fragmentsBytes, 0);
        return fragments.shift();
      }
      let offset = 0;
      const output = Buffer.allocUnsafeSlow(__privateGet(this, _fragmentsBytes));
      for (let i = 0; i < fragments.length; ++i) {
        const buffer = fragments[i];
        output.set(buffer, offset);
        offset += buffer.length;
      }
      __privateSet(this, _fragments, []);
      __privateSet(this, _fragmentsBytes, 0);
      return output;
    }
    parseCloseBody(data) {
      assert2(data.length !== 1);
      let code;
      if (data.length >= 2) {
        code = data.readUInt16BE(0);
      }
      if (code !== void 0 && !isValidStatusCode(code)) {
        return { code: 1002, reason: "Invalid status code", error: true };
      }
      let reason = data.subarray(2);
      if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
        reason = reason.subarray(3);
      }
      try {
        reason = utf8Decode(reason);
      } catch {
        return { code: 1007, reason: "Invalid UTF-8", error: true };
      }
      return { code, reason, error: false };
    }
    /**
     * Parses control frames.
     * @param {Buffer} body
     */
    parseControlFrame(body2) {
      const { opcode, payloadLength } = __privateGet(this, _info);
      if (opcode === opcodes.CLOSE) {
        if (payloadLength === 1) {
          failWebsocketConnection(__privateGet(this, _handler9), 1002, "Received close frame with a 1-byte body.");
          return false;
        }
        __privateGet(this, _info).closeInfo = this.parseCloseBody(body2);
        if (__privateGet(this, _info).closeInfo.error) {
          const { code, reason } = __privateGet(this, _info).closeInfo;
          failWebsocketConnection(__privateGet(this, _handler9), code, reason);
          return false;
        }
        if (!__privateGet(this, _handler9).closeState.has(sentCloseFrameState.SENT) && !__privateGet(this, _handler9).closeState.has(sentCloseFrameState.RECEIVED)) {
          let body3 = emptyBuffer;
          if (__privateGet(this, _info).closeInfo.code) {
            body3 = Buffer.allocUnsafe(2);
            body3.writeUInt16BE(__privateGet(this, _info).closeInfo.code, 0);
          }
          const closeFrame = new WebsocketFrameSend(body3);
          __privateGet(this, _handler9).socket.write(closeFrame.createFrame(opcodes.CLOSE));
          __privateGet(this, _handler9).closeState.add(sentCloseFrameState.SENT);
        }
        __privateGet(this, _handler9).readyState = states.CLOSING;
        __privateGet(this, _handler9).closeState.add(sentCloseFrameState.RECEIVED);
        return false;
      } else if (opcode === opcodes.PING) {
        if (!__privateGet(this, _handler9).closeState.has(sentCloseFrameState.RECEIVED)) {
          const frame2 = new WebsocketFrameSend(body2);
          __privateGet(this, _handler9).socket.write(frame2.createFrame(opcodes.PONG));
          if (channels2.ping.hasSubscribers) {
            channels2.ping.publish({
              payload: body2
            });
          }
        }
      } else if (opcode === opcodes.PONG) {
        if (channels2.pong.hasSubscribers) {
          channels2.pong.publish({
            payload: body2
          });
        }
      }
      return true;
    }
    get closingInfo() {
      return __privateGet(this, _info).closeInfo;
    }
  }
  _buffers = new WeakMap();
  _fragmentsBytes = new WeakMap();
  _byteOffset = new WeakMap();
  _loop = new WeakMap();
  _state3 = new WeakMap();
  _info = new WeakMap();
  _fragments = new WeakMap();
  _extensions = new WeakMap();
  _handler9 = new WeakMap();
  receiver$1 = {
    ByteParser
  };
  return receiver$1;
}
var sender$1;
var hasRequiredSender$1;
function requireSender$1() {
  var _queue, _running, _socket, _SendQueue_instances, run_fn;
  if (hasRequiredSender$1) return sender$1;
  hasRequiredSender$1 = 1;
  const { WebsocketFrameSend } = requireFrame$1();
  const { opcodes, sendHints } = requireConstants$3();
  const FixedQueue4 = fixedQueue$1;
  class SendQueue {
    constructor(socket) {
      __privateAdd(this, _SendQueue_instances);
      /**
       * @type {FixedQueue}
       */
      __privateAdd(this, _queue, new FixedQueue4());
      /**
       * @type {boolean}
       */
      __privateAdd(this, _running, false);
      /** @type {import('node:net').Socket} */
      __privateAdd(this, _socket);
      __privateSet(this, _socket, socket);
    }
    add(item, cb, hint) {
      if (hint !== sendHints.blob) {
        if (!__privateGet(this, _running)) {
          if (hint === sendHints.text) {
            const { 0: head, 1: body2 } = WebsocketFrameSend.createFastTextFrame(item);
            __privateGet(this, _socket).cork();
            __privateGet(this, _socket).write(head);
            __privateGet(this, _socket).write(body2, cb);
            __privateGet(this, _socket).uncork();
          } else {
            __privateGet(this, _socket).write(createFrame(item, hint), cb);
          }
        } else {
          const node3 = {
            promise: null,
            callback: cb,
            frame: createFrame(item, hint)
          };
          __privateGet(this, _queue).push(node3);
        }
        return;
      }
      const node2 = {
        promise: item.arrayBuffer().then((ab) => {
          node2.promise = null;
          node2.frame = createFrame(ab, hint);
        }),
        callback: cb,
        frame: null
      };
      __privateGet(this, _queue).push(node2);
      if (!__privateGet(this, _running)) {
        __privateMethod(this, _SendQueue_instances, run_fn).call(this);
      }
    }
  }
  _queue = new WeakMap();
  _running = new WeakMap();
  _socket = new WeakMap();
  _SendQueue_instances = new WeakSet();
  run_fn = async function() {
    __privateSet(this, _running, true);
    const queue2 = __privateGet(this, _queue);
    while (!queue2.isEmpty()) {
      const node2 = queue2.shift();
      if (node2.promise !== null) {
        await node2.promise;
      }
      __privateGet(this, _socket).write(node2.frame, node2.callback);
      node2.callback = node2.frame = null;
    }
    __privateSet(this, _running, false);
  };
  function createFrame(data, hint) {
    return new WebsocketFrameSend(toBuffer2(data, hint)).createFrame(hint === sendHints.text ? opcodes.TEXT : opcodes.BINARY);
  }
  function toBuffer2(data, hint) {
    switch (hint) {
      case sendHints.text:
      case sendHints.typedArray:
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
      case sendHints.arrayBuffer:
      case sendHints.blob:
        return new Uint8Array(data);
    }
  }
  sender$1 = { SendQueue };
  return sender$1;
}
var websocket$1;
var hasRequiredWebsocket$1;
function requireWebsocket$1() {
  var _events, _bufferedAmount, _protocol, _extensions, _sendQueue, _handler9, _url, _binaryType, _parser, _WebSocket_instances, onConnectionEstablished_fn, onFail_fn, onMessage_fn, onParserDrain_fn, onSocketClose_fn;
  if (hasRequiredWebsocket$1) return websocket$1;
  hasRequiredWebsocket$1 = 1;
  const { webidl } = requireWebidl$1();
  const { URLSerializer } = requireDataUrl$1();
  const { environmentSettingsObject } = requireUtil$a();
  const { staticPropertyDescriptors, states, sentCloseFrameState, sendHints, opcodes } = requireConstants$3();
  const {
    isConnecting,
    isEstablished,
    isClosing,
    isValidSubprotocol,
    fireEvent,
    utf8Decode,
    toArrayBuffer,
    getURLRecord
  } = requireUtil$7();
  const { establishWebSocketConnection, closeWebSocketConnection, failWebsocketConnection } = requireConnection$1();
  const { ByteParser } = requireReceiver$1();
  const { kEnumerableProperty: kEnumerableProperty2 } = util$J;
  const { getGlobalDispatcher: getGlobalDispatcher2 } = global$3;
  const { types } = require$$0$2;
  const { ErrorEvent: ErrorEvent2, CloseEvent: CloseEvent2, createFastMessageEvent } = requireEvents$1();
  const { SendQueue } = requireSender$1();
  const { channels: channels2 } = diagnostics$1;
  const _WebSocket = class _WebSocket extends EventTarget {
    /**
     * @param {string} url
     * @param {string|string[]} protocols
     */
    constructor(url, protocols = []) {
      super();
      __privateAdd(this, _WebSocket_instances);
      __privateAdd(this, _events, {
        open: null,
        error: null,
        close: null,
        message: null
      });
      __privateAdd(this, _bufferedAmount, 0);
      __privateAdd(this, _protocol, "");
      __privateAdd(this, _extensions, "");
      /** @type {SendQueue} */
      __privateAdd(this, _sendQueue);
      /** @type {Handler} */
      __privateAdd(this, _handler9, {
        onConnectionEstablished: (response2, extensions) => __privateMethod(this, _WebSocket_instances, onConnectionEstablished_fn).call(this, response2, extensions),
        onFail: (code, reason) => __privateMethod(this, _WebSocket_instances, onFail_fn).call(this, code, reason),
        onMessage: (opcode, data) => __privateMethod(this, _WebSocket_instances, onMessage_fn).call(this, opcode, data),
        onParserError: (err) => failWebsocketConnection(__privateGet(this, _handler9), null, err.message),
        onParserDrain: () => __privateMethod(this, _WebSocket_instances, onParserDrain_fn).call(this),
        onSocketData: (chunk) => {
          if (!__privateGet(this, _parser).write(chunk)) {
            __privateGet(this, _handler9).socket.pause();
          }
        },
        onSocketError: (err) => {
          __privateGet(this, _handler9).readyState = states.CLOSING;
          if (channels2.socketError.hasSubscribers) {
            channels2.socketError.publish(err);
          }
          __privateGet(this, _handler9).socket.destroy();
        },
        onSocketClose: () => __privateMethod(this, _WebSocket_instances, onSocketClose_fn).call(this),
        readyState: states.CONNECTING,
        socket: null,
        closeState: /* @__PURE__ */ new Set(),
        controller: null,
        wasEverConnected: false
      });
      __privateAdd(this, _url);
      __privateAdd(this, _binaryType);
      /** @type {import('./receiver').ByteParser} */
      __privateAdd(this, _parser);
      webidl.util.markAsUncloneable(this);
      const prefix = "WebSocket constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols, prefix, "options");
      url = webidl.converters.USVString(url);
      protocols = options.protocols;
      const baseURL = environmentSettingsObject.settingsObject.baseUrl;
      const urlRecord = getURLRecord(url, baseURL);
      if (typeof protocols === "string") {
        protocols = [protocols];
      }
      if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
        throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
        throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      __privateSet(this, _url, new URL(urlRecord.href));
      const client2 = environmentSettingsObject.settingsObject;
      __privateGet(this, _handler9).controller = establishWebSocketConnection(
        urlRecord,
        protocols,
        client2,
        __privateGet(this, _handler9),
        options
      );
      __privateGet(this, _handler9).readyState = _WebSocket.CONNECTING;
      __privateSet(this, _binaryType, "blob");
    }
    /**
     * @see https://websockets.spec.whatwg.org/#dom-websocket-close
     * @param {number|undefined} code
     * @param {string|undefined} reason
     */
    close(code = void 0, reason = void 0) {
      webidl.brandCheck(this, _WebSocket);
      const prefix = "WebSocket.close";
      if (code !== void 0) {
        code = webidl.converters["unsigned short"](code, prefix, "code", { clamp: true });
      }
      if (reason !== void 0) {
        reason = webidl.converters.USVString(reason);
      }
      code ?? (code = null);
      reason ?? (reason = "");
      closeWebSocketConnection(__privateGet(this, _handler9), code, reason, true);
    }
    /**
     * @see https://websockets.spec.whatwg.org/#dom-websocket-send
     * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
     */
    send(data) {
      webidl.brandCheck(this, _WebSocket);
      const prefix = "WebSocket.send";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      data = webidl.converters.WebSocketSendData(data, prefix, "data");
      if (isConnecting(__privateGet(this, _handler9).readyState)) {
        throw new DOMException("Sent before connected.", "InvalidStateError");
      }
      if (!isEstablished(__privateGet(this, _handler9).readyState) || isClosing(__privateGet(this, _handler9).readyState)) {
        return;
      }
      if (typeof data === "string") {
        const buffer = Buffer.from(data);
        __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + buffer.byteLength);
        __privateGet(this, _sendQueue).add(buffer, () => {
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - buffer.byteLength);
        }, sendHints.text);
      } else if (types.isArrayBuffer(data)) {
        __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + data.byteLength);
        __privateGet(this, _sendQueue).add(data, () => {
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - data.byteLength);
        }, sendHints.arrayBuffer);
      } else if (ArrayBuffer.isView(data)) {
        __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + data.byteLength);
        __privateGet(this, _sendQueue).add(data, () => {
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - data.byteLength);
        }, sendHints.typedArray);
      } else if (webidl.is.Blob(data)) {
        __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + data.size);
        __privateGet(this, _sendQueue).add(data, () => {
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - data.size);
        }, sendHints.blob);
      }
    }
    get readyState() {
      webidl.brandCheck(this, _WebSocket);
      return __privateGet(this, _handler9).readyState;
    }
    get bufferedAmount() {
      webidl.brandCheck(this, _WebSocket);
      return __privateGet(this, _bufferedAmount);
    }
    get url() {
      webidl.brandCheck(this, _WebSocket);
      return URLSerializer(__privateGet(this, _url));
    }
    get extensions() {
      webidl.brandCheck(this, _WebSocket);
      return __privateGet(this, _extensions);
    }
    get protocol() {
      webidl.brandCheck(this, _WebSocket);
      return __privateGet(this, _protocol);
    }
    get onopen() {
      webidl.brandCheck(this, _WebSocket);
      return __privateGet(this, _events).open;
    }
    set onopen(fn) {
      webidl.brandCheck(this, _WebSocket);
      if (__privateGet(this, _events).open) {
        this.removeEventListener("open", __privateGet(this, _events).open);
      }
      if (typeof fn === "function") {
        __privateGet(this, _events).open = fn;
        this.addEventListener("open", fn);
      } else {
        __privateGet(this, _events).open = null;
      }
    }
    get onerror() {
      webidl.brandCheck(this, _WebSocket);
      return __privateGet(this, _events).error;
    }
    set onerror(fn) {
      webidl.brandCheck(this, _WebSocket);
      if (__privateGet(this, _events).error) {
        this.removeEventListener("error", __privateGet(this, _events).error);
      }
      if (typeof fn === "function") {
        __privateGet(this, _events).error = fn;
        this.addEventListener("error", fn);
      } else {
        __privateGet(this, _events).error = null;
      }
    }
    get onclose() {
      webidl.brandCheck(this, _WebSocket);
      return __privateGet(this, _events).close;
    }
    set onclose(fn) {
      webidl.brandCheck(this, _WebSocket);
      if (__privateGet(this, _events).close) {
        this.removeEventListener("close", __privateGet(this, _events).close);
      }
      if (typeof fn === "function") {
        __privateGet(this, _events).close = fn;
        this.addEventListener("close", fn);
      } else {
        __privateGet(this, _events).close = null;
      }
    }
    get onmessage() {
      webidl.brandCheck(this, _WebSocket);
      return __privateGet(this, _events).message;
    }
    set onmessage(fn) {
      webidl.brandCheck(this, _WebSocket);
      if (__privateGet(this, _events).message) {
        this.removeEventListener("message", __privateGet(this, _events).message);
      }
      if (typeof fn === "function") {
        __privateGet(this, _events).message = fn;
        this.addEventListener("message", fn);
      } else {
        __privateGet(this, _events).message = null;
      }
    }
    get binaryType() {
      webidl.brandCheck(this, _WebSocket);
      return __privateGet(this, _binaryType);
    }
    set binaryType(type) {
      webidl.brandCheck(this, _WebSocket);
      if (type !== "blob" && type !== "arraybuffer") {
        __privateSet(this, _binaryType, "blob");
      } else {
        __privateSet(this, _binaryType, type);
      }
    }
  };
  _events = new WeakMap();
  _bufferedAmount = new WeakMap();
  _protocol = new WeakMap();
  _extensions = new WeakMap();
  _sendQueue = new WeakMap();
  _handler9 = new WeakMap();
  _url = new WeakMap();
  _binaryType = new WeakMap();
  _parser = new WeakMap();
  _WebSocket_instances = new WeakSet();
  /**
   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
   */
  onConnectionEstablished_fn = function(response2, parsedExtensions) {
    __privateGet(this, _handler9).socket = response2.socket;
    const parser = new ByteParser(__privateGet(this, _handler9), parsedExtensions);
    parser.on("drain", () => __privateGet(this, _handler9).onParserDrain());
    parser.on("error", (err) => __privateGet(this, _handler9).onParserError(err));
    __privateSet(this, _parser, parser);
    __privateSet(this, _sendQueue, new SendQueue(response2.socket));
    __privateGet(this, _handler9).readyState = states.OPEN;
    const extensions = response2.headersList.get("sec-websocket-extensions");
    if (extensions !== null) {
      __privateSet(this, _extensions, extensions);
    }
    const protocol = response2.headersList.get("sec-websocket-protocol");
    if (protocol !== null) {
      __privateSet(this, _protocol, protocol);
    }
    fireEvent("open", this);
  };
  onFail_fn = function(code, reason) {
    if (reason) {
      fireEvent("error", this, (type, init) => new ErrorEvent2(type, init), {
        error: new Error(reason),
        message: reason
      });
    }
    if (!__privateGet(this, _handler9).wasEverConnected) {
      __privateGet(this, _handler9).readyState = states.CLOSED;
      fireEvent("close", this, (type, init) => new CloseEvent2(type, init), {
        wasClean: false,
        code,
        reason
      });
    }
  };
  onMessage_fn = function(type, data) {
    if (__privateGet(this, _handler9).readyState !== states.OPEN) {
      return;
    }
    let dataForEvent;
    if (type === opcodes.TEXT) {
      try {
        dataForEvent = utf8Decode(data);
      } catch {
        failWebsocketConnection(__privateGet(this, _handler9), 1007, "Received invalid UTF-8 in text frame.");
        return;
      }
    } else if (type === opcodes.BINARY) {
      if (__privateGet(this, _binaryType) === "blob") {
        dataForEvent = new Blob([data]);
      } else {
        dataForEvent = toArrayBuffer(data);
      }
    }
    fireEvent("message", this, createFastMessageEvent, {
      origin: __privateGet(this, _url).origin,
      data: dataForEvent
    });
  };
  onParserDrain_fn = function() {
    __privateGet(this, _handler9).socket.resume();
  };
  /**
   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4
   */
  onSocketClose_fn = function() {
    const wasClean = __privateGet(this, _handler9).closeState.has(sentCloseFrameState.SENT) && __privateGet(this, _handler9).closeState.has(sentCloseFrameState.RECEIVED);
    let code = 1005;
    let reason = "";
    const result = __privateGet(this, _parser).closingInfo;
    if (result && !result.error) {
      code = result.code ?? 1005;
      reason = result.reason;
    } else if (!__privateGet(this, _handler9).closeState.has(sentCloseFrameState.RECEIVED)) {
      code = 1006;
    }
    __privateGet(this, _handler9).readyState = states.CLOSED;
    fireEvent("close", this, (type, init) => new CloseEvent2(type, init), {
      wasClean,
      code,
      reason
    });
    if (channels2.close.hasSubscribers) {
      channels2.close.publish({
        websocket: this,
        code,
        reason
      });
    }
  };
  let WebSocket = _WebSocket;
  WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
  WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
  WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
  WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
  Object.defineProperties(WebSocket.prototype, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors,
    url: kEnumerableProperty2,
    readyState: kEnumerableProperty2,
    bufferedAmount: kEnumerableProperty2,
    onopen: kEnumerableProperty2,
    onerror: kEnumerableProperty2,
    onclose: kEnumerableProperty2,
    close: kEnumerableProperty2,
    onmessage: kEnumerableProperty2,
    binaryType: kEnumerableProperty2,
    send: kEnumerableProperty2,
    extensions: kEnumerableProperty2,
    protocol: kEnumerableProperty2,
    [Symbol.toStringTag]: {
      value: "WebSocket",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  Object.defineProperties(WebSocket, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors
  });
  webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(
    webidl.converters.DOMString
  );
  webidl.converters["DOMString or sequence<DOMString>"] = function(V, prefix, argument) {
    if (webidl.util.Type(V) === webidl.util.Types.OBJECT && Symbol.iterator in V) {
      return webidl.converters["sequence<DOMString>"](V);
    }
    return webidl.converters.DOMString(V, prefix, argument);
  };
  webidl.converters.WebSocketInit = webidl.dictionaryConverter([
    {
      key: "protocols",
      converter: webidl.converters["DOMString or sequence<DOMString>"],
      defaultValue: () => new Array(0)
    },
    {
      key: "dispatcher",
      converter: webidl.converters.any,
      defaultValue: () => getGlobalDispatcher2()
    },
    {
      key: "headers",
      converter: webidl.nullableConverter(webidl.converters.HeadersInit)
    }
  ]);
  webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
    if (webidl.util.Type(V) === webidl.util.Types.OBJECT && !(Symbol.iterator in V)) {
      return webidl.converters.WebSocketInit(V);
    }
    return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
  };
  webidl.converters.WebSocketSendData = function(V) {
    if (webidl.util.Type(V) === webidl.util.Types.OBJECT) {
      if (webidl.is.Blob(V)) {
        return V;
      }
      if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {
        return V;
      }
    }
    return webidl.converters.USVString(V);
  };
  websocket$1 = {
    WebSocket
  };
  return websocket$1;
}
var websocketerror;
var hasRequiredWebsocketerror;
function requireWebsocketerror() {
  var _closeCode, _reason3;
  if (hasRequiredWebsocketerror) return websocketerror;
  hasRequiredWebsocketerror = 1;
  const { webidl } = requireWebidl$1();
  const { validateCloseCodeAndReason } = requireUtil$7();
  const { kConstruct: kConstruct2 } = symbols$5;
  const { kEnumerableProperty: kEnumerableProperty2 } = util$J;
  const _WebSocketError = class _WebSocketError extends DOMException {
    constructor(message = "", init = void 0) {
      message = webidl.converters.DOMString(message, "WebSocketError", "message");
      super(message, "WebSocketError");
      __privateAdd(this, _closeCode);
      __privateAdd(this, _reason3);
      if (init === kConstruct2) {
        return;
      } else if (init !== null) {
        init = webidl.converters.WebSocketCloseInfo(init);
      }
      let code = init.closeCode ?? null;
      const reason = init.reason ?? "";
      validateCloseCodeAndReason(code, reason);
      if (reason.length !== 0 && code === null) {
        code = 1e3;
      }
      __privateSet(this, _closeCode, code);
      __privateSet(this, _reason3, reason);
    }
    get closeCode() {
      return __privateGet(this, _closeCode);
    }
    get reason() {
      return __privateGet(this, _reason3);
    }
    /**
     * @param {string} message
     * @param {number|null} code
     * @param {string} reason
     */
    static createUnvalidatedWebSocketError(message, code, reason) {
      const error = new _WebSocketError(message, kConstruct2);
      __privateSet(error, _closeCode, code);
      __privateSet(error, _reason3, reason);
      return error;
    }
  };
  _closeCode = new WeakMap();
  _reason3 = new WeakMap();
  let WebSocketError = _WebSocketError;
  const { createUnvalidatedWebSocketError } = WebSocketError;
  delete WebSocketError.createUnvalidatedWebSocketError;
  Object.defineProperties(WebSocketError.prototype, {
    closeCode: kEnumerableProperty2,
    reason: kEnumerableProperty2,
    [Symbol.toStringTag]: {
      value: "WebSocketError",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  webidl.is.WebSocketError = webidl.util.MakeTypeAssertion(WebSocketError);
  websocketerror = { WebSocketError, createUnvalidatedWebSocketError };
  return websocketerror;
}
var websocketstream;
var hasRequiredWebsocketstream;
function requireWebsocketstream() {
  var _url, _openedPromise, _closedPromise, _readableStream, _readableStreamController, _writableStream, _handshakeAborted, _handler9, _parser, _WebSocketStream_instances, write_fn, onConnectionEstablished_fn, onMessage_fn, onSocketClose_fn, closeUsingReason_fn, cancel_fn;
  if (hasRequiredWebsocketstream) return websocketstream;
  hasRequiredWebsocketstream = 1;
  const { createDeferredPromise, environmentSettingsObject } = requireUtil$a();
  const { states, opcodes, sentCloseFrameState } = requireConstants$3();
  const { webidl } = requireWebidl$1();
  const { getURLRecord, isValidSubprotocol, isEstablished, utf8Decode } = requireUtil$7();
  const { establishWebSocketConnection, failWebsocketConnection, closeWebSocketConnection } = requireConnection$1();
  const { types } = require$$0$2;
  const { channels: channels2 } = diagnostics$1;
  const { WebsocketFrameSend } = requireFrame$1();
  const { ByteParser } = requireReceiver$1();
  const { WebSocketError, createUnvalidatedWebSocketError } = requireWebsocketerror();
  const { utf8DecodeBytes } = requireUtil$a();
  const { kEnumerableProperty: kEnumerableProperty2 } = util$J;
  let emittedExperimentalWarning = false;
  class WebSocketStream {
    constructor(url, options = void 0) {
      __privateAdd(this, _WebSocketStream_instances);
      // Each WebSocketStream object has an associated url , which is a URL record .
      /** @type {URL} */
      __privateAdd(this, _url);
      // Each WebSocketStream object has an associated opened promise , which is a promise.
      /** @type {ReturnType<typeof createDeferredPromise>} */
      __privateAdd(this, _openedPromise);
      // Each WebSocketStream object has an associated closed promise , which is a promise.
      /** @type {ReturnType<typeof createDeferredPromise>} */
      __privateAdd(this, _closedPromise);
      // Each WebSocketStream object has an associated readable stream , which is a ReadableStream .
      /** @type {ReadableStream} */
      __privateAdd(this, _readableStream);
      /** @type {ReadableStreamDefaultController} */
      __privateAdd(this, _readableStreamController);
      // Each WebSocketStream object has an associated writable stream , which is a WritableStream .
      /** @type {WritableStream} */
      __privateAdd(this, _writableStream);
      // Each WebSocketStream object has an associated boolean handshake aborted , which is initially false.
      __privateAdd(this, _handshakeAborted, false);
      /** @type {import('../websocket').Handler} */
      __privateAdd(this, _handler9, {
        // https://whatpr.org/websockets/48/7b748d3...d5570f3.html#feedback-to-websocket-stream-from-the-protocol
        onConnectionEstablished: (response2, extensions) => __privateMethod(this, _WebSocketStream_instances, onConnectionEstablished_fn).call(this, response2, extensions),
        onFail: (_code, _reason3) => {
        },
        onMessage: (opcode, data) => __privateMethod(this, _WebSocketStream_instances, onMessage_fn).call(this, opcode, data),
        onParserError: (err) => failWebsocketConnection(__privateGet(this, _handler9), null, err.message),
        onParserDrain: () => __privateGet(this, _handler9).socket.resume(),
        onSocketData: (chunk) => {
          if (!__privateGet(this, _parser).write(chunk)) {
            __privateGet(this, _handler9).socket.pause();
          }
        },
        onSocketError: (err) => {
          __privateGet(this, _handler9).readyState = states.CLOSING;
          if (channels2.socketError.hasSubscribers) {
            channels2.socketError.publish(err);
          }
          __privateGet(this, _handler9).socket.destroy();
        },
        onSocketClose: () => __privateMethod(this, _WebSocketStream_instances, onSocketClose_fn).call(this),
        readyState: states.CONNECTING,
        socket: null,
        closeState: /* @__PURE__ */ new Set(),
        controller: null,
        wasEverConnected: false
      });
      /** @type {import('../receiver').ByteParser} */
      __privateAdd(this, _parser);
      if (!emittedExperimentalWarning) {
        process.emitWarning("WebSocketStream is experimental! Expect it to change at any time.", {
          code: "UNDICI-WSS"
        });
        emittedExperimentalWarning = true;
      }
      webidl.argumentLengthCheck(arguments, 1, "WebSocket");
      url = webidl.converters.USVString(url);
      if (options !== null) {
        options = webidl.converters.WebSocketStreamOptions(options);
      }
      const baseURL = environmentSettingsObject.settingsObject.baseUrl;
      const urlRecord = getURLRecord(url, baseURL);
      const protocols = options.protocols;
      if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
        throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
        throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      __privateSet(this, _url, urlRecord.toString());
      __privateSet(this, _openedPromise, createDeferredPromise());
      __privateSet(this, _closedPromise, createDeferredPromise());
      if (options.signal != null) {
        const signal = options.signal;
        if (signal.aborted) {
          __privateGet(this, _openedPromise).reject(signal.reason);
          __privateGet(this, _closedPromise).reject(signal.reason);
          return;
        }
        signal.addEventListener("abort", () => {
          if (!isEstablished(__privateGet(this, _handler9).readyState)) {
            failWebsocketConnection(__privateGet(this, _handler9));
            __privateGet(this, _handler9).readyState = states.CLOSING;
            __privateGet(this, _openedPromise).reject(signal.reason);
            __privateGet(this, _closedPromise).reject(signal.reason);
            __privateSet(this, _handshakeAborted, true);
          }
        }, { once: true });
      }
      const client2 = environmentSettingsObject.settingsObject;
      __privateGet(this, _handler9).controller = establishWebSocketConnection(
        urlRecord,
        protocols,
        client2,
        __privateGet(this, _handler9),
        options
      );
    }
    // The url getter steps are to return this 's url , serialized .
    get url() {
      return __privateGet(this, _url).toString();
    }
    // The opened getter steps are to return this 's opened promise .
    get opened() {
      return __privateGet(this, _openedPromise).promise;
    }
    // The closed getter steps are to return this 's closed promise .
    get closed() {
      return __privateGet(this, _closedPromise).promise;
    }
    // The close( closeInfo ) method steps are:
    close(closeInfo = void 0) {
      if (closeInfo !== null) {
        closeInfo = webidl.converters.WebSocketCloseInfo(closeInfo);
      }
      const code = closeInfo.closeCode ?? null;
      const reason = closeInfo.reason;
      closeWebSocketConnection(__privateGet(this, _handler9), code, reason, true);
    }
  }
  _url = new WeakMap();
  _openedPromise = new WeakMap();
  _closedPromise = new WeakMap();
  _readableStream = new WeakMap();
  _readableStreamController = new WeakMap();
  _writableStream = new WeakMap();
  _handshakeAborted = new WeakMap();
  _handler9 = new WeakMap();
  _parser = new WeakMap();
  _WebSocketStream_instances = new WeakSet();
  write_fn = function(chunk) {
    const promise = createDeferredPromise();
    let data = null;
    let opcode = null;
    if (ArrayBuffer.isView(chunk) || types.isArrayBuffer(chunk)) {
      data = new Uint8Array(ArrayBuffer.isView(chunk) ? new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength) : chunk);
      opcode = opcodes.BINARY;
    } else {
      let string;
      try {
        string = webidl.converters.DOMString(chunk);
      } catch (e) {
        promise.reject(e);
        return;
      }
      data = new TextEncoder().encode(string);
      opcode = opcodes.TEXT;
    }
    if (!__privateGet(this, _handler9).closeState.has(sentCloseFrameState.SENT) && !__privateGet(this, _handler9).closeState.has(sentCloseFrameState.RECEIVED)) {
      const frame2 = new WebsocketFrameSend(data);
      __privateGet(this, _handler9).socket.write(frame2.createFrame(opcode), () => {
        promise.resolve(void 0);
      });
    }
    return promise;
  };
  /** @type {import('../websocket').Handler['onConnectionEstablished']} */
  onConnectionEstablished_fn = function(response2, parsedExtensions) {
    __privateGet(this, _handler9).socket = response2.socket;
    const parser = new ByteParser(__privateGet(this, _handler9), parsedExtensions);
    parser.on("drain", () => __privateGet(this, _handler9).onParserDrain());
    parser.on("error", (err) => __privateGet(this, _handler9).onParserError(err));
    __privateSet(this, _parser, parser);
    __privateGet(this, _handler9).readyState = states.OPEN;
    const extensions = parsedExtensions ?? "";
    const protocol = response2.headersList.get("sec-websocket-protocol") ?? "";
    const readable2 = new ReadableStream({
      start: (controller) => {
        __privateSet(this, _readableStreamController, controller);
      },
      pull(controller) {
        let chunk;
        while (controller.desiredSize > 0 && (chunk = response2.socket.read()) !== null) {
          controller.enqueue(chunk);
        }
      },
      cancel: (reason) => __privateMethod(this, _WebSocketStream_instances, cancel_fn).call(this, reason)
    });
    const writable = new WritableStream({
      write: (chunk) => __privateMethod(this, _WebSocketStream_instances, write_fn).call(this, chunk),
      close: () => closeWebSocketConnection(__privateGet(this, _handler9), null, null),
      abort: (reason) => __privateMethod(this, _WebSocketStream_instances, closeUsingReason_fn).call(this, reason)
    });
    __privateSet(this, _readableStream, readable2);
    __privateSet(this, _writableStream, writable);
    __privateGet(this, _openedPromise).resolve({
      extensions,
      protocol,
      readable: readable2,
      writable
    });
  };
  /** @type {import('../websocket').Handler['onMessage']} */
  onMessage_fn = function(type, data) {
    if (__privateGet(this, _handler9).readyState !== states.OPEN) {
      return;
    }
    let chunk;
    if (type === opcodes.TEXT) {
      try {
        chunk = utf8Decode(data);
      } catch {
        failWebsocketConnection(__privateGet(this, _handler9), "Received invalid UTF-8 in text frame.");
        return;
      }
    } else if (type === opcodes.BINARY) {
      chunk = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    }
    __privateGet(this, _readableStreamController).enqueue(chunk);
  };
  /** @type {import('../websocket').Handler['onSocketClose']} */
  onSocketClose_fn = function() {
    const wasClean = __privateGet(this, _handler9).closeState.has(sentCloseFrameState.SENT) && __privateGet(this, _handler9).closeState.has(sentCloseFrameState.RECEIVED);
    __privateGet(this, _handler9).readyState = states.CLOSED;
    if (__privateGet(this, _handshakeAborted)) {
      return;
    }
    if (!__privateGet(this, _handler9).wasEverConnected) {
      __privateGet(this, _openedPromise).reject(new WebSocketError("Socket never opened"));
    }
    const result = __privateGet(this, _parser).closingInfo;
    let code = (result == null ? void 0 : result.code) ?? 1005;
    if (!__privateGet(this, _handler9).closeState.has(sentCloseFrameState.SENT) && !__privateGet(this, _handler9).closeState.has(sentCloseFrameState.RECEIVED)) {
      code = 1006;
    }
    const reason = (result == null ? void 0 : result.reason) == null ? "" : utf8DecodeBytes(Buffer.from(result.reason));
    if (wasClean) {
      __privateGet(this, _readableStream).cancel().catch(() => {
      });
      if (!__privateGet(this, _writableStream).locked) {
        __privateGet(this, _writableStream).abort(new DOMException("A closed WebSocketStream cannot be written to", "InvalidStateError"));
      }
      __privateGet(this, _closedPromise).resolve({
        closeCode: code,
        reason
      });
    } else {
      const error = createUnvalidatedWebSocketError("unclean close", code, reason);
      __privateGet(this, _readableStreamController).error(error);
      __privateGet(this, _writableStream).abort(error);
      __privateGet(this, _closedPromise).reject(error);
    }
  };
  closeUsingReason_fn = function(reason) {
    let code = null;
    let reasonString = "";
    if (webidl.is.WebSocketError(reason)) {
      code = reason.closeCode;
      reasonString = reason.reason;
    }
    closeWebSocketConnection(__privateGet(this, _handler9), code, reasonString);
  };
  //  To cancel a WebSocketStream stream given reason , close using reason giving stream and reason .
  cancel_fn = function(reason) {
    __privateMethod(this, _WebSocketStream_instances, closeUsingReason_fn).call(this, reason);
  };
  Object.defineProperties(WebSocketStream.prototype, {
    url: kEnumerableProperty2,
    opened: kEnumerableProperty2,
    closed: kEnumerableProperty2,
    close: kEnumerableProperty2,
    [Symbol.toStringTag]: {
      value: "WebSocketStream",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  webidl.converters.WebSocketStreamOptions = webidl.dictionaryConverter([
    {
      key: "protocols",
      converter: webidl.sequenceConverter(webidl.converters.USVString),
      defaultValue: () => []
    },
    {
      key: "signal",
      converter: webidl.nullableConverter(webidl.converters.AbortSignal),
      defaultValue: () => null
    }
  ]);
  webidl.converters.WebSocketCloseInfo = webidl.dictionaryConverter([
    {
      key: "closeCode",
      converter: (V) => webidl.converters["unsigned short"](V, { enforceRange: true })
    },
    {
      key: "reason",
      converter: webidl.converters.USVString,
      defaultValue: () => ""
    }
  ]);
  websocketstream = { WebSocketStream };
  return websocketstream;
}
var util$o;
var hasRequiredUtil$6;
function requireUtil$6() {
  if (hasRequiredUtil$6) return util$o;
  hasRequiredUtil$6 = 1;
  function isValidLastEventId(value) {
    return value.indexOf("\0") === -1;
  }
  function isASCIINumber(value) {
    if (value.length === 0) return false;
    for (let i = 0; i < value.length; i++) {
      if (value.charCodeAt(i) < 48 || value.charCodeAt(i) > 57) return false;
    }
    return true;
  }
  function delay(ms2) {
    return new Promise((resolve2) => {
      setTimeout(resolve2, ms2).unref();
    });
  }
  util$o = {
    isValidLastEventId,
    isASCIINumber,
    delay
  };
  return util$o;
}
var eventsourceStream$1;
var hasRequiredEventsourceStream$1;
function requireEventsourceStream$1() {
  if (hasRequiredEventsourceStream$1) return eventsourceStream$1;
  hasRequiredEventsourceStream$1 = 1;
  const { Transform: Transform2 } = require$$0$4;
  const { isASCIINumber, isValidLastEventId } = requireUtil$6();
  const BOM = [239, 187, 191];
  const LF = 10;
  const CR = 13;
  const COLON = 58;
  const SPACE = 32;
  class EventSourceStream extends Transform2 {
    /**
     * @param {object} options
     * @param {boolean} [options.readableObjectMode]
     * @param {eventSourceSettings} [options.eventSourceSettings]
     * @param {(chunk: any, encoding?: BufferEncoding | undefined) => boolean} [options.push]
     */
    constructor(options = {}) {
      options.readableObjectMode = true;
      super(options);
      /**
       * @type {eventSourceSettings}
       */
      __publicField(this, "state");
      /**
       * Leading byte-order-mark check.
       * @type {boolean}
       */
      __publicField(this, "checkBOM", true);
      /**
       * @type {boolean}
       */
      __publicField(this, "crlfCheck", false);
      /**
       * @type {boolean}
       */
      __publicField(this, "eventEndCheck", false);
      /**
       * @type {Buffer|null}
       */
      __publicField(this, "buffer", null);
      __publicField(this, "pos", 0);
      __publicField(this, "event", {
        data: void 0,
        event: void 0,
        id: void 0,
        retry: void 0
      });
      this.state = options.eventSourceSettings || {};
      if (options.push) {
        this.push = options.push;
      }
    }
    /**
     * @param {Buffer} chunk
     * @param {string} _encoding
     * @param {Function} callback
     * @returns {void}
     */
    _transform(chunk, _encoding, callback) {
      if (chunk.length === 0) {
        callback();
        return;
      }
      if (this.buffer) {
        this.buffer = Buffer.concat([this.buffer, chunk]);
      } else {
        this.buffer = chunk;
      }
      if (this.checkBOM) {
        switch (this.buffer.length) {
          case 1:
            if (this.buffer[0] === BOM[0]) {
              callback();
              return;
            }
            this.checkBOM = false;
            callback();
            return;
          case 2:
            if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1]) {
              callback();
              return;
            }
            this.checkBOM = false;
            break;
          case 3:
            if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
              this.buffer = Buffer.alloc(0);
              this.checkBOM = false;
              callback();
              return;
            }
            this.checkBOM = false;
            break;
          default:
            if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
              this.buffer = this.buffer.subarray(3);
            }
            this.checkBOM = false;
            break;
        }
      }
      while (this.pos < this.buffer.length) {
        if (this.eventEndCheck) {
          if (this.crlfCheck) {
            if (this.buffer[this.pos] === LF) {
              this.buffer = this.buffer.subarray(this.pos + 1);
              this.pos = 0;
              this.crlfCheck = false;
              continue;
            }
            this.crlfCheck = false;
          }
          if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
            if (this.buffer[this.pos] === CR) {
              this.crlfCheck = true;
            }
            this.buffer = this.buffer.subarray(this.pos + 1);
            this.pos = 0;
            if (this.event.data !== void 0 || this.event.event || this.event.id || this.event.retry) {
              this.processEvent(this.event);
            }
            this.clearEvent();
            continue;
          }
          this.eventEndCheck = false;
          continue;
        }
        if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
          if (this.buffer[this.pos] === CR) {
            this.crlfCheck = true;
          }
          this.parseLine(this.buffer.subarray(0, this.pos), this.event);
          this.buffer = this.buffer.subarray(this.pos + 1);
          this.pos = 0;
          this.eventEndCheck = true;
          continue;
        }
        this.pos++;
      }
      callback();
    }
    /**
     * @param {Buffer} line
     * @param {EventSourceStreamEvent} event
     */
    parseLine(line, event) {
      if (line.length === 0) {
        return;
      }
      const colonPosition = line.indexOf(COLON);
      if (colonPosition === 0) {
        return;
      }
      let field = "";
      let value = "";
      if (colonPosition !== -1) {
        field = line.subarray(0, colonPosition).toString("utf8");
        let valueStart = colonPosition + 1;
        if (line[valueStart] === SPACE) {
          ++valueStart;
        }
        value = line.subarray(valueStart).toString("utf8");
      } else {
        field = line.toString("utf8");
        value = "";
      }
      switch (field) {
        case "data":
          if (event[field] === void 0) {
            event[field] = value;
          } else {
            event[field] += `
${value}`;
          }
          break;
        case "retry":
          if (isASCIINumber(value)) {
            event[field] = value;
          }
          break;
        case "id":
          if (isValidLastEventId(value)) {
            event[field] = value;
          }
          break;
        case "event":
          if (value.length > 0) {
            event[field] = value;
          }
          break;
      }
    }
    /**
     * @param {EventSourceStreamEvent} event
     */
    processEvent(event) {
      if (event.retry && isASCIINumber(event.retry)) {
        this.state.reconnectionTime = parseInt(event.retry, 10);
      }
      if (event.id && isValidLastEventId(event.id)) {
        this.state.lastEventId = event.id;
      }
      if (event.data !== void 0) {
        this.push({
          type: event.event || "message",
          options: {
            data: event.data,
            lastEventId: this.state.lastEventId,
            origin: this.state.origin
          }
        });
      }
    }
    clearEvent() {
      this.event = {
        data: void 0,
        event: void 0,
        id: void 0,
        retry: void 0
      };
    }
  }
  eventsourceStream$1 = {
    EventSourceStream
  };
  return eventsourceStream$1;
}
var eventsource$1;
var hasRequiredEventsource$1;
function requireEventsource$1() {
  var _events, _url, _withCredentials, _readyState, _request, _controller4, _dispatcher2, _state3, _EventSource_instances, connect_fn, reconnect_fn;
  if (hasRequiredEventsource$1) return eventsource$1;
  hasRequiredEventsource$1 = 1;
  const { pipeline: pipeline2 } = require$$0$4;
  const { fetching } = requireFetch$1();
  const { makeRequest } = requireRequest$1();
  const { webidl } = requireWebidl$1();
  const { EventSourceStream } = requireEventsourceStream$1();
  const { parseMIMEType: parseMIMEType2 } = requireDataUrl$1();
  const { createFastMessageEvent } = requireEvents$1();
  const { isNetworkError } = requireResponse$1();
  const { delay } = requireUtil$6();
  const { kEnumerableProperty: kEnumerableProperty2 } = util$J;
  const { environmentSettingsObject } = requireUtil$a();
  let experimentalWarned2 = false;
  const defaultReconnectionTime = 3e3;
  const CONNECTING = 0;
  const OPEN = 1;
  const CLOSED = 2;
  const ANONYMOUS = "anonymous";
  const USE_CREDENTIALS = "use-credentials";
  const _EventSource = class _EventSource extends EventTarget {
    /**
     * Creates a new EventSource object.
     * @param {string} url
     * @param {EventSourceInit} [eventSourceInitDict={}]
     * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface
     */
    constructor(url, eventSourceInitDict = {}) {
      super();
      __privateAdd(this, _EventSource_instances);
      __privateAdd(this, _events, {
        open: null,
        error: null,
        message: null
      });
      __privateAdd(this, _url);
      __privateAdd(this, _withCredentials, false);
      /**
       * @type {ReadyState}
       */
      __privateAdd(this, _readyState, CONNECTING);
      __privateAdd(this, _request, null);
      __privateAdd(this, _controller4, null);
      __privateAdd(this, _dispatcher2);
      /**
       * @type {import('./eventsource-stream').eventSourceSettings}
       */
      __privateAdd(this, _state3);
      webidl.util.markAsUncloneable(this);
      const prefix = "EventSource constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      if (!experimentalWarned2) {
        experimentalWarned2 = true;
        process.emitWarning("EventSource is experimental, expect them to change at any time.", {
          code: "UNDICI-ES"
        });
      }
      url = webidl.converters.USVString(url);
      eventSourceInitDict = webidl.converters.EventSourceInitDict(eventSourceInitDict, prefix, "eventSourceInitDict");
      __privateSet(this, _dispatcher2, eventSourceInitDict.dispatcher);
      __privateSet(this, _state3, {
        lastEventId: "",
        reconnectionTime: defaultReconnectionTime
      });
      const settings = environmentSettingsObject;
      let urlRecord;
      try {
        urlRecord = new URL(url, settings.settingsObject.baseUrl);
        __privateGet(this, _state3).origin = urlRecord.origin;
      } catch (e) {
        throw new DOMException(e, "SyntaxError");
      }
      __privateSet(this, _url, urlRecord.href);
      let corsAttributeState = ANONYMOUS;
      if (eventSourceInitDict.withCredentials === true) {
        corsAttributeState = USE_CREDENTIALS;
        __privateSet(this, _withCredentials, true);
      }
      const initRequest = {
        redirect: "follow",
        keepalive: true,
        // @see https://html.spec.whatwg.org/multipage/urls-and-fetching.html#cors-settings-attributes
        mode: "cors",
        credentials: corsAttributeState === "anonymous" ? "same-origin" : "omit",
        referrer: "no-referrer"
      };
      initRequest.client = environmentSettingsObject.settingsObject;
      initRequest.headersList = [["accept", { name: "accept", value: "text/event-stream" }]];
      initRequest.cache = "no-store";
      initRequest.initiator = "other";
      initRequest.urlList = [new URL(__privateGet(this, _url))];
      __privateSet(this, _request, makeRequest(initRequest));
      __privateMethod(this, _EventSource_instances, connect_fn).call(this);
    }
    /**
     * Returns the state of this EventSource object's connection. It can have the
     * values described below.
     * @returns {ReadyState}
     * @readonly
     */
    get readyState() {
      return __privateGet(this, _readyState);
    }
    /**
     * Returns the URL providing the event stream.
     * @readonly
     * @returns {string}
     */
    get url() {
      return __privateGet(this, _url);
    }
    /**
     * Returns a boolean indicating whether the EventSource object was
     * instantiated with CORS credentials set (true), or not (false, the default).
     */
    get withCredentials() {
      return __privateGet(this, _withCredentials);
    }
    /**
     * Closes the connection, if any, and sets the readyState attribute to
     * CLOSED.
     */
    close() {
      webidl.brandCheck(this, _EventSource);
      if (__privateGet(this, _readyState) === CLOSED) return;
      __privateSet(this, _readyState, CLOSED);
      __privateGet(this, _controller4).abort();
      __privateSet(this, _request, null);
    }
    get onopen() {
      return __privateGet(this, _events).open;
    }
    set onopen(fn) {
      if (__privateGet(this, _events).open) {
        this.removeEventListener("open", __privateGet(this, _events).open);
      }
      if (typeof fn === "function") {
        __privateGet(this, _events).open = fn;
        this.addEventListener("open", fn);
      } else {
        __privateGet(this, _events).open = null;
      }
    }
    get onmessage() {
      return __privateGet(this, _events).message;
    }
    set onmessage(fn) {
      if (__privateGet(this, _events).message) {
        this.removeEventListener("message", __privateGet(this, _events).message);
      }
      if (typeof fn === "function") {
        __privateGet(this, _events).message = fn;
        this.addEventListener("message", fn);
      } else {
        __privateGet(this, _events).message = null;
      }
    }
    get onerror() {
      return __privateGet(this, _events).error;
    }
    set onerror(fn) {
      if (__privateGet(this, _events).error) {
        this.removeEventListener("error", __privateGet(this, _events).error);
      }
      if (typeof fn === "function") {
        __privateGet(this, _events).error = fn;
        this.addEventListener("error", fn);
      } else {
        __privateGet(this, _events).error = null;
      }
    }
  };
  _events = new WeakMap();
  _url = new WeakMap();
  _withCredentials = new WeakMap();
  _readyState = new WeakMap();
  _request = new WeakMap();
  _controller4 = new WeakMap();
  _dispatcher2 = new WeakMap();
  _state3 = new WeakMap();
  _EventSource_instances = new WeakSet();
  connect_fn = function() {
    if (__privateGet(this, _readyState) === CLOSED) return;
    __privateSet(this, _readyState, CONNECTING);
    const fetchParams = {
      request: __privateGet(this, _request),
      dispatcher: __privateGet(this, _dispatcher2)
    };
    const processEventSourceEndOfBody = (response2) => {
      if (isNetworkError(response2)) {
        this.dispatchEvent(new Event("error"));
        this.close();
      }
      __privateMethod(this, _EventSource_instances, reconnect_fn).call(this);
    };
    fetchParams.processResponseEndOfBody = processEventSourceEndOfBody;
    fetchParams.processResponse = (response2) => {
      if (isNetworkError(response2)) {
        if (response2.aborted) {
          this.close();
          this.dispatchEvent(new Event("error"));
          return;
        } else {
          __privateMethod(this, _EventSource_instances, reconnect_fn).call(this);
          return;
        }
      }
      const contentType = response2.headersList.get("content-type", true);
      const mimeType = contentType !== null ? parseMIMEType2(contentType) : "failure";
      const contentTypeValid = mimeType !== "failure" && mimeType.essence === "text/event-stream";
      if (response2.status !== 200 || contentTypeValid === false) {
        this.close();
        this.dispatchEvent(new Event("error"));
        return;
      }
      __privateSet(this, _readyState, OPEN);
      this.dispatchEvent(new Event("open"));
      __privateGet(this, _state3).origin = response2.urlList[response2.urlList.length - 1].origin;
      const eventSourceStream = new EventSourceStream({
        eventSourceSettings: __privateGet(this, _state3),
        push: (event) => {
          this.dispatchEvent(createFastMessageEvent(
            event.type,
            event.options
          ));
        }
      });
      pipeline2(
        response2.body.stream,
        eventSourceStream,
        (error) => {
          if ((error == null ? void 0 : error.aborted) === false) {
            this.close();
            this.dispatchEvent(new Event("error"));
          }
        }
      );
    };
    __privateSet(this, _controller4, fetching(fetchParams));
  };
  reconnect_fn = async function() {
    if (__privateGet(this, _readyState) === CLOSED) return;
    __privateSet(this, _readyState, CONNECTING);
    this.dispatchEvent(new Event("error"));
    await delay(__privateGet(this, _state3).reconnectionTime);
    if (__privateGet(this, _readyState) !== CONNECTING) return;
    if (__privateGet(this, _state3).lastEventId.length) {
      __privateGet(this, _request).headersList.set("last-event-id", __privateGet(this, _state3).lastEventId, true);
    }
    __privateMethod(this, _EventSource_instances, connect_fn).call(this);
  };
  let EventSource2 = _EventSource;
  const constantsPropertyDescriptors = {
    CONNECTING: {
      __proto__: null,
      configurable: false,
      enumerable: true,
      value: CONNECTING,
      writable: false
    },
    OPEN: {
      __proto__: null,
      configurable: false,
      enumerable: true,
      value: OPEN,
      writable: false
    },
    CLOSED: {
      __proto__: null,
      configurable: false,
      enumerable: true,
      value: CLOSED,
      writable: false
    }
  };
  Object.defineProperties(EventSource2, constantsPropertyDescriptors);
  Object.defineProperties(EventSource2.prototype, constantsPropertyDescriptors);
  Object.defineProperties(EventSource2.prototype, {
    close: kEnumerableProperty2,
    onerror: kEnumerableProperty2,
    onmessage: kEnumerableProperty2,
    onopen: kEnumerableProperty2,
    readyState: kEnumerableProperty2,
    url: kEnumerableProperty2,
    withCredentials: kEnumerableProperty2
  });
  webidl.converters.EventSourceInitDict = webidl.dictionaryConverter([
    {
      key: "withCredentials",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "dispatcher",
      // undici only
      converter: webidl.converters.any
    }
  ]);
  eventsource$1 = {
    EventSource: EventSource2,
    defaultReconnectionTime
  };
  return eventsource$1;
}
undici$3.exports;
(function(module) {
  const Client4 = client$1;
  const Dispatcher4 = dispatcher$1;
  const Pool4 = pool$1;
  const BalancedPool4 = balancedPool$1;
  const Agent4 = agent$3;
  const ProxyAgent2 = proxyAgent$1;
  const EnvHttpProxyAgent2 = envHttpProxyAgent$1;
  const RetryAgent2 = retryAgent$1;
  const errors2 = errors$2;
  const util2 = util$J;
  const { InvalidArgumentError: InvalidArgumentError4 } = errors2;
  const api2 = api$2;
  const buildConnector2 = connect$6;
  const MockClient4 = mockClient$1;
  const { MockCallHistory: MockCallHistory3, MockCallHistoryLog: MockCallHistoryLog2 } = mockCallHistory;
  const MockAgent4 = mockAgent$1;
  const MockPool4 = mockPool$1;
  const mockErrors2 = mockErrors$2;
  const RetryHandler4 = retryHandler$1;
  const { getGlobalDispatcher: getGlobalDispatcher2, setGlobalDispatcher: setGlobalDispatcher2 } = global$3;
  const DecoratorHandler2 = decoratorHandler$1;
  const RedirectHandler4 = redirectHandler$1;
  Object.assign(Dispatcher4.prototype, api2);
  module.exports.Dispatcher = Dispatcher4;
  module.exports.Client = Client4;
  module.exports.Pool = Pool4;
  module.exports.BalancedPool = BalancedPool4;
  module.exports.Agent = Agent4;
  module.exports.ProxyAgent = ProxyAgent2;
  module.exports.EnvHttpProxyAgent = EnvHttpProxyAgent2;
  module.exports.RetryAgent = RetryAgent2;
  module.exports.RetryHandler = RetryHandler4;
  module.exports.DecoratorHandler = DecoratorHandler2;
  module.exports.RedirectHandler = RedirectHandler4;
  module.exports.interceptors = {
    redirect: redirect$1,
    responseError,
    retry: retry$1,
    dump: dump$1,
    dns: dns$1,
    cache: cache$3
  };
  module.exports.cacheStores = {
    MemoryCacheStore: memoryCacheStore
  };
  const SqliteCacheStore = sqliteCacheStore;
  module.exports.cacheStores.SqliteCacheStore = SqliteCacheStore;
  module.exports.buildConnector = buildConnector2;
  module.exports.errors = errors2;
  module.exports.util = {
    parseHeaders: util2.parseHeaders,
    headerNameToString: util2.headerNameToString
  };
  function makeDispatcher2(fn) {
    return (url, opts, handler) => {
      if (typeof opts === "function") {
        handler = opts;
        opts = null;
      }
      if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
        throw new InvalidArgumentError4("invalid url");
      }
      if (opts != null && typeof opts !== "object") {
        throw new InvalidArgumentError4("invalid opts");
      }
      if (opts && opts.path != null) {
        if (typeof opts.path !== "string") {
          throw new InvalidArgumentError4("invalid opts.path");
        }
        let path2 = opts.path;
        if (!opts.path.startsWith("/")) {
          path2 = `/${path2}`;
        }
        url = new URL(util2.parseOrigin(url).origin + path2);
      } else {
        if (!opts) {
          opts = typeof url === "object" ? url : {};
        }
        url = util2.parseURL(url);
      }
      const { agent: agent2, dispatcher: dispatcher2 = getGlobalDispatcher2() } = opts;
      if (agent2) {
        throw new InvalidArgumentError4("unsupported opts.agent. Did you mean opts.client?");
      }
      return fn.call(dispatcher2, {
        ...opts,
        origin: url.origin,
        path: url.search ? `${url.pathname}${url.search}` : url.pathname,
        method: opts.method || (opts.body ? "PUT" : "GET")
      }, handler);
    };
  }
  module.exports.setGlobalDispatcher = setGlobalDispatcher2;
  module.exports.getGlobalDispatcher = getGlobalDispatcher2;
  const fetchImpl2 = requireFetch$1().fetch;
  module.exports.fetch = async function fetch2(init, options = void 0) {
    try {
      return await fetchImpl2(init, options);
    } catch (err) {
      if (err && typeof err === "object") {
        Error.captureStackTrace(err);
      }
      throw err;
    }
  };
  module.exports.Headers = requireHeaders$1().Headers;
  module.exports.Response = requireResponse$1().Response;
  module.exports.Request = requireRequest$1().Request;
  module.exports.FormData = requireFormdata$1().FormData;
  const { setGlobalOrigin: setGlobalOrigin2, getGlobalOrigin: getGlobalOrigin2 } = requireGlobal$1();
  module.exports.setGlobalOrigin = setGlobalOrigin2;
  module.exports.getGlobalOrigin = getGlobalOrigin2;
  const { CacheStorage: CacheStorage2 } = requireCachestorage$1();
  const { kConstruct: kConstruct2 } = symbols$5;
  module.exports.caches = new CacheStorage2(kConstruct2);
  const { deleteCookie: deleteCookie2, getCookies: getCookies2, getSetCookies: getSetCookies2, setCookie: setCookie2, parseCookie } = requireCookies$1();
  module.exports.deleteCookie = deleteCookie2;
  module.exports.getCookies = getCookies2;
  module.exports.getSetCookies = getSetCookies2;
  module.exports.setCookie = setCookie2;
  module.exports.parseCookie = parseCookie;
  const { parseMIMEType: parseMIMEType2, serializeAMimeType: serializeAMimeType2 } = requireDataUrl$1();
  module.exports.parseMIMEType = parseMIMEType2;
  module.exports.serializeAMimeType = serializeAMimeType2;
  const { CloseEvent: CloseEvent2, ErrorEvent: ErrorEvent2, MessageEvent: MessageEvent2 } = requireEvents$1();
  module.exports.WebSocket = requireWebsocket$1().WebSocket;
  module.exports.CloseEvent = CloseEvent2;
  module.exports.ErrorEvent = ErrorEvent2;
  module.exports.MessageEvent = MessageEvent2;
  module.exports.WebSocketStream = requireWebsocketstream().WebSocketStream;
  module.exports.WebSocketError = requireWebsocketerror().WebSocketError;
  module.exports.request = makeDispatcher2(api2.request);
  module.exports.stream = makeDispatcher2(api2.stream);
  module.exports.pipeline = makeDispatcher2(api2.pipeline);
  module.exports.connect = makeDispatcher2(api2.connect);
  module.exports.upgrade = makeDispatcher2(api2.upgrade);
  module.exports.MockClient = MockClient4;
  module.exports.MockCallHistory = MockCallHistory3;
  module.exports.MockCallHistoryLog = MockCallHistoryLog2;
  module.exports.MockPool = MockPool4;
  module.exports.MockAgent = MockAgent4;
  module.exports.mockErrors = mockErrors2;
  const { EventSource: EventSource2 } = requireEventsource$1();
  module.exports.EventSource = EventSource2;
})(undici$3);
var undiciExports = undici$3.exports;
var agent$2 = {};
var dist$3 = {};
var src = { exports: {} };
var browser = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms;
}
var common;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy2;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy2() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common = setup;
  return common;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser.exports;
  hasRequiredBrowser = 1;
  (function(module, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = requireCommon()(exports);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  })(browser, browser.exports);
  return browser.exports;
}
var node = { exports: {} };
var hasFlag;
var hasRequiredHasFlag;
function requireHasFlag() {
  if (hasRequiredHasFlag) return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
  return hasFlag;
}
var supportsColor_1;
var hasRequiredSupportsColor;
function requireSupportsColor() {
  if (hasRequiredSupportsColor) return supportsColor_1;
  hasRequiredSupportsColor = 1;
  const os = require$$0$8;
  const tty = require$$1$7;
  const hasFlag2 = requireHasFlag();
  const { env } = process;
  let forceColor;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never")) {
    forceColor = 0;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
      return 3;
    }
    if (hasFlag2("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream2) {
    const level = supportsColor(stream2, stream2 && stream2.isTTY);
    return translateLevel(level);
  }
  supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
  return supportsColor_1;
}
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node.exports;
  hasRequiredNode = 1;
  (function(module, exports) {
    const tty = require$$1$7;
    const util2 = require$$1$8;
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = requireSupportsColor();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util2.formatWithOptions(exports.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module.exports = requireCommon()(exports);
    const { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  })(node, node.exports);
  return node.exports;
}
if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
  src.exports = requireBrowser();
} else {
  src.exports = requireNode();
}
var srcExports = src.exports;
var dist$2 = {};
var helpers = {};
var __createBinding$3 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault$3 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$3 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$3(result, mod, k);
  }
  __setModuleDefault$3(result, mod);
  return result;
};
Object.defineProperty(helpers, "__esModule", { value: true });
helpers.req = helpers.json = helpers.toBuffer = void 0;
const http$1 = __importStar$3(require$$0$9);
const https = __importStar$3(require$$1$9);
async function toBuffer(stream2) {
  let length = 0;
  const chunks = [];
  for await (const chunk of stream2) {
    length += chunk.length;
    chunks.push(chunk);
  }
  return Buffer.concat(chunks, length);
}
helpers.toBuffer = toBuffer;
async function json(stream2) {
  const buf = await toBuffer(stream2);
  const str = buf.toString("utf8");
  try {
    return JSON.parse(str);
  } catch (_err) {
    const err = _err;
    err.message += ` (input: ${str})`;
    throw err;
  }
}
helpers.json = json;
function req(url, opts = {}) {
  const href = typeof url === "string" ? url : url.href;
  const req2 = (href.startsWith("https:") ? https : http$1).request(url, opts);
  const promise = new Promise((resolve2, reject) => {
    req2.once("response", resolve2).once("error", reject).end();
  });
  req2.then = promise.then.bind(promise);
  return req2;
}
helpers.req = req;
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Agent = void 0;
  const net2 = __importStar2(require$$0$a);
  const http3 = __importStar2(require$$0$9);
  const https_12 = require$$1$9;
  __exportStar(helpers, exports);
  const INTERNAL = Symbol("AgentBaseInternalState");
  class Agent4 extends http3.Agent {
    constructor(opts) {
      super(opts);
      this[INTERNAL] = {};
    }
    /**
     * Determine whether this is an `http` or `https` request.
     */
    isSecureEndpoint(options) {
      if (options) {
        if (typeof options.secureEndpoint === "boolean") {
          return options.secureEndpoint;
        }
        if (typeof options.protocol === "string") {
          return options.protocol === "https:";
        }
      }
      const { stack } = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    // In order to support async signatures in `connect()` and Node's native
    // connection pooling in `http.Agent`, the array of sockets for each origin
    // has to be updated synchronously. This is so the length of the array is
    // accurate when `addRequest()` is next called. We achieve this by creating a
    // fake socket and adding it to `sockets[origin]` and incrementing
    // `totalSocketCount`.
    incrementSockets(name) {
      if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
        return null;
      }
      if (!this.sockets[name]) {
        this.sockets[name] = [];
      }
      const fakeSocket = new net2.Socket({ writable: false });
      this.sockets[name].push(fakeSocket);
      this.totalSocketCount++;
      return fakeSocket;
    }
    decrementSockets(name, socket) {
      if (!this.sockets[name] || socket === null) {
        return;
      }
      const sockets = this.sockets[name];
      const index = sockets.indexOf(socket);
      if (index !== -1) {
        sockets.splice(index, 1);
        this.totalSocketCount--;
        if (sockets.length === 0) {
          delete this.sockets[name];
        }
      }
    }
    // In order to properly update the socket pool, we need to call `getName()` on
    // the core `https.Agent` if it is a secureEndpoint.
    getName(options) {
      const secureEndpoint = typeof options.secureEndpoint === "boolean" ? options.secureEndpoint : this.isSecureEndpoint(options);
      if (secureEndpoint) {
        return https_12.Agent.prototype.getName.call(this, options);
      }
      return super.getName(options);
    }
    createSocket(req2, options, cb) {
      const connectOpts = {
        ...options,
        secureEndpoint: this.isSecureEndpoint(options)
      };
      const name = this.getName(connectOpts);
      const fakeSocket = this.incrementSockets(name);
      Promise.resolve().then(() => this.connect(req2, connectOpts)).then((socket) => {
        this.decrementSockets(name, fakeSocket);
        if (socket instanceof http3.Agent) {
          try {
            return socket.addRequest(req2, connectOpts);
          } catch (err) {
            return cb(err);
          }
        }
        this[INTERNAL].currentSocket = socket;
        super.createSocket(req2, options, cb);
      }, (err) => {
        this.decrementSockets(name, fakeSocket);
        cb(err);
      });
    }
    createConnection() {
      const socket = this[INTERNAL].currentSocket;
      this[INTERNAL].currentSocket = void 0;
      if (!socket) {
        throw new Error("No socket was returned in the `connect()` function");
      }
      return socket;
    }
    get defaultPort() {
      return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
    }
    set defaultPort(v) {
      if (this[INTERNAL]) {
        this[INTERNAL].defaultPort = v;
      }
    }
    get protocol() {
      return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
    }
    set protocol(v) {
      if (this[INTERNAL]) {
        this[INTERNAL].protocol = v;
      }
    }
  }
  exports.Agent = Agent4;
})(dist$2);
var parseProxyResponse$1 = {};
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(parseProxyResponse$1, "__esModule", { value: true });
parseProxyResponse$1.parseProxyResponse = void 0;
const debug_1$1 = __importDefault$4(srcExports);
const debug$1 = (0, debug_1$1.default)("https-proxy-agent:parse-proxy-response");
function parseProxyResponse(socket) {
  return new Promise((resolve2, reject) => {
    let buffersLength = 0;
    const buffers = [];
    function read() {
      const b = socket.read();
      if (b)
        ondata(b);
      else
        socket.once("readable", read);
    }
    function cleanup() {
      socket.removeListener("end", onend);
      socket.removeListener("error", onerror);
      socket.removeListener("readable", read);
    }
    function onend() {
      cleanup();
      debug$1("onend");
      reject(new Error("Proxy connection ended before receiving CONNECT response"));
    }
    function onerror(err) {
      cleanup();
      debug$1("onerror %o", err);
      reject(err);
    }
    function ondata(b) {
      buffers.push(b);
      buffersLength += b.length;
      const buffered = Buffer.concat(buffers, buffersLength);
      const endOfHeaders = buffered.indexOf("\r\n\r\n");
      if (endOfHeaders === -1) {
        debug$1("have not received end of HTTP headers yet...");
        read();
        return;
      }
      const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
      const firstLine = headerParts.shift();
      if (!firstLine) {
        socket.destroy();
        return reject(new Error("No header received from proxy CONNECT response"));
      }
      const firstLineParts = firstLine.split(" ");
      const statusCode = +firstLineParts[1];
      const statusText = firstLineParts.slice(2).join(" ");
      const headers2 = {};
      for (const header of headerParts) {
        if (!header)
          continue;
        const firstColon = header.indexOf(":");
        if (firstColon === -1) {
          socket.destroy();
          return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
        }
        const key = header.slice(0, firstColon).toLowerCase();
        const value = header.slice(firstColon + 1).trimStart();
        const current = headers2[key];
        if (typeof current === "string") {
          headers2[key] = [current, value];
        } else if (Array.isArray(current)) {
          current.push(value);
        } else {
          headers2[key] = value;
        }
      }
      debug$1("got proxy server response: %o %o", firstLine, headers2);
      cleanup();
      resolve2({
        connect: {
          statusCode,
          statusText,
          headers: headers2
        },
        buffered
      });
    }
    socket.on("error", onerror);
    socket.on("end", onend);
    read();
  });
}
parseProxyResponse$1.parseProxyResponse = parseProxyResponse;
var __createBinding$2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault$2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$2(result, mod, k);
  }
  __setModuleDefault$2(result, mod);
  return result;
};
var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(dist$3, "__esModule", { value: true });
dist$3.HttpsProxyAgent = void 0;
const net$3 = __importStar$2(require$$0$a);
const tls$1 = __importStar$2(require$$1$a);
const assert_1 = __importDefault$3(require$$2$2);
const debug_1 = __importDefault$3(srcExports);
const agent_base_1 = dist$2;
const url_1 = require$$5$2;
const parse_proxy_response_1 = parseProxyResponse$1;
const debug = (0, debug_1.default)("https-proxy-agent");
const setServernameFromNonIpHost = (options) => {
  if (options.servername === void 0 && options.host && !net$3.isIP(options.host)) {
    return {
      ...options,
      servername: options.host
    };
  }
  return options;
};
let HttpsProxyAgent$1 = class HttpsProxyAgent extends agent_base_1.Agent {
  constructor(proxy, opts) {
    super(opts);
    this.options = { path: void 0 };
    this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
    this.proxyHeaders = (opts == null ? void 0 : opts.headers) ?? {};
    debug("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
    const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
    const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
    this.connectOpts = {
      // Attempt to negotiate http/1.1 for proxy servers that support http/2
      ALPNProtocols: ["http/1.1"],
      ...opts ? omit(opts, "headers") : null,
      host,
      port
    };
  }
  /**
   * Called when the node-core HTTP client library is creating a
   * new HTTP request.
   */
  async connect(req2, opts) {
    const { proxy } = this;
    if (!opts.host) {
      throw new TypeError('No "host" provided');
    }
    let socket;
    if (proxy.protocol === "https:") {
      debug("Creating `tls.Socket`: %o", this.connectOpts);
      socket = tls$1.connect(setServernameFromNonIpHost(this.connectOpts));
    } else {
      debug("Creating `net.Socket`: %o", this.connectOpts);
      socket = net$3.connect(this.connectOpts);
    }
    const headers2 = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
    const host = net$3.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
    let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
    if (proxy.username || proxy.password) {
      const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
      headers2["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
    }
    headers2.Host = `${host}:${opts.port}`;
    if (!headers2["Proxy-Connection"]) {
      headers2["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
    }
    for (const name of Object.keys(headers2)) {
      payload += `${name}: ${headers2[name]}\r
`;
    }
    const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
    socket.write(`${payload}\r
`);
    const { connect: connect2, buffered } = await proxyResponsePromise;
    req2.emit("proxyConnect", connect2);
    this.emit("proxyConnect", connect2, req2);
    if (connect2.statusCode === 200) {
      req2.once("socket", resume$1);
      if (opts.secureEndpoint) {
        debug("Upgrading socket connection to TLS");
        return tls$1.connect({
          ...omit(setServernameFromNonIpHost(opts), "host", "path", "port"),
          socket
        });
      }
      return socket;
    }
    socket.destroy();
    const fakeSocket = new net$3.Socket({ writable: false });
    fakeSocket.readable = true;
    req2.once("socket", (s) => {
      debug("Replaying proxy buffer for failed request");
      (0, assert_1.default)(s.listenerCount("data") > 0);
      s.push(buffered);
      s.push(null);
    });
    return fakeSocket;
  }
};
HttpsProxyAgent$1.protocols = ["http", "https"];
dist$3.HttpsProxyAgent = HttpsProxyAgent$1;
function resume$1(socket) {
  socket.resume();
}
function omit(obj, ...keys) {
  const ret = {};
  let key;
  for (key in obj) {
    if (!keys.includes(key)) {
      ret[key] = obj[key];
    }
  }
  return ret;
}
var cookie$1 = {};
var memstore = {};
var pathMatch$1 = {};
Object.defineProperty(pathMatch$1, "__esModule", { value: true });
pathMatch$1.pathMatch = pathMatch;
function pathMatch(reqPath, cookiePath) {
  if (cookiePath === reqPath) {
    return true;
  }
  const idx = reqPath.indexOf(cookiePath);
  if (idx === 0) {
    if (cookiePath[cookiePath.length - 1] === "/") {
      return true;
    }
    if (reqPath.startsWith(cookiePath) && reqPath[cookiePath.length] === "/") {
      return true;
    }
  }
  return false;
}
var permuteDomain$1 = {};
var getPublicSuffix$2 = {};
function shareSameDomainSuffix(hostname, vhost) {
  if (hostname.endsWith(vhost)) {
    return hostname.length === vhost.length || hostname[hostname.length - vhost.length - 1] === ".";
  }
  return false;
}
function extractDomainWithSuffix(hostname, publicSuffix) {
  const publicSuffixIndex = hostname.length - publicSuffix.length - 2;
  const lastDotBeforeSuffixIndex = hostname.lastIndexOf(".", publicSuffixIndex);
  if (lastDotBeforeSuffixIndex === -1) {
    return hostname;
  }
  return hostname.slice(lastDotBeforeSuffixIndex + 1);
}
function getDomain$1(suffix, hostname, options) {
  if (options.validHosts !== null) {
    const validHosts = options.validHosts;
    for (const vhost of validHosts) {
      if (
        /*@__INLINE__*/
        shareSameDomainSuffix(hostname, vhost)
      ) {
        return vhost;
      }
    }
  }
  let numberOfLeadingDots = 0;
  if (hostname.startsWith(".")) {
    while (numberOfLeadingDots < hostname.length && hostname[numberOfLeadingDots] === ".") {
      numberOfLeadingDots += 1;
    }
  }
  if (suffix.length === hostname.length - numberOfLeadingDots) {
    return null;
  }
  return (
    /*@__INLINE__*/
    extractDomainWithSuffix(hostname, suffix)
  );
}
function getDomainWithoutSuffix$1(domain, suffix) {
  return domain.slice(0, -suffix.length - 1);
}
function extractHostname(url, urlIsValidHostname) {
  let start = 0;
  let end = url.length;
  let hasUpper = false;
  if (!urlIsValidHostname) {
    if (url.startsWith("data:")) {
      return null;
    }
    while (start < url.length && url.charCodeAt(start) <= 32) {
      start += 1;
    }
    while (end > start + 1 && url.charCodeAt(end - 1) <= 32) {
      end -= 1;
    }
    if (url.charCodeAt(start) === 47 && url.charCodeAt(start + 1) === 47) {
      start += 2;
    } else {
      const indexOfProtocol = url.indexOf(":/", start);
      if (indexOfProtocol !== -1) {
        const protocolSize = indexOfProtocol - start;
        const c0 = url.charCodeAt(start);
        const c1 = url.charCodeAt(start + 1);
        const c2 = url.charCodeAt(start + 2);
        const c3 = url.charCodeAt(start + 3);
        const c4 = url.charCodeAt(start + 4);
        if (protocolSize === 5 && c0 === 104 && c1 === 116 && c2 === 116 && c3 === 112 && c4 === 115) ;
        else if (protocolSize === 4 && c0 === 104 && c1 === 116 && c2 === 116 && c3 === 112) ;
        else if (protocolSize === 3 && c0 === 119 && c1 === 115 && c2 === 115) ;
        else if (protocolSize === 2 && c0 === 119 && c1 === 115) ;
        else {
          for (let i = start; i < indexOfProtocol; i += 1) {
            const lowerCaseCode = url.charCodeAt(i) | 32;
            if (!(lowerCaseCode >= 97 && lowerCaseCode <= 122 || // [a, z]
            lowerCaseCode >= 48 && lowerCaseCode <= 57 || // [0, 9]
            lowerCaseCode === 46 || // '.'
            lowerCaseCode === 45 || // '-'
            lowerCaseCode === 43)) {
              return null;
            }
          }
        }
        start = indexOfProtocol + 2;
        while (url.charCodeAt(start) === 47) {
          start += 1;
        }
      }
    }
    let indexOfIdentifier = -1;
    let indexOfClosingBracket = -1;
    let indexOfPort = -1;
    for (let i = start; i < end; i += 1) {
      const code = url.charCodeAt(i);
      if (code === 35 || // '#'
      code === 47 || // '/'
      code === 63) {
        end = i;
        break;
      } else if (code === 64) {
        indexOfIdentifier = i;
      } else if (code === 93) {
        indexOfClosingBracket = i;
      } else if (code === 58) {
        indexOfPort = i;
      } else if (code >= 65 && code <= 90) {
        hasUpper = true;
      }
    }
    if (indexOfIdentifier !== -1 && indexOfIdentifier > start && indexOfIdentifier < end) {
      start = indexOfIdentifier + 1;
    }
    if (url.charCodeAt(start) === 91) {
      if (indexOfClosingBracket !== -1) {
        return url.slice(start + 1, indexOfClosingBracket).toLowerCase();
      }
      return null;
    } else if (indexOfPort !== -1 && indexOfPort > start && indexOfPort < end) {
      end = indexOfPort;
    }
  }
  while (end > start + 1 && url.charCodeAt(end - 1) === 46) {
    end -= 1;
  }
  const hostname = start !== 0 || end !== url.length ? url.slice(start, end) : url;
  if (hasUpper) {
    return hostname.toLowerCase();
  }
  return hostname;
}
function isProbablyIpv4(hostname) {
  if (hostname.length < 7) {
    return false;
  }
  if (hostname.length > 15) {
    return false;
  }
  let numberOfDots = 0;
  for (let i = 0; i < hostname.length; i += 1) {
    const code = hostname.charCodeAt(i);
    if (code === 46) {
      numberOfDots += 1;
    } else if (code < 48 || code > 57) {
      return false;
    }
  }
  return numberOfDots === 3 && hostname.charCodeAt(0) !== 46 && hostname.charCodeAt(hostname.length - 1) !== 46;
}
function isProbablyIpv6(hostname) {
  if (hostname.length < 3) {
    return false;
  }
  let start = hostname.startsWith("[") ? 1 : 0;
  let end = hostname.length;
  if (hostname[end - 1] === "]") {
    end -= 1;
  }
  if (end - start > 39) {
    return false;
  }
  let hasColon = false;
  for (; start < end; start += 1) {
    const code = hostname.charCodeAt(start);
    if (code === 58) {
      hasColon = true;
    } else if (!(code >= 48 && code <= 57 || // 0-9
    code >= 97 && code <= 102 || // a-f
    code >= 65 && code <= 90)) {
      return false;
    }
  }
  return hasColon;
}
function isIp(hostname) {
  return isProbablyIpv6(hostname) || isProbablyIpv4(hostname);
}
function isValidAscii(code) {
  return code >= 97 && code <= 122 || code >= 48 && code <= 57 || code > 127;
}
function isValidHostname(hostname) {
  if (hostname.length > 255) {
    return false;
  }
  if (hostname.length === 0) {
    return false;
  }
  if (
    /*@__INLINE__*/
    !isValidAscii(hostname.charCodeAt(0)) && hostname.charCodeAt(0) !== 46 && // '.' (dot)
    hostname.charCodeAt(0) !== 95
  ) {
    return false;
  }
  let lastDotIndex = -1;
  let lastCharCode = -1;
  const len = hostname.length;
  for (let i = 0; i < len; i += 1) {
    const code = hostname.charCodeAt(i);
    if (code === 46) {
      if (
        // Check that previous label is < 63 bytes long (64 = 63 + '.')
        i - lastDotIndex > 64 || // Check that previous character was not already a '.'
        lastCharCode === 46 || // Check that the previous label does not end with a '-' (dash)
        lastCharCode === 45 || // Check that the previous label does not end with a '_' (underscore)
        lastCharCode === 95
      ) {
        return false;
      }
      lastDotIndex = i;
    } else if (!/*@__INLINE__*/
    (isValidAscii(code) || code === 45 || code === 95)) {
      return false;
    }
    lastCharCode = code;
  }
  return (
    // Check that last label is shorter than 63 chars
    len - lastDotIndex - 1 <= 63 && // Check that the last character is an allowed trailing label character.
    // Since we already checked that the char is a valid hostname character,
    // we only need to check that it's different from '-'.
    lastCharCode !== 45
  );
}
function setDefaultsImpl({ allowIcannDomains = true, allowPrivateDomains = false, detectIp = true, extractHostname: extractHostname2 = true, mixedInputs = true, validHosts = null, validateHostname = true }) {
  return {
    allowIcannDomains,
    allowPrivateDomains,
    detectIp,
    extractHostname: extractHostname2,
    mixedInputs,
    validHosts,
    validateHostname
  };
}
const DEFAULT_OPTIONS = (
  /*@__INLINE__*/
  setDefaultsImpl({})
);
function setDefaults(options) {
  if (options === void 0) {
    return DEFAULT_OPTIONS;
  }
  return (
    /*@__INLINE__*/
    setDefaultsImpl(options)
  );
}
function getSubdomain$1(hostname, domain) {
  if (domain.length === hostname.length) {
    return "";
  }
  return hostname.slice(0, -domain.length - 1);
}
function getEmptyResult() {
  return {
    domain: null,
    domainWithoutSuffix: null,
    hostname: null,
    isIcann: null,
    isIp: null,
    isPrivate: null,
    publicSuffix: null,
    subdomain: null
  };
}
function resetResult(result) {
  result.domain = null;
  result.domainWithoutSuffix = null;
  result.hostname = null;
  result.isIcann = null;
  result.isIp = null;
  result.isPrivate = null;
  result.publicSuffix = null;
  result.subdomain = null;
}
function parseImpl(url, step, suffixLookup2, partialOptions, result) {
  const options = (
    /*@__INLINE__*/
    setDefaults(partialOptions)
  );
  if (typeof url !== "string") {
    return result;
  }
  if (!options.extractHostname) {
    result.hostname = url;
  } else if (options.mixedInputs) {
    result.hostname = extractHostname(url, isValidHostname(url));
  } else {
    result.hostname = extractHostname(url, false);
  }
  if (step === 0 || result.hostname === null) {
    return result;
  }
  if (options.detectIp) {
    result.isIp = isIp(result.hostname);
    if (result.isIp) {
      return result;
    }
  }
  if (options.validateHostname && options.extractHostname && !isValidHostname(result.hostname)) {
    result.hostname = null;
    return result;
  }
  suffixLookup2(result.hostname, options, result);
  if (step === 2 || result.publicSuffix === null) {
    return result;
  }
  result.domain = getDomain$1(result.publicSuffix, result.hostname, options);
  if (step === 3 || result.domain === null) {
    return result;
  }
  result.subdomain = getSubdomain$1(result.hostname, result.domain);
  if (step === 4) {
    return result;
  }
  result.domainWithoutSuffix = getDomainWithoutSuffix$1(result.domain, result.publicSuffix);
  return result;
}
function fastPathLookup(hostname, options, out) {
  if (!options.allowPrivateDomains && hostname.length > 3) {
    const last = hostname.length - 1;
    const c3 = hostname.charCodeAt(last);
    const c2 = hostname.charCodeAt(last - 1);
    const c1 = hostname.charCodeAt(last - 2);
    const c0 = hostname.charCodeAt(last - 3);
    if (c3 === 109 && c2 === 111 && c1 === 99 && c0 === 46) {
      out.isIcann = true;
      out.isPrivate = false;
      out.publicSuffix = "com";
      return true;
    } else if (c3 === 103 && c2 === 114 && c1 === 111 && c0 === 46) {
      out.isIcann = true;
      out.isPrivate = false;
      out.publicSuffix = "org";
      return true;
    } else if (c3 === 117 && c2 === 100 && c1 === 101 && c0 === 46) {
      out.isIcann = true;
      out.isPrivate = false;
      out.publicSuffix = "edu";
      return true;
    } else if (c3 === 118 && c2 === 111 && c1 === 103 && c0 === 46) {
      out.isIcann = true;
      out.isPrivate = false;
      out.publicSuffix = "gov";
      return true;
    } else if (c3 === 116 && c2 === 101 && c1 === 110 && c0 === 46) {
      out.isIcann = true;
      out.isPrivate = false;
      out.publicSuffix = "net";
      return true;
    } else if (c3 === 101 && c2 === 100 && c1 === 46) {
      out.isIcann = true;
      out.isPrivate = false;
      out.publicSuffix = "de";
      return true;
    }
  }
  return false;
}
const exceptions = /* @__PURE__ */ function() {
  const _0 = [1, {}], _1 = [2, {}], _2 = [0, { "city": _0 }];
  const exceptions2 = [0, { "ck": [0, { "www": _0 }], "jp": [0, { "kawasaki": _2, "kitakyushu": _2, "kobe": _2, "nagoya": _2, "sapporo": _2, "sendai": _2, "yokohama": _2 }], "dev": [0, { "hrsn": [0, { "psl": [0, { "wc": [0, { "ignored": _1, "sub": [0, { "ignored": _1 }] }] }] }] }] }];
  return exceptions2;
}();
const rules = /* @__PURE__ */ function() {
  const _3 = [1, {}], _4 = [2, {}], _5 = [1, { "com": _3, "edu": _3, "gov": _3, "net": _3, "org": _3 }], _6 = [1, { "com": _3, "edu": _3, "gov": _3, "mil": _3, "net": _3, "org": _3 }], _7 = [0, { "*": _4 }], _8 = [2, { "s": _7 }], _9 = [0, { "relay": _4 }], _10 = [2, { "id": _4 }], _11 = [1, { "gov": _3 }], _12 = [0, { "transfer-webapp": _4 }], _13 = [0, { "notebook": _4, "studio": _4 }], _14 = [0, { "labeling": _4, "notebook": _4, "studio": _4 }], _15 = [0, { "notebook": _4 }], _16 = [0, { "labeling": _4, "notebook": _4, "notebook-fips": _4, "studio": _4 }], _17 = [0, { "notebook": _4, "notebook-fips": _4, "studio": _4, "studio-fips": _4 }], _18 = [0, { "*": _3 }], _19 = [1, { "co": _4 }], _20 = [0, { "objects": _4 }], _21 = [2, { "nodes": _4 }], _22 = [0, { "my": _7 }], _23 = [0, { "s3": _4, "s3-accesspoint": _4, "s3-website": _4 }], _24 = [0, { "s3": _4, "s3-accesspoint": _4 }], _25 = [0, { "direct": _4 }], _26 = [0, { "webview-assets": _4 }], _27 = [0, { "vfs": _4, "webview-assets": _4 }], _28 = [0, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, "dualstack": _23, "s3": _4, "s3-accesspoint": _4, "s3-object-lambda": _4, "s3-website": _4, "aws-cloud9": _26, "cloud9": _27 }], _29 = [0, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, "dualstack": _24, "s3": _4, "s3-accesspoint": _4, "s3-object-lambda": _4, "s3-website": _4, "aws-cloud9": _26, "cloud9": _27 }], _30 = [0, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, "dualstack": _23, "s3": _4, "s3-accesspoint": _4, "s3-object-lambda": _4, "s3-website": _4, "analytics-gateway": _4, "aws-cloud9": _26, "cloud9": _27 }], _31 = [0, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, "dualstack": _23, "s3": _4, "s3-accesspoint": _4, "s3-object-lambda": _4, "s3-website": _4 }], _32 = [0, { "s3": _4, "s3-accesspoint": _4, "s3-accesspoint-fips": _4, "s3-fips": _4, "s3-website": _4 }], _33 = [0, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, "dualstack": _32, "s3": _4, "s3-accesspoint": _4, "s3-accesspoint-fips": _4, "s3-fips": _4, "s3-object-lambda": _4, "s3-website": _4, "aws-cloud9": _26, "cloud9": _27 }], _34 = [0, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, "dualstack": _32, "s3": _4, "s3-accesspoint": _4, "s3-accesspoint-fips": _4, "s3-deprecated": _4, "s3-fips": _4, "s3-object-lambda": _4, "s3-website": _4, "analytics-gateway": _4, "aws-cloud9": _26, "cloud9": _27 }], _35 = [0, { "s3": _4, "s3-accesspoint": _4, "s3-accesspoint-fips": _4, "s3-fips": _4 }], _36 = [0, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, "dualstack": _35, "s3": _4, "s3-accesspoint": _4, "s3-accesspoint-fips": _4, "s3-fips": _4, "s3-object-lambda": _4, "s3-website": _4 }], _37 = [0, { "auth": _4 }], _38 = [0, { "auth": _4, "auth-fips": _4 }], _39 = [0, { "apps": _4 }], _40 = [0, { "paas": _4 }], _41 = [2, { "eu": _4 }], _42 = [0, { "app": _4 }], _43 = [0, { "site": _4 }], _44 = [1, { "com": _3, "edu": _3, "net": _3, "org": _3 }], _45 = [0, { "j": _4 }], _46 = [0, { "dyn": _4 }], _47 = [1, { "co": _3, "com": _3, "edu": _3, "gov": _3, "net": _3, "org": _3 }], _48 = [0, { "p": _4 }], _49 = [0, { "user": _4 }], _50 = [0, { "shop": _4 }], _51 = [0, { "cdn": _4 }], _52 = [0, { "cust": _4, "reservd": _4 }], _53 = [0, { "cust": _4 }], _54 = [0, { "s3": _4 }], _55 = [1, { "biz": _3, "com": _3, "edu": _3, "gov": _3, "info": _3, "net": _3, "org": _3 }], _56 = [1, { "framer": _4 }], _57 = [0, { "forgot": _4 }], _58 = [1, { "gs": _3 }], _59 = [0, { "nes": _3 }], _60 = [1, { "k12": _3, "cc": _3, "lib": _3 }], _61 = [1, { "cc": _3, "lib": _3 }];
  const rules2 = [0, { "ac": [1, { "com": _3, "edu": _3, "gov": _3, "mil": _3, "net": _3, "org": _3, "drr": _4, "feedback": _4, "forms": _4 }], "ad": _3, "ae": [1, { "ac": _3, "co": _3, "gov": _3, "mil": _3, "net": _3, "org": _3, "sch": _3 }], "aero": [1, { "airline": _3, "airport": _3, "accident-investigation": _3, "accident-prevention": _3, "aerobatic": _3, "aeroclub": _3, "aerodrome": _3, "agents": _3, "air-surveillance": _3, "air-traffic-control": _3, "aircraft": _3, "airtraffic": _3, "ambulance": _3, "association": _3, "author": _3, "ballooning": _3, "broker": _3, "caa": _3, "cargo": _3, "catering": _3, "certification": _3, "championship": _3, "charter": _3, "civilaviation": _3, "club": _3, "conference": _3, "consultant": _3, "consulting": _3, "control": _3, "council": _3, "crew": _3, "design": _3, "dgca": _3, "educator": _3, "emergency": _3, "engine": _3, "engineer": _3, "entertainment": _3, "equipment": _3, "exchange": _3, "express": _3, "federation": _3, "flight": _3, "freight": _3, "fuel": _3, "gliding": _3, "government": _3, "groundhandling": _3, "group": _3, "hanggliding": _3, "homebuilt": _3, "insurance": _3, "journal": _3, "journalist": _3, "leasing": _3, "logistics": _3, "magazine": _3, "maintenance": _3, "marketplace": _3, "media": _3, "microlight": _3, "modelling": _3, "navigation": _3, "parachuting": _3, "paragliding": _3, "passenger-association": _3, "pilot": _3, "press": _3, "production": _3, "recreation": _3, "repbody": _3, "res": _3, "research": _3, "rotorcraft": _3, "safety": _3, "scientist": _3, "services": _3, "show": _3, "skydiving": _3, "software": _3, "student": _3, "taxi": _3, "trader": _3, "trading": _3, "trainer": _3, "union": _3, "workinggroup": _3, "works": _3 }], "af": _5, "ag": [1, { "co": _3, "com": _3, "net": _3, "nom": _3, "org": _3, "obj": _4 }], "ai": [1, { "com": _3, "net": _3, "off": _3, "org": _3, "uwu": _4, "framer": _4 }], "al": _6, "am": [1, { "co": _3, "com": _3, "commune": _3, "net": _3, "org": _3, "radio": _4 }], "ao": [1, { "co": _3, "ed": _3, "edu": _3, "gov": _3, "gv": _3, "it": _3, "og": _3, "org": _3, "pb": _3 }], "aq": _3, "ar": [1, { "bet": _3, "com": _3, "coop": _3, "edu": _3, "gob": _3, "gov": _3, "int": _3, "mil": _3, "musica": _3, "mutual": _3, "net": _3, "org": _3, "senasa": _3, "tur": _3 }], "arpa": [1, { "e164": _3, "home": _3, "in-addr": _3, "ip6": _3, "iris": _3, "uri": _3, "urn": _3 }], "as": _11, "asia": [1, { "cloudns": _4, "daemon": _4, "dix": _4 }], "at": [1, { "ac": [1, { "sth": _3 }], "co": _3, "gv": _3, "or": _3, "funkfeuer": [0, { "wien": _4 }], "futurecms": [0, { "*": _4, "ex": _7, "in": _7 }], "futurehosting": _4, "futuremailing": _4, "ortsinfo": [0, { "ex": _7, "kunden": _7 }], "biz": _4, "info": _4, "123webseite": _4, "priv": _4, "myspreadshop": _4, "12hp": _4, "2ix": _4, "4lima": _4, "lima-city": _4 }], "au": [1, { "asn": _3, "com": [1, { "cloudlets": [0, { "mel": _4 }], "myspreadshop": _4 }], "edu": [1, { "act": _3, "catholic": _3, "nsw": [1, { "schools": _3 }], "nt": _3, "qld": _3, "sa": _3, "tas": _3, "vic": _3, "wa": _3 }], "gov": [1, { "qld": _3, "sa": _3, "tas": _3, "vic": _3, "wa": _3 }], "id": _3, "net": _3, "org": _3, "conf": _3, "oz": _3, "act": _3, "nsw": _3, "nt": _3, "qld": _3, "sa": _3, "tas": _3, "vic": _3, "wa": _3 }], "aw": [1, { "com": _3 }], "ax": _3, "az": [1, { "biz": _3, "co": _3, "com": _3, "edu": _3, "gov": _3, "info": _3, "int": _3, "mil": _3, "name": _3, "net": _3, "org": _3, "pp": _3, "pro": _3 }], "ba": [1, { "com": _3, "edu": _3, "gov": _3, "mil": _3, "net": _3, "org": _3, "rs": _4 }], "bb": [1, { "biz": _3, "co": _3, "com": _3, "edu": _3, "gov": _3, "info": _3, "net": _3, "org": _3, "store": _3, "tv": _3 }], "bd": _18, "be": [1, { "ac": _3, "cloudns": _4, "webhosting": _4, "interhostsolutions": [0, { "cloud": _4 }], "kuleuven": [0, { "ezproxy": _4 }], "123website": _4, "myspreadshop": _4, "transurl": _7 }], "bf": _11, "bg": [1, { "0": _3, "1": _3, "2": _3, "3": _3, "4": _3, "5": _3, "6": _3, "7": _3, "8": _3, "9": _3, "a": _3, "b": _3, "c": _3, "d": _3, "e": _3, "f": _3, "g": _3, "h": _3, "i": _3, "j": _3, "k": _3, "l": _3, "m": _3, "n": _3, "o": _3, "p": _3, "q": _3, "r": _3, "s": _3, "t": _3, "u": _3, "v": _3, "w": _3, "x": _3, "y": _3, "z": _3, "barsy": _4 }], "bh": _5, "bi": [1, { "co": _3, "com": _3, "edu": _3, "or": _3, "org": _3 }], "biz": [1, { "activetrail": _4, "cloud-ip": _4, "cloudns": _4, "jozi": _4, "dyndns": _4, "for-better": _4, "for-more": _4, "for-some": _4, "for-the": _4, "selfip": _4, "webhop": _4, "orx": _4, "mmafan": _4, "myftp": _4, "no-ip": _4, "dscloud": _4 }], "bj": [1, { "africa": _3, "agro": _3, "architectes": _3, "assur": _3, "avocats": _3, "co": _3, "com": _3, "eco": _3, "econo": _3, "edu": _3, "info": _3, "loisirs": _3, "money": _3, "net": _3, "org": _3, "ote": _3, "restaurant": _3, "resto": _3, "tourism": _3, "univ": _3 }], "bm": _5, "bn": [1, { "com": _3, "edu": _3, "gov": _3, "net": _3, "org": _3, "co": _4 }], "bo": [1, { "com": _3, "edu": _3, "gob": _3, "int": _3, "mil": _3, "net": _3, "org": _3, "tv": _3, "web": _3, "academia": _3, "agro": _3, "arte": _3, "blog": _3, "bolivia": _3, "ciencia": _3, "cooperativa": _3, "democracia": _3, "deporte": _3, "ecologia": _3, "economia": _3, "empresa": _3, "indigena": _3, "industria": _3, "info": _3, "medicina": _3, "movimiento": _3, "musica": _3, "natural": _3, "nombre": _3, "noticias": _3, "patria": _3, "plurinacional": _3, "politica": _3, "profesional": _3, "pueblo": _3, "revista": _3, "salud": _3, "tecnologia": _3, "tksat": _3, "transporte": _3, "wiki": _3 }], "br": [1, { "9guacu": _3, "abc": _3, "adm": _3, "adv": _3, "agr": _3, "aju": _3, "am": _3, "anani": _3, "aparecida": _3, "app": _3, "arq": _3, "art": _3, "ato": _3, "b": _3, "barueri": _3, "belem": _3, "bet": _3, "bhz": _3, "bib": _3, "bio": _3, "blog": _3, "bmd": _3, "boavista": _3, "bsb": _3, "campinagrande": _3, "campinas": _3, "caxias": _3, "cim": _3, "cng": _3, "cnt": _3, "com": [1, { "simplesite": _4 }], "contagem": _3, "coop": _3, "coz": _3, "cri": _3, "cuiaba": _3, "curitiba": _3, "def": _3, "des": _3, "det": _3, "dev": _3, "ecn": _3, "eco": _3, "edu": _3, "emp": _3, "enf": _3, "eng": _3, "esp": _3, "etc": _3, "eti": _3, "far": _3, "feira": _3, "flog": _3, "floripa": _3, "fm": _3, "fnd": _3, "fortal": _3, "fot": _3, "foz": _3, "fst": _3, "g12": _3, "geo": _3, "ggf": _3, "goiania": _3, "gov": [1, { "ac": _3, "al": _3, "am": _3, "ap": _3, "ba": _3, "ce": _3, "df": _3, "es": _3, "go": _3, "ma": _3, "mg": _3, "ms": _3, "mt": _3, "pa": _3, "pb": _3, "pe": _3, "pi": _3, "pr": _3, "rj": _3, "rn": _3, "ro": _3, "rr": _3, "rs": _3, "sc": _3, "se": _3, "sp": _3, "to": _3 }], "gru": _3, "imb": _3, "ind": _3, "inf": _3, "jab": _3, "jampa": _3, "jdf": _3, "joinville": _3, "jor": _3, "jus": _3, "leg": [1, { "ac": _4, "al": _4, "am": _4, "ap": _4, "ba": _4, "ce": _4, "df": _4, "es": _4, "go": _4, "ma": _4, "mg": _4, "ms": _4, "mt": _4, "pa": _4, "pb": _4, "pe": _4, "pi": _4, "pr": _4, "rj": _4, "rn": _4, "ro": _4, "rr": _4, "rs": _4, "sc": _4, "se": _4, "sp": _4, "to": _4 }], "leilao": _3, "lel": _3, "log": _3, "londrina": _3, "macapa": _3, "maceio": _3, "manaus": _3, "maringa": _3, "mat": _3, "med": _3, "mil": _3, "morena": _3, "mp": _3, "mus": _3, "natal": _3, "net": _3, "niteroi": _3, "nom": _18, "not": _3, "ntr": _3, "odo": _3, "ong": _3, "org": _3, "osasco": _3, "palmas": _3, "poa": _3, "ppg": _3, "pro": _3, "psc": _3, "psi": _3, "pvh": _3, "qsl": _3, "radio": _3, "rec": _3, "recife": _3, "rep": _3, "ribeirao": _3, "rio": _3, "riobranco": _3, "riopreto": _3, "salvador": _3, "sampa": _3, "santamaria": _3, "santoandre": _3, "saobernardo": _3, "saogonca": _3, "seg": _3, "sjc": _3, "slg": _3, "slz": _3, "sorocaba": _3, "srv": _3, "taxi": _3, "tc": _3, "tec": _3, "teo": _3, "the": _3, "tmp": _3, "trd": _3, "tur": _3, "tv": _3, "udi": _3, "vet": _3, "vix": _3, "vlog": _3, "wiki": _3, "zlg": _3 }], "bs": [1, { "com": _3, "edu": _3, "gov": _3, "net": _3, "org": _3, "we": _4 }], "bt": _5, "bv": _3, "bw": [1, { "ac": _3, "co": _3, "gov": _3, "net": _3, "org": _3 }], "by": [1, { "gov": _3, "mil": _3, "com": _3, "of": _3, "mediatech": _4 }], "bz": [1, { "co": _3, "com": _3, "edu": _3, "gov": _3, "net": _3, "org": _3, "za": _4, "mydns": _4, "gsj": _4 }], "ca": [1, { "ab": _3, "bc": _3, "mb": _3, "nb": _3, "nf": _3, "nl": _3, "ns": _3, "nt": _3, "nu": _3, "on": _3, "pe": _3, "qc": _3, "sk": _3, "yk": _3, "gc": _3, "barsy": _4, "awdev": _7, "co": _4, "no-ip": _4, "myspreadshop": _4, "box": _4 }], "cat": _3, "cc": [1, { "cleverapps": _4, "cloudns": _4, "ftpaccess": _4, "game-server": _4, "myphotos": _4, "scrapping": _4, "twmail": _4, "csx": _4, "fantasyleague": _4, "spawn": [0, { "instances": _4 }] }], "cd": _11, "cf": _3, "cg": _3, "ch": [1, { "square7": _4, "cloudns": _4, "cloudscale": [0, { "cust": _4, "lpg": _20, "rma": _20 }], "flow": [0, { "ae": [0, { "alp1": _4 }], "appengine": _4 }], "linkyard-cloud": _4, "gotdns": _4, "dnsking": _4, "123website": _4, "myspreadshop": _4, "firenet": [0, { "*": _4, "svc": _7 }], "12hp": _4, "2ix": _4, "4lima": _4, "lima-city": _4 }], "ci": [1, { "ac": _3, "xn--aroport-bya": _3, "aéroport": _3, "asso": _3, "co": _3, "com": _3, "ed": _3, "edu": _3, "go": _3, "gouv": _3, "int": _3, "net": _3, "or": _3, "org": _3 }], "ck": _18, "cl": [1, { "co": _3, "gob": _3, "gov": _3, "mil": _3, "cloudns": _4 }], "cm": [1, { "co": _3, "com": _3, "gov": _3, "net": _3 }], "cn": [1, { "ac": _3, "com": [1, { "amazonaws": [0, { "cn-north-1": [0, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, "dualstack": _23, "s3": _4, "s3-accesspoint": _4, "s3-deprecated": _4, "s3-object-lambda": _4, "s3-website": _4 }], "cn-northwest-1": [0, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, "dualstack": _24, "s3": _4, "s3-accesspoint": _4, "s3-object-lambda": _4, "s3-website": _4 }], "compute": _7, "airflow": [0, { "cn-north-1": _7, "cn-northwest-1": _7 }], "eb": [0, { "cn-north-1": _4, "cn-northwest-1": _4 }], "elb": _7 }], "sagemaker": [0, { "cn-north-1": _13, "cn-northwest-1": _13 }] }], "edu": _3, "gov": _3, "mil": _3, "net": _3, "org": _3, "xn--55qx5d": _3, "公司": _3, "xn--od0alg": _3, "網絡": _3, "xn--io0a7i": _3, "网络": _3, "ah": _3, "bj": _3, "cq": _3, "fj": _3, "gd": _3, "gs": _3, "gx": _3, "gz": _3, "ha": _3, "hb": _3, "he": _3, "hi": _3, "hk": _3, "hl": _3, "hn": _3, "jl": _3, "js": _3, "jx": _3, "ln": _3, "mo": _3, "nm": _3, "nx": _3, "qh": _3, "sc": _3, "sd": _3, "sh": [1, { "as": _4 }], "sn": _3, "sx": _3, "tj": _3, "tw": _3, "xj": _3, "xz": _3, "yn": _3, "zj": _3, "canva-apps": _4, "canvasite": _22, "myqnapcloud": _4, "quickconnect": _25 }], "co": [1, { "com": _3, "edu": _3, "gov": _3, "mil": _3, "net": _3, "nom": _3, "org": _3, "carrd": _4, "crd": _4, "otap": _7, "leadpages": _4, "lpages": _4, "mypi": _4, "xmit": _7, "firewalledreplit": _10, "repl": _10, "supabase": _4 }], "com": [1, { "a2hosted": _4, "cpserver": _4, "adobeaemcloud": [2, { "dev": _7 }], "africa": _4, "airkitapps": _4, "airkitapps-au": _4, "aivencloud": _4, "alibabacloudcs": _4, "kasserver": _4, "amazonaws": [0, { "af-south-1": _28, "ap-east-1": _29, "ap-northeast-1": _30, "ap-northeast-2": _30, "ap-northeast-3": _28, "ap-south-1": _30, "ap-south-2": _31, "ap-southeast-1": _30, "ap-southeast-2": _30, "ap-southeast-3": _31, "ap-southeast-4": _31, "ap-southeast-5": [0, { "execute-api": _4, "dualstack": _23, "s3": _4, "s3-accesspoint": _4, "s3-deprecated": _4, "s3-object-lambda": _4, "s3-website": _4 }], "ca-central-1": _33, "ca-west-1": [0, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, "dualstack": _32, "s3": _4, "s3-accesspoint": _4, "s3-accesspoint-fips": _4, "s3-fips": _4, "s3-object-lambda": _4, "s3-website": _4 }], "eu-central-1": _30, "eu-central-2": _31, "eu-north-1": _29, "eu-south-1": _28, "eu-south-2": _31, "eu-west-1": [0, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, "dualstack": _23, "s3": _4, "s3-accesspoint": _4, "s3-deprecated": _4, "s3-object-lambda": _4, "s3-website": _4, "analytics-gateway": _4, "aws-cloud9": _26, "cloud9": _27 }], "eu-west-2": _29, "eu-west-3": _28, "il-central-1": [0, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, "dualstack": _23, "s3": _4, "s3-accesspoint": _4, "s3-object-lambda": _4, "s3-website": _4, "aws-cloud9": _26, "cloud9": [0, { "vfs": _4 }] }], "me-central-1": _31, "me-south-1": _29, "sa-east-1": _28, "us-east-1": [2, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, "dualstack": _32, "s3": _4, "s3-accesspoint": _4, "s3-accesspoint-fips": _4, "s3-deprecated": _4, "s3-fips": _4, "s3-object-lambda": _4, "s3-website": _4, "analytics-gateway": _4, "aws-cloud9": _26, "cloud9": _27 }], "us-east-2": _34, "us-gov-east-1": _36, "us-gov-west-1": _36, "us-west-1": _33, "us-west-2": _34, "compute": _7, "compute-1": _7, "airflow": [0, { "af-south-1": _7, "ap-east-1": _7, "ap-northeast-1": _7, "ap-northeast-2": _7, "ap-northeast-3": _7, "ap-south-1": _7, "ap-south-2": _7, "ap-southeast-1": _7, "ap-southeast-2": _7, "ap-southeast-3": _7, "ap-southeast-4": _7, "ca-central-1": _7, "ca-west-1": _7, "eu-central-1": _7, "eu-central-2": _7, "eu-north-1": _7, "eu-south-1": _7, "eu-south-2": _7, "eu-west-1": _7, "eu-west-2": _7, "eu-west-3": _7, "il-central-1": _7, "me-central-1": _7, "me-south-1": _7, "sa-east-1": _7, "us-east-1": _7, "us-east-2": _7, "us-west-1": _7, "us-west-2": _7 }], "s3": _4, "s3-1": _4, "s3-ap-east-1": _4, "s3-ap-northeast-1": _4, "s3-ap-northeast-2": _4, "s3-ap-northeast-3": _4, "s3-ap-south-1": _4, "s3-ap-southeast-1": _4, "s3-ap-southeast-2": _4, "s3-ca-central-1": _4, "s3-eu-central-1": _4, "s3-eu-north-1": _4, "s3-eu-west-1": _4, "s3-eu-west-2": _4, "s3-eu-west-3": _4, "s3-external-1": _4, "s3-fips-us-gov-east-1": _4, "s3-fips-us-gov-west-1": _4, "s3-global": [0, { "accesspoint": [0, { "mrap": _4 }] }], "s3-me-south-1": _4, "s3-sa-east-1": _4, "s3-us-east-2": _4, "s3-us-gov-east-1": _4, "s3-us-gov-west-1": _4, "s3-us-west-1": _4, "s3-us-west-2": _4, "s3-website-ap-northeast-1": _4, "s3-website-ap-southeast-1": _4, "s3-website-ap-southeast-2": _4, "s3-website-eu-west-1": _4, "s3-website-sa-east-1": _4, "s3-website-us-east-1": _4, "s3-website-us-gov-west-1": _4, "s3-website-us-west-1": _4, "s3-website-us-west-2": _4, "elb": _7 }], "amazoncognito": [0, { "af-south-1": _37, "ap-east-1": _37, "ap-northeast-1": _37, "ap-northeast-2": _37, "ap-northeast-3": _37, "ap-south-1": _37, "ap-south-2": _37, "ap-southeast-1": _37, "ap-southeast-2": _37, "ap-southeast-3": _37, "ap-southeast-4": _37, "ca-central-1": _37, "ca-west-1": _37, "eu-central-1": _37, "eu-central-2": _37, "eu-north-1": _37, "eu-south-1": _37, "eu-south-2": _37, "eu-west-1": _37, "eu-west-2": _37, "eu-west-3": _37, "il-central-1": _37, "me-central-1": _37, "me-south-1": _37, "sa-east-1": _37, "us-east-1": _38, "us-east-2": _38, "us-gov-west-1": [0, { "auth-fips": _4 }], "us-west-1": _38, "us-west-2": _38 }], "amplifyapp": _4, "awsapprunner": _7, "awsapps": _4, "elasticbeanstalk": [2, { "af-south-1": _4, "ap-east-1": _4, "ap-northeast-1": _4, "ap-northeast-2": _4, "ap-northeast-3": _4, "ap-south-1": _4, "ap-southeast-1": _4, "ap-southeast-2": _4, "ap-southeast-3": _4, "ca-central-1": _4, "eu-central-1": _4, "eu-north-1": _4, "eu-south-1": _4, "eu-west-1": _4, "eu-west-2": _4, "eu-west-3": _4, "il-central-1": _4, "me-south-1": _4, "sa-east-1": _4, "us-east-1": _4, "us-east-2": _4, "us-gov-east-1": _4, "us-gov-west-1": _4, "us-west-1": _4, "us-west-2": _4 }], "awsglobalaccelerator": _4, "siiites": _4, "appspacehosted": _4, "appspaceusercontent": _4, "on-aptible": _4, "myasustor": _4, "balena-devices": _4, "boutir": _4, "bplaced": _4, "cafjs": _4, "canva-apps": _4, "cdn77-storage": _4, "br": _4, "cn": _4, "de": _4, "eu": _4, "jpn": _4, "mex": _4, "ru": _4, "sa": _4, "uk": _4, "us": _4, "za": _4, "clever-cloud": [0, { "services": _7 }], "dnsabr": _4, "ip-ddns": _4, "jdevcloud": _4, "wpdevcloud": _4, "cf-ipfs": _4, "cloudflare-ipfs": _4, "trycloudflare": _4, "co": _4, "builtwithdark": _4, "datadetect": [0, { "demo": _4, "instance": _4 }], "dattolocal": _4, "dattorelay": _4, "dattoweb": _4, "mydatto": _4, "digitaloceanspaces": _7, "discordsays": _4, "discordsez": _4, "drayddns": _4, "dreamhosters": _4, "durumis": _4, "mydrobo": _4, "blogdns": _4, "cechire": _4, "dnsalias": _4, "dnsdojo": _4, "doesntexist": _4, "dontexist": _4, "doomdns": _4, "dyn-o-saur": _4, "dynalias": _4, "dyndns-at-home": _4, "dyndns-at-work": _4, "dyndns-blog": _4, "dyndns-free": _4, "dyndns-home": _4, "dyndns-ip": _4, "dyndns-mail": _4, "dyndns-office": _4, "dyndns-pics": _4, "dyndns-remote": _4, "dyndns-server": _4, "dyndns-web": _4, "dyndns-wiki": _4, "dyndns-work": _4, "est-a-la-maison": _4, "est-a-la-masion": _4, "est-le-patron": _4, "est-mon-blogueur": _4, "from-ak": _4, "from-al": _4, "from-ar": _4, "from-ca": _4, "from-ct": _4, "from-dc": _4, "from-de": _4, "from-fl": _4, "from-ga": _4, "from-hi": _4, "from-ia": _4, "from-id": _4, "from-il": _4, "from-in": _4, "from-ks": _4, "from-ky": _4, "from-ma": _4, "from-md": _4, "from-mi": _4, "from-mn": _4, "from-mo": _4, "from-ms": _4, "from-mt": _4, "from-nc": _4, "from-nd": _4, "from-ne": _4, "from-nh": _4, "from-nj": _4, "from-nm": _4, "from-nv": _4, "from-oh": _4, "from-ok": _4, "from-or": _4, "from-pa": _4, "from-pr": _4, "from-ri": _4, "from-sc": _4, "from-sd": _4, "from-tn": _4, "from-tx": _4, "from-ut": _4, "from-va": _4, "from-vt": _4, "from-wa": _4, "from-wi": _4, "from-wv": _4, "from-wy": _4, "getmyip": _4, "gotdns": _4, "hobby-site": _4, "homelinux": _4, "homeunix": _4, "iamallama": _4, "is-a-anarchist": _4, "is-a-blogger": _4, "is-a-bookkeeper": _4, "is-a-bulls-fan": _4, "is-a-caterer": _4, "is-a-chef": _4, "is-a-conservative": _4, "is-a-cpa": _4, "is-a-cubicle-slave": _4, "is-a-democrat": _4, "is-a-designer": _4, "is-a-doctor": _4, "is-a-financialadvisor": _4, "is-a-geek": _4, "is-a-green": _4, "is-a-guru": _4, "is-a-hard-worker": _4, "is-a-hunter": _4, "is-a-landscaper": _4, "is-a-lawyer": _4, "is-a-liberal": _4, "is-a-libertarian": _4, "is-a-llama": _4, "is-a-musician": _4, "is-a-nascarfan": _4, "is-a-nurse": _4, "is-a-painter": _4, "is-a-personaltrainer": _4, "is-a-photographer": _4, "is-a-player": _4, "is-a-republican": _4, "is-a-rockstar": _4, "is-a-socialist": _4, "is-a-student": _4, "is-a-teacher": _4, "is-a-techie": _4, "is-a-therapist": _4, "is-an-accountant": _4, "is-an-actor": _4, "is-an-actress": _4, "is-an-anarchist": _4, "is-an-artist": _4, "is-an-engineer": _4, "is-an-entertainer": _4, "is-certified": _4, "is-gone": _4, "is-into-anime": _4, "is-into-cars": _4, "is-into-cartoons": _4, "is-into-games": _4, "is-leet": _4, "is-not-certified": _4, "is-slick": _4, "is-uberleet": _4, "is-with-theband": _4, "isa-geek": _4, "isa-hockeynut": _4, "issmarterthanyou": _4, "likes-pie": _4, "likescandy": _4, "neat-url": _4, "saves-the-whales": _4, "selfip": _4, "sells-for-less": _4, "sells-for-u": _4, "servebbs": _4, "simple-url": _4, "space-to-rent": _4, "teaches-yoga": _4, "writesthisblog": _4, "ddnsfree": _4, "ddnsgeek": _4, "giize": _4, "gleeze": _4, "kozow": _4, "loseyourip": _4, "ooguy": _4, "theworkpc": _4, "mytuleap": _4, "tuleap-partners": _4, "encoreapi": _4, "evennode": [0, { "eu-1": _4, "eu-2": _4, "eu-3": _4, "eu-4": _4, "us-1": _4, "us-2": _4, "us-3": _4, "us-4": _4 }], "onfabrica": _4, "fastly-edge": _4, "fastly-terrarium": _4, "fastvps-server": _4, "mydobiss": _4, "firebaseapp": _4, "fldrv": _4, "forgeblocks": _4, "framercanvas": _4, "freebox-os": _4, "freeboxos": _4, "freemyip": _4, "aliases121": _4, "gentapps": _4, "gentlentapis": _4, "githubusercontent": _4, "0emm": _7, "appspot": [2, { "r": _7 }], "blogspot": _4, "codespot": _4, "googleapis": _4, "googlecode": _4, "pagespeedmobilizer": _4, "withgoogle": _4, "withyoutube": _4, "grayjayleagues": _4, "hatenablog": _4, "hatenadiary": _4, "herokuapp": _4, "gr": _4, "smushcdn": _4, "wphostedmail": _4, "wpmucdn": _4, "pixolino": _4, "apps-1and1": _4, "live-website": _4, "dopaas": _4, "hosted-by-previder": _40, "hosteur": [0, { "rag-cloud": _4, "rag-cloud-ch": _4 }], "ik-server": [0, { "jcloud": _4, "jcloud-ver-jpc": _4 }], "jelastic": [0, { "demo": _4 }], "massivegrid": _40, "wafaicloud": [0, { "jed": _4, "ryd": _4 }], "webadorsite": _4, "joyent": [0, { "cns": _7 }], "lpusercontent": _4, "linode": [0, { "members": _4, "nodebalancer": _7 }], "linodeobjects": _7, "linodeusercontent": [0, { "ip": _4 }], "localtonet": _4, "lovableproject": _4, "barsycenter": _4, "barsyonline": _4, "modelscape": _4, "mwcloudnonprod": _4, "polyspace": _4, "mazeplay": _4, "miniserver": _4, "atmeta": _4, "fbsbx": _39, "meteorapp": _41, "routingthecloud": _4, "mydbserver": _4, "hostedpi": _4, "mythic-beasts": [0, { "caracal": _4, "customer": _4, "fentiger": _4, "lynx": _4, "ocelot": _4, "oncilla": _4, "onza": _4, "sphinx": _4, "vs": _4, "x": _4, "yali": _4 }], "nospamproxy": [0, { "cloud": [2, { "o365": _4 }] }], "4u": _4, "nfshost": _4, "3utilities": _4, "blogsyte": _4, "ciscofreak": _4, "damnserver": _4, "ddnsking": _4, "ditchyourip": _4, "dnsiskinky": _4, "dynns": _4, "geekgalaxy": _4, "health-carereform": _4, "homesecuritymac": _4, "homesecuritypc": _4, "myactivedirectory": _4, "mysecuritycamera": _4, "myvnc": _4, "net-freaks": _4, "onthewifi": _4, "point2this": _4, "quicksytes": _4, "securitytactics": _4, "servebeer": _4, "servecounterstrike": _4, "serveexchange": _4, "serveftp": _4, "servegame": _4, "servehalflife": _4, "servehttp": _4, "servehumour": _4, "serveirc": _4, "servemp3": _4, "servep2p": _4, "servepics": _4, "servequake": _4, "servesarcasm": _4, "stufftoread": _4, "unusualperson": _4, "workisboring": _4, "myiphost": _4, "observableusercontent": [0, { "static": _4 }], "simplesite": _4, "orsites": _4, "operaunite": _4, "customer-oci": [0, { "*": _4, "oci": _7, "ocp": _7, "ocs": _7 }], "oraclecloudapps": _7, "oraclegovcloudapps": _7, "authgear-staging": _4, "authgearapps": _4, "skygearapp": _4, "outsystemscloud": _4, "ownprovider": _4, "pgfog": _4, "pagexl": _4, "gotpantheon": _4, "paywhirl": _7, "upsunapp": _4, "postman-echo": _4, "prgmr": [0, { "xen": _4 }], "pythonanywhere": _41, "qa2": _4, "alpha-myqnapcloud": _4, "dev-myqnapcloud": _4, "mycloudnas": _4, "mynascloud": _4, "myqnapcloud": _4, "qualifioapp": _4, "ladesk": _4, "qbuser": _4, "quipelements": _7, "rackmaze": _4, "readthedocs-hosted": _4, "rhcloud": _4, "onrender": _4, "render": _42, "subsc-pay": _4, "180r": _4, "dojin": _4, "sakuratan": _4, "sakuraweb": _4, "x0": _4, "code": [0, { "builder": _7, "dev-builder": _7, "stg-builder": _7 }], "salesforce": [0, { "platform": [0, { "code-builder-stg": [0, { "test": [0, { "001": _7 }] }] }] }], "logoip": _4, "scrysec": _4, "firewall-gateway": _4, "myshopblocks": _4, "myshopify": _4, "shopitsite": _4, "1kapp": _4, "appchizi": _4, "applinzi": _4, "sinaapp": _4, "vipsinaapp": _4, "streamlitapp": _4, "try-snowplow": _4, "playstation-cloud": _4, "myspreadshop": _4, "w-corp-staticblitz": _4, "w-credentialless-staticblitz": _4, "w-staticblitz": _4, "stackhero-network": _4, "stdlib": [0, { "api": _4 }], "strapiapp": [2, { "media": _4 }], "streak-link": _4, "streaklinks": _4, "streakusercontent": _4, "temp-dns": _4, "dsmynas": _4, "familyds": _4, "mytabit": _4, "taveusercontent": _4, "tb-hosting": _43, "reservd": _4, "thingdustdata": _4, "townnews-staging": _4, "typeform": [0, { "pro": _4 }], "hk": _4, "it": _4, "deus-canvas": _4, "vultrobjects": _7, "wafflecell": _4, "hotelwithflight": _4, "reserve-online": _4, "cprapid": _4, "pleskns": _4, "remotewd": _4, "wiardweb": [0, { "pages": _4 }], "wixsite": _4, "wixstudio": _4, "messwithdns": _4, "woltlab-demo": _4, "wpenginepowered": [2, { "js": _4 }], "xnbay": [2, { "u2": _4, "u2-local": _4 }], "yolasite": _4 }], "coop": _3, "cr": [1, { "ac": _3, "co": _3, "ed": _3, "fi": _3, "go": _3, "or": _3, "sa": _3 }], "cu": [1, { "com": _3, "edu": _3, "gob": _3, "inf": _3, "nat": _3, "net": _3, "org": _3 }], "cv": [1, { "com": _3, "edu": _3, "id": _3, "int": _3, "net": _3, "nome": _3, "org": _3, "publ": _3 }], "cw": _44, "cx": [1, { "gov": _3, "cloudns": _4, "ath": _4, "info": _4, "assessments": _4, "calculators": _4, "funnels": _4, "paynow": _4, "quizzes": _4, "researched": _4, "tests": _4 }], "cy": [1, { "ac": _3, "biz": _3, "com": [1, { "scaleforce": _45 }], "ekloges": _3, "gov": _3, "ltd": _3, "mil": _3, "net": _3, "org": _3, "press": _3, "pro": _3, "tm": _3 }], "cz": [1, { "contentproxy9": [0, { "rsc": _4 }], "realm": _4, "e4": _4, "co": _4, "metacentrum": [0, { "cloud": _7, "custom": _4 }], "muni": [0, { "cloud": [0, { "flt": _4, "usr": _4 }] }] }], "de": [1, { "bplaced": _4, "square7": _4, "com": _4, "cosidns": _46, "dnsupdater": _4, "dynamisches-dns": _4, "internet-dns": _4, "l-o-g-i-n": _4, "ddnss": [2, { "dyn": _4, "dyndns": _4 }], "dyn-ip24": _4, "dyndns1": _4, "home-webserver": [2, { "dyn": _4 }], "myhome-server": _4, "dnshome": _4, "fuettertdasnetz": _4, "isteingeek": _4, "istmein": _4, "lebtimnetz": _4, "leitungsen": _4, "traeumtgerade": _4, "frusky": _7, "goip": _4, "xn--gnstigbestellen-zvb": _4, "günstigbestellen": _4, "xn--gnstigliefern-wob": _4, "günstigliefern": _4, "hs-heilbronn": [0, { "it": [0, { "pages": _4, "pages-research": _4 }] }], "dyn-berlin": _4, "in-berlin": _4, "in-brb": _4, "in-butter": _4, "in-dsl": _4, "in-vpn": _4, "iservschule": _4, "mein-iserv": _4, "schulplattform": _4, "schulserver": _4, "test-iserv": _4, "keymachine": _4, "git-repos": _4, "lcube-server": _4, "svn-repos": _4, "barsy": _4, "webspaceconfig": _4, "123webseite": _4, "rub": _4, "ruhr-uni-bochum": [2, { "noc": [0, { "io": _4 }] }], "logoip": _4, "firewall-gateway": _4, "my-gateway": _4, "my-router": _4, "spdns": _4, "speedpartner": [0, { "customer": _4 }], "myspreadshop": _4, "taifun-dns": _4, "12hp": _4, "2ix": _4, "4lima": _4, "lima-city": _4, "dd-dns": _4, "dray-dns": _4, "draydns": _4, "dyn-vpn": _4, "dynvpn": _4, "mein-vigor": _4, "my-vigor": _4, "my-wan": _4, "syno-ds": _4, "synology-diskstation": _4, "synology-ds": _4, "uberspace": _7, "virtual-user": _4, "virtualuser": _4, "community-pro": _4, "diskussionsbereich": _4 }], "dj": _3, "dk": [1, { "biz": _4, "co": _4, "firm": _4, "reg": _4, "store": _4, "123hjemmeside": _4, "myspreadshop": _4 }], "dm": _47, "do": [1, { "art": _3, "com": _3, "edu": _3, "gob": _3, "gov": _3, "mil": _3, "net": _3, "org": _3, "sld": _3, "web": _3 }], "dz": [1, { "art": _3, "asso": _3, "com": _3, "edu": _3, "gov": _3, "net": _3, "org": _3, "pol": _3, "soc": _3, "tm": _3 }], "ec": [1, { "com": _3, "edu": _3, "fin": _3, "gob": _3, "gov": _3, "info": _3, "k12": _3, "med": _3, "mil": _3, "net": _3, "org": _3, "pro": _3, "base": _4, "official": _4 }], "edu": [1, { "rit": [0, { "git-pages": _4 }] }], "ee": [1, { "aip": _3, "com": _3, "edu": _3, "fie": _3, "gov": _3, "lib": _3, "med": _3, "org": _3, "pri": _3, "riik": _3 }], "eg": [1, { "ac": _3, "com": _3, "edu": _3, "eun": _3, "gov": _3, "info": _3, "me": _3, "mil": _3, "name": _3, "net": _3, "org": _3, "sci": _3, "sport": _3, "tv": _3 }], "er": _18, "es": [1, { "com": _3, "edu": _3, "gob": _3, "nom": _3, "org": _3, "123miweb": _4, "myspreadshop": _4 }], "et": [1, { "biz": _3, "com": _3, "edu": _3, "gov": _3, "info": _3, "name": _3, "net": _3, "org": _3 }], "eu": [1, { "airkitapps": _4, "cloudns": _4, "dogado": [0, { "jelastic": _4 }], "barsy": _4, "spdns": _4, "transurl": _7, "diskstation": _4 }], "fi": [1, { "aland": _3, "dy": _4, "xn--hkkinen-5wa": _4, "häkkinen": _4, "iki": _4, "cloudplatform": [0, { "fi": _4 }], "datacenter": [0, { "demo": _4, "paas": _4 }], "kapsi": _4, "123kotisivu": _4, "myspreadshop": _4 }], "fj": [1, { "ac": _3, "biz": _3, "com": _3, "gov": _3, "info": _3, "mil": _3, "name": _3, "net": _3, "org": _3, "pro": _3 }], "fk": _18, "fm": [1, { "com": _3, "edu": _3, "net": _3, "org": _3, "radio": _4, "user": _7 }], "fo": _3, "fr": [1, { "asso": _3, "com": _3, "gouv": _3, "nom": _3, "prd": _3, "tm": _3, "avoues": _3, "cci": _3, "greta": _3, "huissier-justice": _3, "en-root": _4, "fbx-os": _4, "fbxos": _4, "freebox-os": _4, "freeboxos": _4, "goupile": _4, "123siteweb": _4, "on-web": _4, "chirurgiens-dentistes-en-france": _4, "dedibox": _4, "aeroport": _4, "avocat": _4, "chambagri": _4, "chirurgiens-dentistes": _4, "experts-comptables": _4, "medecin": _4, "notaires": _4, "pharmacien": _4, "port": _4, "veterinaire": _4, "myspreadshop": _4, "ynh": _4 }], "ga": _3, "gb": _3, "gd": [1, { "edu": _3, "gov": _3 }], "ge": [1, { "com": _3, "edu": _3, "gov": _3, "net": _3, "org": _3, "pvt": _3, "school": _3 }], "gf": _3, "gg": [1, { "co": _3, "net": _3, "org": _3, "botdash": _4, "kaas": _4, "stackit": _4, "panel": [2, { "daemon": _4 }] }], "gh": [1, { "com": _3, "edu": _3, "gov": _3, "mil": _3, "org": _3 }], "gi": [1, { "com": _3, "edu": _3, "gov": _3, "ltd": _3, "mod": _3, "org": _3 }], "gl": [1, { "co": _3, "com": _3, "edu": _3, "net": _3, "org": _3, "biz": _4 }], "gm": _3, "gn": [1, { "ac": _3, "com": _3, "edu": _3, "gov": _3, "net": _3, "org": _3 }], "gov": _3, "gp": [1, { "asso": _3, "com": _3, "edu": _3, "mobi": _3, "net": _3, "org": _3 }], "gq": _3, "gr": [1, { "com": _3, "edu": _3, "gov": _3, "net": _3, "org": _3, "barsy": _4, "simplesite": _4 }], "gs": _3, "gt": [1, { "com": _3, "edu": _3, "gob": _3, "ind": _3, "mil": _3, "net": _3, "org": _3 }], "gu": [1, { "com": _3, "edu": _3, "gov": _3, "guam": _3, "info": _3, "net": _3, "org": _3, "web": _3 }], "gw": _3, "gy": _47, "hk": [1, { "com": _3, "edu": _3, "gov": _3, "idv": _3, "net": _3, "org": _3, "xn--ciqpn": _3, "个人": _3, "xn--gmqw5a": _3, "個人": _3, "xn--55qx5d": _3, "公司": _3, "xn--mxtq1m": _3, "政府": _3, "xn--lcvr32d": _3, "敎育": _3, "xn--wcvs22d": _3, "教育": _3, "xn--gmq050i": _3, "箇人": _3, "xn--uc0atv": _3, "組織": _3, "xn--uc0ay4a": _3, "組织": _3, "xn--od0alg": _3, "網絡": _3, "xn--zf0avx": _3, "網络": _3, "xn--mk0axi": _3, "组織": _3, "xn--tn0ag": _3, "组织": _3, "xn--od0aq3b": _3, "网絡": _3, "xn--io0a7i": _3, "网络": _3, "inc": _4, "ltd": _4 }], "hm": _3, "hn": [1, { "com": _3, "edu": _3, "gob": _3, "mil": _3, "net": _3, "org": _3 }], "hr": [1, { "com": _3, "from": _3, "iz": _3, "name": _3, "brendly": _50 }], "ht": [1, { "adult": _3, "art": _3, "asso": _3, "com": _3, "coop": _3, "edu": _3, "firm": _3, "gouv": _3, "info": _3, "med": _3, "net": _3, "org": _3, "perso": _3, "pol": _3, "pro": _3, "rel": _3, "shop": _3, "rt": _4 }], "hu": [1, { "2000": _3, "agrar": _3, "bolt": _3, "casino": _3, "city": _3, "co": _3, "erotica": _3, "erotika": _3, "film": _3, "forum": _3, "games": _3, "hotel": _3, "info": _3, "ingatlan": _3, "jogasz": _3, "konyvelo": _3, "lakas": _3, "media": _3, "news": _3, "org": _3, "priv": _3, "reklam": _3, "sex": _3, "shop": _3, "sport": _3, "suli": _3, "szex": _3, "tm": _3, "tozsde": _3, "utazas": _3, "video": _3 }], "id": [1, { "ac": _3, "biz": _3, "co": _3, "desa": _3, "go": _3, "mil": _3, "my": _3, "net": _3, "or": _3, "ponpes": _3, "sch": _3, "web": _3, "zone": _4 }], "ie": [1, { "gov": _3, "myspreadshop": _4 }], "il": [1, { "ac": _3, "co": [1, { "ravpage": _4, "mytabit": _4, "tabitorder": _4 }], "gov": _3, "idf": _3, "k12": _3, "muni": _3, "net": _3, "org": _3 }], "xn--4dbrk0ce": [1, { "xn--4dbgdty6c": _3, "xn--5dbhl8d": _3, "xn--8dbq2a": _3, "xn--hebda8b": _3 }], "ישראל": [1, { "אקדמיה": _3, "ישוב": _3, "צהל": _3, "ממשל": _3 }], "im": [1, { "ac": _3, "co": [1, { "ltd": _3, "plc": _3 }], "com": _3, "net": _3, "org": _3, "tt": _3, "tv": _3 }], "in": [1, { "5g": _3, "6g": _3, "ac": _3, "ai": _3, "am": _3, "bihar": _3, "biz": _3, "business": _3, "ca": _3, "cn": _3, "co": _3, "com": _3, "coop": _3, "cs": _3, "delhi": _3, "dr": _3, "edu": _3, "er": _3, "firm": _3, "gen": _3, "gov": _3, "gujarat": _3, "ind": _3, "info": _3, "int": _3, "internet": _3, "io": _3, "me": _3, "mil": _3, "net": _3, "nic": _3, "org": _3, "pg": _3, "post": _3, "pro": _3, "res": _3, "travel": _3, "tv": _3, "uk": _3, "up": _3, "us": _3, "cloudns": _4, "barsy": _4, "web": _4, "supabase": _4 }], "info": [1, { "cloudns": _4, "dynamic-dns": _4, "barrel-of-knowledge": _4, "barrell-of-knowledge": _4, "dyndns": _4, "for-our": _4, "groks-the": _4, "groks-this": _4, "here-for-more": _4, "knowsitall": _4, "selfip": _4, "webhop": _4, "barsy": _4, "mayfirst": _4, "mittwald": _4, "mittwaldserver": _4, "typo3server": _4, "dvrcam": _4, "ilovecollege": _4, "no-ip": _4, "forumz": _4, "nsupdate": _4, "dnsupdate": _4, "v-info": _4 }], "int": [1, { "eu": _3 }], "io": [1, { "2038": _4, "co": _3, "com": _3, "edu": _3, "gov": _3, "mil": _3, "net": _3, "nom": _3, "org": _3, "on-acorn": _7, "myaddr": _4, "apigee": _4, "b-data": _4, "beagleboard": _4, "bitbucket": _4, "bluebite": _4, "boxfuse": _4, "brave": _8, "browsersafetymark": _4, "bubble": _51, "bubbleapps": _4, "bigv": [0, { "uk0": _4 }], "cleverapps": _4, "cloudbeesusercontent": _4, "dappnode": [0, { "dyndns": _4 }], "darklang": _4, "definima": _4, "dedyn": _4, "fh-muenster": _4, "shw": _4, "forgerock": [0, { "id": _4 }], "github": _4, "gitlab": _4, "lolipop": _4, "hasura-app": _4, "hostyhosting": _4, "hypernode": _4, "moonscale": _7, "beebyte": _40, "beebyteapp": [0, { "sekd1": _4 }], "jele": _4, "webthings": _4, "loginline": _4, "barsy": _4, "azurecontainer": _7, "ngrok": [2, { "ap": _4, "au": _4, "eu": _4, "in": _4, "jp": _4, "sa": _4, "us": _4 }], "nodeart": [0, { "stage": _4 }], "pantheonsite": _4, "pstmn": [2, { "mock": _4 }], "protonet": _4, "qcx": [2, { "sys": _7 }], "qoto": _4, "vaporcloud": _4, "myrdbx": _4, "rb-hosting": _43, "on-k3s": _7, "on-rio": _7, "readthedocs": _4, "resindevice": _4, "resinstaging": [0, { "devices": _4 }], "hzc": _4, "sandcats": _4, "scrypted": [0, { "client": _4 }], "mo-siemens": _4, "lair": _39, "stolos": _7, "musician": _4, "utwente": _4, "edugit": _4, "telebit": _4, "thingdust": [0, { "dev": _52, "disrec": _52, "prod": _53, "testing": _52 }], "tickets": _4, "webflow": _4, "webflowtest": _4, "editorx": _4, "wixstudio": _4, "basicserver": _4, "virtualserver": _4 }], "iq": _6, "ir": [1, { "ac": _3, "co": _3, "gov": _3, "id": _3, "net": _3, "org": _3, "sch": _3, "xn--mgba3a4f16a": _3, "ایران": _3, "xn--mgba3a4fra": _3, "ايران": _3, "arvanedge": _4 }], "is": _3, "it": [1, { "edu": _3, "gov": _3, "abr": _3, "abruzzo": _3, "aosta-valley": _3, "aostavalley": _3, "bas": _3, "basilicata": _3, "cal": _3, "calabria": _3, "cam": _3, "campania": _3, "emilia-romagna": _3, "emiliaromagna": _3, "emr": _3, "friuli-v-giulia": _3, "friuli-ve-giulia": _3, "friuli-vegiulia": _3, "friuli-venezia-giulia": _3, "friuli-veneziagiulia": _3, "friuli-vgiulia": _3, "friuliv-giulia": _3, "friulive-giulia": _3, "friulivegiulia": _3, "friulivenezia-giulia": _3, "friuliveneziagiulia": _3, "friulivgiulia": _3, "fvg": _3, "laz": _3, "lazio": _3, "lig": _3, "liguria": _3, "lom": _3, "lombardia": _3, "lombardy": _3, "lucania": _3, "mar": _3, "marche": _3, "mol": _3, "molise": _3, "piedmont": _3, "piemonte": _3, "pmn": _3, "pug": _3, "puglia": _3, "sar": _3, "sardegna": _3, "sardinia": _3, "sic": _3, "sicilia": _3, "sicily": _3, "taa": _3, "tos": _3, "toscana": _3, "trentin-sud-tirol": _3, "xn--trentin-sd-tirol-rzb": _3, "trentin-süd-tirol": _3, "trentin-sudtirol": _3, "xn--trentin-sdtirol-7vb": _3, "trentin-südtirol": _3, "trentin-sued-tirol": _3, "trentin-suedtirol": _3, "trentino": _3, "trentino-a-adige": _3, "trentino-aadige": _3, "trentino-alto-adige": _3, "trentino-altoadige": _3, "trentino-s-tirol": _3, "trentino-stirol": _3, "trentino-sud-tirol": _3, "xn--trentino-sd-tirol-c3b": _3, "trentino-süd-tirol": _3, "trentino-sudtirol": _3, "xn--trentino-sdtirol-szb": _3, "trentino-südtirol": _3, "trentino-sued-tirol": _3, "trentino-suedtirol": _3, "trentinoa-adige": _3, "trentinoaadige": _3, "trentinoalto-adige": _3, "trentinoaltoadige": _3, "trentinos-tirol": _3, "trentinostirol": _3, "trentinosud-tirol": _3, "xn--trentinosd-tirol-rzb": _3, "trentinosüd-tirol": _3, "trentinosudtirol": _3, "xn--trentinosdtirol-7vb": _3, "trentinosüdtirol": _3, "trentinosued-tirol": _3, "trentinosuedtirol": _3, "trentinsud-tirol": _3, "xn--trentinsd-tirol-6vb": _3, "trentinsüd-tirol": _3, "trentinsudtirol": _3, "xn--trentinsdtirol-nsb": _3, "trentinsüdtirol": _3, "trentinsued-tirol": _3, "trentinsuedtirol": _3, "tuscany": _3, "umb": _3, "umbria": _3, "val-d-aosta": _3, "val-daosta": _3, "vald-aosta": _3, "valdaosta": _3, "valle-aosta": _3, "valle-d-aosta": _3, "valle-daosta": _3, "valleaosta": _3, "valled-aosta": _3, "valledaosta": _3, "vallee-aoste": _3, "xn--valle-aoste-ebb": _3, "vallée-aoste": _3, "vallee-d-aoste": _3, "xn--valle-d-aoste-ehb": _3, "vallée-d-aoste": _3, "valleeaoste": _3, "xn--valleaoste-e7a": _3, "valléeaoste": _3, "valleedaoste": _3, "xn--valledaoste-ebb": _3, "valléedaoste": _3, "vao": _3, "vda": _3, "ven": _3, "veneto": _3, "ag": _3, "agrigento": _3, "al": _3, "alessandria": _3, "alto-adige": _3, "altoadige": _3, "an": _3, "ancona": _3, "andria-barletta-trani": _3, "andria-trani-barletta": _3, "andriabarlettatrani": _3, "andriatranibarletta": _3, "ao": _3, "aosta": _3, "aoste": _3, "ap": _3, "aq": _3, "aquila": _3, "ar": _3, "arezzo": _3, "ascoli-piceno": _3, "ascolipiceno": _3, "asti": _3, "at": _3, "av": _3, "avellino": _3, "ba": _3, "balsan": _3, "balsan-sudtirol": _3, "xn--balsan-sdtirol-nsb": _3, "balsan-südtirol": _3, "balsan-suedtirol": _3, "bari": _3, "barletta-trani-andria": _3, "barlettatraniandria": _3, "belluno": _3, "benevento": _3, "bergamo": _3, "bg": _3, "bi": _3, "biella": _3, "bl": _3, "bn": _3, "bo": _3, "bologna": _3, "bolzano": _3, "bolzano-altoadige": _3, "bozen": _3, "bozen-sudtirol": _3, "xn--bozen-sdtirol-2ob": _3, "bozen-südtirol": _3, "bozen-suedtirol": _3, "br": _3, "brescia": _3, "brindisi": _3, "bs": _3, "bt": _3, "bulsan": _3, "bulsan-sudtirol": _3, "xn--bulsan-sdtirol-nsb": _3, "bulsan-südtirol": _3, "bulsan-suedtirol": _3, "bz": _3, "ca": _3, "cagliari": _3, "caltanissetta": _3, "campidano-medio": _3, "campidanomedio": _3, "campobasso": _3, "carbonia-iglesias": _3, "carboniaiglesias": _3, "carrara-massa": _3, "carraramassa": _3, "caserta": _3, "catania": _3, "catanzaro": _3, "cb": _3, "ce": _3, "cesena-forli": _3, "xn--cesena-forl-mcb": _3, "cesena-forlì": _3, "cesenaforli": _3, "xn--cesenaforl-i8a": _3, "cesenaforlì": _3, "ch": _3, "chieti": _3, "ci": _3, "cl": _3, "cn": _3, "co": _3, "como": _3, "cosenza": _3, "cr": _3, "cremona": _3, "crotone": _3, "cs": _3, "ct": _3, "cuneo": _3, "cz": _3, "dell-ogliastra": _3, "dellogliastra": _3, "en": _3, "enna": _3, "fc": _3, "fe": _3, "fermo": _3, "ferrara": _3, "fg": _3, "fi": _3, "firenze": _3, "florence": _3, "fm": _3, "foggia": _3, "forli-cesena": _3, "xn--forl-cesena-fcb": _3, "forlì-cesena": _3, "forlicesena": _3, "xn--forlcesena-c8a": _3, "forlìcesena": _3, "fr": _3, "frosinone": _3, "ge": _3, "genoa": _3, "genova": _3, "go": _3, "gorizia": _3, "gr": _3, "grosseto": _3, "iglesias-carbonia": _3, "iglesiascarbonia": _3, "im": _3, "imperia": _3, "is": _3, "isernia": _3, "kr": _3, "la-spezia": _3, "laquila": _3, "laspezia": _3, "latina": _3, "lc": _3, "le": _3, "lecce": _3, "lecco": _3, "li": _3, "livorno": _3, "lo": _3, "lodi": _3, "lt": _3, "lu": _3, "lucca": _3, "macerata": _3, "mantova": _3, "massa-carrara": _3, "massacarrara": _3, "matera": _3, "mb": _3, "mc": _3, "me": _3, "medio-campidano": _3, "mediocampidano": _3, "messina": _3, "mi": _3, "milan": _3, "milano": _3, "mn": _3, "mo": _3, "modena": _3, "monza": _3, "monza-brianza": _3, "monza-e-della-brianza": _3, "monzabrianza": _3, "monzaebrianza": _3, "monzaedellabrianza": _3, "ms": _3, "mt": _3, "na": _3, "naples": _3, "napoli": _3, "no": _3, "novara": _3, "nu": _3, "nuoro": _3, "og": _3, "ogliastra": _3, "olbia-tempio": _3, "olbiatempio": _3, "or": _3, "oristano": _3, "ot": _3, "pa": _3, "padova": _3, "padua": _3, "palermo": _3, "parma": _3, "pavia": _3, "pc": _3, "pd": _3, "pe": _3, "perugia": _3, "pesaro-urbino": _3, "pesarourbino": _3, "pescara": _3, "pg": _3, "pi": _3, "piacenza": _3, "pisa": _3, "pistoia": _3, "pn": _3, "po": _3, "pordenone": _3, "potenza": _3, "pr": _3, "prato": _3, "pt": _3, "pu": _3, "pv": _3, "pz": _3, "ra": _3, "ragusa": _3, "ravenna": _3, "rc": _3, "re": _3, "reggio-calabria": _3, "reggio-emilia": _3, "reggiocalabria": _3, "reggioemilia": _3, "rg": _3, "ri": _3, "rieti": _3, "rimini": _3, "rm": _3, "rn": _3, "ro": _3, "roma": _3, "rome": _3, "rovigo": _3, "sa": _3, "salerno": _3, "sassari": _3, "savona": _3, "si": _3, "siena": _3, "siracusa": _3, "so": _3, "sondrio": _3, "sp": _3, "sr": _3, "ss": _3, "xn--sdtirol-n2a": _3, "südtirol": _3, "suedtirol": _3, "sv": _3, "ta": _3, "taranto": _3, "te": _3, "tempio-olbia": _3, "tempioolbia": _3, "teramo": _3, "terni": _3, "tn": _3, "to": _3, "torino": _3, "tp": _3, "tr": _3, "trani-andria-barletta": _3, "trani-barletta-andria": _3, "traniandriabarletta": _3, "tranibarlettaandria": _3, "trapani": _3, "trento": _3, "treviso": _3, "trieste": _3, "ts": _3, "turin": _3, "tv": _3, "ud": _3, "udine": _3, "urbino-pesaro": _3, "urbinopesaro": _3, "va": _3, "varese": _3, "vb": _3, "vc": _3, "ve": _3, "venezia": _3, "venice": _3, "verbania": _3, "vercelli": _3, "verona": _3, "vi": _3, "vibo-valentia": _3, "vibovalentia": _3, "vicenza": _3, "viterbo": _3, "vr": _3, "vs": _3, "vt": _3, "vv": _3, "12chars": _4, "ibxos": _4, "iliadboxos": _4, "neen": [0, { "jc": _4 }], "123homepage": _4, "16-b": _4, "32-b": _4, "64-b": _4, "myspreadshop": _4, "syncloud": _4 }], "je": [1, { "co": _3, "net": _3, "org": _3, "of": _4 }], "jm": _18, "jo": [1, { "agri": _3, "ai": _3, "com": _3, "edu": _3, "eng": _3, "fm": _3, "gov": _3, "mil": _3, "net": _3, "org": _3, "per": _3, "phd": _3, "sch": _3, "tv": _3 }], "jobs": _3, "jp": [1, { "ac": _3, "ad": _3, "co": _3, "ed": _3, "go": _3, "gr": _3, "lg": _3, "ne": [1, { "aseinet": _49, "gehirn": _4, "ivory": _4, "mail-box": _4, "mints": _4, "mokuren": _4, "opal": _4, "sakura": _4, "sumomo": _4, "topaz": _4 }], "or": _3, "aichi": [1, { "aisai": _3, "ama": _3, "anjo": _3, "asuke": _3, "chiryu": _3, "chita": _3, "fuso": _3, "gamagori": _3, "handa": _3, "hazu": _3, "hekinan": _3, "higashiura": _3, "ichinomiya": _3, "inazawa": _3, "inuyama": _3, "isshiki": _3, "iwakura": _3, "kanie": _3, "kariya": _3, "kasugai": _3, "kira": _3, "kiyosu": _3, "komaki": _3, "konan": _3, "kota": _3, "mihama": _3, "miyoshi": _3, "nishio": _3, "nisshin": _3, "obu": _3, "oguchi": _3, "oharu": _3, "okazaki": _3, "owariasahi": _3, "seto": _3, "shikatsu": _3, "shinshiro": _3, "shitara": _3, "tahara": _3, "takahama": _3, "tobishima": _3, "toei": _3, "togo": _3, "tokai": _3, "tokoname": _3, "toyoake": _3, "toyohashi": _3, "toyokawa": _3, "toyone": _3, "toyota": _3, "tsushima": _3, "yatomi": _3 }], "akita": [1, { "akita": _3, "daisen": _3, "fujisato": _3, "gojome": _3, "hachirogata": _3, "happou": _3, "higashinaruse": _3, "honjo": _3, "honjyo": _3, "ikawa": _3, "kamikoani": _3, "kamioka": _3, "katagami": _3, "kazuno": _3, "kitaakita": _3, "kosaka": _3, "kyowa": _3, "misato": _3, "mitane": _3, "moriyoshi": _3, "nikaho": _3, "noshiro": _3, "odate": _3, "oga": _3, "ogata": _3, "semboku": _3, "yokote": _3, "yurihonjo": _3 }], "aomori": [1, { "aomori": _3, "gonohe": _3, "hachinohe": _3, "hashikami": _3, "hiranai": _3, "hirosaki": _3, "itayanagi": _3, "kuroishi": _3, "misawa": _3, "mutsu": _3, "nakadomari": _3, "noheji": _3, "oirase": _3, "owani": _3, "rokunohe": _3, "sannohe": _3, "shichinohe": _3, "shingo": _3, "takko": _3, "towada": _3, "tsugaru": _3, "tsuruta": _3 }], "chiba": [1, { "abiko": _3, "asahi": _3, "chonan": _3, "chosei": _3, "choshi": _3, "chuo": _3, "funabashi": _3, "futtsu": _3, "hanamigawa": _3, "ichihara": _3, "ichikawa": _3, "ichinomiya": _3, "inzai": _3, "isumi": _3, "kamagaya": _3, "kamogawa": _3, "kashiwa": _3, "katori": _3, "katsuura": _3, "kimitsu": _3, "kisarazu": _3, "kozaki": _3, "kujukuri": _3, "kyonan": _3, "matsudo": _3, "midori": _3, "mihama": _3, "minamiboso": _3, "mobara": _3, "mutsuzawa": _3, "nagara": _3, "nagareyama": _3, "narashino": _3, "narita": _3, "noda": _3, "oamishirasato": _3, "omigawa": _3, "onjuku": _3, "otaki": _3, "sakae": _3, "sakura": _3, "shimofusa": _3, "shirako": _3, "shiroi": _3, "shisui": _3, "sodegaura": _3, "sosa": _3, "tako": _3, "tateyama": _3, "togane": _3, "tohnosho": _3, "tomisato": _3, "urayasu": _3, "yachimata": _3, "yachiyo": _3, "yokaichiba": _3, "yokoshibahikari": _3, "yotsukaido": _3 }], "ehime": [1, { "ainan": _3, "honai": _3, "ikata": _3, "imabari": _3, "iyo": _3, "kamijima": _3, "kihoku": _3, "kumakogen": _3, "masaki": _3, "matsuno": _3, "matsuyama": _3, "namikata": _3, "niihama": _3, "ozu": _3, "saijo": _3, "seiyo": _3, "shikokuchuo": _3, "tobe": _3, "toon": _3, "uchiko": _3, "uwajima": _3, "yawatahama": _3 }], "fukui": [1, { "echizen": _3, "eiheiji": _3, "fukui": _3, "ikeda": _3, "katsuyama": _3, "mihama": _3, "minamiechizen": _3, "obama": _3, "ohi": _3, "ono": _3, "sabae": _3, "sakai": _3, "takahama": _3, "tsuruga": _3, "wakasa": _3 }], "fukuoka": [1, { "ashiya": _3, "buzen": _3, "chikugo": _3, "chikuho": _3, "chikujo": _3, "chikushino": _3, "chikuzen": _3, "chuo": _3, "dazaifu": _3, "fukuchi": _3, "hakata": _3, "higashi": _3, "hirokawa": _3, "hisayama": _3, "iizuka": _3, "inatsuki": _3, "kaho": _3, "kasuga": _3, "kasuya": _3, "kawara": _3, "keisen": _3, "koga": _3, "kurate": _3, "kurogi": _3, "kurume": _3, "minami": _3, "miyako": _3, "miyama": _3, "miyawaka": _3, "mizumaki": _3, "munakata": _3, "nakagawa": _3, "nakama": _3, "nishi": _3, "nogata": _3, "ogori": _3, "okagaki": _3, "okawa": _3, "oki": _3, "omuta": _3, "onga": _3, "onojo": _3, "oto": _3, "saigawa": _3, "sasaguri": _3, "shingu": _3, "shinyoshitomi": _3, "shonai": _3, "soeda": _3, "sue": _3, "tachiarai": _3, "tagawa": _3, "takata": _3, "toho": _3, "toyotsu": _3, "tsuiki": _3, "ukiha": _3, "umi": _3, "usui": _3, "yamada": _3, "yame": _3, "yanagawa": _3, "yukuhashi": _3 }], "fukushima": [1, { "aizubange": _3, "aizumisato": _3, "aizuwakamatsu": _3, "asakawa": _3, "bandai": _3, "date": _3, "fukushima": _3, "furudono": _3, "futaba": _3, "hanawa": _3, "higashi": _3, "hirata": _3, "hirono": _3, "iitate": _3, "inawashiro": _3, "ishikawa": _3, "iwaki": _3, "izumizaki": _3, "kagamiishi": _3, "kaneyama": _3, "kawamata": _3, "kitakata": _3, "kitashiobara": _3, "koori": _3, "koriyama": _3, "kunimi": _3, "miharu": _3, "mishima": _3, "namie": _3, "nango": _3, "nishiaizu": _3, "nishigo": _3, "okuma": _3, "omotego": _3, "ono": _3, "otama": _3, "samegawa": _3, "shimogo": _3, "shirakawa": _3, "showa": _3, "soma": _3, "sukagawa": _3, "taishin": _3, "tamakawa": _3, "tanagura": _3, "tenei": _3, "yabuki": _3, "yamato": _3, "yamatsuri": _3, "yanaizu": _3, "yugawa": _3 }], "gifu": [1, { "anpachi": _3, "ena": _3, "gifu": _3, "ginan": _3, "godo": _3, "gujo": _3, "hashima": _3, "hichiso": _3, "hida": _3, "higashishirakawa": _3, "ibigawa": _3, "ikeda": _3, "kakamigahara": _3, "kani": _3, "kasahara": _3, "kasamatsu": _3, "kawaue": _3, "kitagata": _3, "mino": _3, "minokamo": _3, "mitake": _3, "mizunami": _3, "motosu": _3, "nakatsugawa": _3, "ogaki": _3, "sakahogi": _3, "seki": _3, "sekigahara": _3, "shirakawa": _3, "tajimi": _3, "takayama": _3, "tarui": _3, "toki": _3, "tomika": _3, "wanouchi": _3, "yamagata": _3, "yaotsu": _3, "yoro": _3 }], "gunma": [1, { "annaka": _3, "chiyoda": _3, "fujioka": _3, "higashiagatsuma": _3, "isesaki": _3, "itakura": _3, "kanna": _3, "kanra": _3, "katashina": _3, "kawaba": _3, "kiryu": _3, "kusatsu": _3, "maebashi": _3, "meiwa": _3, "midori": _3, "minakami": _3, "naganohara": _3, "nakanojo": _3, "nanmoku": _3, "numata": _3, "oizumi": _3, "ora": _3, "ota": _3, "shibukawa": _3, "shimonita": _3, "shinto": _3, "showa": _3, "takasaki": _3, "takayama": _3, "tamamura": _3, "tatebayashi": _3, "tomioka": _3, "tsukiyono": _3, "tsumagoi": _3, "ueno": _3, "yoshioka": _3 }], "hiroshima": [1, { "asaminami": _3, "daiwa": _3, "etajima": _3, "fuchu": _3, "fukuyama": _3, "hatsukaichi": _3, "higashihiroshima": _3, "hongo": _3, "jinsekikogen": _3, "kaita": _3, "kui": _3, "kumano": _3, "kure": _3, "mihara": _3, "miyoshi": _3, "naka": _3, "onomichi": _3, "osakikamijima": _3, "otake": _3, "saka": _3, "sera": _3, "seranishi": _3, "shinichi": _3, "shobara": _3, "takehara": _3 }], "hokkaido": [1, { "abashiri": _3, "abira": _3, "aibetsu": _3, "akabira": _3, "akkeshi": _3, "asahikawa": _3, "ashibetsu": _3, "ashoro": _3, "assabu": _3, "atsuma": _3, "bibai": _3, "biei": _3, "bifuka": _3, "bihoro": _3, "biratori": _3, "chippubetsu": _3, "chitose": _3, "date": _3, "ebetsu": _3, "embetsu": _3, "eniwa": _3, "erimo": _3, "esan": _3, "esashi": _3, "fukagawa": _3, "fukushima": _3, "furano": _3, "furubira": _3, "haboro": _3, "hakodate": _3, "hamatonbetsu": _3, "hidaka": _3, "higashikagura": _3, "higashikawa": _3, "hiroo": _3, "hokuryu": _3, "hokuto": _3, "honbetsu": _3, "horokanai": _3, "horonobe": _3, "ikeda": _3, "imakane": _3, "ishikari": _3, "iwamizawa": _3, "iwanai": _3, "kamifurano": _3, "kamikawa": _3, "kamishihoro": _3, "kamisunagawa": _3, "kamoenai": _3, "kayabe": _3, "kembuchi": _3, "kikonai": _3, "kimobetsu": _3, "kitahiroshima": _3, "kitami": _3, "kiyosato": _3, "koshimizu": _3, "kunneppu": _3, "kuriyama": _3, "kuromatsunai": _3, "kushiro": _3, "kutchan": _3, "kyowa": _3, "mashike": _3, "matsumae": _3, "mikasa": _3, "minamifurano": _3, "mombetsu": _3, "moseushi": _3, "mukawa": _3, "muroran": _3, "naie": _3, "nakagawa": _3, "nakasatsunai": _3, "nakatombetsu": _3, "nanae": _3, "nanporo": _3, "nayoro": _3, "nemuro": _3, "niikappu": _3, "niki": _3, "nishiokoppe": _3, "noboribetsu": _3, "numata": _3, "obihiro": _3, "obira": _3, "oketo": _3, "okoppe": _3, "otaru": _3, "otobe": _3, "otofuke": _3, "otoineppu": _3, "oumu": _3, "ozora": _3, "pippu": _3, "rankoshi": _3, "rebun": _3, "rikubetsu": _3, "rishiri": _3, "rishirifuji": _3, "saroma": _3, "sarufutsu": _3, "shakotan": _3, "shari": _3, "shibecha": _3, "shibetsu": _3, "shikabe": _3, "shikaoi": _3, "shimamaki": _3, "shimizu": _3, "shimokawa": _3, "shinshinotsu": _3, "shintoku": _3, "shiranuka": _3, "shiraoi": _3, "shiriuchi": _3, "sobetsu": _3, "sunagawa": _3, "taiki": _3, "takasu": _3, "takikawa": _3, "takinoue": _3, "teshikaga": _3, "tobetsu": _3, "tohma": _3, "tomakomai": _3, "tomari": _3, "toya": _3, "toyako": _3, "toyotomi": _3, "toyoura": _3, "tsubetsu": _3, "tsukigata": _3, "urakawa": _3, "urausu": _3, "uryu": _3, "utashinai": _3, "wakkanai": _3, "wassamu": _3, "yakumo": _3, "yoichi": _3 }], "hyogo": [1, { "aioi": _3, "akashi": _3, "ako": _3, "amagasaki": _3, "aogaki": _3, "asago": _3, "ashiya": _3, "awaji": _3, "fukusaki": _3, "goshiki": _3, "harima": _3, "himeji": _3, "ichikawa": _3, "inagawa": _3, "itami": _3, "kakogawa": _3, "kamigori": _3, "kamikawa": _3, "kasai": _3, "kasuga": _3, "kawanishi": _3, "miki": _3, "minamiawaji": _3, "nishinomiya": _3, "nishiwaki": _3, "ono": _3, "sanda": _3, "sannan": _3, "sasayama": _3, "sayo": _3, "shingu": _3, "shinonsen": _3, "shiso": _3, "sumoto": _3, "taishi": _3, "taka": _3, "takarazuka": _3, "takasago": _3, "takino": _3, "tamba": _3, "tatsuno": _3, "toyooka": _3, "yabu": _3, "yashiro": _3, "yoka": _3, "yokawa": _3 }], "ibaraki": [1, { "ami": _3, "asahi": _3, "bando": _3, "chikusei": _3, "daigo": _3, "fujishiro": _3, "hitachi": _3, "hitachinaka": _3, "hitachiomiya": _3, "hitachiota": _3, "ibaraki": _3, "ina": _3, "inashiki": _3, "itako": _3, "iwama": _3, "joso": _3, "kamisu": _3, "kasama": _3, "kashima": _3, "kasumigaura": _3, "koga": _3, "miho": _3, "mito": _3, "moriya": _3, "naka": _3, "namegata": _3, "oarai": _3, "ogawa": _3, "omitama": _3, "ryugasaki": _3, "sakai": _3, "sakuragawa": _3, "shimodate": _3, "shimotsuma": _3, "shirosato": _3, "sowa": _3, "suifu": _3, "takahagi": _3, "tamatsukuri": _3, "tokai": _3, "tomobe": _3, "tone": _3, "toride": _3, "tsuchiura": _3, "tsukuba": _3, "uchihara": _3, "ushiku": _3, "yachiyo": _3, "yamagata": _3, "yawara": _3, "yuki": _3 }], "ishikawa": [1, { "anamizu": _3, "hakui": _3, "hakusan": _3, "kaga": _3, "kahoku": _3, "kanazawa": _3, "kawakita": _3, "komatsu": _3, "nakanoto": _3, "nanao": _3, "nomi": _3, "nonoichi": _3, "noto": _3, "shika": _3, "suzu": _3, "tsubata": _3, "tsurugi": _3, "uchinada": _3, "wajima": _3 }], "iwate": [1, { "fudai": _3, "fujisawa": _3, "hanamaki": _3, "hiraizumi": _3, "hirono": _3, "ichinohe": _3, "ichinoseki": _3, "iwaizumi": _3, "iwate": _3, "joboji": _3, "kamaishi": _3, "kanegasaki": _3, "karumai": _3, "kawai": _3, "kitakami": _3, "kuji": _3, "kunohe": _3, "kuzumaki": _3, "miyako": _3, "mizusawa": _3, "morioka": _3, "ninohe": _3, "noda": _3, "ofunato": _3, "oshu": _3, "otsuchi": _3, "rikuzentakata": _3, "shiwa": _3, "shizukuishi": _3, "sumita": _3, "tanohata": _3, "tono": _3, "yahaba": _3, "yamada": _3 }], "kagawa": [1, { "ayagawa": _3, "higashikagawa": _3, "kanonji": _3, "kotohira": _3, "manno": _3, "marugame": _3, "mitoyo": _3, "naoshima": _3, "sanuki": _3, "tadotsu": _3, "takamatsu": _3, "tonosho": _3, "uchinomi": _3, "utazu": _3, "zentsuji": _3 }], "kagoshima": [1, { "akune": _3, "amami": _3, "hioki": _3, "isa": _3, "isen": _3, "izumi": _3, "kagoshima": _3, "kanoya": _3, "kawanabe": _3, "kinko": _3, "kouyama": _3, "makurazaki": _3, "matsumoto": _3, "minamitane": _3, "nakatane": _3, "nishinoomote": _3, "satsumasendai": _3, "soo": _3, "tarumizu": _3, "yusui": _3 }], "kanagawa": [1, { "aikawa": _3, "atsugi": _3, "ayase": _3, "chigasaki": _3, "ebina": _3, "fujisawa": _3, "hadano": _3, "hakone": _3, "hiratsuka": _3, "isehara": _3, "kaisei": _3, "kamakura": _3, "kiyokawa": _3, "matsuda": _3, "minamiashigara": _3, "miura": _3, "nakai": _3, "ninomiya": _3, "odawara": _3, "oi": _3, "oiso": _3, "sagamihara": _3, "samukawa": _3, "tsukui": _3, "yamakita": _3, "yamato": _3, "yokosuka": _3, "yugawara": _3, "zama": _3, "zushi": _3 }], "kochi": [1, { "aki": _3, "geisei": _3, "hidaka": _3, "higashitsuno": _3, "ino": _3, "kagami": _3, "kami": _3, "kitagawa": _3, "kochi": _3, "mihara": _3, "motoyama": _3, "muroto": _3, "nahari": _3, "nakamura": _3, "nankoku": _3, "nishitosa": _3, "niyodogawa": _3, "ochi": _3, "okawa": _3, "otoyo": _3, "otsuki": _3, "sakawa": _3, "sukumo": _3, "susaki": _3, "tosa": _3, "tosashimizu": _3, "toyo": _3, "tsuno": _3, "umaji": _3, "yasuda": _3, "yusuhara": _3 }], "kumamoto": [1, { "amakusa": _3, "arao": _3, "aso": _3, "choyo": _3, "gyokuto": _3, "kamiamakusa": _3, "kikuchi": _3, "kumamoto": _3, "mashiki": _3, "mifune": _3, "minamata": _3, "minamioguni": _3, "nagasu": _3, "nishihara": _3, "oguni": _3, "ozu": _3, "sumoto": _3, "takamori": _3, "uki": _3, "uto": _3, "yamaga": _3, "yamato": _3, "yatsushiro": _3 }], "kyoto": [1, { "ayabe": _3, "fukuchiyama": _3, "higashiyama": _3, "ide": _3, "ine": _3, "joyo": _3, "kameoka": _3, "kamo": _3, "kita": _3, "kizu": _3, "kumiyama": _3, "kyotamba": _3, "kyotanabe": _3, "kyotango": _3, "maizuru": _3, "minami": _3, "minamiyamashiro": _3, "miyazu": _3, "muko": _3, "nagaokakyo": _3, "nakagyo": _3, "nantan": _3, "oyamazaki": _3, "sakyo": _3, "seika": _3, "tanabe": _3, "uji": _3, "ujitawara": _3, "wazuka": _3, "yamashina": _3, "yawata": _3 }], "mie": [1, { "asahi": _3, "inabe": _3, "ise": _3, "kameyama": _3, "kawagoe": _3, "kiho": _3, "kisosaki": _3, "kiwa": _3, "komono": _3, "kumano": _3, "kuwana": _3, "matsusaka": _3, "meiwa": _3, "mihama": _3, "minamiise": _3, "misugi": _3, "miyama": _3, "nabari": _3, "shima": _3, "suzuka": _3, "tado": _3, "taiki": _3, "taki": _3, "tamaki": _3, "toba": _3, "tsu": _3, "udono": _3, "ureshino": _3, "watarai": _3, "yokkaichi": _3 }], "miyagi": [1, { "furukawa": _3, "higashimatsushima": _3, "ishinomaki": _3, "iwanuma": _3, "kakuda": _3, "kami": _3, "kawasaki": _3, "marumori": _3, "matsushima": _3, "minamisanriku": _3, "misato": _3, "murata": _3, "natori": _3, "ogawara": _3, "ohira": _3, "onagawa": _3, "osaki": _3, "rifu": _3, "semine": _3, "shibata": _3, "shichikashuku": _3, "shikama": _3, "shiogama": _3, "shiroishi": _3, "tagajo": _3, "taiwa": _3, "tome": _3, "tomiya": _3, "wakuya": _3, "watari": _3, "yamamoto": _3, "zao": _3 }], "miyazaki": [1, { "aya": _3, "ebino": _3, "gokase": _3, "hyuga": _3, "kadogawa": _3, "kawaminami": _3, "kijo": _3, "kitagawa": _3, "kitakata": _3, "kitaura": _3, "kobayashi": _3, "kunitomi": _3, "kushima": _3, "mimata": _3, "miyakonojo": _3, "miyazaki": _3, "morotsuka": _3, "nichinan": _3, "nishimera": _3, "nobeoka": _3, "saito": _3, "shiiba": _3, "shintomi": _3, "takaharu": _3, "takanabe": _3, "takazaki": _3, "tsuno": _3 }], "nagano": [1, { "achi": _3, "agematsu": _3, "anan": _3, "aoki": _3, "asahi": _3, "azumino": _3, "chikuhoku": _3, "chikuma": _3, "chino": _3, "fujimi": _3, "hakuba": _3, "hara": _3, "hiraya": _3, "iida": _3, "iijima": _3, "iiyama": _3, "iizuna": _3, "ikeda": _3, "ikusaka": _3, "ina": _3, "karuizawa": _3, "kawakami": _3, "kiso": _3, "kisofukushima": _3, "kitaaiki": _3, "komagane": _3, "komoro": _3, "matsukawa": _3, "matsumoto": _3, "miasa": _3, "minamiaiki": _3, "minamimaki": _3, "minamiminowa": _3, "minowa": _3, "miyada": _3, "miyota": _3, "mochizuki": _3, "nagano": _3, "nagawa": _3, "nagiso": _3, "nakagawa": _3, "nakano": _3, "nozawaonsen": _3, "obuse": _3, "ogawa": _3, "okaya": _3, "omachi": _3, "omi": _3, "ookuwa": _3, "ooshika": _3, "otaki": _3, "otari": _3, "sakae": _3, "sakaki": _3, "saku": _3, "sakuho": _3, "shimosuwa": _3, "shinanomachi": _3, "shiojiri": _3, "suwa": _3, "suzaka": _3, "takagi": _3, "takamori": _3, "takayama": _3, "tateshina": _3, "tatsuno": _3, "togakushi": _3, "togura": _3, "tomi": _3, "ueda": _3, "wada": _3, "yamagata": _3, "yamanouchi": _3, "yasaka": _3, "yasuoka": _3 }], "nagasaki": [1, { "chijiwa": _3, "futsu": _3, "goto": _3, "hasami": _3, "hirado": _3, "iki": _3, "isahaya": _3, "kawatana": _3, "kuchinotsu": _3, "matsuura": _3, "nagasaki": _3, "obama": _3, "omura": _3, "oseto": _3, "saikai": _3, "sasebo": _3, "seihi": _3, "shimabara": _3, "shinkamigoto": _3, "togitsu": _3, "tsushima": _3, "unzen": _3 }], "nara": [1, { "ando": _3, "gose": _3, "heguri": _3, "higashiyoshino": _3, "ikaruga": _3, "ikoma": _3, "kamikitayama": _3, "kanmaki": _3, "kashiba": _3, "kashihara": _3, "katsuragi": _3, "kawai": _3, "kawakami": _3, "kawanishi": _3, "koryo": _3, "kurotaki": _3, "mitsue": _3, "miyake": _3, "nara": _3, "nosegawa": _3, "oji": _3, "ouda": _3, "oyodo": _3, "sakurai": _3, "sango": _3, "shimoichi": _3, "shimokitayama": _3, "shinjo": _3, "soni": _3, "takatori": _3, "tawaramoto": _3, "tenkawa": _3, "tenri": _3, "uda": _3, "yamatokoriyama": _3, "yamatotakada": _3, "yamazoe": _3, "yoshino": _3 }], "niigata": [1, { "aga": _3, "agano": _3, "gosen": _3, "itoigawa": _3, "izumozaki": _3, "joetsu": _3, "kamo": _3, "kariwa": _3, "kashiwazaki": _3, "minamiuonuma": _3, "mitsuke": _3, "muika": _3, "murakami": _3, "myoko": _3, "nagaoka": _3, "niigata": _3, "ojiya": _3, "omi": _3, "sado": _3, "sanjo": _3, "seiro": _3, "seirou": _3, "sekikawa": _3, "shibata": _3, "tagami": _3, "tainai": _3, "tochio": _3, "tokamachi": _3, "tsubame": _3, "tsunan": _3, "uonuma": _3, "yahiko": _3, "yoita": _3, "yuzawa": _3 }], "oita": [1, { "beppu": _3, "bungoono": _3, "bungotakada": _3, "hasama": _3, "hiji": _3, "himeshima": _3, "hita": _3, "kamitsue": _3, "kokonoe": _3, "kuju": _3, "kunisaki": _3, "kusu": _3, "oita": _3, "saiki": _3, "taketa": _3, "tsukumi": _3, "usa": _3, "usuki": _3, "yufu": _3 }], "okayama": [1, { "akaiwa": _3, "asakuchi": _3, "bizen": _3, "hayashima": _3, "ibara": _3, "kagamino": _3, "kasaoka": _3, "kibichuo": _3, "kumenan": _3, "kurashiki": _3, "maniwa": _3, "misaki": _3, "nagi": _3, "niimi": _3, "nishiawakura": _3, "okayama": _3, "satosho": _3, "setouchi": _3, "shinjo": _3, "shoo": _3, "soja": _3, "takahashi": _3, "tamano": _3, "tsuyama": _3, "wake": _3, "yakage": _3 }], "okinawa": [1, { "aguni": _3, "ginowan": _3, "ginoza": _3, "gushikami": _3, "haebaru": _3, "higashi": _3, "hirara": _3, "iheya": _3, "ishigaki": _3, "ishikawa": _3, "itoman": _3, "izena": _3, "kadena": _3, "kin": _3, "kitadaito": _3, "kitanakagusuku": _3, "kumejima": _3, "kunigami": _3, "minamidaito": _3, "motobu": _3, "nago": _3, "naha": _3, "nakagusuku": _3, "nakijin": _3, "nanjo": _3, "nishihara": _3, "ogimi": _3, "okinawa": _3, "onna": _3, "shimoji": _3, "taketomi": _3, "tarama": _3, "tokashiki": _3, "tomigusuku": _3, "tonaki": _3, "urasoe": _3, "uruma": _3, "yaese": _3, "yomitan": _3, "yonabaru": _3, "yonaguni": _3, "zamami": _3 }], "osaka": [1, { "abeno": _3, "chihayaakasaka": _3, "chuo": _3, "daito": _3, "fujiidera": _3, "habikino": _3, "hannan": _3, "higashiosaka": _3, "higashisumiyoshi": _3, "higashiyodogawa": _3, "hirakata": _3, "ibaraki": _3, "ikeda": _3, "izumi": _3, "izumiotsu": _3, "izumisano": _3, "kadoma": _3, "kaizuka": _3, "kanan": _3, "kashiwara": _3, "katano": _3, "kawachinagano": _3, "kishiwada": _3, "kita": _3, "kumatori": _3, "matsubara": _3, "minato": _3, "minoh": _3, "misaki": _3, "moriguchi": _3, "neyagawa": _3, "nishi": _3, "nose": _3, "osakasayama": _3, "sakai": _3, "sayama": _3, "sennan": _3, "settsu": _3, "shijonawate": _3, "shimamoto": _3, "suita": _3, "tadaoka": _3, "taishi": _3, "tajiri": _3, "takaishi": _3, "takatsuki": _3, "tondabayashi": _3, "toyonaka": _3, "toyono": _3, "yao": _3 }], "saga": [1, { "ariake": _3, "arita": _3, "fukudomi": _3, "genkai": _3, "hamatama": _3, "hizen": _3, "imari": _3, "kamimine": _3, "kanzaki": _3, "karatsu": _3, "kashima": _3, "kitagata": _3, "kitahata": _3, "kiyama": _3, "kouhoku": _3, "kyuragi": _3, "nishiarita": _3, "ogi": _3, "omachi": _3, "ouchi": _3, "saga": _3, "shiroishi": _3, "taku": _3, "tara": _3, "tosu": _3, "yoshinogari": _3 }], "saitama": [1, { "arakawa": _3, "asaka": _3, "chichibu": _3, "fujimi": _3, "fujimino": _3, "fukaya": _3, "hanno": _3, "hanyu": _3, "hasuda": _3, "hatogaya": _3, "hatoyama": _3, "hidaka": _3, "higashichichibu": _3, "higashimatsuyama": _3, "honjo": _3, "ina": _3, "iruma": _3, "iwatsuki": _3, "kamiizumi": _3, "kamikawa": _3, "kamisato": _3, "kasukabe": _3, "kawagoe": _3, "kawaguchi": _3, "kawajima": _3, "kazo": _3, "kitamoto": _3, "koshigaya": _3, "kounosu": _3, "kuki": _3, "kumagaya": _3, "matsubushi": _3, "minano": _3, "misato": _3, "miyashiro": _3, "miyoshi": _3, "moroyama": _3, "nagatoro": _3, "namegawa": _3, "niiza": _3, "ogano": _3, "ogawa": _3, "ogose": _3, "okegawa": _3, "omiya": _3, "otaki": _3, "ranzan": _3, "ryokami": _3, "saitama": _3, "sakado": _3, "satte": _3, "sayama": _3, "shiki": _3, "shiraoka": _3, "soka": _3, "sugito": _3, "toda": _3, "tokigawa": _3, "tokorozawa": _3, "tsurugashima": _3, "urawa": _3, "warabi": _3, "yashio": _3, "yokoze": _3, "yono": _3, "yorii": _3, "yoshida": _3, "yoshikawa": _3, "yoshimi": _3 }], "shiga": [1, { "aisho": _3, "gamo": _3, "higashiomi": _3, "hikone": _3, "koka": _3, "konan": _3, "kosei": _3, "koto": _3, "kusatsu": _3, "maibara": _3, "moriyama": _3, "nagahama": _3, "nishiazai": _3, "notogawa": _3, "omihachiman": _3, "otsu": _3, "ritto": _3, "ryuoh": _3, "takashima": _3, "takatsuki": _3, "torahime": _3, "toyosato": _3, "yasu": _3 }], "shimane": [1, { "akagi": _3, "ama": _3, "gotsu": _3, "hamada": _3, "higashiizumo": _3, "hikawa": _3, "hikimi": _3, "izumo": _3, "kakinoki": _3, "masuda": _3, "matsue": _3, "misato": _3, "nishinoshima": _3, "ohda": _3, "okinoshima": _3, "okuizumo": _3, "shimane": _3, "tamayu": _3, "tsuwano": _3, "unnan": _3, "yakumo": _3, "yasugi": _3, "yatsuka": _3 }], "shizuoka": [1, { "arai": _3, "atami": _3, "fuji": _3, "fujieda": _3, "fujikawa": _3, "fujinomiya": _3, "fukuroi": _3, "gotemba": _3, "haibara": _3, "hamamatsu": _3, "higashiizu": _3, "ito": _3, "iwata": _3, "izu": _3, "izunokuni": _3, "kakegawa": _3, "kannami": _3, "kawanehon": _3, "kawazu": _3, "kikugawa": _3, "kosai": _3, "makinohara": _3, "matsuzaki": _3, "minamiizu": _3, "mishima": _3, "morimachi": _3, "nishiizu": _3, "numazu": _3, "omaezaki": _3, "shimada": _3, "shimizu": _3, "shimoda": _3, "shizuoka": _3, "susono": _3, "yaizu": _3, "yoshida": _3 }], "tochigi": [1, { "ashikaga": _3, "bato": _3, "haga": _3, "ichikai": _3, "iwafune": _3, "kaminokawa": _3, "kanuma": _3, "karasuyama": _3, "kuroiso": _3, "mashiko": _3, "mibu": _3, "moka": _3, "motegi": _3, "nasu": _3, "nasushiobara": _3, "nikko": _3, "nishikata": _3, "nogi": _3, "ohira": _3, "ohtawara": _3, "oyama": _3, "sakura": _3, "sano": _3, "shimotsuke": _3, "shioya": _3, "takanezawa": _3, "tochigi": _3, "tsuga": _3, "ujiie": _3, "utsunomiya": _3, "yaita": _3 }], "tokushima": [1, { "aizumi": _3, "anan": _3, "ichiba": _3, "itano": _3, "kainan": _3, "komatsushima": _3, "matsushige": _3, "mima": _3, "minami": _3, "miyoshi": _3, "mugi": _3, "nakagawa": _3, "naruto": _3, "sanagochi": _3, "shishikui": _3, "tokushima": _3, "wajiki": _3 }], "tokyo": [1, { "adachi": _3, "akiruno": _3, "akishima": _3, "aogashima": _3, "arakawa": _3, "bunkyo": _3, "chiyoda": _3, "chofu": _3, "chuo": _3, "edogawa": _3, "fuchu": _3, "fussa": _3, "hachijo": _3, "hachioji": _3, "hamura": _3, "higashikurume": _3, "higashimurayama": _3, "higashiyamato": _3, "hino": _3, "hinode": _3, "hinohara": _3, "inagi": _3, "itabashi": _3, "katsushika": _3, "kita": _3, "kiyose": _3, "kodaira": _3, "koganei": _3, "kokubunji": _3, "komae": _3, "koto": _3, "kouzushima": _3, "kunitachi": _3, "machida": _3, "meguro": _3, "minato": _3, "mitaka": _3, "mizuho": _3, "musashimurayama": _3, "musashino": _3, "nakano": _3, "nerima": _3, "ogasawara": _3, "okutama": _3, "ome": _3, "oshima": _3, "ota": _3, "setagaya": _3, "shibuya": _3, "shinagawa": _3, "shinjuku": _3, "suginami": _3, "sumida": _3, "tachikawa": _3, "taito": _3, "tama": _3, "toshima": _3 }], "tottori": [1, { "chizu": _3, "hino": _3, "kawahara": _3, "koge": _3, "kotoura": _3, "misasa": _3, "nanbu": _3, "nichinan": _3, "sakaiminato": _3, "tottori": _3, "wakasa": _3, "yazu": _3, "yonago": _3 }], "toyama": [1, { "asahi": _3, "fuchu": _3, "fukumitsu": _3, "funahashi": _3, "himi": _3, "imizu": _3, "inami": _3, "johana": _3, "kamiichi": _3, "kurobe": _3, "nakaniikawa": _3, "namerikawa": _3, "nanto": _3, "nyuzen": _3, "oyabe": _3, "taira": _3, "takaoka": _3, "tateyama": _3, "toga": _3, "tonami": _3, "toyama": _3, "unazuki": _3, "uozu": _3, "yamada": _3 }], "wakayama": [1, { "arida": _3, "aridagawa": _3, "gobo": _3, "hashimoto": _3, "hidaka": _3, "hirogawa": _3, "inami": _3, "iwade": _3, "kainan": _3, "kamitonda": _3, "katsuragi": _3, "kimino": _3, "kinokawa": _3, "kitayama": _3, "koya": _3, "koza": _3, "kozagawa": _3, "kudoyama": _3, "kushimoto": _3, "mihama": _3, "misato": _3, "nachikatsuura": _3, "shingu": _3, "shirahama": _3, "taiji": _3, "tanabe": _3, "wakayama": _3, "yuasa": _3, "yura": _3 }], "yamagata": [1, { "asahi": _3, "funagata": _3, "higashine": _3, "iide": _3, "kahoku": _3, "kaminoyama": _3, "kaneyama": _3, "kawanishi": _3, "mamurogawa": _3, "mikawa": _3, "murayama": _3, "nagai": _3, "nakayama": _3, "nanyo": _3, "nishikawa": _3, "obanazawa": _3, "oe": _3, "oguni": _3, "ohkura": _3, "oishida": _3, "sagae": _3, "sakata": _3, "sakegawa": _3, "shinjo": _3, "shirataka": _3, "shonai": _3, "takahata": _3, "tendo": _3, "tozawa": _3, "tsuruoka": _3, "yamagata": _3, "yamanobe": _3, "yonezawa": _3, "yuza": _3 }], "yamaguchi": [1, { "abu": _3, "hagi": _3, "hikari": _3, "hofu": _3, "iwakuni": _3, "kudamatsu": _3, "mitou": _3, "nagato": _3, "oshima": _3, "shimonoseki": _3, "shunan": _3, "tabuse": _3, "tokuyama": _3, "toyota": _3, "ube": _3, "yuu": _3 }], "yamanashi": [1, { "chuo": _3, "doshi": _3, "fuefuki": _3, "fujikawa": _3, "fujikawaguchiko": _3, "fujiyoshida": _3, "hayakawa": _3, "hokuto": _3, "ichikawamisato": _3, "kai": _3, "kofu": _3, "koshu": _3, "kosuge": _3, "minami-alps": _3, "minobu": _3, "nakamichi": _3, "nanbu": _3, "narusawa": _3, "nirasaki": _3, "nishikatsura": _3, "oshino": _3, "otsuki": _3, "showa": _3, "tabayama": _3, "tsuru": _3, "uenohara": _3, "yamanakako": _3, "yamanashi": _3 }], "xn--ehqz56n": _3, "三重": _3, "xn--1lqs03n": _3, "京都": _3, "xn--qqqt11m": _3, "佐賀": _3, "xn--f6qx53a": _3, "兵庫": _3, "xn--djrs72d6uy": _3, "北海道": _3, "xn--mkru45i": _3, "千葉": _3, "xn--0trq7p7nn": _3, "和歌山": _3, "xn--5js045d": _3, "埼玉": _3, "xn--kbrq7o": _3, "大分": _3, "xn--pssu33l": _3, "大阪": _3, "xn--ntsq17g": _3, "奈良": _3, "xn--uisz3g": _3, "宮城": _3, "xn--6btw5a": _3, "宮崎": _3, "xn--1ctwo": _3, "富山": _3, "xn--6orx2r": _3, "山口": _3, "xn--rht61e": _3, "山形": _3, "xn--rht27z": _3, "山梨": _3, "xn--nit225k": _3, "岐阜": _3, "xn--rht3d": _3, "岡山": _3, "xn--djty4k": _3, "岩手": _3, "xn--klty5x": _3, "島根": _3, "xn--kltx9a": _3, "広島": _3, "xn--kltp7d": _3, "徳島": _3, "xn--c3s14m": _3, "愛媛": _3, "xn--vgu402c": _3, "愛知": _3, "xn--efvn9s": _3, "新潟": _3, "xn--1lqs71d": _3, "東京": _3, "xn--4pvxs": _3, "栃木": _3, "xn--uuwu58a": _3, "沖縄": _3, "xn--zbx025d": _3, "滋賀": _3, "xn--8pvr4u": _3, "熊本": _3, "xn--5rtp49c": _3, "石川": _3, "xn--ntso0iqx3a": _3, "神奈川": _3, "xn--elqq16h": _3, "福井": _3, "xn--4it168d": _3, "福岡": _3, "xn--klt787d": _3, "福島": _3, "xn--rny31h": _3, "秋田": _3, "xn--7t0a264c": _3, "群馬": _3, "xn--uist22h": _3, "茨城": _3, "xn--8ltr62k": _3, "長崎": _3, "xn--2m4a15e": _3, "長野": _3, "xn--32vp30h": _3, "青森": _3, "xn--4it797k": _3, "静岡": _3, "xn--5rtq34k": _3, "香川": _3, "xn--k7yn95e": _3, "高知": _3, "xn--tor131o": _3, "鳥取": _3, "xn--d5qv7z876c": _3, "鹿児島": _3, "kawasaki": _18, "kitakyushu": _18, "kobe": _18, "nagoya": _18, "sapporo": _18, "sendai": _18, "yokohama": _18, "buyshop": _4, "fashionstore": _4, "handcrafted": _4, "kawaiishop": _4, "supersale": _4, "theshop": _4, "0am": _4, "0g0": _4, "0j0": _4, "0t0": _4, "mydns": _4, "pgw": _4, "wjg": _4, "usercontent": _4, "angry": _4, "babyblue": _4, "babymilk": _4, "backdrop": _4, "bambina": _4, "bitter": _4, "blush": _4, "boo": _4, "boy": _4, "boyfriend": _4, "but": _4, "candypop": _4, "capoo": _4, "catfood": _4, "cheap": _4, "chicappa": _4, "chillout": _4, "chips": _4, "chowder": _4, "chu": _4, "ciao": _4, "cocotte": _4, "coolblog": _4, "cranky": _4, "cutegirl": _4, "daa": _4, "deca": _4, "deci": _4, "digick": _4, "egoism": _4, "fakefur": _4, "fem": _4, "flier": _4, "floppy": _4, "fool": _4, "frenchkiss": _4, "girlfriend": _4, "girly": _4, "gloomy": _4, "gonna": _4, "greater": _4, "hacca": _4, "heavy": _4, "her": _4, "hiho": _4, "hippy": _4, "holy": _4, "hungry": _4, "icurus": _4, "itigo": _4, "jellybean": _4, "kikirara": _4, "kill": _4, "kilo": _4, "kuron": _4, "littlestar": _4, "lolipopmc": _4, "lolitapunk": _4, "lomo": _4, "lovepop": _4, "lovesick": _4, "main": _4, "mods": _4, "mond": _4, "mongolian": _4, "moo": _4, "namaste": _4, "nikita": _4, "nobushi": _4, "noor": _4, "oops": _4, "parallel": _4, "parasite": _4, "pecori": _4, "peewee": _4, "penne": _4, "pepper": _4, "perma": _4, "pigboat": _4, "pinoko": _4, "punyu": _4, "pupu": _4, "pussycat": _4, "pya": _4, "raindrop": _4, "readymade": _4, "sadist": _4, "schoolbus": _4, "secret": _4, "staba": _4, "stripper": _4, "sub": _4, "sunnyday": _4, "thick": _4, "tonkotsu": _4, "under": _4, "upper": _4, "velvet": _4, "verse": _4, "versus": _4, "vivian": _4, "watson": _4, "weblike": _4, "whitesnow": _4, "zombie": _4, "hateblo": _4, "hatenablog": _4, "hatenadiary": _4, "2-d": _4, "bona": _4, "crap": _4, "daynight": _4, "eek": _4, "flop": _4, "halfmoon": _4, "jeez": _4, "matrix": _4, "mimoza": _4, "netgamers": _4, "nyanta": _4, "o0o0": _4, "rdy": _4, "rgr": _4, "rulez": _4, "sakurastorage": [0, { "isk01": _54, "isk02": _54 }], "saloon": _4, "sblo": _4, "skr": _4, "tank": _4, "uh-oh": _4, "undo": _4, "webaccel": [0, { "rs": _4, "user": _4 }], "websozai": _4, "xii": _4 }], "ke": [1, { "ac": _3, "co": _3, "go": _3, "info": _3, "me": _3, "mobi": _3, "ne": _3, "or": _3, "sc": _3 }], "kg": [1, { "com": _3, "edu": _3, "gov": _3, "mil": _3, "net": _3, "org": _3, "us": _4 }], "kh": _18, "ki": _55, "km": [1, { "ass": _3, "com": _3, "edu": _3, "gov": _3, "mil": _3, "nom": _3, "org": _3, "prd": _3, "tm": _3, "asso": _3, "coop": _3, "gouv": _3, "medecin": _3, "notaires": _3, "pharmaciens": _3, "presse": _3, "veterinaire": _3 }], "kn": [1, { "edu": _3, "gov": _3, "net": _3, "org": _3 }], "kp": [1, { "com": _3, "edu": _3, "gov": _3, "org": _3, "rep": _3, "tra": _3 }], "kr": [1, { "ac": _3, "co": _3, "es": _3, "go": _3, "hs": _3, "kg": _3, "mil": _3, "ms": _3, "ne": _3, "or": _3, "pe": _3, "re": _3, "sc": _3, "busan": _3, "chungbuk": _3, "chungnam": _3, "daegu": _3, "daejeon": _3, "gangwon": _3, "gwangju": _3, "gyeongbuk": _3, "gyeonggi": _3, "gyeongnam": _3, "incheon": _3, "jeju": _3, "jeonbuk": _3, "jeonnam": _3, "seoul": _3, "ulsan": _3 }], "kw": [1, { "com": _3, "edu": _3, "emb": _3, "gov": _3, "ind": _3, "net": _3, "org": _3 }], "ky": _44, "kz": [1, { "com": _3, "edu": _3, "gov": _3, "mil": _3, "net": _3, "org": _3, "jcloud": _4 }], "la": [1, { "com": _3, "edu": _3, "gov": _3, "info": _3, "int": _3, "net": _3, "org": _3, "per": _3, "bnr": _4 }], "lb": _5, "lc": [1, { "co": _3, "com": _3, "edu": _3, "gov": _3, "net": _3, "org": _3, "oy": _4 }], "li": _3, "lk": [1, { "ac": _3, "assn": _3, "com": _3, "edu": _3, "gov": _3, "grp": _3, "hotel": _3, "int": _3, "ltd": _3, "net": _3, "ngo": _3, "org": _3, "sch": _3, "soc": _3, "web": _3 }], "lr": _5, "ls": [1, { "ac": _3, "biz": _3, "co": _3, "edu": _3, "gov": _3, "info": _3, "net": _3, "org": _3, "sc": _3 }], "lt": _11, "lu": [1, { "123website": _4 }], "lv": [1, { "asn": _3, "com": _3, "conf": _3, "edu": _3, "gov": _3, "id": _3, "mil": _3, "net": _3, "org": _3 }], "ly": [1, { "com": _3, "edu": _3, "gov": _3, "id": _3, "med": _3, "net": _3, "org": _3, "plc": _3, "sch": _3 }], "ma": [1, { "ac": _3, "co": _3, "gov": _3, "net": _3, "org": _3, "press": _3 }], "mc": [1, { "asso": _3, "tm": _3 }], "md": [1, { "ir": _4 }], "me": [1, { "ac": _3, "co": _3, "edu": _3, "gov": _3, "its": _3, "net": _3, "org": _3, "priv": _3, "c66": _4, "craft": _4, "edgestack": _4, "filegear": _4, "glitch": _4, "filegear-sg": _4, "lohmus": _4, "barsy": _4, "mcdir": _4, "brasilia": _4, "ddns": _4, "dnsfor": _4, "hopto": _4, "loginto": _4, "noip": _4, "webhop": _4, "soundcast": _4, "tcp4": _4, "vp4": _4, "diskstation": _4, "dscloud": _4, "i234": _4, "myds": _4, "synology": _4, "transip": _43, "nohost": _4 }], "mg": [1, { "co": _3, "com": _3, "edu": _3, "gov": _3, "mil": _3, "nom": _3, "org": _3, "prd": _3 }], "mh": _3, "mil": _3, "mk": [1, { "com": _3, "edu": _3, "gov": _3, "inf": _3, "name": _3, "net": _3, "org": _3 }], "ml": [1, { "ac": _3, "art": _3, "asso": _3, "com": _3, "edu": _3, "gouv": _3, "gov": _3, "info": _3, "inst": _3, "net": _3, "org": _3, "pr": _3, "presse": _3 }], "mm": _18, "mn": [1, { "edu": _3, "gov": _3, "org": _3, "nyc": _4 }], "mo": _5, "mobi": [1, { "barsy": _4, "dscloud": _4 }], "mp": [1, { "ju": _4 }], "mq": _3, "mr": _11, "ms": [1, { "com": _3, "edu": _3, "gov": _3, "net": _3, "org": _3, "minisite": _4 }], "mt": _44, "mu": [1, { "ac": _3, "co": _3, "com": _3, "gov": _3, "net": _3, "or": _3, "org": _3 }], "museum": _3, "mv": [1, { "aero": _3, "biz": _3, "com": _3, "coop": _3, "edu": _3, "gov": _3, "info": _3, "int": _3, "mil": _3, "museum": _3, "name": _3, "net": _3, "org": _3, "pro": _3 }], "mw": [1, { "ac": _3, "biz": _3, "co": _3, "com": _3, "coop": _3, "edu": _3, "gov": _3, "int": _3, "net": _3, "org": _3 }], "mx": [1, { "com": _3, "edu": _3, "gob": _3, "net": _3, "org": _3 }], "my": [1, { "biz": _3, "com": _3, "edu": _3, "gov": _3, "mil": _3, "name": _3, "net": _3, "org": _3 }], "mz": [1, { "ac": _3, "adv": _3, "co": _3, "edu": _3, "gov": _3, "mil": _3, "net": _3, "org": _3 }], "na": [1, { "alt": _3, "co": _3, "com": _3, "gov": _3, "net": _3, "org": _3 }], "name": [1, { "her": _57, "his": _57 }], "nc": [1, { "asso": _3, "nom": _3 }], "ne": _3, "net": [1, { "adobeaemcloud": _4, "adobeio-static": _4, "adobeioruntime": _4, "akadns": _4, "akamai": _4, "akamai-staging": _4, "akamaiedge": _4, "akamaiedge-staging": _4, "akamaihd": _4, "akamaihd-staging": _4, "akamaiorigin": _4, "akamaiorigin-staging": _4, "akamaized": _4, "akamaized-staging": _4, "edgekey": _4, "edgekey-staging": _4, "edgesuite": _4, "edgesuite-staging": _4, "alwaysdata": _4, "myamaze": _4, "cloudfront": _4, "appudo": _4, "atlassian-dev": [0, { "prod": _51 }], "myfritz": _4, "onavstack": _4, "shopselect": _4, "blackbaudcdn": _4, "boomla": _4, "bplaced": _4, "square7": _4, "cdn77": [0, { "r": _4 }], "cdn77-ssl": _4, "gb": _4, "hu": _4, "jp": _4, "se": _4, "uk": _4, "clickrising": _4, "ddns-ip": _4, "dns-cloud": _4, "dns-dynamic": _4, "cloudaccess": _4, "cloudflare": [2, { "cdn": _4 }], "cloudflareanycast": _51, "cloudflarecn": _51, "cloudflareglobal": _51, "ctfcloud": _4, "feste-ip": _4, "knx-server": _4, "static-access": _4, "cryptonomic": _7, "dattolocal": _4, "mydatto": _4, "debian": _4, "definima": _4, "deno": _4, "at-band-camp": _4, "blogdns": _4, "broke-it": _4, "buyshouses": _4, "dnsalias": _4, "dnsdojo": _4, "does-it": _4, "dontexist": _4, "dynalias": _4, "dynathome": _4, "endofinternet": _4, "from-az": _4, "from-co": _4, "from-la": _4, "from-ny": _4, "gets-it": _4, "ham-radio-op": _4, "homeftp": _4, "homeip": _4, "homelinux": _4, "homeunix": _4, "in-the-band": _4, "is-a-chef": _4, "is-a-geek": _4, "isa-geek": _4, "kicks-ass": _4, "office-on-the": _4, "podzone": _4, "scrapper-site": _4, "selfip": _4, "sells-it": _4, "servebbs": _4, "serveftp": _4, "thruhere": _4, "webhop": _4, "casacam": _4, "dynu": _4, "dynv6": _4, "twmail": _4, "ru": _4, "channelsdvr": [2, { "u": _4 }], "fastly": [0, { "freetls": _4, "map": _4, "prod": [0, { "a": _4, "global": _4 }], "ssl": [0, { "a": _4, "b": _4, "global": _4 }] }], "fastlylb": [2, { "map": _4 }], "edgeapp": _4, "keyword-on": _4, "live-on": _4, "server-on": _4, "cdn-edges": _4, "heteml": _4, "cloudfunctions": _4, "grafana-dev": _4, "iobb": _4, "moonscale": _4, "in-dsl": _4, "in-vpn": _4, "oninferno": _4, "botdash": _4, "apps-1and1": _4, "ipifony": _4, "cloudjiffy": [2, { "fra1-de": _4, "west1-us": _4 }], "elastx": [0, { "jls-sto1": _4, "jls-sto2": _4, "jls-sto3": _4 }], "massivegrid": [0, { "paas": [0, { "fr-1": _4, "lon-1": _4, "lon-2": _4, "ny-1": _4, "ny-2": _4, "sg-1": _4 }] }], "saveincloud": [0, { "jelastic": _4, "nordeste-idc": _4 }], "scaleforce": _45, "kinghost": _4, "uni5": _4, "krellian": _4, "ggff": _4, "localcert": _4, "localhostcert": _4, "localto": _7, "barsy": _4, "memset": _4, "azure-api": _4, "azure-mobile": _4, "azureedge": _4, "azurefd": _4, "azurestaticapps": [2, { "1": _4, "2": _4, "3": _4, "4": _4, "5": _4, "6": _4, "7": _4, "centralus": _4, "eastasia": _4, "eastus2": _4, "westeurope": _4, "westus2": _4 }], "azurewebsites": _4, "cloudapp": _4, "trafficmanager": _4, "windows": [0, { "core": [0, { "blob": _4 }], "servicebus": _4 }], "mynetname": [0, { "sn": _4 }], "routingthecloud": _4, "bounceme": _4, "ddns": _4, "eating-organic": _4, "mydissent": _4, "myeffect": _4, "mymediapc": _4, "mypsx": _4, "mysecuritycamera": _4, "nhlfan": _4, "no-ip": _4, "pgafan": _4, "privatizehealthinsurance": _4, "redirectme": _4, "serveblog": _4, "serveminecraft": _4, "sytes": _4, "dnsup": _4, "hicam": _4, "now-dns": _4, "ownip": _4, "vpndns": _4, "cloudycluster": _4, "ovh": [0, { "hosting": _7, "webpaas": _7 }], "rackmaze": _4, "myradweb": _4, "in": _4, "subsc-pay": _4, "squares": _4, "schokokeks": _4, "firewall-gateway": _4, "seidat": _4, "senseering": _4, "siteleaf": _4, "mafelo": _4, "myspreadshop": _4, "vps-host": [2, { "jelastic": [0, { "atl": _4, "njs": _4, "ric": _4 }] }], "srcf": [0, { "soc": _4, "user": _4 }], "supabase": _4, "dsmynas": _4, "familyds": _4, "ts": [2, { "c": _7 }], "torproject": [2, { "pages": _4 }], "vusercontent": _4, "reserve-online": _4, "community-pro": _4, "meinforum": _4, "yandexcloud": [2, { "storage": _4, "website": _4 }], "za": _4 }], "nf": [1, { "arts": _3, "com": _3, "firm": _3, "info": _3, "net": _3, "other": _3, "per": _3, "rec": _3, "store": _3, "web": _3 }], "ng": [1, { "com": _3, "edu": _3, "gov": _3, "i": _3, "mil": _3, "mobi": _3, "name": _3, "net": _3, "org": _3, "sch": _3, "biz": [2, { "co": _4, "dl": _4, "go": _4, "lg": _4, "on": _4 }], "col": _4, "firm": _4, "gen": _4, "ltd": _4, "ngo": _4, "plc": _4 }], "ni": [1, { "ac": _3, "biz": _3, "co": _3, "com": _3, "edu": _3, "gob": _3, "in": _3, "info": _3, "int": _3, "mil": _3, "net": _3, "nom": _3, "org": _3, "web": _3 }], "nl": [1, { "co": _4, "hosting-cluster": _4, "gov": _4, "khplay": _4, "123website": _4, "myspreadshop": _4, "transurl": _7, "cistron": _4, "demon": _4 }], "no": [1, { "fhs": _3, "folkebibl": _3, "fylkesbibl": _3, "idrett": _3, "museum": _3, "priv": _3, "vgs": _3, "dep": _3, "herad": _3, "kommune": _3, "mil": _3, "stat": _3, "aa": _58, "ah": _58, "bu": _58, "fm": _58, "hl": _58, "hm": _58, "jan-mayen": _58, "mr": _58, "nl": _58, "nt": _58, "of": _58, "ol": _58, "oslo": _58, "rl": _58, "sf": _58, "st": _58, "svalbard": _58, "tm": _58, "tr": _58, "va": _58, "vf": _58, "akrehamn": _3, "xn--krehamn-dxa": _3, "åkrehamn": _3, "algard": _3, "xn--lgrd-poac": _3, "ålgård": _3, "arna": _3, "bronnoysund": _3, "xn--brnnysund-m8ac": _3, "brønnøysund": _3, "brumunddal": _3, "bryne": _3, "drobak": _3, "xn--drbak-wua": _3, "drøbak": _3, "egersund": _3, "fetsund": _3, "floro": _3, "xn--flor-jra": _3, "florø": _3, "fredrikstad": _3, "hokksund": _3, "honefoss": _3, "xn--hnefoss-q1a": _3, "hønefoss": _3, "jessheim": _3, "jorpeland": _3, "xn--jrpeland-54a": _3, "jørpeland": _3, "kirkenes": _3, "kopervik": _3, "krokstadelva": _3, "langevag": _3, "xn--langevg-jxa": _3, "langevåg": _3, "leirvik": _3, "mjondalen": _3, "xn--mjndalen-64a": _3, "mjøndalen": _3, "mo-i-rana": _3, "mosjoen": _3, "xn--mosjen-eya": _3, "mosjøen": _3, "nesoddtangen": _3, "orkanger": _3, "osoyro": _3, "xn--osyro-wua": _3, "osøyro": _3, "raholt": _3, "xn--rholt-mra": _3, "råholt": _3, "sandnessjoen": _3, "xn--sandnessjen-ogb": _3, "sandnessjøen": _3, "skedsmokorset": _3, "slattum": _3, "spjelkavik": _3, "stathelle": _3, "stavern": _3, "stjordalshalsen": _3, "xn--stjrdalshalsen-sqb": _3, "stjørdalshalsen": _3, "tananger": _3, "tranby": _3, "vossevangen": _3, "aarborte": _3, "aejrie": _3, "afjord": _3, "xn--fjord-lra": _3, "åfjord": _3, "agdenes": _3, "akershus": _59, "aknoluokta": _3, "xn--koluokta-7ya57h": _3, "ákŋoluokta": _3, "al": _3, "xn--l-1fa": _3, "ål": _3, "alaheadju": _3, "xn--laheadju-7ya": _3, "álaheadju": _3, "alesund": _3, "xn--lesund-hua": _3, "ålesund": _3, "alstahaug": _3, "alta": _3, "xn--lt-liac": _3, "áltá": _3, "alvdal": _3, "amli": _3, "xn--mli-tla": _3, "åmli": _3, "amot": _3, "xn--mot-tla": _3, "åmot": _3, "andasuolo": _3, "andebu": _3, "andoy": _3, "xn--andy-ira": _3, "andøy": _3, "ardal": _3, "xn--rdal-poa": _3, "årdal": _3, "aremark": _3, "arendal": _3, "xn--s-1fa": _3, "ås": _3, "aseral": _3, "xn--seral-lra": _3, "åseral": _3, "asker": _3, "askim": _3, "askoy": _3, "xn--asky-ira": _3, "askøy": _3, "askvoll": _3, "asnes": _3, "xn--snes-poa": _3, "åsnes": _3, "audnedaln": _3, "aukra": _3, "aure": _3, "aurland": _3, "aurskog-holand": _3, "xn--aurskog-hland-jnb": _3, "aurskog-høland": _3, "austevoll": _3, "austrheim": _3, "averoy": _3, "xn--avery-yua": _3, "averøy": _3, "badaddja": _3, "xn--bdddj-mrabd": _3, "bådåddjå": _3, "xn--brum-voa": _3, "bærum": _3, "bahcavuotna": _3, "xn--bhcavuotna-s4a": _3, "báhcavuotna": _3, "bahccavuotna": _3, "xn--bhccavuotna-k7a": _3, "báhccavuotna": _3, "baidar": _3, "xn--bidr-5nac": _3, "báidár": _3, "bajddar": _3, "xn--bjddar-pta": _3, "bájddar": _3, "balat": _3, "xn--blt-elab": _3, "bálát": _3, "balestrand": _3, "ballangen": _3, "balsfjord": _3, "bamble": _3, "bardu": _3, "barum": _3, "batsfjord": _3, "xn--btsfjord-9za": _3, "båtsfjord": _3, "bearalvahki": _3, "xn--bearalvhki-y4a": _3, "bearalváhki": _3, "beardu": _3, "beiarn": _3, "berg": _3, "bergen": _3, "berlevag": _3, "xn--berlevg-jxa": _3, "berlevåg": _3, "bievat": _3, "xn--bievt-0qa": _3, "bievát": _3, "bindal": _3, "birkenes": _3, "bjarkoy": _3, "xn--bjarky-fya": _3, "bjarkøy": _3, "bjerkreim": _3, "bjugn": _3, "bodo": _3, "xn--bod-2na": _3, "bodø": _3, "bokn": _3, "bomlo": _3, "xn--bmlo-gra": _3, "bømlo": _3, "bremanger": _3, "bronnoy": _3, "xn--brnny-wuac": _3, "brønnøy": _3, "budejju": _3, "buskerud": _59, "bygland": _3, "bykle": _3, "cahcesuolo": _3, "xn--hcesuolo-7ya35b": _3, "čáhcesuolo": _3, "davvenjarga": _3, "xn--davvenjrga-y4a": _3, "davvenjárga": _3, "davvesiida": _3, "deatnu": _3, "dielddanuorri": _3, "divtasvuodna": _3, "divttasvuotna": _3, "donna": _3, "xn--dnna-gra": _3, "dønna": _3, "dovre": _3, "drammen": _3, "drangedal": _3, "dyroy": _3, "xn--dyry-ira": _3, "dyrøy": _3, "eid": _3, "eidfjord": _3, "eidsberg": _3, "eidskog": _3, "eidsvoll": _3, "eigersund": _3, "elverum": _3, "enebakk": _3, "engerdal": _3, "etne": _3, "etnedal": _3, "evenassi": _3, "xn--eveni-0qa01ga": _3, "evenášši": _3, "evenes": _3, "evje-og-hornnes": _3, "farsund": _3, "fauske": _3, "fedje": _3, "fet": _3, "finnoy": _3, "xn--finny-yua": _3, "finnøy": _3, "fitjar": _3, "fjaler": _3, "fjell": _3, "fla": _3, "xn--fl-zia": _3, "flå": _3, "flakstad": _3, "flatanger": _3, "flekkefjord": _3, "flesberg": _3, "flora": _3, "folldal": _3, "forde": _3, "xn--frde-gra": _3, "førde": _3, "forsand": _3, "fosnes": _3, "xn--frna-woa": _3, "fræna": _3, "frana": _3, "frei": _3, "frogn": _3, "froland": _3, "frosta": _3, "froya": _3, "xn--frya-hra": _3, "frøya": _3, "fuoisku": _3, "fuossko": _3, "fusa": _3, "fyresdal": _3, "gaivuotna": _3, "xn--givuotna-8ya": _3, "gáivuotna": _3, "galsa": _3, "xn--gls-elac": _3, "gálsá": _3, "gamvik": _3, "gangaviika": _3, "xn--ggaviika-8ya47h": _3, "gáŋgaviika": _3, "gaular": _3, "gausdal": _3, "giehtavuoatna": _3, "gildeskal": _3, "xn--gildeskl-g0a": _3, "gildeskål": _3, "giske": _3, "gjemnes": _3, "gjerdrum": _3, "gjerstad": _3, "gjesdal": _3, "gjovik": _3, "xn--gjvik-wua": _3, "gjøvik": _3, "gloppen": _3, "gol": _3, "gran": _3, "grane": _3, "granvin": _3, "gratangen": _3, "grimstad": _3, "grong": _3, "grue": _3, "gulen": _3, "guovdageaidnu": _3, "ha": _3, "xn--h-2fa": _3, "hå": _3, "habmer": _3, "xn--hbmer-xqa": _3, "hábmer": _3, "hadsel": _3, "xn--hgebostad-g3a": _3, "hægebostad": _3, "hagebostad": _3, "halden": _3, "halsa": _3, "hamar": _3, "hamaroy": _3, "hammarfeasta": _3, "xn--hmmrfeasta-s4ac": _3, "hámmárfeasta": _3, "hammerfest": _3, "hapmir": _3, "xn--hpmir-xqa": _3, "hápmir": _3, "haram": _3, "hareid": _3, "harstad": _3, "hasvik": _3, "hattfjelldal": _3, "haugesund": _3, "hedmark": [0, { "os": _3, "valer": _3, "xn--vler-qoa": _3, "våler": _3 }], "hemne": _3, "hemnes": _3, "hemsedal": _3, "hitra": _3, "hjartdal": _3, "hjelmeland": _3, "hobol": _3, "xn--hobl-ira": _3, "hobøl": _3, "hof": _3, "hol": _3, "hole": _3, "holmestrand": _3, "holtalen": _3, "xn--holtlen-hxa": _3, "holtålen": _3, "hordaland": [0, { "os": _3 }], "hornindal": _3, "horten": _3, "hoyanger": _3, "xn--hyanger-q1a": _3, "høyanger": _3, "hoylandet": _3, "xn--hylandet-54a": _3, "høylandet": _3, "hurdal": _3, "hurum": _3, "hvaler": _3, "hyllestad": _3, "ibestad": _3, "inderoy": _3, "xn--indery-fya": _3, "inderøy": _3, "iveland": _3, "ivgu": _3, "jevnaker": _3, "jolster": _3, "xn--jlster-bya": _3, "jølster": _3, "jondal": _3, "kafjord": _3, "xn--kfjord-iua": _3, "kåfjord": _3, "karasjohka": _3, "xn--krjohka-hwab49j": _3, "kárášjohka": _3, "karasjok": _3, "karlsoy": _3, "karmoy": _3, "xn--karmy-yua": _3, "karmøy": _3, "kautokeino": _3, "klabu": _3, "xn--klbu-woa": _3, "klæbu": _3, "klepp": _3, "kongsberg": _3, "kongsvinger": _3, "kraanghke": _3, "xn--kranghke-b0a": _3, "kråanghke": _3, "kragero": _3, "xn--krager-gya": _3, "kragerø": _3, "kristiansand": _3, "kristiansund": _3, "krodsherad": _3, "xn--krdsherad-m8a": _3, "krødsherad": _3, "xn--kvfjord-nxa": _3, "kvæfjord": _3, "xn--kvnangen-k0a": _3, "kvænangen": _3, "kvafjord": _3, "kvalsund": _3, "kvam": _3, "kvanangen": _3, "kvinesdal": _3, "kvinnherad": _3, "kviteseid": _3, "kvitsoy": _3, "xn--kvitsy-fya": _3, "kvitsøy": _3, "laakesvuemie": _3, "xn--lrdal-sra": _3, "lærdal": _3, "lahppi": _3, "xn--lhppi-xqa": _3, "láhppi": _3, "lardal": _3, "larvik": _3, "lavagis": _3, "lavangen": _3, "leangaviika": _3, "xn--leagaviika-52b": _3, "leaŋgaviika": _3, "lebesby": _3, "leikanger": _3, "leirfjord": _3, "leka": _3, "leksvik": _3, "lenvik": _3, "lerdal": _3, "lesja": _3, "levanger": _3, "lier": _3, "lierne": _3, "lillehammer": _3, "lillesand": _3, "lindas": _3, "xn--linds-pra": _3, "lindås": _3, "lindesnes": _3, "loabat": _3, "xn--loabt-0qa": _3, "loabát": _3, "lodingen": _3, "xn--ldingen-q1a": _3, "lødingen": _3, "lom": _3, "loppa": _3, "lorenskog": _3, "xn--lrenskog-54a": _3, "lørenskog": _3, "loten": _3, "xn--lten-gra": _3, "løten": _3, "lund": _3, "lunner": _3, "luroy": _3, "xn--lury-ira": _3, "lurøy": _3, "luster": _3, "lyngdal": _3, "lyngen": _3, "malatvuopmi": _3, "xn--mlatvuopmi-s4a": _3, "málatvuopmi": _3, "malselv": _3, "xn--mlselv-iua": _3, "målselv": _3, "malvik": _3, "mandal": _3, "marker": _3, "marnardal": _3, "masfjorden": _3, "masoy": _3, "xn--msy-ula0h": _3, "måsøy": _3, "matta-varjjat": _3, "xn--mtta-vrjjat-k7af": _3, "mátta-várjjat": _3, "meland": _3, "meldal": _3, "melhus": _3, "meloy": _3, "xn--mely-ira": _3, "meløy": _3, "meraker": _3, "xn--merker-kua": _3, "meråker": _3, "midsund": _3, "midtre-gauldal": _3, "moareke": _3, "xn--moreke-jua": _3, "moåreke": _3, "modalen": _3, "modum": _3, "molde": _3, "more-og-romsdal": [0, { "heroy": _3, "sande": _3 }], "xn--mre-og-romsdal-qqb": [0, { "xn--hery-ira": _3, "sande": _3 }], "møre-og-romsdal": [0, { "herøy": _3, "sande": _3 }], "moskenes": _3, "moss": _3, "mosvik": _3, "muosat": _3, "xn--muost-0qa": _3, "muosát": _3, "naamesjevuemie": _3, "xn--nmesjevuemie-tcba": _3, "nååmesjevuemie": _3, "xn--nry-yla5g": _3, "nærøy": _3, "namdalseid": _3, "namsos": _3, "namsskogan": _3, "nannestad": _3, "naroy": _3, "narviika": _3, "narvik": _3, "naustdal": _3, "navuotna": _3, "xn--nvuotna-hwa": _3, "návuotna": _3, "nedre-eiker": _3, "nesna": _3, "nesodden": _3, "nesseby": _3, "nesset": _3, "nissedal": _3, "nittedal": _3, "nord-aurdal": _3, "nord-fron": _3, "nord-odal": _3, "norddal": _3, "nordkapp": _3, "nordland": [0, { "bo": _3, "xn--b-5ga": _3, "bø": _3, "heroy": _3, "xn--hery-ira": _3, "herøy": _3 }], "nordre-land": _3, "nordreisa": _3, "nore-og-uvdal": _3, "notodden": _3, "notteroy": _3, "xn--nttery-byae": _3, "nøtterøy": _3, "odda": _3, "oksnes": _3, "xn--ksnes-uua": _3, "øksnes": _3, "omasvuotna": _3, "oppdal": _3, "oppegard": _3, "xn--oppegrd-ixa": _3, "oppegård": _3, "orkdal": _3, "orland": _3, "xn--rland-uua": _3, "ørland": _3, "orskog": _3, "xn--rskog-uua": _3, "ørskog": _3, "orsta": _3, "xn--rsta-fra": _3, "ørsta": _3, "osen": _3, "osteroy": _3, "xn--ostery-fya": _3, "osterøy": _3, "ostfold": [0, { "valer": _3 }], "xn--stfold-9xa": [0, { "xn--vler-qoa": _3 }], "østfold": [0, { "våler": _3 }], "ostre-toten": _3, "xn--stre-toten-zcb": _3, "østre-toten": _3, "overhalla": _3, "ovre-eiker": _3, "xn--vre-eiker-k8a": _3, "øvre-eiker": _3, "oyer": _3, "xn--yer-zna": _3, "øyer": _3, "oygarden": _3, "xn--ygarden-p1a": _3, "øygarden": _3, "oystre-slidre": _3, "xn--ystre-slidre-ujb": _3, "øystre-slidre": _3, "porsanger": _3, "porsangu": _3, "xn--porsgu-sta26f": _3, "porsáŋgu": _3, "porsgrunn": _3, "rade": _3, "xn--rde-ula": _3, "råde": _3, "radoy": _3, "xn--rady-ira": _3, "radøy": _3, "xn--rlingen-mxa": _3, "rælingen": _3, "rahkkeravju": _3, "xn--rhkkervju-01af": _3, "ráhkkerávju": _3, "raisa": _3, "xn--risa-5na": _3, "ráisa": _3, "rakkestad": _3, "ralingen": _3, "rana": _3, "randaberg": _3, "rauma": _3, "rendalen": _3, "rennebu": _3, "rennesoy": _3, "xn--rennesy-v1a": _3, "rennesøy": _3, "rindal": _3, "ringebu": _3, "ringerike": _3, "ringsaker": _3, "risor": _3, "xn--risr-ira": _3, "risør": _3, "rissa": _3, "roan": _3, "rodoy": _3, "xn--rdy-0nab": _3, "rødøy": _3, "rollag": _3, "romsa": _3, "romskog": _3, "xn--rmskog-bya": _3, "rømskog": _3, "roros": _3, "xn--rros-gra": _3, "røros": _3, "rost": _3, "xn--rst-0na": _3, "røst": _3, "royken": _3, "xn--ryken-vua": _3, "røyken": _3, "royrvik": _3, "xn--ryrvik-bya": _3, "røyrvik": _3, "ruovat": _3, "rygge": _3, "salangen": _3, "salat": _3, "xn--slat-5na": _3, "sálat": _3, "xn--slt-elab": _3, "sálát": _3, "saltdal": _3, "samnanger": _3, "sandefjord": _3, "sandnes": _3, "sandoy": _3, "xn--sandy-yua": _3, "sandøy": _3, "sarpsborg": _3, "sauda": _3, "sauherad": _3, "sel": _3, "selbu": _3, "selje": _3, "seljord": _3, "siellak": _3, "sigdal": _3, "siljan": _3, "sirdal": _3, "skanit": _3, "xn--sknit-yqa": _3, "skánit": _3, "skanland": _3, "xn--sknland-fxa": _3, "skånland": _3, "skaun": _3, "skedsmo": _3, "ski": _3, "skien": _3, "skierva": _3, "xn--skierv-uta": _3, "skiervá": _3, "skiptvet": _3, "skjak": _3, "xn--skjk-soa": _3, "skjåk": _3, "skjervoy": _3, "xn--skjervy-v1a": _3, "skjervøy": _3, "skodje": _3, "smola": _3, "xn--smla-hra": _3, "smøla": _3, "snaase": _3, "xn--snase-nra": _3, "snåase": _3, "snasa": _3, "xn--snsa-roa": _3, "snåsa": _3, "snillfjord": _3, "snoasa": _3, "sogndal": _3, "sogne": _3, "xn--sgne-gra": _3, "søgne": _3, "sokndal": _3, "sola": _3, "solund": _3, "somna": _3, "xn--smna-gra": _3, "sømna": _3, "sondre-land": _3, "xn--sndre-land-0cb": _3, "søndre-land": _3, "songdalen": _3, "sor-aurdal": _3, "xn--sr-aurdal-l8a": _3, "sør-aurdal": _3, "sor-fron": _3, "xn--sr-fron-q1a": _3, "sør-fron": _3, "sor-odal": _3, "xn--sr-odal-q1a": _3, "sør-odal": _3, "sor-varanger": _3, "xn--sr-varanger-ggb": _3, "sør-varanger": _3, "sorfold": _3, "xn--srfold-bya": _3, "sørfold": _3, "sorreisa": _3, "xn--srreisa-q1a": _3, "sørreisa": _3, "sortland": _3, "sorum": _3, "xn--srum-gra": _3, "sørum": _3, "spydeberg": _3, "stange": _3, "stavanger": _3, "steigen": _3, "steinkjer": _3, "stjordal": _3, "xn--stjrdal-s1a": _3, "stjørdal": _3, "stokke": _3, "stor-elvdal": _3, "stord": _3, "stordal": _3, "storfjord": _3, "strand": _3, "stranda": _3, "stryn": _3, "sula": _3, "suldal": _3, "sund": _3, "sunndal": _3, "surnadal": _3, "sveio": _3, "svelvik": _3, "sykkylven": _3, "tana": _3, "telemark": [0, { "bo": _3, "xn--b-5ga": _3, "bø": _3 }], "time": _3, "tingvoll": _3, "tinn": _3, "tjeldsund": _3, "tjome": _3, "xn--tjme-hra": _3, "tjøme": _3, "tokke": _3, "tolga": _3, "tonsberg": _3, "xn--tnsberg-q1a": _3, "tønsberg": _3, "torsken": _3, "xn--trna-woa": _3, "træna": _3, "trana": _3, "tranoy": _3, "xn--trany-yua": _3, "tranøy": _3, "troandin": _3, "trogstad": _3, "xn--trgstad-r1a": _3, "trøgstad": _3, "tromsa": _3, "tromso": _3, "xn--troms-zua": _3, "tromsø": _3, "trondheim": _3, "trysil": _3, "tvedestrand": _3, "tydal": _3, "tynset": _3, "tysfjord": _3, "tysnes": _3, "xn--tysvr-vra": _3, "tysvær": _3, "tysvar": _3, "ullensaker": _3, "ullensvang": _3, "ulvik": _3, "unjarga": _3, "xn--unjrga-rta": _3, "unjárga": _3, "utsira": _3, "vaapste": _3, "vadso": _3, "xn--vads-jra": _3, "vadsø": _3, "xn--vry-yla5g": _3, "værøy": _3, "vaga": _3, "xn--vg-yiab": _3, "vågå": _3, "vagan": _3, "xn--vgan-qoa": _3, "vågan": _3, "vagsoy": _3, "xn--vgsy-qoa0j": _3, "vågsøy": _3, "vaksdal": _3, "valle": _3, "vang": _3, "vanylven": _3, "vardo": _3, "xn--vard-jra": _3, "vardø": _3, "varggat": _3, "xn--vrggt-xqad": _3, "várggát": _3, "varoy": _3, "vefsn": _3, "vega": _3, "vegarshei": _3, "xn--vegrshei-c0a": _3, "vegårshei": _3, "vennesla": _3, "verdal": _3, "verran": _3, "vestby": _3, "vestfold": [0, { "sande": _3 }], "vestnes": _3, "vestre-slidre": _3, "vestre-toten": _3, "vestvagoy": _3, "xn--vestvgy-ixa6o": _3, "vestvågøy": _3, "vevelstad": _3, "vik": _3, "vikna": _3, "vindafjord": _3, "voagat": _3, "volda": _3, "voss": _3, "co": _4, "123hjemmeside": _4, "myspreadshop": _4 }], "np": _18, "nr": _55, "nu": [1, { "merseine": _4, "mine": _4, "shacknet": _4, "enterprisecloud": _4 }], "nz": [1, { "ac": _3, "co": _3, "cri": _3, "geek": _3, "gen": _3, "govt": _3, "health": _3, "iwi": _3, "kiwi": _3, "maori": _3, "xn--mori-qsa": _3, "māori": _3, "mil": _3, "net": _3, "org": _3, "parliament": _3, "school": _3, "cloudns": _4 }], "om": [1, { "co": _3, "com": _3, "edu": _3, "gov": _3, "med": _3, "museum": _3, "net": _3, "org": _3, "pro": _3 }], "onion": _3, "org": [1, { "altervista": _4, "pimienta": _4, "poivron": _4, "potager": _4, "sweetpepper": _4, "cdn77": [0, { "c": _4, "rsc": _4 }], "cdn77-secure": [0, { "origin": [0, { "ssl": _4 }] }], "ae": _4, "cloudns": _4, "ip-dynamic": _4, "ddnss": _4, "duckdns": _4, "tunk": _4, "blogdns": _4, "blogsite": _4, "boldlygoingnowhere": _4, "dnsalias": _4, "dnsdojo": _4, "doesntexist": _4, "dontexist": _4, "doomdns": _4, "dvrdns": _4, "dynalias": _4, "dyndns": [2, { "go": _4, "home": _4 }], "endofinternet": _4, "endoftheinternet": _4, "from-me": _4, "game-host": _4, "gotdns": _4, "hobby-site": _4, "homedns": _4, "homeftp": _4, "homelinux": _4, "homeunix": _4, "is-a-bruinsfan": _4, "is-a-candidate": _4, "is-a-celticsfan": _4, "is-a-chef": _4, "is-a-geek": _4, "is-a-knight": _4, "is-a-linux-user": _4, "is-a-patsfan": _4, "is-a-soxfan": _4, "is-found": _4, "is-lost": _4, "is-saved": _4, "is-very-bad": _4, "is-very-evil": _4, "is-very-good": _4, "is-very-nice": _4, "is-very-sweet": _4, "isa-geek": _4, "kicks-ass": _4, "misconfused": _4, "podzone": _4, "readmyblog": _4, "selfip": _4, "sellsyourhome": _4, "servebbs": _4, "serveftp": _4, "servegame": _4, "stuff-4-sale": _4, "webhop": _4, "accesscam": _4, "camdvr": _4, "freeddns": _4, "mywire": _4, "webredirect": _4, "twmail": _4, "eu": [2, { "al": _4, "asso": _4, "at": _4, "au": _4, "be": _4, "bg": _4, "ca": _4, "cd": _4, "ch": _4, "cn": _4, "cy": _4, "cz": _4, "de": _4, "dk": _4, "edu": _4, "ee": _4, "es": _4, "fi": _4, "fr": _4, "gr": _4, "hr": _4, "hu": _4, "ie": _4, "il": _4, "in": _4, "int": _4, "is": _4, "it": _4, "jp": _4, "kr": _4, "lt": _4, "lu": _4, "lv": _4, "me": _4, "mk": _4, "mt": _4, "my": _4, "net": _4, "ng": _4, "nl": _4, "no": _4, "nz": _4, "pl": _4, "pt": _4, "ro": _4, "ru": _4, "se": _4, "si": _4, "sk": _4, "tr": _4, "uk": _4, "us": _4 }], "fedorainfracloud": _4, "fedorapeople": _4, "fedoraproject": [0, { "cloud": _4, "os": _42, "stg": [0, { "os": _42 }] }], "freedesktop": _4, "hatenadiary": _4, "hepforge": _4, "in-dsl": _4, "in-vpn": _4, "js": _4, "barsy": _4, "mayfirst": _4, "routingthecloud": _4, "bmoattachments": _4, "cable-modem": _4, "collegefan": _4, "couchpotatofries": _4, "hopto": _4, "mlbfan": _4, "myftp": _4, "mysecuritycamera": _4, "nflfan": _4, "no-ip": _4, "read-books": _4, "ufcfan": _4, "zapto": _4, "dynserv": _4, "now-dns": _4, "is-local": _4, "httpbin": _4, "pubtls": _4, "jpn": _4, "my-firewall": _4, "myfirewall": _4, "spdns": _4, "small-web": _4, "dsmynas": _4, "familyds": _4, "teckids": _54, "tuxfamily": _4, "diskstation": _4, "hk": _4, "us": _4, "toolforge": _4, "wmcloud": _4, "wmflabs": _4, "za": _4 }], "pa": [1, { "abo": _3, "ac": _3, "com": _3, "edu": _3, "gob": _3, "ing": _3, "med": _3, "net": _3, "nom": _3, "org": _3, "sld": _3 }], "pe": [1, { "com": _3, "edu": _3, "gob": _3, "mil": _3, "net": _3, "nom": _3, "org": _3 }], "pf": [1, { "com": _3, "edu": _3, "org": _3 }], "pg": _18, "ph": [1, { "com": _3, "edu": _3, "gov": _3, "i": _3, "mil": _3, "net": _3, "ngo": _3, "org": _3, "cloudns": _4 }], "pk": [1, { "ac": _3, "biz": _3, "com": _3, "edu": _3, "fam": _3, "gkp": _3, "gob": _3, "gog": _3, "gok": _3, "gop": _3, "gos": _3, "gov": _3, "net": _3, "org": _3, "web": _3 }], "pl": [1, { "com": _3, "net": _3, "org": _3, "agro": _3, "aid": _3, "atm": _3, "auto": _3, "biz": _3, "edu": _3, "gmina": _3, "gsm": _3, "info": _3, "mail": _3, "media": _3, "miasta": _3, "mil": _3, "nieruchomosci": _3, "nom": _3, "pc": _3, "powiat": _3, "priv": _3, "realestate": _3, "rel": _3, "sex": _3, "shop": _3, "sklep": _3, "sos": _3, "szkola": _3, "targi": _3, "tm": _3, "tourism": _3, "travel": _3, "turystyka": _3, "gov": [1, { "ap": _3, "griw": _3, "ic": _3, "is": _3, "kmpsp": _3, "konsulat": _3, "kppsp": _3, "kwp": _3, "kwpsp": _3, "mup": _3, "mw": _3, "oia": _3, "oirm": _3, "oke": _3, "oow": _3, "oschr": _3, "oum": _3, "pa": _3, "pinb": _3, "piw": _3, "po": _3, "pr": _3, "psp": _3, "psse": _3, "pup": _3, "rzgw": _3, "sa": _3, "sdn": _3, "sko": _3, "so": _3, "sr": _3, "starostwo": _3, "ug": _3, "ugim": _3, "um": _3, "umig": _3, "upow": _3, "uppo": _3, "us": _3, "uw": _3, "uzs": _3, "wif": _3, "wiih": _3, "winb": _3, "wios": _3, "witd": _3, "wiw": _3, "wkz": _3, "wsa": _3, "wskr": _3, "wsse": _3, "wuoz": _3, "wzmiuw": _3, "zp": _3, "zpisdn": _3 }], "augustow": _3, "babia-gora": _3, "bedzin": _3, "beskidy": _3, "bialowieza": _3, "bialystok": _3, "bielawa": _3, "bieszczady": _3, "boleslawiec": _3, "bydgoszcz": _3, "bytom": _3, "cieszyn": _3, "czeladz": _3, "czest": _3, "dlugoleka": _3, "elblag": _3, "elk": _3, "glogow": _3, "gniezno": _3, "gorlice": _3, "grajewo": _3, "ilawa": _3, "jaworzno": _3, "jelenia-gora": _3, "jgora": _3, "kalisz": _3, "karpacz": _3, "kartuzy": _3, "kaszuby": _3, "katowice": _3, "kazimierz-dolny": _3, "kepno": _3, "ketrzyn": _3, "klodzko": _3, "kobierzyce": _3, "kolobrzeg": _3, "konin": _3, "konskowola": _3, "kutno": _3, "lapy": _3, "lebork": _3, "legnica": _3, "lezajsk": _3, "limanowa": _3, "lomza": _3, "lowicz": _3, "lubin": _3, "lukow": _3, "malbork": _3, "malopolska": _3, "mazowsze": _3, "mazury": _3, "mielec": _3, "mielno": _3, "mragowo": _3, "naklo": _3, "nowaruda": _3, "nysa": _3, "olawa": _3, "olecko": _3, "olkusz": _3, "olsztyn": _3, "opoczno": _3, "opole": _3, "ostroda": _3, "ostroleka": _3, "ostrowiec": _3, "ostrowwlkp": _3, "pila": _3, "pisz": _3, "podhale": _3, "podlasie": _3, "polkowice": _3, "pomorskie": _3, "pomorze": _3, "prochowice": _3, "pruszkow": _3, "przeworsk": _3, "pulawy": _3, "radom": _3, "rawa-maz": _3, "rybnik": _3, "rzeszow": _3, "sanok": _3, "sejny": _3, "skoczow": _3, "slask": _3, "slupsk": _3, "sosnowiec": _3, "stalowa-wola": _3, "starachowice": _3, "stargard": _3, "suwalki": _3, "swidnica": _3, "swiebodzin": _3, "swinoujscie": _3, "szczecin": _3, "szczytno": _3, "tarnobrzeg": _3, "tgory": _3, "turek": _3, "tychy": _3, "ustka": _3, "walbrzych": _3, "warmia": _3, "warszawa": _3, "waw": _3, "wegrow": _3, "wielun": _3, "wlocl": _3, "wloclawek": _3, "wodzislaw": _3, "wolomin": _3, "wroclaw": _3, "zachpomor": _3, "zagan": _3, "zarow": _3, "zgora": _3, "zgorzelec": _3, "art": _4, "gliwice": _4, "krakow": _4, "poznan": _4, "wroc": _4, "zakopane": _4, "beep": _4, "ecommerce-shop": _4, "cfolks": _4, "dfirma": _4, "dkonto": _4, "you2": _4, "shoparena": _4, "homesklep": _4, "sdscloud": _4, "unicloud": _4, "lodz": _4, "pabianice": _4, "plock": _4, "sieradz": _4, "skierniewice": _4, "zgierz": _4, "krasnik": _4, "leczna": _4, "lubartow": _4, "lublin": _4, "poniatowa": _4, "swidnik": _4, "co": _4, "torun": _4, "simplesite": _4, "myspreadshop": _4, "gda": _4, "gdansk": _4, "gdynia": _4, "med": _4, "sopot": _4, "bielsko": _4 }], "pm": [1, { "own": _4, "name": _4 }], "pn": [1, { "co": _3, "edu": _3, "gov": _3, "net": _3, "org": _3 }], "post": _3, "pr": [1, { "biz": _3, "com": _3, "edu": _3, "gov": _3, "info": _3, "isla": _3, "name": _3, "net": _3, "org": _3, "pro": _3, "ac": _3, "est": _3, "prof": _3 }], "pro": [1, { "aaa": _3, "aca": _3, "acct": _3, "avocat": _3, "bar": _3, "cpa": _3, "eng": _3, "jur": _3, "law": _3, "med": _3, "recht": _3, "12chars": _4, "cloudns": _4, "barsy": _4, "ngrok": _4 }], "ps": [1, { "com": _3, "edu": _3, "gov": _3, "net": _3, "org": _3, "plo": _3, "sec": _3 }], "pt": [1, { "com": _3, "edu": _3, "gov": _3, "int": _3, "net": _3, "nome": _3, "org": _3, "publ": _3, "123paginaweb": _4 }], "pw": [1, { "gov": _3, "cloudns": _4, "x443": _4 }], "py": [1, { "com": _3, "coop": _3, "edu": _3, "gov": _3, "mil": _3, "net": _3, "org": _3 }], "qa": [1, { "com": _3, "edu": _3, "gov": _3, "mil": _3, "name": _3, "net": _3, "org": _3, "sch": _3 }], "re": [1, { "asso": _3, "com": _3, "netlib": _4, "can": _4 }], "ro": [1, { "arts": _3, "com": _3, "firm": _3, "info": _3, "nom": _3, "nt": _3, "org": _3, "rec": _3, "store": _3, "tm": _3, "www": _3, "co": _4, "shop": _4, "barsy": _4 }], "rs": [1, { "ac": _3, "co": _3, "edu": _3, "gov": _3, "in": _3, "org": _3, "brendly": _50, "barsy": _4, "ox": _4 }], "ru": [1, { "ac": _4, "edu": _4, "gov": _4, "int": _4, "mil": _4, "eurodir": _4, "adygeya": _4, "bashkiria": _4, "bir": _4, "cbg": _4, "com": _4, "dagestan": _4, "grozny": _4, "kalmykia": _4, "kustanai": _4, "marine": _4, "mordovia": _4, "msk": _4, "mytis": _4, "nalchik": _4, "nov": _4, "pyatigorsk": _4, "spb": _4, "vladikavkaz": _4, "vladimir": _4, "na4u": _4, "mircloud": _4, "myjino": [2, { "hosting": _7, "landing": _7, "spectrum": _7, "vps": _7 }], "cldmail": [0, { "hb": _4 }], "mcdir": [2, { "vps": _4 }], "mcpre": _4, "net": _4, "org": _4, "pp": _4, "lk3": _4, "ras": _4 }], "rw": [1, { "ac": _3, "co": _3, "coop": _3, "gov": _3, "mil": _3, "net": _3, "org": _3 }], "sa": [1, { "com": _3, "edu": _3, "gov": _3, "med": _3, "net": _3, "org": _3, "pub": _3, "sch": _3 }], "sb": _5, "sc": _5, "sd": [1, { "com": _3, "edu": _3, "gov": _3, "info": _3, "med": _3, "net": _3, "org": _3, "tv": _3 }], "se": [1, { "a": _3, "ac": _3, "b": _3, "bd": _3, "brand": _3, "c": _3, "d": _3, "e": _3, "f": _3, "fh": _3, "fhsk": _3, "fhv": _3, "g": _3, "h": _3, "i": _3, "k": _3, "komforb": _3, "kommunalforbund": _3, "komvux": _3, "l": _3, "lanbib": _3, "m": _3, "n": _3, "naturbruksgymn": _3, "o": _3, "org": _3, "p": _3, "parti": _3, "pp": _3, "press": _3, "r": _3, "s": _3, "t": _3, "tm": _3, "u": _3, "w": _3, "x": _3, "y": _3, "z": _3, "com": _4, "iopsys": _4, "123minsida": _4, "itcouldbewor": _4, "myspreadshop": _4 }], "sg": [1, { "com": _3, "edu": _3, "gov": _3, "net": _3, "org": _3, "enscaled": _4 }], "sh": [1, { "com": _3, "gov": _3, "mil": _3, "net": _3, "org": _3, "hashbang": _4, "botda": _4, "platform": [0, { "ent": _4, "eu": _4, "us": _4 }], "now": _4 }], "si": [1, { "f5": _4, "gitapp": _4, "gitpage": _4 }], "sj": _3, "sk": _3, "sl": _5, "sm": _3, "sn": [1, { "art": _3, "com": _3, "edu": _3, "gouv": _3, "org": _3, "perso": _3, "univ": _3 }], "so": [1, { "com": _3, "edu": _3, "gov": _3, "me": _3, "net": _3, "org": _3, "surveys": _4 }], "sr": _3, "ss": [1, { "biz": _3, "co": _3, "com": _3, "edu": _3, "gov": _3, "me": _3, "net": _3, "org": _3, "sch": _3 }], "st": [1, { "co": _3, "com": _3, "consulado": _3, "edu": _3, "embaixada": _3, "mil": _3, "net": _3, "org": _3, "principe": _3, "saotome": _3, "store": _3, "helioho": _4, "kirara": _4, "noho": _4 }], "su": [1, { "abkhazia": _4, "adygeya": _4, "aktyubinsk": _4, "arkhangelsk": _4, "armenia": _4, "ashgabad": _4, "azerbaijan": _4, "balashov": _4, "bashkiria": _4, "bryansk": _4, "bukhara": _4, "chimkent": _4, "dagestan": _4, "east-kazakhstan": _4, "exnet": _4, "georgia": _4, "grozny": _4, "ivanovo": _4, "jambyl": _4, "kalmykia": _4, "kaluga": _4, "karacol": _4, "karaganda": _4, "karelia": _4, "khakassia": _4, "krasnodar": _4, "kurgan": _4, "kustanai": _4, "lenug": _4, "mangyshlak": _4, "mordovia": _4, "msk": _4, "murmansk": _4, "nalchik": _4, "navoi": _4, "north-kazakhstan": _4, "nov": _4, "obninsk": _4, "penza": _4, "pokrovsk": _4, "sochi": _4, "spb": _4, "tashkent": _4, "termez": _4, "togliatti": _4, "troitsk": _4, "tselinograd": _4, "tula": _4, "tuva": _4, "vladikavkaz": _4, "vladimir": _4, "vologda": _4 }], "sv": [1, { "com": _3, "edu": _3, "gob": _3, "org": _3, "red": _3 }], "sx": _11, "sy": _6, "sz": [1, { "ac": _3, "co": _3, "org": _3 }], "tc": _3, "td": _3, "tel": _3, "tf": [1, { "sch": _4 }], "tg": _3, "th": [1, { "ac": _3, "co": _3, "go": _3, "in": _3, "mi": _3, "net": _3, "or": _3, "online": _4, "shop": _4 }], "tj": [1, { "ac": _3, "biz": _3, "co": _3, "com": _3, "edu": _3, "go": _3, "gov": _3, "int": _3, "mil": _3, "name": _3, "net": _3, "nic": _3, "org": _3, "test": _3, "web": _3 }], "tk": _3, "tl": _11, "tm": [1, { "co": _3, "com": _3, "edu": _3, "gov": _3, "mil": _3, "net": _3, "nom": _3, "org": _3 }], "tn": [1, { "com": _3, "ens": _3, "fin": _3, "gov": _3, "ind": _3, "info": _3, "intl": _3, "mincom": _3, "nat": _3, "net": _3, "org": _3, "perso": _3, "tourism": _3, "orangecloud": _4 }], "to": [1, { "611": _4, "com": _3, "edu": _3, "gov": _3, "mil": _3, "net": _3, "org": _3, "oya": _4, "x0": _4, "quickconnect": _25, "vpnplus": _4 }], "tr": [1, { "av": _3, "bbs": _3, "bel": _3, "biz": _3, "com": _3, "dr": _3, "edu": _3, "gen": _3, "gov": _3, "info": _3, "k12": _3, "kep": _3, "mil": _3, "name": _3, "net": _3, "org": _3, "pol": _3, "tel": _3, "tsk": _3, "tv": _3, "web": _3, "nc": _11 }], "tt": [1, { "biz": _3, "co": _3, "com": _3, "edu": _3, "gov": _3, "info": _3, "mil": _3, "name": _3, "net": _3, "org": _3, "pro": _3 }], "tv": [1, { "better-than": _4, "dyndns": _4, "on-the-web": _4, "worse-than": _4, "from": _4, "sakura": _4 }], "tw": [1, { "club": _3, "com": [1, { "mymailer": _4 }], "ebiz": _3, "edu": _3, "game": _3, "gov": _3, "idv": _3, "mil": _3, "net": _3, "org": _3, "url": _4, "mydns": _4 }], "tz": [1, { "ac": _3, "co": _3, "go": _3, "hotel": _3, "info": _3, "me": _3, "mil": _3, "mobi": _3, "ne": _3, "or": _3, "sc": _3, "tv": _3 }], "ua": [1, { "com": _3, "edu": _3, "gov": _3, "in": _3, "net": _3, "org": _3, "cherkassy": _3, "cherkasy": _3, "chernigov": _3, "chernihiv": _3, "chernivtsi": _3, "chernovtsy": _3, "ck": _3, "cn": _3, "cr": _3, "crimea": _3, "cv": _3, "dn": _3, "dnepropetrovsk": _3, "dnipropetrovsk": _3, "donetsk": _3, "dp": _3, "if": _3, "ivano-frankivsk": _3, "kh": _3, "kharkiv": _3, "kharkov": _3, "kherson": _3, "khmelnitskiy": _3, "khmelnytskyi": _3, "kiev": _3, "kirovograd": _3, "km": _3, "kr": _3, "kropyvnytskyi": _3, "krym": _3, "ks": _3, "kv": _3, "kyiv": _3, "lg": _3, "lt": _3, "lugansk": _3, "luhansk": _3, "lutsk": _3, "lv": _3, "lviv": _3, "mk": _3, "mykolaiv": _3, "nikolaev": _3, "od": _3, "odesa": _3, "odessa": _3, "pl": _3, "poltava": _3, "rivne": _3, "rovno": _3, "rv": _3, "sb": _3, "sebastopol": _3, "sevastopol": _3, "sm": _3, "sumy": _3, "te": _3, "ternopil": _3, "uz": _3, "uzhgorod": _3, "uzhhorod": _3, "vinnica": _3, "vinnytsia": _3, "vn": _3, "volyn": _3, "yalta": _3, "zakarpattia": _3, "zaporizhzhe": _3, "zaporizhzhia": _3, "zhitomir": _3, "zhytomyr": _3, "zp": _3, "zt": _3, "cc": _4, "inf": _4, "ltd": _4, "cx": _4, "ie": _4, "biz": _4, "co": _4, "pp": _4, "v": _4 }], "ug": [1, { "ac": _3, "co": _3, "com": _3, "edu": _3, "go": _3, "gov": _3, "mil": _3, "ne": _3, "or": _3, "org": _3, "sc": _3, "us": _3 }], "uk": [1, { "ac": _3, "co": [1, { "bytemark": [0, { "dh": _4, "vm": _4 }], "layershift": _45, "barsy": _4, "barsyonline": _4, "retrosnub": _53, "nh-serv": _4, "no-ip": _4, "adimo": _4, "myspreadshop": _4 }], "gov": [1, { "api": _4, "campaign": _4, "service": _4 }], "ltd": _3, "me": _3, "net": _3, "nhs": _3, "org": [1, { "glug": _4, "lug": _4, "lugs": _4, "affinitylottery": _4, "raffleentry": _4, "weeklylottery": _4 }], "plc": _3, "police": _3, "sch": _18, "conn": _4, "copro": _4, "hosp": _4, "independent-commission": _4, "independent-inquest": _4, "independent-inquiry": _4, "independent-panel": _4, "independent-review": _4, "public-inquiry": _4, "royal-commission": _4, "pymnt": _4, "barsy": _4, "nimsite": _4, "oraclegovcloudapps": _7 }], "us": [1, { "dni": _3, "isa": _3, "nsn": _3, "ak": _60, "al": _60, "ar": _60, "as": _60, "az": _60, "ca": _60, "co": _60, "ct": _60, "dc": _60, "de": [1, { "cc": _3, "lib": _4 }], "fl": _60, "ga": _60, "gu": _60, "hi": _61, "ia": _60, "id": _60, "il": _60, "in": _60, "ks": _60, "ky": _60, "la": _60, "ma": [1, { "k12": [1, { "chtr": _3, "paroch": _3, "pvt": _3 }], "cc": _3, "lib": _3 }], "md": _60, "me": _60, "mi": [1, { "k12": _3, "cc": _3, "lib": _3, "ann-arbor": _3, "cog": _3, "dst": _3, "eaton": _3, "gen": _3, "mus": _3, "tec": _3, "washtenaw": _3 }], "mn": _60, "mo": _60, "ms": _60, "mt": _60, "nc": _60, "nd": _61, "ne": _60, "nh": _60, "nj": _60, "nm": _60, "nv": _60, "ny": _60, "oh": _60, "ok": _60, "or": _60, "pa": _60, "pr": _60, "ri": _61, "sc": _60, "sd": _61, "tn": _60, "tx": _60, "ut": _60, "va": _60, "vi": _60, "vt": _60, "wa": _60, "wi": _60, "wv": [1, { "cc": _3 }], "wy": _60, "cloudns": _4, "is-by": _4, "land-4-sale": _4, "stuff-4-sale": _4, "heliohost": _4, "enscaled": [0, { "phx": _4 }], "mircloud": _4, "ngo": _4, "golffan": _4, "noip": _4, "pointto": _4, "freeddns": _4, "srv": [2, { "gh": _4, "gl": _4 }], "platterp": _4, "servername": _4 }], "uy": [1, { "com": _3, "edu": _3, "gub": _3, "mil": _3, "net": _3, "org": _3 }], "uz": [1, { "co": _3, "com": _3, "net": _3, "org": _3 }], "va": _3, "vc": [1, { "com": _3, "edu": _3, "gov": _3, "mil": _3, "net": _3, "org": _3, "gv": [2, { "d": _4 }], "0e": _7, "mydns": _4 }], "ve": [1, { "arts": _3, "bib": _3, "co": _3, "com": _3, "e12": _3, "edu": _3, "emprende": _3, "firm": _3, "gob": _3, "gov": _3, "info": _3, "int": _3, "mil": _3, "net": _3, "nom": _3, "org": _3, "rar": _3, "rec": _3, "store": _3, "tec": _3, "web": _3 }], "vg": [1, { "edu": _3 }], "vi": [1, { "co": _3, "com": _3, "k12": _3, "net": _3, "org": _3 }], "vn": [1, { "ac": _3, "ai": _3, "biz": _3, "com": _3, "edu": _3, "gov": _3, "health": _3, "id": _3, "info": _3, "int": _3, "io": _3, "name": _3, "net": _3, "org": _3, "pro": _3, "angiang": _3, "bacgiang": _3, "backan": _3, "baclieu": _3, "bacninh": _3, "baria-vungtau": _3, "bentre": _3, "binhdinh": _3, "binhduong": _3, "binhphuoc": _3, "binhthuan": _3, "camau": _3, "cantho": _3, "caobang": _3, "daklak": _3, "daknong": _3, "danang": _3, "dienbien": _3, "dongnai": _3, "dongthap": _3, "gialai": _3, "hagiang": _3, "haiduong": _3, "haiphong": _3, "hanam": _3, "hanoi": _3, "hatinh": _3, "haugiang": _3, "hoabinh": _3, "hungyen": _3, "khanhhoa": _3, "kiengiang": _3, "kontum": _3, "laichau": _3, "lamdong": _3, "langson": _3, "laocai": _3, "longan": _3, "namdinh": _3, "nghean": _3, "ninhbinh": _3, "ninhthuan": _3, "phutho": _3, "phuyen": _3, "quangbinh": _3, "quangnam": _3, "quangngai": _3, "quangninh": _3, "quangtri": _3, "soctrang": _3, "sonla": _3, "tayninh": _3, "thaibinh": _3, "thainguyen": _3, "thanhhoa": _3, "thanhphohochiminh": _3, "thuathienhue": _3, "tiengiang": _3, "travinh": _3, "tuyenquang": _3, "vinhlong": _3, "vinhphuc": _3, "yenbai": _3 }], "vu": _44, "wf": [1, { "biz": _4, "sch": _4 }], "ws": [1, { "com": _3, "edu": _3, "gov": _3, "net": _3, "org": _3, "advisor": _7, "cloud66": _4, "dyndns": _4, "mypets": _4 }], "yt": [1, { "org": _4 }], "xn--mgbaam7a8h": _3, "امارات": _3, "xn--y9a3aq": _3, "հայ": _3, "xn--54b7fta0cc": _3, "বাংলা": _3, "xn--90ae": _3, "бг": _3, "xn--mgbcpq6gpa1a": _3, "البحرين": _3, "xn--90ais": _3, "бел": _3, "xn--fiqs8s": _3, "中国": _3, "xn--fiqz9s": _3, "中國": _3, "xn--lgbbat1ad8j": _3, "الجزائر": _3, "xn--wgbh1c": _3, "مصر": _3, "xn--e1a4c": _3, "ею": _3, "xn--qxa6a": _3, "ευ": _3, "xn--mgbah1a3hjkrd": _3, "موريتانيا": _3, "xn--node": _3, "გე": _3, "xn--qxam": _3, "ελ": _3, "xn--j6w193g": [1, { "xn--gmqw5a": _3, "xn--55qx5d": _3, "xn--mxtq1m": _3, "xn--wcvs22d": _3, "xn--uc0atv": _3, "xn--od0alg": _3 }], "香港": [1, { "個人": _3, "公司": _3, "政府": _3, "教育": _3, "組織": _3, "網絡": _3 }], "xn--2scrj9c": _3, "ಭಾರತ": _3, "xn--3hcrj9c": _3, "ଭାରତ": _3, "xn--45br5cyl": _3, "ভাৰত": _3, "xn--h2breg3eve": _3, "भारतम्": _3, "xn--h2brj9c8c": _3, "भारोत": _3, "xn--mgbgu82a": _3, "ڀارت": _3, "xn--rvc1e0am3e": _3, "ഭാരതം": _3, "xn--h2brj9c": _3, "भारत": _3, "xn--mgbbh1a": _3, "بارت": _3, "xn--mgbbh1a71e": _3, "بھارت": _3, "xn--fpcrj9c3d": _3, "భారత్": _3, "xn--gecrj9c": _3, "ભારત": _3, "xn--s9brj9c": _3, "ਭਾਰਤ": _3, "xn--45brj9c": _3, "ভারত": _3, "xn--xkc2dl3a5ee0h": _3, "இந்தியா": _3, "xn--mgba3a4f16a": _3, "ایران": _3, "xn--mgba3a4fra": _3, "ايران": _3, "xn--mgbtx2b": _3, "عراق": _3, "xn--mgbayh7gpa": _3, "الاردن": _3, "xn--3e0b707e": _3, "한국": _3, "xn--80ao21a": _3, "қаз": _3, "xn--q7ce6a": _3, "ລາວ": _3, "xn--fzc2c9e2c": _3, "ලංකා": _3, "xn--xkc2al3hye2a": _3, "இலங்கை": _3, "xn--mgbc0a9azcg": _3, "المغرب": _3, "xn--d1alf": _3, "мкд": _3, "xn--l1acc": _3, "мон": _3, "xn--mix891f": _3, "澳門": _3, "xn--mix082f": _3, "澳门": _3, "xn--mgbx4cd0ab": _3, "مليسيا": _3, "xn--mgb9awbf": _3, "عمان": _3, "xn--mgbai9azgqp6j": _3, "پاکستان": _3, "xn--mgbai9a5eva00b": _3, "پاكستان": _3, "xn--ygbi2ammx": _3, "فلسطين": _3, "xn--90a3ac": [1, { "xn--80au": _3, "xn--90azh": _3, "xn--d1at": _3, "xn--c1avg": _3, "xn--o1ac": _3, "xn--o1ach": _3 }], "срб": [1, { "ак": _3, "обр": _3, "од": _3, "орг": _3, "пр": _3, "упр": _3 }], "xn--p1ai": _3, "рф": _3, "xn--wgbl6a": _3, "قطر": _3, "xn--mgberp4a5d4ar": _3, "السعودية": _3, "xn--mgberp4a5d4a87g": _3, "السعودیة": _3, "xn--mgbqly7c0a67fbc": _3, "السعودیۃ": _3, "xn--mgbqly7cvafr": _3, "السعوديه": _3, "xn--mgbpl2fh": _3, "سودان": _3, "xn--yfro4i67o": _3, "新加坡": _3, "xn--clchc0ea0b2g2a9gcd": _3, "சிங்கப்பூர்": _3, "xn--ogbpf8fl": _3, "سورية": _3, "xn--mgbtf8fl": _3, "سوريا": _3, "xn--o3cw4h": [1, { "xn--o3cyx2a": _3, "xn--12co0c3b4eva": _3, "xn--m3ch0j3a": _3, "xn--h3cuzk1di": _3, "xn--12c1fe0br": _3, "xn--12cfi8ixb8l": _3 }], "ไทย": [1, { "ทหาร": _3, "ธุรกิจ": _3, "เน็ต": _3, "รัฐบาล": _3, "ศึกษา": _3, "องค์กร": _3 }], "xn--pgbs0dh": _3, "تونس": _3, "xn--kpry57d": _3, "台灣": _3, "xn--kprw13d": _3, "台湾": _3, "xn--nnx388a": _3, "臺灣": _3, "xn--j1amh": _3, "укр": _3, "xn--mgb2ddes": _3, "اليمن": _3, "xxx": _3, "ye": _6, "za": [0, { "ac": _3, "agric": _3, "alt": _3, "co": _3, "edu": _3, "gov": _3, "grondar": _3, "law": _3, "mil": _3, "net": _3, "ngo": _3, "nic": _3, "nis": _3, "nom": _3, "org": _3, "school": _3, "tm": _3, "web": _3 }], "zm": [1, { "ac": _3, "biz": _3, "co": _3, "com": _3, "edu": _3, "gov": _3, "info": _3, "mil": _3, "net": _3, "org": _3, "sch": _3 }], "zw": [1, { "ac": _3, "co": _3, "gov": _3, "mil": _3, "org": _3 }], "aaa": _3, "aarp": _3, "abb": _3, "abbott": _3, "abbvie": _3, "abc": _3, "able": _3, "abogado": _3, "abudhabi": _3, "academy": [1, { "official": _4 }], "accenture": _3, "accountant": _3, "accountants": _3, "aco": _3, "actor": _3, "ads": _3, "adult": _3, "aeg": _3, "aetna": _3, "afl": _3, "africa": _3, "agakhan": _3, "agency": _3, "aig": _3, "airbus": _3, "airforce": _3, "airtel": _3, "akdn": _3, "alibaba": _3, "alipay": _3, "allfinanz": _3, "allstate": _3, "ally": _3, "alsace": _3, "alstom": _3, "amazon": _3, "americanexpress": _3, "americanfamily": _3, "amex": _3, "amfam": _3, "amica": _3, "amsterdam": _3, "analytics": _3, "android": _3, "anquan": _3, "anz": _3, "aol": _3, "apartments": _3, "app": [1, { "adaptable": _4, "aiven": _4, "beget": _7, "brave": _8, "clerk": _4, "clerkstage": _4, "wnext": _4, "csb": [2, { "preview": _4 }], "deta": _4, "ondigitalocean": _4, "easypanel": _4, "encr": _4, "evervault": _9, "expo": [2, { "staging": _4 }], "edgecompute": _4, "on-fleek": _4, "flutterflow": _4, "framer": _4, "hosted": _7, "run": _7, "web": _4, "hasura": _4, "botdash": _4, "loginline": _4, "lovable": _4, "medusajs": _4, "messerli": _4, "netfy": _4, "netlify": _4, "ngrok": _4, "ngrok-free": _4, "developer": _7, "noop": _4, "northflank": _7, "upsun": _7, "replit": _10, "nyat": _4, "snowflake": [0, { "*": _4, "privatelink": _7 }], "streamlit": _4, "storipress": _4, "telebit": _4, "typedream": _4, "vercel": _4, "bookonline": _4, "wdh": _4, "zeabur": _4, "zerops": _7 }], "apple": _3, "aquarelle": _3, "arab": _3, "aramco": _3, "archi": _3, "army": _3, "art": _3, "arte": _3, "asda": _3, "associates": _3, "athleta": _3, "attorney": _3, "auction": _3, "audi": _3, "audible": _3, "audio": _3, "auspost": _3, "author": _3, "auto": _3, "autos": _3, "aws": [1, { "sagemaker": [0, { "ap-northeast-1": _14, "ap-northeast-2": _14, "ap-south-1": _14, "ap-southeast-1": _14, "ap-southeast-2": _14, "ca-central-1": _16, "eu-central-1": _14, "eu-west-1": _14, "eu-west-2": _14, "us-east-1": _16, "us-east-2": _16, "us-west-2": _16, "af-south-1": _13, "ap-east-1": _13, "ap-northeast-3": _13, "ap-south-2": _15, "ap-southeast-3": _13, "ap-southeast-4": _15, "ca-west-1": [0, { "notebook": _4, "notebook-fips": _4 }], "eu-central-2": _13, "eu-north-1": _13, "eu-south-1": _13, "eu-south-2": _13, "eu-west-3": _13, "il-central-1": _13, "me-central-1": _13, "me-south-1": _13, "sa-east-1": _13, "us-gov-east-1": _17, "us-gov-west-1": _17, "us-west-1": [0, { "notebook": _4, "notebook-fips": _4, "studio": _4 }], "experiments": _7 }], "repost": [0, { "private": _7 }], "on": [0, { "ap-northeast-1": _12, "ap-southeast-1": _12, "ap-southeast-2": _12, "eu-central-1": _12, "eu-north-1": _12, "eu-west-1": _12, "us-east-1": _12, "us-east-2": _12, "us-west-2": _12 }] }], "axa": _3, "azure": _3, "baby": _3, "baidu": _3, "banamex": _3, "band": _3, "bank": _3, "bar": _3, "barcelona": _3, "barclaycard": _3, "barclays": _3, "barefoot": _3, "bargains": _3, "baseball": _3, "basketball": [1, { "aus": _4, "nz": _4 }], "bauhaus": _3, "bayern": _3, "bbc": _3, "bbt": _3, "bbva": _3, "bcg": _3, "bcn": _3, "beats": _3, "beauty": _3, "beer": _3, "bentley": _3, "berlin": _3, "best": _3, "bestbuy": _3, "bet": _3, "bharti": _3, "bible": _3, "bid": _3, "bike": _3, "bing": _3, "bingo": _3, "bio": _3, "black": _3, "blackfriday": _3, "blockbuster": _3, "blog": _3, "bloomberg": _3, "blue": _3, "bms": _3, "bmw": _3, "bnpparibas": _3, "boats": _3, "boehringer": _3, "bofa": _3, "bom": _3, "bond": _3, "boo": _3, "book": _3, "booking": _3, "bosch": _3, "bostik": _3, "boston": _3, "bot": _3, "boutique": _3, "box": _3, "bradesco": _3, "bridgestone": _3, "broadway": _3, "broker": _3, "brother": _3, "brussels": _3, "build": [1, { "v0": _4 }], "builders": [1, { "cloudsite": _4 }], "business": _19, "buy": _3, "buzz": _3, "bzh": _3, "cab": _3, "cafe": _3, "cal": _3, "call": _3, "calvinklein": _3, "cam": _3, "camera": _3, "camp": [1, { "emf": [0, { "at": _4 }] }], "canon": _3, "capetown": _3, "capital": _3, "capitalone": _3, "car": _3, "caravan": _3, "cards": _3, "care": _3, "career": _3, "careers": _3, "cars": _3, "casa": [1, { "nabu": [0, { "ui": _4 }] }], "case": _3, "cash": _3, "casino": _3, "catering": _3, "catholic": _3, "cba": _3, "cbn": _3, "cbre": _3, "center": _3, "ceo": _3, "cern": _3, "cfa": _3, "cfd": _3, "chanel": _3, "channel": _3, "charity": _3, "chase": _3, "chat": _3, "cheap": _3, "chintai": _3, "christmas": _3, "chrome": _3, "church": _3, "cipriani": _3, "circle": _3, "cisco": _3, "citadel": _3, "citi": _3, "citic": _3, "city": _3, "claims": _3, "cleaning": _3, "click": _3, "clinic": _3, "clinique": _3, "clothing": _3, "cloud": [1, { "elementor": _4, "encoway": [0, { "eu": _4 }], "statics": _7, "ravendb": _4, "axarnet": [0, { "es-1": _4 }], "diadem": _4, "jelastic": [0, { "vip": _4 }], "jele": _4, "jenv-aruba": [0, { "aruba": [0, { "eur": [0, { "it1": _4 }] }], "it1": _4 }], "keliweb": [2, { "cs": _4 }], "oxa": [2, { "tn": _4, "uk": _4 }], "primetel": [2, { "uk": _4 }], "reclaim": [0, { "ca": _4, "uk": _4, "us": _4 }], "trendhosting": [0, { "ch": _4, "de": _4 }], "jotelulu": _4, "kuleuven": _4, "laravel": _4, "linkyard": _4, "magentosite": _7, "matlab": _4, "observablehq": _4, "perspecta": _4, "vapor": _4, "on-rancher": _7, "scw": [0, { "baremetal": [0, { "fr-par-1": _4, "fr-par-2": _4, "nl-ams-1": _4 }], "fr-par": [0, { "cockpit": _4, "fnc": [2, { "functions": _4 }], "k8s": _21, "s3": _4, "s3-website": _4, "whm": _4 }], "instances": [0, { "priv": _4, "pub": _4 }], "k8s": _4, "nl-ams": [0, { "cockpit": _4, "k8s": _21, "s3": _4, "s3-website": _4, "whm": _4 }], "pl-waw": [0, { "cockpit": _4, "k8s": _21, "s3": _4, "s3-website": _4 }], "scalebook": _4, "smartlabeling": _4 }], "servebolt": _4, "onstackit": [0, { "runs": _4 }], "trafficplex": _4, "unison-services": _4, "urown": _4, "voorloper": _4, "zap": _4 }], "club": [1, { "cloudns": _4, "jele": _4, "barsy": _4 }], "clubmed": _3, "coach": _3, "codes": [1, { "owo": _7 }], "coffee": _3, "college": _3, "cologne": _3, "commbank": _3, "community": [1, { "nog": _4, "ravendb": _4, "myforum": _4 }], "company": _3, "compare": _3, "computer": _3, "comsec": _3, "condos": _3, "construction": _3, "consulting": _3, "contact": _3, "contractors": _3, "cooking": _3, "cool": [1, { "elementor": _4, "de": _4 }], "corsica": _3, "country": _3, "coupon": _3, "coupons": _3, "courses": _3, "cpa": _3, "credit": _3, "creditcard": _3, "creditunion": _3, "cricket": _3, "crown": _3, "crs": _3, "cruise": _3, "cruises": _3, "cuisinella": _3, "cymru": _3, "cyou": _3, "dad": _3, "dance": _3, "data": _3, "date": _3, "dating": _3, "datsun": _3, "day": _3, "dclk": _3, "dds": _3, "deal": _3, "dealer": _3, "deals": _3, "degree": _3, "delivery": _3, "dell": _3, "deloitte": _3, "delta": _3, "democrat": _3, "dental": _3, "dentist": _3, "desi": _3, "design": [1, { "graphic": _4, "bss": _4 }], "dev": [1, { "12chars": _4, "myaddr": _4, "panel": _4, "lcl": _7, "lclstage": _7, "stg": _7, "stgstage": _7, "pages": _4, "r2": _4, "workers": _4, "deno": _4, "deno-staging": _4, "deta": _4, "evervault": _9, "fly": _4, "githubpreview": _4, "gateway": _7, "hrsn": [2, { "psl": [0, { "sub": _4, "wc": [0, { "*": _4, "sub": _7 }] }] }], "botdash": _4, "is-a-good": _4, "is-a": _4, "iserv": _4, "runcontainers": _4, "localcert": [0, { "user": _7 }], "loginline": _4, "barsy": _4, "mediatech": _4, "modx": _4, "ngrok": _4, "ngrok-free": _4, "is-a-fullstack": _4, "is-cool": _4, "is-not-a": _4, "localplayer": _4, "xmit": _4, "platter-app": _4, "replit": [2, { "archer": _4, "bones": _4, "canary": _4, "global": _4, "hacker": _4, "id": _4, "janeway": _4, "kim": _4, "kira": _4, "kirk": _4, "odo": _4, "paris": _4, "picard": _4, "pike": _4, "prerelease": _4, "reed": _4, "riker": _4, "sisko": _4, "spock": _4, "staging": _4, "sulu": _4, "tarpit": _4, "teams": _4, "tucker": _4, "wesley": _4, "worf": _4 }], "crm": [0, { "d": _7, "w": _7, "wa": _7, "wb": _7, "wc": _7, "wd": _7, "we": _7, "wf": _7 }], "vercel": _4, "webhare": _7 }], "dhl": _3, "diamonds": _3, "diet": _3, "digital": [1, { "cloudapps": [2, { "london": _4 }] }], "direct": [1, { "libp2p": _4 }], "directory": _3, "discount": _3, "discover": _3, "dish": _3, "diy": _3, "dnp": _3, "docs": _3, "doctor": _3, "dog": _3, "domains": _3, "dot": _3, "download": _3, "drive": _3, "dtv": _3, "dubai": _3, "dunlop": _3, "dupont": _3, "durban": _3, "dvag": _3, "dvr": _3, "earth": _3, "eat": _3, "eco": _3, "edeka": _3, "education": _19, "email": [1, { "crisp": [0, { "on": _4 }], "tawk": _48, "tawkto": _48 }], "emerck": _3, "energy": _3, "engineer": _3, "engineering": _3, "enterprises": _3, "epson": _3, "equipment": _3, "ericsson": _3, "erni": _3, "esq": _3, "estate": [1, { "compute": _7 }], "eurovision": _3, "eus": [1, { "party": _49 }], "events": [1, { "koobin": _4, "co": _4 }], "exchange": _3, "expert": _3, "exposed": _3, "express": _3, "extraspace": _3, "fage": _3, "fail": _3, "fairwinds": _3, "faith": _3, "family": _3, "fan": _3, "fans": _3, "farm": [1, { "storj": _4 }], "farmers": _3, "fashion": _3, "fast": _3, "fedex": _3, "feedback": _3, "ferrari": _3, "ferrero": _3, "fidelity": _3, "fido": _3, "film": _3, "final": _3, "finance": _3, "financial": _19, "fire": _3, "firestone": _3, "firmdale": _3, "fish": _3, "fishing": _3, "fit": _3, "fitness": _3, "flickr": _3, "flights": _3, "flir": _3, "florist": _3, "flowers": _3, "fly": _3, "foo": _3, "food": _3, "football": _3, "ford": _3, "forex": _3, "forsale": _3, "forum": _3, "foundation": _3, "fox": _3, "free": _3, "fresenius": _3, "frl": _3, "frogans": _3, "frontier": _3, "ftr": _3, "fujitsu": _3, "fun": _3, "fund": _3, "furniture": _3, "futbol": _3, "fyi": _3, "gal": _3, "gallery": _3, "gallo": _3, "gallup": _3, "game": _3, "games": [1, { "pley": _4, "sheezy": _4 }], "gap": _3, "garden": _3, "gay": [1, { "pages": _4 }], "gbiz": _3, "gdn": [1, { "cnpy": _4 }], "gea": _3, "gent": _3, "genting": _3, "george": _3, "ggee": _3, "gift": _3, "gifts": _3, "gives": _3, "giving": _3, "glass": _3, "gle": _3, "global": _3, "globo": _3, "gmail": _3, "gmbh": _3, "gmo": _3, "gmx": _3, "godaddy": _3, "gold": _3, "goldpoint": _3, "golf": _3, "goo": _3, "goodyear": _3, "goog": [1, { "cloud": _4, "translate": _4, "usercontent": _7 }], "google": _3, "gop": _3, "got": _3, "grainger": _3, "graphics": _3, "gratis": _3, "green": _3, "gripe": _3, "grocery": _3, "group": [1, { "discourse": _4 }], "gucci": _3, "guge": _3, "guide": _3, "guitars": _3, "guru": _3, "hair": _3, "hamburg": _3, "hangout": _3, "haus": _3, "hbo": _3, "hdfc": _3, "hdfcbank": _3, "health": [1, { "hra": _4 }], "healthcare": _3, "help": _3, "helsinki": _3, "here": _3, "hermes": _3, "hiphop": _3, "hisamitsu": _3, "hitachi": _3, "hiv": _3, "hkt": _3, "hockey": _3, "holdings": _3, "holiday": _3, "homedepot": _3, "homegoods": _3, "homes": _3, "homesense": _3, "honda": _3, "horse": _3, "hospital": _3, "host": [1, { "cloudaccess": _4, "freesite": _4, "easypanel": _4, "fastvps": _4, "myfast": _4, "tempurl": _4, "wpmudev": _4, "jele": _4, "mircloud": _4, "wp2": _4, "half": _4 }], "hosting": [1, { "opencraft": _4 }], "hot": _3, "hotels": _3, "hotmail": _3, "house": _3, "how": _3, "hsbc": _3, "hughes": _3, "hyatt": _3, "hyundai": _3, "ibm": _3, "icbc": _3, "ice": _3, "icu": _3, "ieee": _3, "ifm": _3, "ikano": _3, "imamat": _3, "imdb": _3, "immo": _3, "immobilien": _3, "inc": _3, "industries": _3, "infiniti": _3, "ing": _3, "ink": _3, "institute": _3, "insurance": _3, "insure": _3, "international": _3, "intuit": _3, "investments": _3, "ipiranga": _3, "irish": _3, "ismaili": _3, "ist": _3, "istanbul": _3, "itau": _3, "itv": _3, "jaguar": _3, "java": _3, "jcb": _3, "jeep": _3, "jetzt": _3, "jewelry": _3, "jio": _3, "jll": _3, "jmp": _3, "jnj": _3, "joburg": _3, "jot": _3, "joy": _3, "jpmorgan": _3, "jprs": _3, "juegos": _3, "juniper": _3, "kaufen": _3, "kddi": _3, "kerryhotels": _3, "kerryproperties": _3, "kfh": _3, "kia": _3, "kids": _3, "kim": _3, "kindle": _3, "kitchen": _3, "kiwi": _3, "koeln": _3, "komatsu": _3, "kosher": _3, "kpmg": _3, "kpn": _3, "krd": [1, { "co": _4, "edu": _4 }], "kred": _3, "kuokgroup": _3, "kyoto": _3, "lacaixa": _3, "lamborghini": _3, "lamer": _3, "lancaster": _3, "land": _3, "landrover": _3, "lanxess": _3, "lasalle": _3, "lat": _3, "latino": _3, "latrobe": _3, "law": _3, "lawyer": _3, "lds": _3, "lease": _3, "leclerc": _3, "lefrak": _3, "legal": _3, "lego": _3, "lexus": _3, "lgbt": _3, "lidl": _3, "life": _3, "lifeinsurance": _3, "lifestyle": _3, "lighting": _3, "like": _3, "lilly": _3, "limited": _3, "limo": _3, "lincoln": _3, "link": [1, { "myfritz": _4, "cyon": _4, "dweb": _7, "nftstorage": [0, { "ipfs": _4 }], "mypep": _4 }], "live": [1, { "aem": _4, "hlx": _4, "ewp": _7 }], "living": _3, "llc": _3, "llp": _3, "loan": _3, "loans": _3, "locker": _3, "locus": _3, "lol": [1, { "omg": _4 }], "london": _3, "lotte": _3, "lotto": _3, "love": _3, "lpl": _3, "lplfinancial": _3, "ltd": _3, "ltda": _3, "lundbeck": _3, "luxe": _3, "luxury": _3, "madrid": _3, "maif": _3, "maison": _3, "makeup": _3, "man": _3, "management": [1, { "router": _4 }], "mango": _3, "map": _3, "market": _3, "marketing": _3, "markets": _3, "marriott": _3, "marshalls": _3, "mattel": _3, "mba": _3, "mckinsey": _3, "med": _3, "media": _56, "meet": _3, "melbourne": _3, "meme": _3, "memorial": _3, "men": _3, "menu": [1, { "barsy": _4, "barsyonline": _4 }], "merck": _3, "merckmsd": _3, "miami": _3, "microsoft": _3, "mini": _3, "mint": _3, "mit": _3, "mitsubishi": _3, "mlb": _3, "mls": _3, "mma": _3, "mobile": _3, "moda": _3, "moe": _3, "moi": _3, "mom": [1, { "ind": _4 }], "monash": _3, "money": _3, "monster": _3, "mormon": _3, "mortgage": _3, "moscow": _3, "moto": _3, "motorcycles": _3, "mov": _3, "movie": _3, "msd": _3, "mtn": _3, "mtr": _3, "music": _3, "nab": _3, "nagoya": _3, "navy": _3, "nba": _3, "nec": _3, "netbank": _3, "netflix": _3, "network": [1, { "alces": _7, "co": _4, "arvo": _4, "azimuth": _4, "tlon": _4 }], "neustar": _3, "new": _3, "news": [1, { "noticeable": _4 }], "next": _3, "nextdirect": _3, "nexus": _3, "nfl": _3, "ngo": _3, "nhk": _3, "nico": _3, "nike": _3, "nikon": _3, "ninja": _3, "nissan": _3, "nissay": _3, "nokia": _3, "norton": _3, "now": _3, "nowruz": _3, "nowtv": _3, "nra": _3, "nrw": _3, "ntt": _3, "nyc": _3, "obi": _3, "observer": _3, "office": _3, "okinawa": _3, "olayan": _3, "olayangroup": _3, "ollo": _3, "omega": _3, "one": [1, { "kin": _7, "service": _4 }], "ong": [1, { "obl": _4 }], "onl": _3, "online": [1, { "eero": _4, "eero-stage": _4, "websitebuilder": _4, "barsy": _4 }], "ooo": _3, "open": _3, "oracle": _3, "orange": [1, { "tech": _4 }], "organic": _3, "origins": _3, "osaka": _3, "otsuka": _3, "ott": _3, "ovh": [1, { "nerdpol": _4 }], "page": [1, { "aem": _4, "hlx": _4, "hlx3": _4, "translated": _4, "codeberg": _4, "heyflow": _4, "prvcy": _4, "rocky": _4, "pdns": _4, "plesk": _4 }], "panasonic": _3, "paris": _3, "pars": _3, "partners": _3, "parts": _3, "party": _3, "pay": _3, "pccw": _3, "pet": _3, "pfizer": _3, "pharmacy": _3, "phd": _3, "philips": _3, "phone": _3, "photo": _3, "photography": _3, "photos": _56, "physio": _3, "pics": _3, "pictet": _3, "pictures": [1, { "1337": _4 }], "pid": _3, "pin": _3, "ping": _3, "pink": _3, "pioneer": _3, "pizza": [1, { "ngrok": _4 }], "place": _19, "play": _3, "playstation": _3, "plumbing": _3, "plus": _3, "pnc": _3, "pohl": _3, "poker": _3, "politie": _3, "porn": _3, "pramerica": _3, "praxi": _3, "press": _3, "prime": _3, "prod": _3, "productions": _3, "prof": _3, "progressive": _3, "promo": _3, "properties": _3, "property": _3, "protection": _3, "pru": _3, "prudential": _3, "pub": [1, { "id": _7, "kin": _7, "barsy": _4 }], "pwc": _3, "qpon": _3, "quebec": _3, "quest": _3, "racing": _3, "radio": _3, "read": _3, "realestate": _3, "realtor": _3, "realty": _3, "recipes": _3, "red": _3, "redstone": _3, "redumbrella": _3, "rehab": _3, "reise": _3, "reisen": _3, "reit": _3, "reliance": _3, "ren": _3, "rent": _3, "rentals": _3, "repair": _3, "report": _3, "republican": _3, "rest": _3, "restaurant": _3, "review": _3, "reviews": _3, "rexroth": _3, "rich": _3, "richardli": _3, "ricoh": _3, "ril": _3, "rio": _3, "rip": [1, { "clan": _4 }], "rocks": [1, { "myddns": _4, "stackit": _4, "lima-city": _4, "webspace": _4 }], "rodeo": _3, "rogers": _3, "room": _3, "rsvp": _3, "rugby": _3, "ruhr": _3, "run": [1, { "development": _4, "ravendb": _4, "liara": [2, { "iran": _4 }], "servers": _4, "build": _7, "code": _7, "database": _7, "migration": _7, "onporter": _4, "repl": _4, "stackit": _4, "val": [0, { "express": _4, "web": _4 }], "wix": _4 }], "rwe": _3, "ryukyu": _3, "saarland": _3, "safe": _3, "safety": _3, "sakura": _3, "sale": _3, "salon": _3, "samsclub": _3, "samsung": _3, "sandvik": _3, "sandvikcoromant": _3, "sanofi": _3, "sap": _3, "sarl": _3, "sas": _3, "save": _3, "saxo": _3, "sbi": _3, "sbs": _3, "scb": _3, "schaeffler": _3, "schmidt": _3, "scholarships": _3, "school": _3, "schule": _3, "schwarz": _3, "science": _3, "scot": [1, { "gov": [2, { "service": _4 }] }], "search": _3, "seat": _3, "secure": _3, "security": _3, "seek": _3, "select": _3, "sener": _3, "services": [1, { "loginline": _4 }], "seven": _3, "sew": _3, "sex": _3, "sexy": _3, "sfr": _3, "shangrila": _3, "sharp": _3, "shell": _3, "shia": _3, "shiksha": _3, "shoes": _3, "shop": [1, { "base": _4, "hoplix": _4, "barsy": _4, "barsyonline": _4, "shopware": _4 }], "shopping": _3, "shouji": _3, "show": _3, "silk": _3, "sina": _3, "singles": _3, "site": [1, { "square": _4, "canva": _22, "cloudera": _7, "convex": _4, "cyon": _4, "fastvps": _4, "heyflow": _4, "jele": _4, "jouwweb": _4, "loginline": _4, "barsy": _4, "notion": _4, "omniwe": _4, "opensocial": _4, "madethis": _4, "platformsh": _7, "tst": _7, "byen": _4, "srht": _4, "novecore": _4, "cpanel": _4, "wpsquared": _4 }], "ski": _3, "skin": _3, "sky": _3, "skype": _3, "sling": _3, "smart": _3, "smile": _3, "sncf": _3, "soccer": _3, "social": _3, "softbank": _3, "software": _3, "sohu": _3, "solar": _3, "solutions": _3, "song": _3, "sony": _3, "soy": _3, "spa": _3, "space": [1, { "myfast": _4, "heiyu": _4, "hf": [2, { "static": _4 }], "app-ionos": _4, "project": _4, "uber": _4, "xs4all": _4 }], "sport": _3, "spot": _3, "srl": _3, "stada": _3, "staples": _3, "star": _3, "statebank": _3, "statefarm": _3, "stc": _3, "stcgroup": _3, "stockholm": _3, "storage": _3, "store": [1, { "barsy": _4, "sellfy": _4, "shopware": _4, "storebase": _4 }], "stream": _3, "studio": _3, "study": _3, "style": _3, "sucks": _3, "supplies": _3, "supply": _3, "support": [1, { "barsy": _4 }], "surf": _3, "surgery": _3, "suzuki": _3, "swatch": _3, "swiss": _3, "sydney": _3, "systems": [1, { "knightpoint": _4 }], "tab": _3, "taipei": _3, "talk": _3, "taobao": _3, "target": _3, "tatamotors": _3, "tatar": _3, "tattoo": _3, "tax": _3, "taxi": _3, "tci": _3, "tdk": _3, "team": [1, { "discourse": _4, "jelastic": _4 }], "tech": [1, { "cleverapps": _4 }], "technology": _19, "temasek": _3, "tennis": _3, "teva": _3, "thd": _3, "theater": _3, "theatre": _3, "tiaa": _3, "tickets": _3, "tienda": _3, "tips": _3, "tires": _3, "tirol": _3, "tjmaxx": _3, "tjx": _3, "tkmaxx": _3, "tmall": _3, "today": [1, { "prequalifyme": _4 }], "tokyo": _3, "tools": [1, { "addr": _46, "myaddr": _4 }], "top": [1, { "ntdll": _4, "wadl": _7 }], "toray": _3, "toshiba": _3, "total": _3, "tours": _3, "town": _3, "toyota": _3, "toys": _3, "trade": _3, "trading": _3, "training": _3, "travel": _3, "travelers": _3, "travelersinsurance": _3, "trust": _3, "trv": _3, "tube": _3, "tui": _3, "tunes": _3, "tushu": _3, "tvs": _3, "ubank": _3, "ubs": _3, "unicom": _3, "university": _3, "uno": _3, "uol": _3, "ups": _3, "vacations": _3, "vana": _3, "vanguard": _3, "vegas": _3, "ventures": _3, "verisign": _3, "versicherung": _3, "vet": _3, "viajes": _3, "video": _3, "vig": _3, "viking": _3, "villas": _3, "vin": _3, "vip": _3, "virgin": _3, "visa": _3, "vision": _3, "viva": _3, "vivo": _3, "vlaanderen": _3, "vodka": _3, "volvo": _3, "vote": _3, "voting": _3, "voto": _3, "voyage": _3, "wales": _3, "walmart": _3, "walter": _3, "wang": _3, "wanggou": _3, "watch": _3, "watches": _3, "weather": _3, "weatherchannel": _3, "webcam": _3, "weber": _3, "website": _56, "wed": _3, "wedding": _3, "weibo": _3, "weir": _3, "whoswho": _3, "wien": _3, "wiki": _56, "williamhill": _3, "win": _3, "windows": _3, "wine": _3, "winners": _3, "wme": _3, "wolterskluwer": _3, "woodside": _3, "work": _3, "works": _3, "world": _3, "wow": _3, "wtc": _3, "wtf": _3, "xbox": _3, "xerox": _3, "xihuan": _3, "xin": _3, "xn--11b4c3d": _3, "कॉम": _3, "xn--1ck2e1b": _3, "セール": _3, "xn--1qqw23a": _3, "佛山": _3, "xn--30rr7y": _3, "慈善": _3, "xn--3bst00m": _3, "集团": _3, "xn--3ds443g": _3, "在线": _3, "xn--3pxu8k": _3, "点看": _3, "xn--42c2d9a": _3, "คอม": _3, "xn--45q11c": _3, "八卦": _3, "xn--4gbrim": _3, "موقع": _3, "xn--55qw42g": _3, "公益": _3, "xn--55qx5d": _3, "公司": _3, "xn--5su34j936bgsg": _3, "香格里拉": _3, "xn--5tzm5g": _3, "网站": _3, "xn--6frz82g": _3, "移动": _3, "xn--6qq986b3xl": _3, "我爱你": _3, "xn--80adxhks": _3, "москва": _3, "xn--80aqecdr1a": _3, "католик": _3, "xn--80asehdb": _3, "онлайн": _3, "xn--80aswg": _3, "сайт": _3, "xn--8y0a063a": _3, "联通": _3, "xn--9dbq2a": _3, "קום": _3, "xn--9et52u": _3, "时尚": _3, "xn--9krt00a": _3, "微博": _3, "xn--b4w605ferd": _3, "淡马锡": _3, "xn--bck1b9a5dre4c": _3, "ファッション": _3, "xn--c1avg": _3, "орг": _3, "xn--c2br7g": _3, "नेट": _3, "xn--cck2b3b": _3, "ストア": _3, "xn--cckwcxetd": _3, "アマゾン": _3, "xn--cg4bki": _3, "삼성": _3, "xn--czr694b": _3, "商标": _3, "xn--czrs0t": _3, "商店": _3, "xn--czru2d": _3, "商城": _3, "xn--d1acj3b": _3, "дети": _3, "xn--eckvdtc9d": _3, "ポイント": _3, "xn--efvy88h": _3, "新闻": _3, "xn--fct429k": _3, "家電": _3, "xn--fhbei": _3, "كوم": _3, "xn--fiq228c5hs": _3, "中文网": _3, "xn--fiq64b": _3, "中信": _3, "xn--fjq720a": _3, "娱乐": _3, "xn--flw351e": _3, "谷歌": _3, "xn--fzys8d69uvgm": _3, "電訊盈科": _3, "xn--g2xx48c": _3, "购物": _3, "xn--gckr3f0f": _3, "クラウド": _3, "xn--gk3at1e": _3, "通販": _3, "xn--hxt814e": _3, "网店": _3, "xn--i1b6b1a6a2e": _3, "संगठन": _3, "xn--imr513n": _3, "餐厅": _3, "xn--io0a7i": _3, "网络": _3, "xn--j1aef": _3, "ком": _3, "xn--jlq480n2rg": _3, "亚马逊": _3, "xn--jvr189m": _3, "食品": _3, "xn--kcrx77d1x4a": _3, "飞利浦": _3, "xn--kput3i": _3, "手机": _3, "xn--mgba3a3ejt": _3, "ارامكو": _3, "xn--mgba7c0bbn0a": _3, "العليان": _3, "xn--mgbab2bd": _3, "بازار": _3, "xn--mgbca7dzdo": _3, "ابوظبي": _3, "xn--mgbi4ecexp": _3, "كاثوليك": _3, "xn--mgbt3dhd": _3, "همراه": _3, "xn--mk1bu44c": _3, "닷컴": _3, "xn--mxtq1m": _3, "政府": _3, "xn--ngbc5azd": _3, "شبكة": _3, "xn--ngbe9e0a": _3, "بيتك": _3, "xn--ngbrx": _3, "عرب": _3, "xn--nqv7f": _3, "机构": _3, "xn--nqv7fs00ema": _3, "组织机构": _3, "xn--nyqy26a": _3, "健康": _3, "xn--otu796d": _3, "招聘": _3, "xn--p1acf": [1, { "xn--90amc": _4, "xn--j1aef": _4, "xn--j1ael8b": _4, "xn--h1ahn": _4, "xn--j1adp": _4, "xn--c1avg": _4, "xn--80aaa0cvac": _4, "xn--h1aliz": _4, "xn--90a1af": _4, "xn--41a": _4 }], "рус": [1, { "биз": _4, "ком": _4, "крым": _4, "мир": _4, "мск": _4, "орг": _4, "самара": _4, "сочи": _4, "спб": _4, "я": _4 }], "xn--pssy2u": _3, "大拿": _3, "xn--q9jyb4c": _3, "みんな": _3, "xn--qcka1pmc": _3, "グーグル": _3, "xn--rhqv96g": _3, "世界": _3, "xn--rovu88b": _3, "書籍": _3, "xn--ses554g": _3, "网址": _3, "xn--t60b56a": _3, "닷넷": _3, "xn--tckwe": _3, "コム": _3, "xn--tiq49xqyj": _3, "天主教": _3, "xn--unup4y": _3, "游戏": _3, "xn--vermgensberater-ctb": _3, "vermögensberater": _3, "xn--vermgensberatung-pwb": _3, "vermögensberatung": _3, "xn--vhquv": _3, "企业": _3, "xn--vuq861b": _3, "信息": _3, "xn--w4r85el8fhu5dnra": _3, "嘉里大酒店": _3, "xn--w4rs40l": _3, "嘉里": _3, "xn--xhq521b": _3, "广东": _3, "xn--zfr164b": _3, "政务": _3, "xyz": [1, { "botdash": _4, "telebit": _7 }], "yachts": _3, "yahoo": _3, "yamaxun": _3, "yandex": _3, "yodobashi": _3, "yoga": _3, "yokohama": _3, "you": _3, "youtube": _3, "yun": _3, "zappos": _3, "zara": _3, "zero": _3, "zip": _3, "zone": [1, { "cloud66": _4, "triton": _7, "stackit": _4, "lima": _4 }], "zuerich": _3 }];
  return rules2;
}();
function lookupInTrie(parts, trie, index, allowedMask) {
  let result = null;
  let node2 = trie;
  while (node2 !== void 0) {
    if ((node2[0] & allowedMask) !== 0) {
      result = {
        index: index + 1,
        isIcann: node2[0] === 1,
        isPrivate: node2[0] === 2
      };
    }
    if (index === -1) {
      break;
    }
    const succ = node2[1];
    node2 = Object.prototype.hasOwnProperty.call(succ, parts[index]) ? succ[parts[index]] : succ["*"];
    index -= 1;
  }
  return result;
}
function suffixLookup(hostname, options, out) {
  var _a2;
  if (fastPathLookup(hostname, options, out)) {
    return;
  }
  const hostnameParts = hostname.split(".");
  const allowedMask = (options.allowPrivateDomains ? 2 : 0) | (options.allowIcannDomains ? 1 : 0);
  const exceptionMatch = lookupInTrie(hostnameParts, exceptions, hostnameParts.length - 1, allowedMask);
  if (exceptionMatch !== null) {
    out.isIcann = exceptionMatch.isIcann;
    out.isPrivate = exceptionMatch.isPrivate;
    out.publicSuffix = hostnameParts.slice(exceptionMatch.index + 1).join(".");
    return;
  }
  const rulesMatch = lookupInTrie(hostnameParts, rules, hostnameParts.length - 1, allowedMask);
  if (rulesMatch !== null) {
    out.isIcann = rulesMatch.isIcann;
    out.isPrivate = rulesMatch.isPrivate;
    out.publicSuffix = hostnameParts.slice(rulesMatch.index).join(".");
    return;
  }
  out.isIcann = false;
  out.isPrivate = false;
  out.publicSuffix = (_a2 = hostnameParts[hostnameParts.length - 1]) !== null && _a2 !== void 0 ? _a2 : null;
}
const RESULT = getEmptyResult();
function parse$2(url, options = {}) {
  return parseImpl(url, 5, suffixLookup, options, getEmptyResult());
}
function getHostname$1(url, options = {}) {
  resetResult(RESULT);
  return parseImpl(url, 0, suffixLookup, options, RESULT).hostname;
}
function getPublicSuffix$1(url, options = {}) {
  resetResult(RESULT);
  return parseImpl(url, 2, suffixLookup, options, RESULT).publicSuffix;
}
function getDomain(url, options = {}) {
  resetResult(RESULT);
  return parseImpl(url, 3, suffixLookup, options, RESULT).domain;
}
function getSubdomain(url, options = {}) {
  resetResult(RESULT);
  return parseImpl(url, 4, suffixLookup, options, RESULT).subdomain;
}
function getDomainWithoutSuffix(url, options = {}) {
  resetResult(RESULT);
  return parseImpl(url, 5, suffixLookup, options, RESULT).domainWithoutSuffix;
}
const es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getDomain,
  getDomainWithoutSuffix,
  getHostname: getHostname$1,
  getPublicSuffix: getPublicSuffix$1,
  getSubdomain,
  parse: parse$2
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(es6);
Object.defineProperty(getPublicSuffix$2, "__esModule", { value: true });
getPublicSuffix$2.getPublicSuffix = getPublicSuffix;
const tldts_1 = require$$0;
const SPECIAL_USE_DOMAINS = ["local", "example", "invalid", "localhost", "test"];
const SPECIAL_TREATMENT_DOMAINS = ["localhost", "invalid"];
const defaultGetPublicSuffixOptions = {
  allowSpecialUseDomain: false,
  ignoreError: false
};
function getPublicSuffix(domain, options = {}) {
  options = { ...defaultGetPublicSuffixOptions, ...options };
  const domainParts = domain.split(".");
  const topLevelDomain = domainParts[domainParts.length - 1];
  const allowSpecialUseDomain = !!options.allowSpecialUseDomain;
  const ignoreError = !!options.ignoreError;
  if (allowSpecialUseDomain && topLevelDomain !== void 0 && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
    if (domainParts.length > 1) {
      const secondLevelDomain = domainParts[domainParts.length - 2];
      return `${secondLevelDomain}.${topLevelDomain}`;
    } else if (SPECIAL_TREATMENT_DOMAINS.includes(topLevelDomain)) {
      return topLevelDomain;
    }
  }
  if (!ignoreError && topLevelDomain !== void 0 && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
    throw new Error(`Cookie has domain set to the public suffix "${topLevelDomain}" which is a special use domain. To allow this, configure your CookieJar with {allowSpecialUseDomain: true, rejectPublicSuffixes: false}.`);
  }
  const publicSuffix = (0, tldts_1.getDomain)(domain, {
    allowIcannDomains: true,
    allowPrivateDomains: true
  });
  if (publicSuffix)
    return publicSuffix;
}
Object.defineProperty(permuteDomain$1, "__esModule", { value: true });
permuteDomain$1.permuteDomain = permuteDomain;
const getPublicSuffix_1$2 = getPublicSuffix$2;
function permuteDomain(domain, allowSpecialUseDomain) {
  const pubSuf = (0, getPublicSuffix_1$2.getPublicSuffix)(domain, {
    allowSpecialUseDomain
  });
  if (!pubSuf) {
    return void 0;
  }
  if (pubSuf == domain) {
    return [domain];
  }
  if (domain.slice(-1) == ".") {
    domain = domain.slice(0, -1);
  }
  const prefix = domain.slice(0, -(pubSuf.length + 1));
  const parts = prefix.split(".").reverse();
  let cur = pubSuf;
  const permutations = [cur];
  while (parts.length) {
    const part = parts.shift();
    cur = `${part}.${cur}`;
    permutations.push(cur);
  }
  return permutations;
}
var store = {};
Object.defineProperty(store, "__esModule", { value: true });
store.Store = void 0;
class Store {
  constructor() {
    this.synchronous = false;
  }
  /**
   * @internal No doc because this is an overload that supports the implementation
   */
  findCookie(_domain, _path, _key, _callback2) {
    throw new Error("findCookie is not implemented");
  }
  /**
   * @internal No doc because this is an overload that supports the implementation
   */
  findCookies(_domain, _path, _allowSpecialUseDomain = false, _callback2) {
    throw new Error("findCookies is not implemented");
  }
  /**
   * @internal No doc because this is an overload that supports the implementation
   */
  putCookie(_cookie, _callback2) {
    throw new Error("putCookie is not implemented");
  }
  /**
   * @internal No doc because this is an overload that supports the implementation
   */
  updateCookie(_oldCookie, _newCookie, _callback2) {
    throw new Error("updateCookie is not implemented");
  }
  /**
   * @internal No doc because this is an overload that supports the implementation
   */
  removeCookie(_domain, _path, _key, _callback2) {
    throw new Error("removeCookie is not implemented");
  }
  /**
   * @internal No doc because this is an overload that supports the implementation
   */
  removeCookies(_domain, _path, _callback2) {
    throw new Error("removeCookies is not implemented");
  }
  /**
   * @internal No doc because this is an overload that supports the implementation
   */
  removeAllCookies(_callback2) {
    throw new Error("removeAllCookies is not implemented");
  }
  /**
   * @internal No doc because this is an overload that supports the implementation
   */
  getAllCookies(_callback2) {
    throw new Error("getAllCookies is not implemented (therefore jar cannot be serialized)");
  }
}
store.Store = Store;
var utils$3 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.safeToString = exports.objectToString = void 0;
  exports.createPromiseCallback = createPromiseCallback;
  exports.inOperator = inOperator;
  const objectToString = (obj) => Object.prototype.toString.call(obj);
  exports.objectToString = objectToString;
  const safeArrayToString = (arr, seenArrays) => {
    if (typeof arr.join !== "function")
      return (0, exports.objectToString)(arr);
    seenArrays.add(arr);
    const mapped = arr.map((val) => val === null || val === void 0 || seenArrays.has(val) ? "" : safeToStringImpl(val, seenArrays));
    return mapped.join();
  };
  const safeToStringImpl = (val, seenArrays = /* @__PURE__ */ new WeakSet()) => {
    if (typeof val !== "object" || val === null) {
      return String(val);
    } else if (typeof val.toString === "function") {
      return Array.isArray(val) ? (
        // Arrays have a weird custom toString that we need to replicate
        safeArrayToString(val, seenArrays)
      ) : (
        // eslint-disable-next-line @typescript-eslint/no-base-to-string
        String(val)
      );
    } else {
      return (0, exports.objectToString)(val);
    }
  };
  const safeToString = (val) => safeToStringImpl(val);
  exports.safeToString = safeToString;
  function createPromiseCallback(cb) {
    let callback;
    let resolve2;
    let reject;
    const promise = new Promise((_resolve, _reject) => {
      resolve2 = _resolve;
      reject = _reject;
    });
    if (typeof cb === "function") {
      callback = (err, result) => {
        try {
          if (err)
            cb(err);
          else
            cb(null, result);
        } catch (e) {
          reject(e instanceof Error ? e : new Error());
        }
      };
    } else {
      callback = (err, result) => {
        try {
          if (err)
            reject(err);
          else
            resolve2(result);
        } catch (e) {
          reject(e instanceof Error ? e : new Error());
        }
      };
    }
    return {
      promise,
      callback,
      resolve: (value) => {
        callback(null, value);
        return promise;
      },
      reject: (error) => {
        callback(error);
        return promise;
      }
    };
  }
  function inOperator(k, o) {
    return k in o;
  }
})(utils$3);
Object.defineProperty(memstore, "__esModule", { value: true });
memstore.MemoryCookieStore = void 0;
const pathMatch_1$1 = pathMatch$1;
const permuteDomain_1 = permuteDomain$1;
const store_1$1 = store;
const utils_1$3 = utils$3;
class MemoryCookieStore extends store_1$1.Store {
  /**
   * Create a new {@link MemoryCookieStore}.
   */
  constructor() {
    super();
    this.synchronous = true;
    this.idx = /* @__PURE__ */ Object.create(null);
  }
  /**
   * @internal No doc because this is an overload that supports the implementation
   */
  findCookie(domain, path2, key, callback) {
    var _a2, _b2;
    const promiseCallback = (0, utils_1$3.createPromiseCallback)(callback);
    if (domain == null || path2 == null || key == null) {
      return promiseCallback.resolve(void 0);
    }
    const result = (_b2 = (_a2 = this.idx[domain]) == null ? void 0 : _a2[path2]) == null ? void 0 : _b2[key];
    return promiseCallback.resolve(result);
  }
  /**
   * @internal No doc because this is an overload that supports the implementation
   */
  findCookies(domain, path2, allowSpecialUseDomain = false, callback) {
    if (typeof allowSpecialUseDomain === "function") {
      callback = allowSpecialUseDomain;
      allowSpecialUseDomain = true;
    }
    const results = [];
    const promiseCallback = (0, utils_1$3.createPromiseCallback)(callback);
    if (!domain) {
      return promiseCallback.resolve([]);
    }
    let pathMatcher;
    if (!path2) {
      pathMatcher = function matchAll(domainIndex) {
        for (const curPath in domainIndex) {
          const pathIndex = domainIndex[curPath];
          for (const key in pathIndex) {
            const value = pathIndex[key];
            if (value) {
              results.push(value);
            }
          }
        }
      };
    } else {
      pathMatcher = function matchRFC(domainIndex) {
        for (const cookiePath in domainIndex) {
          if ((0, pathMatch_1$1.pathMatch)(path2, cookiePath)) {
            const pathIndex = domainIndex[cookiePath];
            for (const key in pathIndex) {
              const value = pathIndex[key];
              if (value) {
                results.push(value);
              }
            }
          }
        }
      };
    }
    const domains = (0, permuteDomain_1.permuteDomain)(domain, allowSpecialUseDomain) || [domain];
    const idx = this.idx;
    domains.forEach((curDomain) => {
      const domainIndex = idx[curDomain];
      if (!domainIndex) {
        return;
      }
      pathMatcher(domainIndex);
    });
    return promiseCallback.resolve(results);
  }
  /**
   * @internal No doc because this is an overload that supports the implementation
   */
  putCookie(cookie2, callback) {
    const promiseCallback = (0, utils_1$3.createPromiseCallback)(callback);
    const { domain, path: path2, key } = cookie2;
    if (domain == null || path2 == null || key == null) {
      return promiseCallback.resolve(void 0);
    }
    const domainEntry = this.idx[domain] ?? /* @__PURE__ */ Object.create(null);
    this.idx[domain] = domainEntry;
    const pathEntry = domainEntry[path2] ?? /* @__PURE__ */ Object.create(null);
    domainEntry[path2] = pathEntry;
    pathEntry[key] = cookie2;
    return promiseCallback.resolve(void 0);
  }
  /**
   * @internal No doc because this is an overload that supports the implementation
   */
  updateCookie(_oldCookie, newCookie, callback) {
    if (callback)
      this.putCookie(newCookie, callback);
    else
      return this.putCookie(newCookie);
  }
  /**
   * @internal No doc because this is an overload that supports the implementation
   */
  removeCookie(domain, path2, key, callback) {
    var _a2, _b2;
    const promiseCallback = (0, utils_1$3.createPromiseCallback)(callback);
    (_b2 = (_a2 = this.idx[domain]) == null ? void 0 : _a2[path2]) == null ? true : delete _b2[key];
    return promiseCallback.resolve(void 0);
  }
  /**
   * @internal No doc because this is an overload that supports the implementation
   */
  removeCookies(domain, path2, callback) {
    const promiseCallback = (0, utils_1$3.createPromiseCallback)(callback);
    const domainEntry = this.idx[domain];
    if (domainEntry) {
      if (path2) {
        delete domainEntry[path2];
      } else {
        delete this.idx[domain];
      }
    }
    return promiseCallback.resolve(void 0);
  }
  /**
   * @internal No doc because this is an overload that supports the implementation
   */
  removeAllCookies(callback) {
    const promiseCallback = (0, utils_1$3.createPromiseCallback)(callback);
    this.idx = /* @__PURE__ */ Object.create(null);
    return promiseCallback.resolve(void 0);
  }
  /**
   * @internal No doc because this is an overload that supports the implementation
   */
  getAllCookies(callback) {
    const promiseCallback = (0, utils_1$3.createPromiseCallback)(callback);
    const cookies2 = [];
    const idx = this.idx;
    const domains = Object.keys(idx);
    domains.forEach((domain) => {
      const domainEntry = idx[domain] ?? {};
      const paths = Object.keys(domainEntry);
      paths.forEach((path2) => {
        const pathEntry = domainEntry[path2] ?? {};
        const keys = Object.keys(pathEntry);
        keys.forEach((key) => {
          const keyEntry = pathEntry[key];
          if (keyEntry != null) {
            cookies2.push(keyEntry);
          }
        });
      });
    });
    cookies2.sort((a, b) => {
      return (a.creationIndex || 0) - (b.creationIndex || 0);
    });
    return promiseCallback.resolve(cookies2);
  }
}
memstore.MemoryCookieStore = MemoryCookieStore;
var validators$2 = {};
Object.defineProperty(validators$2, "__esModule", { value: true });
validators$2.ParameterError = void 0;
validators$2.isNonEmptyString = isNonEmptyString;
validators$2.isDate = isDate;
validators$2.isEmptyString = isEmptyString;
validators$2.isString = isString;
validators$2.isObject = isObject;
validators$2.isInteger = isInteger;
validators$2.validate = validate;
const utils_1$2 = utils$3;
function isNonEmptyString(data) {
  return isString(data) && data !== "";
}
function isDate(data) {
  return data instanceof Date && isInteger(data.getTime());
}
function isEmptyString(data) {
  return data === "" || data instanceof String && data.toString() === "";
}
function isString(data) {
  return typeof data === "string" || data instanceof String;
}
function isObject(data) {
  return (0, utils_1$2.objectToString)(data) === "[object Object]";
}
function isInteger(data) {
  return typeof data === "number" && data % 1 === 0;
}
function validate(bool, cbOrMessage, message) {
  if (bool)
    return;
  const cb = typeof cbOrMessage === "function" ? cbOrMessage : void 0;
  let options = typeof cbOrMessage === "function" ? message : cbOrMessage;
  if (!isObject(options))
    options = "[object Object]";
  const err = new ParameterError((0, utils_1$2.safeToString)(options));
  if (cb)
    cb(err);
  else
    throw err;
}
class ParameterError extends Error {
}
validators$2.ParameterError = ParameterError;
var version$1 = {};
Object.defineProperty(version$1, "__esModule", { value: true });
version$1.version = void 0;
version$1.version = "5.1.2";
var canonicalDomain$2 = {};
var constants$6 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IP_V6_REGEX_OBJECT = exports.PrefixSecurityEnum = void 0;
  exports.PrefixSecurityEnum = {
    SILENT: "silent",
    STRICT: "strict",
    DISABLED: "unsafe-disabled"
  };
  Object.freeze(exports.PrefixSecurityEnum);
  const IP_V6_REGEX = `
\\[?(?:
(?:[a-fA-F\\d]{1,4}:){7}(?:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,2}|:)|
(?:[a-fA-F\\d]{1,4}:){4}(?:(?::[a-fA-F\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,3}|:)|
(?:[a-fA-F\\d]{1,4}:){3}(?:(?::[a-fA-F\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){2}(?:(?::[a-fA-F\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,5}|:)|
(?:[a-fA-F\\d]{1,4}:){1}(?:(?::[a-fA-F\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,6}|:)|
(?::(?:(?::[a-fA-F\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,7}|:))
)(?:%[0-9a-zA-Z]{1,})?\\]?
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
  exports.IP_V6_REGEX_OBJECT = new RegExp(`^${IP_V6_REGEX}$`);
})(constants$6);
Object.defineProperty(canonicalDomain$2, "__esModule", { value: true });
canonicalDomain$2.canonicalDomain = canonicalDomain$1;
const constants_1$1 = constants$6;
function domainToASCII(domain) {
  return new URL(`http://${domain}`).hostname;
}
function canonicalDomain$1(domainName) {
  if (domainName == null) {
    return void 0;
  }
  let str = domainName.trim().replace(/^\./, "");
  if (constants_1$1.IP_V6_REGEX_OBJECT.test(str)) {
    if (!str.startsWith("[")) {
      str = "[" + str;
    }
    if (!str.endsWith("]")) {
      str = str + "]";
    }
    return domainToASCII(str).slice(1, -1);
  }
  if (/[^\u0001-\u007f]/.test(str)) {
    return domainToASCII(str);
  }
  return str.toLowerCase();
}
var cookie = {};
var formatDate$1 = {};
Object.defineProperty(formatDate$1, "__esModule", { value: true });
formatDate$1.formatDate = formatDate;
function formatDate(date2) {
  return date2.toUTCString();
}
var parseDate$1 = {};
Object.defineProperty(parseDate$1, "__esModule", { value: true });
parseDate$1.parseDate = parseDate;
const DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;
const MONTH_TO_NUM = {
  jan: 0,
  feb: 1,
  mar: 2,
  apr: 3,
  may: 4,
  jun: 5,
  jul: 6,
  aug: 7,
  sep: 8,
  oct: 9,
  nov: 10,
  dec: 11
};
function parseDigits(token, minDigits, maxDigits, trailingOK) {
  let count = 0;
  while (count < token.length) {
    const c = token.charCodeAt(count);
    if (c <= 47 || c >= 58) {
      break;
    }
    count++;
  }
  if (count < minDigits || count > maxDigits) {
    return;
  }
  if (!trailingOK && count != token.length) {
    return;
  }
  return parseInt(token.slice(0, count), 10);
}
function parseTime$1(token) {
  const parts = token.split(":");
  const result = [0, 0, 0];
  if (parts.length !== 3) {
    return;
  }
  for (let i = 0; i < 3; i++) {
    const trailingOK = i == 2;
    const numPart = parts[i];
    if (numPart === void 0) {
      return;
    }
    const num = parseDigits(numPart, 1, 2, trailingOK);
    if (num === void 0) {
      return;
    }
    result[i] = num;
  }
  return result;
}
function parseMonth(token) {
  token = String(token).slice(0, 3).toLowerCase();
  switch (token) {
    case "jan":
      return MONTH_TO_NUM.jan;
    case "feb":
      return MONTH_TO_NUM.feb;
    case "mar":
      return MONTH_TO_NUM.mar;
    case "apr":
      return MONTH_TO_NUM.apr;
    case "may":
      return MONTH_TO_NUM.may;
    case "jun":
      return MONTH_TO_NUM.jun;
    case "jul":
      return MONTH_TO_NUM.jul;
    case "aug":
      return MONTH_TO_NUM.aug;
    case "sep":
      return MONTH_TO_NUM.sep;
    case "oct":
      return MONTH_TO_NUM.oct;
    case "nov":
      return MONTH_TO_NUM.nov;
    case "dec":
      return MONTH_TO_NUM.dec;
    default:
      return;
  }
}
function parseDate(cookieDate) {
  if (!cookieDate) {
    return;
  }
  const tokens = cookieDate.split(DATE_DELIM);
  let hour;
  let minute;
  let second;
  let dayOfMonth;
  let month;
  let year;
  for (let i = 0; i < tokens.length; i++) {
    const token = (tokens[i] ?? "").trim();
    if (!token.length) {
      continue;
    }
    if (second === void 0) {
      const result = parseTime$1(token);
      if (result) {
        hour = result[0];
        minute = result[1];
        second = result[2];
        continue;
      }
    }
    if (dayOfMonth === void 0) {
      const result = parseDigits(token, 1, 2, true);
      if (result !== void 0) {
        dayOfMonth = result;
        continue;
      }
    }
    if (month === void 0) {
      const result = parseMonth(token);
      if (result !== void 0) {
        month = result;
        continue;
      }
    }
    if (year === void 0) {
      const result = parseDigits(token, 2, 4, true);
      if (result !== void 0) {
        year = result;
        if (year >= 70 && year <= 99) {
          year += 1900;
        } else if (year >= 0 && year <= 69) {
          year += 2e3;
        }
      }
    }
  }
  if (dayOfMonth === void 0 || month === void 0 || year === void 0 || hour === void 0 || minute === void 0 || second === void 0 || dayOfMonth < 1 || dayOfMonth > 31 || year < 1601 || hour > 23 || minute > 59 || second > 59) {
    return;
  }
  return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
}
var __createBinding$1 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault$1 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$1(result, mod, k);
  }
  __setModuleDefault$1(result, mod);
  return result;
};
Object.defineProperty(cookie, "__esModule", { value: true });
cookie.Cookie = void 0;
/*!
 * Copyright (c) 2015-2020, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
const getPublicSuffix_1$1 = getPublicSuffix$2;
const validators$1 = __importStar$1(validators$2);
const utils_1$1 = utils$3;
const formatDate_1 = formatDate$1;
const parseDate_1 = parseDate$1;
const canonicalDomain_1$2 = canonicalDomain$2;
const COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/;
const PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;
const CONTROL_CHARS = /[\x00-\x1F]/;
const TERMINATORS = ["\n", "\r", "\0"];
function trimTerminator(str) {
  if (validators$1.isEmptyString(str))
    return str;
  for (let t = 0; t < TERMINATORS.length; t++) {
    const terminator = TERMINATORS[t];
    const terminatorIdx = terminator ? str.indexOf(terminator) : -1;
    if (terminatorIdx !== -1) {
      str = str.slice(0, terminatorIdx);
    }
  }
  return str;
}
function parseCookiePair(cookiePair, looseMode) {
  cookiePair = trimTerminator(cookiePair);
  let firstEq = cookiePair.indexOf("=");
  if (looseMode) {
    if (firstEq === 0) {
      cookiePair = cookiePair.substring(1);
      firstEq = cookiePair.indexOf("=");
    }
  } else {
    if (firstEq <= 0) {
      return void 0;
    }
  }
  let cookieName, cookieValue;
  if (firstEq <= 0) {
    cookieName = "";
    cookieValue = cookiePair.trim();
  } else {
    cookieName = cookiePair.slice(0, firstEq).trim();
    cookieValue = cookiePair.slice(firstEq + 1).trim();
  }
  if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {
    return void 0;
  }
  const c = new Cookie$1();
  c.key = cookieName;
  c.value = cookieValue;
  return c;
}
function parse$1(str, options) {
  if (validators$1.isEmptyString(str) || !validators$1.isString(str)) {
    return void 0;
  }
  str = str.trim();
  const firstSemi = str.indexOf(";");
  const cookiePair = firstSemi === -1 ? str : str.slice(0, firstSemi);
  const c = parseCookiePair(cookiePair, (options == null ? void 0 : options.loose) ?? false);
  if (!c) {
    return void 0;
  }
  if (firstSemi === -1) {
    return c;
  }
  const unparsed = str.slice(firstSemi + 1).trim();
  if (unparsed.length === 0) {
    return c;
  }
  const cookie_avs = unparsed.split(";");
  while (cookie_avs.length) {
    const av = (cookie_avs.shift() ?? "").trim();
    if (av.length === 0) {
      continue;
    }
    const av_sep = av.indexOf("=");
    let av_key, av_value;
    if (av_sep === -1) {
      av_key = av;
      av_value = null;
    } else {
      av_key = av.slice(0, av_sep);
      av_value = av.slice(av_sep + 1);
    }
    av_key = av_key.trim().toLowerCase();
    if (av_value) {
      av_value = av_value.trim();
    }
    switch (av_key) {
      case "expires":
        if (av_value) {
          const exp = (0, parseDate_1.parseDate)(av_value);
          if (exp) {
            c.expires = exp;
          }
        }
        break;
      case "max-age":
        if (av_value) {
          if (/^-?[0-9]+$/.test(av_value)) {
            const delta = parseInt(av_value, 10);
            c.setMaxAge(delta);
          }
        }
        break;
      case "domain":
        if (av_value) {
          const domain = av_value.trim().replace(/^\./, "");
          if (domain) {
            c.domain = domain.toLowerCase();
          }
        }
        break;
      case "path":
        c.path = av_value && av_value[0] === "/" ? av_value : null;
        break;
      case "secure":
        c.secure = true;
        break;
      case "httponly":
        c.httpOnly = true;
        break;
      case "samesite":
        switch (av_value ? av_value.toLowerCase() : "") {
          case "strict":
            c.sameSite = "strict";
            break;
          case "lax":
            c.sameSite = "lax";
            break;
          case "none":
            c.sameSite = "none";
            break;
          default:
            c.sameSite = void 0;
            break;
        }
        break;
      default:
        c.extensions = c.extensions || [];
        c.extensions.push(av);
        break;
    }
  }
  return c;
}
function fromJSON(str) {
  if (!str || validators$1.isEmptyString(str)) {
    return void 0;
  }
  let obj;
  if (typeof str === "string") {
    try {
      obj = JSON.parse(str);
    } catch {
      return void 0;
    }
  } else {
    obj = str;
  }
  const c = new Cookie$1();
  Cookie$1.serializableProperties.forEach((prop) => {
    if (obj && typeof obj === "object" && (0, utils_1$1.inOperator)(prop, obj)) {
      const val = obj[prop];
      if (val === void 0) {
        return;
      }
      if ((0, utils_1$1.inOperator)(prop, cookieDefaults) && val === cookieDefaults[prop]) {
        return;
      }
      switch (prop) {
        case "key":
        case "value":
        case "sameSite":
          if (typeof val === "string") {
            c[prop] = val;
          }
          break;
        case "expires":
        case "creation":
        case "lastAccessed":
          if (typeof val === "number" || typeof val === "string" || val instanceof Date) {
            c[prop] = obj[prop] == "Infinity" ? "Infinity" : new Date(val);
          } else if (val === null) {
            c[prop] = null;
          }
          break;
        case "maxAge":
          if (typeof val === "number" || val === "Infinity" || val === "-Infinity") {
            c[prop] = val;
          }
          break;
        case "domain":
        case "path":
          if (typeof val === "string" || val === null) {
            c[prop] = val;
          }
          break;
        case "secure":
        case "httpOnly":
          if (typeof val === "boolean") {
            c[prop] = val;
          }
          break;
        case "extensions":
          if (Array.isArray(val) && val.every((item) => typeof item === "string")) {
            c[prop] = val;
          }
          break;
        case "hostOnly":
        case "pathIsDefault":
          if (typeof val === "boolean" || val === null) {
            c[prop] = val;
          }
          break;
      }
    }
  });
  return c;
}
const cookieDefaults = {
  // the order in which the RFC has them:
  key: "",
  value: "",
  expires: "Infinity",
  maxAge: null,
  domain: null,
  path: null,
  secure: false,
  httpOnly: false,
  extensions: null,
  // set by the CookieJar:
  hostOnly: null,
  pathIsDefault: null,
  creation: null,
  lastAccessed: null,
  sameSite: void 0
};
let Cookie$1 = class Cookie {
  /**
   * Create a new Cookie instance.
   * @public
   * @param options - The attributes to set on the cookie
   */
  constructor(options = {}) {
    this.key = options.key ?? cookieDefaults.key;
    this.value = options.value ?? cookieDefaults.value;
    this.expires = options.expires ?? cookieDefaults.expires;
    this.maxAge = options.maxAge ?? cookieDefaults.maxAge;
    this.domain = options.domain ?? cookieDefaults.domain;
    this.path = options.path ?? cookieDefaults.path;
    this.secure = options.secure ?? cookieDefaults.secure;
    this.httpOnly = options.httpOnly ?? cookieDefaults.httpOnly;
    this.extensions = options.extensions ?? cookieDefaults.extensions;
    this.creation = options.creation ?? cookieDefaults.creation;
    this.hostOnly = options.hostOnly ?? cookieDefaults.hostOnly;
    this.pathIsDefault = options.pathIsDefault ?? cookieDefaults.pathIsDefault;
    this.lastAccessed = options.lastAccessed ?? cookieDefaults.lastAccessed;
    this.sameSite = options.sameSite ?? cookieDefaults.sameSite;
    this.creation = options.creation ?? /* @__PURE__ */ new Date();
    Object.defineProperty(this, "creationIndex", {
      configurable: false,
      enumerable: false,
      // important for assert.deepEqual checks
      writable: true,
      value: ++Cookie.cookiesCreated
    });
    this.creationIndex = Cookie.cookiesCreated;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    const now = Date.now();
    const hostOnly = this.hostOnly != null ? this.hostOnly.toString() : "?";
    const createAge = this.creation && this.creation !== "Infinity" ? `${String(now - this.creation.getTime())}ms` : "?";
    const accessAge = this.lastAccessed && this.lastAccessed !== "Infinity" ? `${String(now - this.lastAccessed.getTime())}ms` : "?";
    return `Cookie="${this.toString()}; hostOnly=${hostOnly}; aAge=${accessAge}; cAge=${createAge}"`;
  }
  /**
   * For convenience in using `JSON.stringify(cookie)`. Returns a plain-old Object that can be JSON-serialized.
   *
   * @remarks
   * - Any `Date` properties (such as {@link Cookie.expires}, {@link Cookie.creation}, and {@link Cookie.lastAccessed}) are exported in ISO format (`Date.toISOString()`).
   *
   *  - Custom Cookie properties are discarded. In tough-cookie 1.x, since there was no {@link Cookie.toJSON} method explicitly defined, all enumerable properties were captured.
   *      If you want a property to be serialized, add the property name to {@link Cookie.serializableProperties}.
   */
  toJSON() {
    const obj = {};
    for (const prop of Cookie.serializableProperties) {
      const val = this[prop];
      if (val === cookieDefaults[prop]) {
        continue;
      }
      switch (prop) {
        case "key":
        case "value":
        case "sameSite":
          if (typeof val === "string") {
            obj[prop] = val;
          }
          break;
        case "expires":
        case "creation":
        case "lastAccessed":
          if (typeof val === "number" || typeof val === "string" || val instanceof Date) {
            obj[prop] = val == "Infinity" ? "Infinity" : new Date(val).toISOString();
          } else if (val === null) {
            obj[prop] = null;
          }
          break;
        case "maxAge":
          if (typeof val === "number" || val === "Infinity" || val === "-Infinity") {
            obj[prop] = val;
          }
          break;
        case "domain":
        case "path":
          if (typeof val === "string" || val === null) {
            obj[prop] = val;
          }
          break;
        case "secure":
        case "httpOnly":
          if (typeof val === "boolean") {
            obj[prop] = val;
          }
          break;
        case "extensions":
          if (Array.isArray(val)) {
            obj[prop] = val;
          }
          break;
        case "hostOnly":
        case "pathIsDefault":
          if (typeof val === "boolean" || val === null) {
            obj[prop] = val;
          }
          break;
      }
    }
    return obj;
  }
  /**
   * Does a deep clone of this cookie, implemented exactly as `Cookie.fromJSON(cookie.toJSON())`.
   * @public
   */
  clone() {
    return fromJSON(this.toJSON());
  }
  /**
   * Validates cookie attributes for semantic correctness. Useful for "lint" checking any `Set-Cookie` headers you generate.
   * For now, it returns a boolean, but eventually could return a reason string.
   *
   * @remarks
   * Works for a few things, but is by no means comprehensive.
   *
   * @beta
   */
  validate() {
    if (!this.value || !COOKIE_OCTETS.test(this.value)) {
      return false;
    }
    if (this.expires != "Infinity" && !(this.expires instanceof Date) && !(0, parseDate_1.parseDate)(this.expires)) {
      return false;
    }
    if (this.maxAge != null && this.maxAge !== "Infinity" && (this.maxAge === "-Infinity" || this.maxAge <= 0)) {
      return false;
    }
    if (this.path != null && !PATH_VALUE.test(this.path)) {
      return false;
    }
    const cdomain = this.cdomain();
    if (cdomain) {
      if (cdomain.match(/\.$/)) {
        return false;
      }
      const suffix = (0, getPublicSuffix_1$1.getPublicSuffix)(cdomain);
      if (suffix == null) {
        return false;
      }
    }
    return true;
  }
  /**
   * Sets the 'Expires' attribute on a cookie.
   *
   * @remarks
   * When given a `string` value it will be parsed with {@link parseDate}. If the value can't be parsed as a cookie date
   * then the 'Expires' attribute will be set to `"Infinity"`.
   *
   * @param exp - the new value for the 'Expires' attribute of the cookie.
   */
  setExpires(exp) {
    if (exp instanceof Date) {
      this.expires = exp;
    } else {
      this.expires = (0, parseDate_1.parseDate)(exp) || "Infinity";
    }
  }
  /**
   * Sets the 'Max-Age' attribute (in seconds) on a cookie.
   *
   * @remarks
   * Coerces `-Infinity` to `"-Infinity"` and `Infinity` to `"Infinity"` so it can be serialized to JSON.
   *
   * @param age - the new value for the 'Max-Age' attribute (in seconds).
   */
  setMaxAge(age) {
    if (age === Infinity) {
      this.maxAge = "Infinity";
    } else if (age === -Infinity) {
      this.maxAge = "-Infinity";
    } else {
      this.maxAge = age;
    }
  }
  /**
   * Encodes to a `Cookie` header value (specifically, the {@link Cookie.key} and {@link Cookie.value} properties joined with "=").
   * @public
   */
  cookieString() {
    const val = this.value || "";
    if (this.key) {
      return `${this.key}=${val}`;
    }
    return val;
  }
  /**
   * Encodes to a `Set-Cookie header` value.
   * @public
   */
  toString() {
    let str = this.cookieString();
    if (this.expires != "Infinity") {
      if (this.expires instanceof Date) {
        str += `; Expires=${(0, formatDate_1.formatDate)(this.expires)}`;
      }
    }
    if (this.maxAge != null && this.maxAge != Infinity) {
      str += `; Max-Age=${String(this.maxAge)}`;
    }
    if (this.domain && !this.hostOnly) {
      str += `; Domain=${this.domain}`;
    }
    if (this.path) {
      str += `; Path=${this.path}`;
    }
    if (this.secure) {
      str += "; Secure";
    }
    if (this.httpOnly) {
      str += "; HttpOnly";
    }
    if (this.sameSite && this.sameSite !== "none") {
      if (this.sameSite.toLowerCase() === Cookie.sameSiteCanonical.lax.toLowerCase()) {
        str += `; SameSite=${Cookie.sameSiteCanonical.lax}`;
      } else if (this.sameSite.toLowerCase() === Cookie.sameSiteCanonical.strict.toLowerCase()) {
        str += `; SameSite=${Cookie.sameSiteCanonical.strict}`;
      } else {
        str += `; SameSite=${this.sameSite}`;
      }
    }
    if (this.extensions) {
      this.extensions.forEach((ext) => {
        str += `; ${ext}`;
      });
    }
    return str;
  }
  /**
   * Computes the TTL relative to now (milliseconds).
   *
   * @remarks
   * - `Infinity` is returned for cookies without an explicit expiry
   *
   * - `0` is returned if the cookie is expired.
   *
   * - Otherwise a time-to-live in milliseconds is returned.
   *
   * @param now - passing an explicit value is mostly used for testing purposes since this defaults to the `Date.now()`
   * @public
   */
  TTL(now = Date.now()) {
    if (this.maxAge != null && typeof this.maxAge === "number") {
      return this.maxAge <= 0 ? 0 : this.maxAge * 1e3;
    }
    const expires = this.expires;
    if (expires === "Infinity") {
      return Infinity;
    }
    return ((expires == null ? void 0 : expires.getTime()) ?? now) - (now || Date.now());
  }
  /**
   * Computes the absolute unix-epoch milliseconds that this cookie expires.
   *
   * The "Max-Age" attribute takes precedence over "Expires" (as per the RFC). The {@link Cookie.lastAccessed} attribute
   * (or the `now` parameter if given) is used to offset the {@link Cookie.maxAge} attribute.
   *
   * If Expires ({@link Cookie.expires}) is set, that's returned.
   *
   * @param now - can be used to provide a time offset (instead of {@link Cookie.lastAccessed}) to use when calculating the "Max-Age" value
   */
  expiryTime(now) {
    if (this.maxAge != null) {
      const relativeTo = now || this.lastAccessed || /* @__PURE__ */ new Date();
      const maxAge = typeof this.maxAge === "number" ? this.maxAge : -Infinity;
      const age = maxAge <= 0 ? -Infinity : maxAge * 1e3;
      if (relativeTo === "Infinity") {
        return Infinity;
      }
      return relativeTo.getTime() + age;
    }
    if (this.expires == "Infinity") {
      return Infinity;
    }
    return this.expires ? this.expires.getTime() : void 0;
  }
  /**
   * Similar to {@link Cookie.expiryTime}, computes the absolute unix-epoch milliseconds that this cookie expires and returns it as a Date.
   *
   * The "Max-Age" attribute takes precedence over "Expires" (as per the RFC). The {@link Cookie.lastAccessed} attribute
   * (or the `now` parameter if given) is used to offset the {@link Cookie.maxAge} attribute.
   *
   * If Expires ({@link Cookie.expires}) is set, that's returned.
   *
   * @param now - can be used to provide a time offset (instead of {@link Cookie.lastAccessed}) to use when calculating the "Max-Age" value
   */
  expiryDate(now) {
    const millisec = this.expiryTime(now);
    if (millisec == Infinity) {
      return /* @__PURE__ */ new Date(2147483647e3);
    } else if (millisec == -Infinity) {
      return /* @__PURE__ */ new Date(0);
    } else {
      return millisec == void 0 ? void 0 : new Date(millisec);
    }
  }
  /**
   * Indicates if the cookie has been persisted to a store or not.
   * @public
   */
  isPersistent() {
    return this.maxAge != null || this.expires != "Infinity";
  }
  /**
   * Calls {@link canonicalDomain} with the {@link Cookie.domain} property.
   * @public
   */
  canonicalizedDomain() {
    return (0, canonicalDomain_1$2.canonicalDomain)(this.domain);
  }
  /**
   * Alias for {@link Cookie.canonicalizedDomain}
   * @public
   */
  cdomain() {
    return (0, canonicalDomain_1$2.canonicalDomain)(this.domain);
  }
  /**
   * Parses a string into a Cookie object.
   *
   * @remarks
   * Note: when parsing a `Cookie` header it must be split by ';' before each Cookie string can be parsed.
   *
   * @example
   * ```
   * // parse a `Set-Cookie` header
   * const setCookieHeader = 'a=bcd; Expires=Tue, 18 Oct 2011 07:05:03 GMT'
   * const cookie = Cookie.parse(setCookieHeader)
   * cookie.key === 'a'
   * cookie.value === 'bcd'
   * cookie.expires === new Date(Date.parse('Tue, 18 Oct 2011 07:05:03 GMT'))
   * ```
   *
   * @example
   * ```
   * // parse a `Cookie` header
   * const cookieHeader = 'name=value; name2=value2; name3=value3'
   * const cookies = cookieHeader.split(';').map(Cookie.parse)
   * cookies[0].name === 'name'
   * cookies[0].value === 'value'
   * cookies[1].name === 'name2'
   * cookies[1].value === 'value2'
   * cookies[2].name === 'name3'
   * cookies[2].value === 'value3'
   * ```
   *
   * @param str - The `Set-Cookie` header or a Cookie string to parse.
   * @param options - Configures `strict` or `loose` mode for cookie parsing
   */
  static parse(str, options) {
    return parse$1(str, options);
  }
  /**
   * Does the reverse of {@link Cookie.toJSON}.
   *
   * @remarks
   * Any Date properties (such as .expires, .creation, and .lastAccessed) are parsed via Date.parse, not tough-cookie's parseDate, since ISO timestamps are being handled at this layer.
   *
   * @example
   * ```
   * const json = JSON.stringify({
   *   key: 'alpha',
   *   value: 'beta',
   *   domain: 'example.com',
   *   path: '/foo',
   *   expires: '2038-01-19T03:14:07.000Z',
   * })
   * const cookie = Cookie.fromJSON(json)
   * cookie.key === 'alpha'
   * cookie.value === 'beta'
   * cookie.domain === 'example.com'
   * cookie.path === '/foo'
   * cookie.expires === new Date(Date.parse('2038-01-19T03:14:07.000Z'))
   * ```
   *
   * @param str - An unparsed JSON string or a value that has already been parsed as JSON
   */
  static fromJSON(str) {
    return fromJSON(str);
  }
};
cookie.Cookie = Cookie$1;
Cookie$1.cookiesCreated = 0;
Cookie$1.sameSiteLevel = {
  strict: 3,
  lax: 2,
  none: 1
};
Cookie$1.sameSiteCanonical = {
  strict: "Strict",
  lax: "Lax"
};
Cookie$1.serializableProperties = [
  "key",
  "value",
  "expires",
  "maxAge",
  "domain",
  "path",
  "secure",
  "httpOnly",
  "extensions",
  "hostOnly",
  "pathIsDefault",
  "creation",
  "lastAccessed",
  "sameSite"
];
var cookieCompare$1 = {};
Object.defineProperty(cookieCompare$1, "__esModule", { value: true });
cookieCompare$1.cookieCompare = cookieCompare;
const MAX_TIME = 2147483647e3;
function cookieCompare(a, b) {
  let cmp;
  const aPathLen = a.path ? a.path.length : 0;
  const bPathLen = b.path ? b.path.length : 0;
  cmp = bPathLen - aPathLen;
  if (cmp !== 0) {
    return cmp;
  }
  const aTime = a.creation && a.creation instanceof Date ? a.creation.getTime() : MAX_TIME;
  const bTime = b.creation && b.creation instanceof Date ? b.creation.getTime() : MAX_TIME;
  cmp = aTime - bTime;
  if (cmp !== 0) {
    return cmp;
  }
  cmp = (a.creationIndex || 0) - (b.creationIndex || 0);
  return cmp;
}
var cookieJar = {};
var defaultPath$1 = {};
Object.defineProperty(defaultPath$1, "__esModule", { value: true });
defaultPath$1.defaultPath = defaultPath;
function defaultPath(path2) {
  if (!path2 || path2.slice(0, 1) !== "/") {
    return "/";
  }
  if (path2 === "/") {
    return path2;
  }
  const rightSlash = path2.lastIndexOf("/");
  if (rightSlash === 0) {
    return "/";
  }
  return path2.slice(0, rightSlash);
}
var domainMatch$1 = {};
Object.defineProperty(domainMatch$1, "__esModule", { value: true });
domainMatch$1.domainMatch = domainMatch;
const canonicalDomain_1$1 = canonicalDomain$2;
const IP_REGEX_LOWERCASE = /(?:^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$)|(?:^(?:(?:[a-f\d]{1,4}:){7}(?:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,2}|:)|(?:[a-f\d]{1,4}:){4}(?:(?::[a-f\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,3}|:)|(?:[a-f\d]{1,4}:){3}(?:(?::[a-f\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,4}|:)|(?:[a-f\d]{1,4}:){2}(?:(?::[a-f\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,5}|:)|(?:[a-f\d]{1,4}:){1}(?:(?::[a-f\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,6}|:)|(?::(?:(?::[a-f\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,7}|:)))$)/;
function domainMatch(domain, cookieDomain, canonicalize) {
  if (domain == null || cookieDomain == null) {
    return void 0;
  }
  let _str;
  let _domStr;
  if (canonicalize !== false) {
    _str = (0, canonicalDomain_1$1.canonicalDomain)(domain);
    _domStr = (0, canonicalDomain_1$1.canonicalDomain)(cookieDomain);
  } else {
    _str = domain;
    _domStr = cookieDomain;
  }
  if (_str == null || _domStr == null) {
    return void 0;
  }
  if (_str == _domStr) {
    return true;
  }
  const idx = _str.lastIndexOf(_domStr);
  if (idx <= 0) {
    return false;
  }
  if (_str.length !== _domStr.length + idx) {
    return false;
  }
  if (_str.substring(idx - 1, idx) !== ".") {
    return false;
  }
  return !IP_REGEX_LOWERCASE.test(_str);
}
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(cookieJar, "__esModule", { value: true });
cookieJar.CookieJar = void 0;
const getPublicSuffix_1 = getPublicSuffix$2;
const validators = __importStar(validators$2);
const validators_1 = validators$2;
const store_1 = store;
const memstore_1 = memstore;
const pathMatch_1 = pathMatch$1;
const cookie_1 = cookie;
const utils_1 = utils$3;
const canonicalDomain_1 = canonicalDomain$2;
const constants_1 = constants$6;
const defaultPath_1 = defaultPath$1;
const domainMatch_1 = domainMatch$1;
const cookieCompare_1 = cookieCompare$1;
const version_1 = version$1;
const defaultSetCookieOptions = {
  loose: false,
  sameSiteContext: void 0,
  ignoreError: false,
  http: true
};
const defaultGetCookieOptions = {
  http: true,
  expire: true,
  allPaths: false,
  sameSiteContext: void 0,
  sort: void 0
};
const SAME_SITE_CONTEXT_VAL_ERR = 'Invalid sameSiteContext option for getCookies(); expected one of "strict", "lax", or "none"';
function getCookieContext(url) {
  if (url && typeof url === "object" && "hostname" in url && typeof url.hostname === "string" && "pathname" in url && typeof url.pathname === "string" && "protocol" in url && typeof url.protocol === "string") {
    return {
      hostname: url.hostname,
      pathname: url.pathname,
      protocol: url.protocol
    };
  } else if (typeof url === "string") {
    try {
      return new URL(decodeURI(url));
    } catch {
      return new URL(url);
    }
  } else {
    throw new validators_1.ParameterError("`url` argument is not a string or URL.");
  }
}
function checkSameSiteContext(value) {
  const context = String(value).toLowerCase();
  if (context === "none" || context === "lax" || context === "strict") {
    return context;
  } else {
    return void 0;
  }
}
function isSecurePrefixConditionMet(cookie2) {
  const startsWithSecurePrefix = typeof cookie2.key === "string" && cookie2.key.startsWith("__Secure-");
  return !startsWithSecurePrefix || cookie2.secure;
}
function isHostPrefixConditionMet(cookie2) {
  const startsWithHostPrefix = typeof cookie2.key === "string" && cookie2.key.startsWith("__Host-");
  return !startsWithHostPrefix || Boolean(cookie2.secure && cookie2.hostOnly && cookie2.path != null && cookie2.path === "/");
}
function getNormalizedPrefixSecurity(prefixSecurity) {
  const normalizedPrefixSecurity = prefixSecurity.toLowerCase();
  switch (normalizedPrefixSecurity) {
    case constants_1.PrefixSecurityEnum.STRICT:
    case constants_1.PrefixSecurityEnum.SILENT:
    case constants_1.PrefixSecurityEnum.DISABLED:
      return normalizedPrefixSecurity;
    default:
      return constants_1.PrefixSecurityEnum.SILENT;
  }
}
let CookieJar$1 = class CookieJar {
  /**
   * Creates a new `CookieJar` instance.
   *
   * @remarks
   * - If a custom store is not passed to the constructor, an in-memory store ({@link MemoryCookieStore} will be created and used.
   * - If a boolean value is passed as the `options` parameter, this is equivalent to passing `{ rejectPublicSuffixes: <value> }`
   *
   * @param store - a custom {@link Store} implementation (defaults to {@link MemoryCookieStore})
   * @param options - configures how cookies are processed by the cookie jar
   */
  constructor(store2, options) {
    if (typeof options === "boolean") {
      options = { rejectPublicSuffixes: options };
    }
    this.rejectPublicSuffixes = (options == null ? void 0 : options.rejectPublicSuffixes) ?? true;
    this.enableLooseMode = (options == null ? void 0 : options.looseMode) ?? false;
    this.allowSpecialUseDomain = (options == null ? void 0 : options.allowSpecialUseDomain) ?? true;
    this.prefixSecurity = getNormalizedPrefixSecurity((options == null ? void 0 : options.prefixSecurity) ?? "silent");
    this.store = store2 ?? new memstore_1.MemoryCookieStore();
  }
  callSync(fn) {
    if (!this.store.synchronous) {
      throw new Error("CookieJar store is not synchronous; use async API instead.");
    }
    let syncErr = null;
    let syncResult = void 0;
    try {
      fn.call(this, (error, result) => {
        syncErr = error;
        syncResult = result;
      });
    } catch (err) {
      syncErr = err;
    }
    if (syncErr)
      throw syncErr;
    return syncResult;
  }
  /**
   * @internal No doc because this is the overload implementation
   */
  setCookie(cookie2, url, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = void 0;
    }
    const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
    const cb = promiseCallback.callback;
    let context;
    try {
      if (typeof url === "string") {
        validators.validate(validators.isNonEmptyString(url), callback, (0, utils_1.safeToString)(options));
      }
      context = getCookieContext(url);
      if (typeof url === "function") {
        return promiseCallback.reject(new Error("No URL was specified"));
      }
      if (typeof options === "function") {
        options = defaultSetCookieOptions;
      }
      validators.validate(typeof cb === "function", cb);
      if (!validators.isNonEmptyString(cookie2) && !validators.isObject(cookie2) && cookie2 instanceof String && cookie2.length == 0) {
        return promiseCallback.resolve(void 0);
      }
    } catch (err) {
      return promiseCallback.reject(err);
    }
    const host = (0, canonicalDomain_1.canonicalDomain)(context.hostname) ?? null;
    const loose = (options == null ? void 0 : options.loose) || this.enableLooseMode;
    let sameSiteContext = null;
    if (options == null ? void 0 : options.sameSiteContext) {
      sameSiteContext = checkSameSiteContext(options.sameSiteContext);
      if (!sameSiteContext) {
        return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));
      }
    }
    if (typeof cookie2 === "string" || cookie2 instanceof String) {
      const parsedCookie = cookie_1.Cookie.parse(cookie2.toString(), { loose });
      if (!parsedCookie) {
        const err = new Error("Cookie failed to parse");
        return (options == null ? void 0 : options.ignoreError) ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);
      }
      cookie2 = parsedCookie;
    } else if (!(cookie2 instanceof cookie_1.Cookie)) {
      const err = new Error("First argument to setCookie must be a Cookie object or string");
      return (options == null ? void 0 : options.ignoreError) ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);
    }
    const now = (options == null ? void 0 : options.now) || /* @__PURE__ */ new Date();
    if (this.rejectPublicSuffixes && cookie2.domain) {
      try {
        const cdomain = cookie2.cdomain();
        const suffix = typeof cdomain === "string" ? (0, getPublicSuffix_1.getPublicSuffix)(cdomain, {
          allowSpecialUseDomain: this.allowSpecialUseDomain,
          ignoreError: options == null ? void 0 : options.ignoreError
        }) : null;
        if (suffix == null && !constants_1.IP_V6_REGEX_OBJECT.test(cookie2.domain)) {
          const err = new Error("Cookie has domain set to a public suffix");
          return (options == null ? void 0 : options.ignoreError) ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);
        }
      } catch (err) {
        return (options == null ? void 0 : options.ignoreError) ? promiseCallback.resolve(void 0) : (
          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
          promiseCallback.reject(err)
        );
      }
    }
    if (cookie2.domain) {
      if (!(0, domainMatch_1.domainMatch)(host ?? void 0, cookie2.cdomain() ?? void 0, false)) {
        const err = new Error(`Cookie not in this host's domain. Cookie:${cookie2.cdomain() ?? "null"} Request:${host ?? "null"}`);
        return (options == null ? void 0 : options.ignoreError) ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);
      }
      if (cookie2.hostOnly == null) {
        cookie2.hostOnly = false;
      }
    } else {
      cookie2.hostOnly = true;
      cookie2.domain = host;
    }
    if (!cookie2.path || cookie2.path[0] !== "/") {
      cookie2.path = (0, defaultPath_1.defaultPath)(context.pathname);
      cookie2.pathIsDefault = true;
    }
    if ((options == null ? void 0 : options.http) === false && cookie2.httpOnly) {
      const err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
      return options.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);
    }
    if (cookie2.sameSite !== "none" && cookie2.sameSite !== void 0 && sameSiteContext) {
      if (sameSiteContext === "none") {
        const err = new Error("Cookie is SameSite but this is a cross-origin request");
        return (options == null ? void 0 : options.ignoreError) ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);
      }
    }
    const ignoreErrorForPrefixSecurity = this.prefixSecurity === constants_1.PrefixSecurityEnum.SILENT;
    const prefixSecurityDisabled = this.prefixSecurity === constants_1.PrefixSecurityEnum.DISABLED;
    if (!prefixSecurityDisabled) {
      let errorFound = false;
      let errorMsg;
      if (!isSecurePrefixConditionMet(cookie2)) {
        errorFound = true;
        errorMsg = "Cookie has __Secure prefix but Secure attribute is not set";
      } else if (!isHostPrefixConditionMet(cookie2)) {
        errorFound = true;
        errorMsg = "Cookie has __Host prefix but either Secure or HostOnly attribute is not set or Path is not '/'";
      }
      if (errorFound) {
        return (options == null ? void 0 : options.ignoreError) || ignoreErrorForPrefixSecurity ? promiseCallback.resolve(void 0) : promiseCallback.reject(new Error(errorMsg));
      }
    }
    const store2 = this.store;
    if (!store2.updateCookie) {
      store2.updateCookie = async function(_oldCookie, newCookie, cb2) {
        return this.putCookie(newCookie).then(() => cb2 == null ? void 0 : cb2(null), (error) => cb2 == null ? void 0 : cb2(error));
      };
    }
    const withCookie = function withCookie2(err, oldCookie) {
      if (err) {
        cb(err);
        return;
      }
      const next = function(err2) {
        if (err2) {
          cb(err2);
        } else if (typeof cookie2 === "string") {
          cb(null, void 0);
        } else {
          cb(null, cookie2);
        }
      };
      if (oldCookie) {
        if (options && "http" in options && options.http === false && oldCookie.httpOnly) {
          err = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
          if (options.ignoreError)
            cb(null, void 0);
          else
            cb(err);
          return;
        }
        if (cookie2 instanceof cookie_1.Cookie) {
          cookie2.creation = oldCookie.creation;
          cookie2.creationIndex = oldCookie.creationIndex;
          cookie2.lastAccessed = now;
          store2.updateCookie(oldCookie, cookie2, next);
        }
      } else {
        if (cookie2 instanceof cookie_1.Cookie) {
          cookie2.creation = cookie2.lastAccessed = now;
          store2.putCookie(cookie2, next);
        }
      }
    };
    store2.findCookie(cookie2.domain, cookie2.path, cookie2.key, withCookie);
    return promiseCallback.promise;
  }
  /**
   * Synchronously attempt to set the {@link Cookie} in the {@link CookieJar}.
   *
   * <strong>Note:</strong> Only works if the configured {@link Store} is also synchronous.
   *
   * @remarks
   * - If successfully persisted, the {@link Cookie} will have updated
   *     {@link Cookie.creation}, {@link Cookie.lastAccessed} and {@link Cookie.hostOnly}
   *     properties.
   *
   * - As per the RFC, the {@link Cookie.hostOnly} flag is set if there was no `Domain={value}`
   *     atttribute on the cookie string. The {@link Cookie.domain} property is set to the
   *     fully-qualified hostname of `currentUrl` in this case. Matching this cookie requires an
   *     exact hostname match (not a {@link domainMatch} as per usual)
   *
   * @param cookie - The cookie object or cookie string to store. A string value will be parsed into a cookie using {@link Cookie.parse}.
   * @param url - The domain to store the cookie with.
   * @param options - Configuration settings to use when storing the cookie.
   * @public
   */
  setCookieSync(cookie2, url, options) {
    const setCookieFn = options ? this.setCookie.bind(this, cookie2, url, options) : this.setCookie.bind(this, cookie2, url);
    return this.callSync(setCookieFn);
  }
  /**
   * @internal No doc because this is the overload implementation
   */
  getCookies(url, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = defaultGetCookieOptions;
    } else if (options === void 0) {
      options = defaultGetCookieOptions;
    }
    const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
    const cb = promiseCallback.callback;
    let context;
    try {
      if (typeof url === "string") {
        validators.validate(validators.isNonEmptyString(url), cb, url);
      }
      context = getCookieContext(url);
      validators.validate(validators.isObject(options), cb, (0, utils_1.safeToString)(options));
      validators.validate(typeof cb === "function", cb);
    } catch (parameterError) {
      return promiseCallback.reject(parameterError);
    }
    const host = (0, canonicalDomain_1.canonicalDomain)(context.hostname);
    const path2 = context.pathname || "/";
    const secure = context.protocol && (context.protocol == "https:" || context.protocol == "wss:");
    let sameSiteLevel = 0;
    if (options.sameSiteContext) {
      const sameSiteContext = checkSameSiteContext(options.sameSiteContext);
      if (sameSiteContext == null) {
        return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));
      }
      sameSiteLevel = cookie_1.Cookie.sameSiteLevel[sameSiteContext];
      if (!sameSiteLevel) {
        return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));
      }
    }
    const http3 = options.http ?? true;
    const now = Date.now();
    const expireCheck = options.expire ?? true;
    const allPaths = options.allPaths ?? false;
    const store2 = this.store;
    function matchingCookie(c) {
      if (c.hostOnly) {
        if (c.domain != host) {
          return false;
        }
      } else {
        if (!(0, domainMatch_1.domainMatch)(host ?? void 0, c.domain ?? void 0, false)) {
          return false;
        }
      }
      if (!allPaths && typeof c.path === "string" && !(0, pathMatch_1.pathMatch)(path2, c.path)) {
        return false;
      }
      if (c.secure && !secure) {
        return false;
      }
      if (c.httpOnly && !http3) {
        return false;
      }
      if (sameSiteLevel) {
        let cookieLevel;
        if (c.sameSite === "lax") {
          cookieLevel = cookie_1.Cookie.sameSiteLevel.lax;
        } else if (c.sameSite === "strict") {
          cookieLevel = cookie_1.Cookie.sameSiteLevel.strict;
        } else {
          cookieLevel = cookie_1.Cookie.sameSiteLevel.none;
        }
        if (cookieLevel > sameSiteLevel) {
          return false;
        }
      }
      const expiryTime = c.expiryTime();
      if (expireCheck && expiryTime != void 0 && expiryTime <= now) {
        store2.removeCookie(c.domain, c.path, c.key, () => {
        });
        return false;
      }
      return true;
    }
    store2.findCookies(host, allPaths ? null : path2, this.allowSpecialUseDomain, (err, cookies2) => {
      if (err) {
        cb(err);
        return;
      }
      if (cookies2 == null) {
        cb(null, []);
        return;
      }
      cookies2 = cookies2.filter(matchingCookie);
      if ("sort" in options && options.sort !== false) {
        cookies2 = cookies2.sort(cookieCompare_1.cookieCompare);
      }
      const now2 = /* @__PURE__ */ new Date();
      for (const cookie2 of cookies2) {
        cookie2.lastAccessed = now2;
      }
      cb(null, cookies2);
    });
    return promiseCallback.promise;
  }
  /**
   * Synchronously retrieve the list of cookies that can be sent in a Cookie header for the
   * current URL.
   *
   * <strong>Note</strong>: Only works if the configured Store is also synchronous.
   *
   * @remarks
   * - The array of cookies returned will be sorted according to {@link cookieCompare}.
   *
   * - The {@link Cookie.lastAccessed} property will be updated on all returned cookies.
   *
   * @param url - The domain to store the cookie with.
   * @param options - Configuration settings to use when retrieving the cookies.
   */
  getCookiesSync(url, options) {
    return this.callSync(this.getCookies.bind(this, url, options)) ?? [];
  }
  /**
   * @internal No doc because this is the overload implementation
   */
  getCookieString(url, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = void 0;
    }
    const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
    const next = function(err, cookies2) {
      if (err) {
        promiseCallback.callback(err);
      } else {
        promiseCallback.callback(null, cookies2 == null ? void 0 : cookies2.sort(cookieCompare_1.cookieCompare).map((c) => c.cookieString()).join("; "));
      }
    };
    this.getCookies(url, options, next);
    return promiseCallback.promise;
  }
  /**
   * Synchronous version of `.getCookieString()`. Accepts the same options as `.getCookies()` but returns a string suitable for a
   * `Cookie` header rather than an Array.
   *
   * <strong>Note</strong>: Only works if the configured Store is also synchronous.
   *
   * @param url - The domain to store the cookie with.
   * @param options - Configuration settings to use when retrieving the cookies.
   */
  getCookieStringSync(url, options) {
    return this.callSync(options ? this.getCookieString.bind(this, url, options) : this.getCookieString.bind(this, url)) ?? "";
  }
  /**
   * @internal No doc because this is the overload implementation
   */
  getSetCookieStrings(url, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = void 0;
    }
    const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
    const next = function(err, cookies2) {
      if (err) {
        promiseCallback.callback(err);
      } else {
        promiseCallback.callback(null, cookies2 == null ? void 0 : cookies2.map((c) => {
          return c.toString();
        }));
      }
    };
    this.getCookies(url, options, next);
    return promiseCallback.promise;
  }
  /**
   * Synchronous version of `.getSetCookieStrings()`. Returns an array of strings suitable for `Set-Cookie` headers.
   * Accepts the same options as `.getCookies()`.
   *
   * <strong>Note</strong>: Only works if the configured Store is also synchronous.
   *
   * @param url - The domain to store the cookie with.
   * @param options - Configuration settings to use when retrieving the cookies.
   */
  getSetCookieStringsSync(url, options = {}) {
    return this.callSync(this.getSetCookieStrings.bind(this, url, options)) ?? [];
  }
  /**
   * @internal No doc because this is the overload implementation
   */
  serialize(callback) {
    const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
    let type = this.store.constructor.name;
    if (validators.isObject(type)) {
      type = null;
    }
    const serialized = {
      // The version of tough-cookie that serialized this jar. Generally a good
      // practice since future versions can make data import decisions based on
      // known past behavior. When/if this matters, use `semver`.
      version: `tough-cookie@${version_1.version}`,
      // add the store type, to make humans happy:
      storeType: type,
      // CookieJar configuration:
      rejectPublicSuffixes: this.rejectPublicSuffixes,
      enableLooseMode: this.enableLooseMode,
      allowSpecialUseDomain: this.allowSpecialUseDomain,
      prefixSecurity: getNormalizedPrefixSecurity(this.prefixSecurity),
      // this gets filled from getAllCookies:
      cookies: []
    };
    if (typeof this.store.getAllCookies !== "function") {
      return promiseCallback.reject(new Error("store does not support getAllCookies and cannot be serialized"));
    }
    this.store.getAllCookies((err, cookies2) => {
      if (err) {
        promiseCallback.callback(err);
        return;
      }
      if (cookies2 == null) {
        promiseCallback.callback(null, serialized);
        return;
      }
      serialized.cookies = cookies2.map((cookie2) => {
        const serializedCookie = cookie2.toJSON();
        delete serializedCookie.creationIndex;
        return serializedCookie;
      });
      promiseCallback.callback(null, serialized);
    });
    return promiseCallback.promise;
  }
  /**
   * Serialize the CookieJar if the underlying store supports `.getAllCookies`.
   *
   * <strong>Note</strong>: Only works if the configured Store is also synchronous.
   */
  serializeSync() {
    return this.callSync((callback) => {
      this.serialize(callback);
    });
  }
  /**
   * Alias of {@link CookieJar.serializeSync}. Allows the cookie to be serialized
   * with `JSON.stringify(cookieJar)`.
   */
  toJSON() {
    return this.serializeSync();
  }
  /**
   * Use the class method CookieJar.deserialize instead of calling this directly
   * @internal
   */
  _importCookies(serialized, callback) {
    let cookies2 = void 0;
    if (serialized && typeof serialized === "object" && (0, utils_1.inOperator)("cookies", serialized) && Array.isArray(serialized.cookies)) {
      cookies2 = serialized.cookies;
    }
    if (!cookies2) {
      callback(new Error("serialized jar has no cookies array"), void 0);
      return;
    }
    cookies2 = cookies2.slice();
    const putNext = (err) => {
      if (err) {
        callback(err, void 0);
        return;
      }
      if (Array.isArray(cookies2)) {
        if (!cookies2.length) {
          callback(err, this);
          return;
        }
        let cookie2;
        try {
          cookie2 = cookie_1.Cookie.fromJSON(cookies2.shift());
        } catch (e) {
          callback(e instanceof Error ? e : new Error(), void 0);
          return;
        }
        if (cookie2 === void 0) {
          putNext(null);
          return;
        }
        this.store.putCookie(cookie2, putNext);
      }
    };
    putNext(null);
  }
  /**
   * @internal
   */
  _importCookiesSync(serialized) {
    this.callSync(this._importCookies.bind(this, serialized));
  }
  /**
   * @internal No doc because this is the overload implementation
   */
  clone(newStore, callback) {
    if (typeof newStore === "function") {
      callback = newStore;
      newStore = void 0;
    }
    const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
    const cb = promiseCallback.callback;
    this.serialize((err, serialized) => {
      if (err) {
        return promiseCallback.reject(err);
      }
      return CookieJar.deserialize(serialized ?? "", newStore, cb);
    });
    return promiseCallback.promise;
  }
  /**
   * @internal
   */
  _cloneSync(newStore) {
    const cloneFn = newStore && typeof newStore !== "function" ? this.clone.bind(this, newStore) : this.clone.bind(this);
    return this.callSync((callback) => {
      cloneFn(callback);
    });
  }
  /**
   * Produces a deep clone of this CookieJar. Modifications to the original do
   * not affect the clone, and vice versa.
   *
   * <strong>Note</strong>: Only works if both the configured Store and destination
   * Store are synchronous.
   *
   * @remarks
   * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.
   *
   * - Transferring between store types is supported so long as the source
   *     implements `.getAllCookies()` and the destination implements `.putCookie()`.
   *
   * @param newStore - The target {@link Store} to clone cookies into.
   */
  cloneSync(newStore) {
    if (!newStore) {
      return this._cloneSync();
    }
    if (!newStore.synchronous) {
      throw new Error("CookieJar clone destination store is not synchronous; use async API instead.");
    }
    return this._cloneSync(newStore);
  }
  /**
   * @internal No doc because this is the overload implementation
   */
  removeAllCookies(callback) {
    const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
    const cb = promiseCallback.callback;
    const store2 = this.store;
    if (typeof store2.removeAllCookies === "function" && store2.removeAllCookies !== store_1.Store.prototype.removeAllCookies) {
      store2.removeAllCookies(cb);
      return promiseCallback.promise;
    }
    store2.getAllCookies((err, cookies2) => {
      if (err) {
        cb(err);
        return;
      }
      if (!cookies2) {
        cookies2 = [];
      }
      if (cookies2.length === 0) {
        cb(null, void 0);
        return;
      }
      let completedCount = 0;
      const removeErrors = [];
      const removeCookieCb = function removeCookieCb2(removeErr) {
        if (removeErr) {
          removeErrors.push(removeErr);
        }
        completedCount++;
        if (completedCount === cookies2.length) {
          if (removeErrors[0])
            cb(removeErrors[0]);
          else
            cb(null, void 0);
          return;
        }
      };
      cookies2.forEach((cookie2) => {
        store2.removeCookie(cookie2.domain, cookie2.path, cookie2.key, removeCookieCb);
      });
    });
    return promiseCallback.promise;
  }
  /**
   * Removes all cookies from the CookieJar.
   *
   * <strong>Note</strong>: Only works if the configured Store is also synchronous.
   *
   * @remarks
   * - This is a new backwards-compatible feature of tough-cookie version 2.5,
   *     so not all Stores will implement it efficiently. For Stores that do not
   *     implement `removeAllCookies`, the fallback is to call `removeCookie` after
   *     `getAllCookies`.
   *
   * - If `getAllCookies` fails or isn't implemented in the Store, an error is returned.
   *
   * - If one or more of the `removeCookie` calls fail, only the first error is returned.
   */
  removeAllCookiesSync() {
    this.callSync((callback) => {
      this.removeAllCookies(callback);
    });
  }
  /**
   * @internal No doc because this is the overload implementation
   */
  static deserialize(strOrObj, store2, callback) {
    if (typeof store2 === "function") {
      callback = store2;
      store2 = void 0;
    }
    const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
    let serialized;
    if (typeof strOrObj === "string") {
      try {
        serialized = JSON.parse(strOrObj);
      } catch (e) {
        return promiseCallback.reject(e instanceof Error ? e : new Error());
      }
    } else {
      serialized = strOrObj;
    }
    const readSerializedProperty = (property) => {
      return serialized && typeof serialized === "object" && (0, utils_1.inOperator)(property, serialized) ? serialized[property] : void 0;
    };
    const readSerializedBoolean = (property) => {
      const value = readSerializedProperty(property);
      return typeof value === "boolean" ? value : void 0;
    };
    const readSerializedString = (property) => {
      const value = readSerializedProperty(property);
      return typeof value === "string" ? value : void 0;
    };
    const jar = new CookieJar(store2, {
      rejectPublicSuffixes: readSerializedBoolean("rejectPublicSuffixes"),
      looseMode: readSerializedBoolean("enableLooseMode"),
      allowSpecialUseDomain: readSerializedBoolean("allowSpecialUseDomain"),
      prefixSecurity: getNormalizedPrefixSecurity(readSerializedString("prefixSecurity") ?? "silent")
    });
    jar._importCookies(serialized, (err) => {
      if (err) {
        promiseCallback.callback(err);
        return;
      }
      promiseCallback.callback(null, jar);
    });
    return promiseCallback.promise;
  }
  /**
   * A new CookieJar is created and the serialized {@link Cookie} values are added to
   * the underlying store. Each {@link Cookie} is added via `store.putCookie(...)` in
   * the order in which they appear in the serialization.
   *
   * <strong>Note</strong>: Only works if the configured Store is also synchronous.
   *
   * @remarks
   * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.
   *
   * - As a convenience, if `strOrObj` is a string, it is passed through `JSON.parse` first.
   *
   * @param strOrObj - A JSON string or object representing the deserialized cookies.
   * @param store - The underlying store to persist the deserialized cookies into.
   */
  static deserializeSync(strOrObj, store2) {
    const serialized = typeof strOrObj === "string" ? JSON.parse(strOrObj) : strOrObj;
    const readSerializedProperty = (property) => {
      return serialized && typeof serialized === "object" && (0, utils_1.inOperator)(property, serialized) ? serialized[property] : void 0;
    };
    const readSerializedBoolean = (property) => {
      const value = readSerializedProperty(property);
      return typeof value === "boolean" ? value : void 0;
    };
    const readSerializedString = (property) => {
      const value = readSerializedProperty(property);
      return typeof value === "string" ? value : void 0;
    };
    const jar = new CookieJar(store2, {
      rejectPublicSuffixes: readSerializedBoolean("rejectPublicSuffixes"),
      looseMode: readSerializedBoolean("enableLooseMode"),
      allowSpecialUseDomain: readSerializedBoolean("allowSpecialUseDomain"),
      prefixSecurity: getNormalizedPrefixSecurity(readSerializedString("prefixSecurity") ?? "silent")
    });
    if (!jar.store.synchronous) {
      throw new Error("CookieJar store is not synchronous; use async API instead.");
    }
    jar._importCookiesSync(serialized);
    return jar;
  }
  /**
   * Alias of {@link CookieJar.deserializeSync}.
   *
   * @remarks
   * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.
   *
   * - As a convenience, if `strOrObj` is a string, it is passed through `JSON.parse` first.
   *
   * @param jsonString - A JSON string or object representing the deserialized cookies.
   * @param store - The underlying store to persist the deserialized cookies into.
   */
  static fromJSON(jsonString, store2) {
    return CookieJar.deserializeSync(jsonString, store2);
  }
};
cookieJar.CookieJar = CookieJar$1;
var permutePath$1 = {};
Object.defineProperty(permutePath$1, "__esModule", { value: true });
permutePath$1.permutePath = permutePath;
function permutePath(path2) {
  if (path2 === "/") {
    return ["/"];
  }
  const permutations = [path2];
  while (path2.length > 1) {
    const lindex = path2.lastIndexOf("/");
    if (lindex === 0) {
      break;
    }
    path2 = path2.slice(0, lindex);
    permutations.push(path2);
  }
  permutations.push("/");
  return permutations;
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.permutePath = exports.parseDate = exports.formatDate = exports.domainMatch = exports.defaultPath = exports.CookieJar = exports.cookieCompare = exports.Cookie = exports.PrefixSecurityEnum = exports.canonicalDomain = exports.version = exports.ParameterError = exports.Store = exports.getPublicSuffix = exports.permuteDomain = exports.pathMatch = exports.MemoryCookieStore = void 0;
  exports.parse = parse2;
  exports.fromJSON = fromJSON2;
  var memstore_12 = memstore;
  Object.defineProperty(exports, "MemoryCookieStore", { enumerable: true, get: function() {
    return memstore_12.MemoryCookieStore;
  } });
  var pathMatch_12 = pathMatch$1;
  Object.defineProperty(exports, "pathMatch", { enumerable: true, get: function() {
    return pathMatch_12.pathMatch;
  } });
  var permuteDomain_12 = permuteDomain$1;
  Object.defineProperty(exports, "permuteDomain", { enumerable: true, get: function() {
    return permuteDomain_12.permuteDomain;
  } });
  var getPublicSuffix_12 = getPublicSuffix$2;
  Object.defineProperty(exports, "getPublicSuffix", { enumerable: true, get: function() {
    return getPublicSuffix_12.getPublicSuffix;
  } });
  var store_12 = store;
  Object.defineProperty(exports, "Store", { enumerable: true, get: function() {
    return store_12.Store;
  } });
  var validators_12 = validators$2;
  Object.defineProperty(exports, "ParameterError", { enumerable: true, get: function() {
    return validators_12.ParameterError;
  } });
  var version_12 = version$1;
  Object.defineProperty(exports, "version", { enumerable: true, get: function() {
    return version_12.version;
  } });
  var canonicalDomain_12 = canonicalDomain$2;
  Object.defineProperty(exports, "canonicalDomain", { enumerable: true, get: function() {
    return canonicalDomain_12.canonicalDomain;
  } });
  var constants_12 = constants$6;
  Object.defineProperty(exports, "PrefixSecurityEnum", { enumerable: true, get: function() {
    return constants_12.PrefixSecurityEnum;
  } });
  var cookie_12 = cookie;
  Object.defineProperty(exports, "Cookie", { enumerable: true, get: function() {
    return cookie_12.Cookie;
  } });
  var cookieCompare_12 = cookieCompare$1;
  Object.defineProperty(exports, "cookieCompare", { enumerable: true, get: function() {
    return cookieCompare_12.cookieCompare;
  } });
  var cookieJar_1 = cookieJar;
  Object.defineProperty(exports, "CookieJar", { enumerable: true, get: function() {
    return cookieJar_1.CookieJar;
  } });
  var defaultPath_12 = defaultPath$1;
  Object.defineProperty(exports, "defaultPath", { enumerable: true, get: function() {
    return defaultPath_12.defaultPath;
  } });
  var domainMatch_12 = domainMatch$1;
  Object.defineProperty(exports, "domainMatch", { enumerable: true, get: function() {
    return domainMatch_12.domainMatch;
  } });
  var formatDate_12 = formatDate$1;
  Object.defineProperty(exports, "formatDate", { enumerable: true, get: function() {
    return formatDate_12.formatDate;
  } });
  var parseDate_12 = parseDate$1;
  Object.defineProperty(exports, "parseDate", { enumerable: true, get: function() {
    return parseDate_12.parseDate;
  } });
  var permutePath_1 = permutePath$1;
  Object.defineProperty(exports, "permutePath", { enumerable: true, get: function() {
    return permutePath_1.permutePath;
  } });
  const cookie_2 = cookie;
  function parse2(str, options) {
    return cookie_2.Cookie.parse(str, options);
  }
  function fromJSON2(str) {
    return cookie_2.Cookie.fromJSON(str);
  }
})(cookie$1);
var undici$2 = {};
var cookie_agent = {};
var undici$1 = {};
var symbols$4 = {
  kClose: Symbol("close"),
  kDestroy: Symbol("destroy"),
  kDispatch: Symbol("dispatch"),
  kUrl: Symbol("url"),
  kWriting: Symbol("writing"),
  kResuming: Symbol("resuming"),
  kQueue: Symbol("queue"),
  kConnect: Symbol("connect"),
  kConnecting: Symbol("connecting"),
  kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
  kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
  kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
  kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
  kKeepAlive: Symbol("keep alive"),
  kHeadersTimeout: Symbol("headers timeout"),
  kBodyTimeout: Symbol("body timeout"),
  kServerName: Symbol("server name"),
  kLocalAddress: Symbol("local address"),
  kHost: Symbol("host"),
  kNoRef: Symbol("no ref"),
  kBodyUsed: Symbol("used"),
  kBody: Symbol("abstracted request body"),
  kRunning: Symbol("running"),
  kBlocking: Symbol("blocking"),
  kPending: Symbol("pending"),
  kSize: Symbol("size"),
  kBusy: Symbol("busy"),
  kQueued: Symbol("queued"),
  kFree: Symbol("free"),
  kConnected: Symbol("connected"),
  kClosed: Symbol("closed"),
  kNeedDrain: Symbol("need drain"),
  kReset: Symbol("reset"),
  kDestroyed: Symbol.for("nodejs.stream.destroyed"),
  kResume: Symbol("resume"),
  kOnError: Symbol("on error"),
  kMaxHeadersSize: Symbol("max headers size"),
  kRunningIdx: Symbol("running index"),
  kPendingIdx: Symbol("pending index"),
  kError: Symbol("error"),
  kClients: Symbol("clients"),
  kClient: Symbol("client"),
  kParser: Symbol("parser"),
  kOnDestroyed: Symbol("destroy callbacks"),
  kPipelining: Symbol("pipelining"),
  kSocket: Symbol("socket"),
  kHostHeader: Symbol("host header"),
  kConnector: Symbol("connector"),
  kStrictContentLength: Symbol("strict content length"),
  kMaxRedirections: Symbol("maxRedirections"),
  kMaxRequests: Symbol("maxRequestsPerClient"),
  kProxy: Symbol("proxy agent options"),
  kCounter: Symbol("socket request counter"),
  kInterceptors: Symbol("dispatch interceptors"),
  kMaxResponseSize: Symbol("max response size"),
  kHTTP2Session: Symbol("http2Session"),
  kHTTP2SessionState: Symbol("http2Session state"),
  kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
  kConstruct: Symbol("constructable"),
  kListeners: Symbol("listeners"),
  kHTTPContext: Symbol("http context"),
  kMaxConcurrentStreams: Symbol("max concurrent streams"),
  kNoProxyAgent: Symbol("no proxy agent"),
  kHttpProxyAgent: Symbol("http proxy agent"),
  kHttpsProxyAgent: Symbol("https proxy agent")
};
let UndiciError$2 = class UndiciError2 extends Error {
  constructor(message) {
    super(message);
    this.name = "UndiciError";
    this.code = "UND_ERR";
  }
};
let ConnectTimeoutError$1 = class ConnectTimeoutError2 extends UndiciError$2 {
  constructor(message) {
    super(message);
    this.name = "ConnectTimeoutError";
    this.message = message || "Connect Timeout Error";
    this.code = "UND_ERR_CONNECT_TIMEOUT";
  }
};
let HeadersTimeoutError$1 = class HeadersTimeoutError2 extends UndiciError$2 {
  constructor(message) {
    super(message);
    this.name = "HeadersTimeoutError";
    this.message = message || "Headers Timeout Error";
    this.code = "UND_ERR_HEADERS_TIMEOUT";
  }
};
let HeadersOverflowError$1 = class HeadersOverflowError2 extends UndiciError$2 {
  constructor(message) {
    super(message);
    this.name = "HeadersOverflowError";
    this.message = message || "Headers Overflow Error";
    this.code = "UND_ERR_HEADERS_OVERFLOW";
  }
};
let BodyTimeoutError$1 = class BodyTimeoutError2 extends UndiciError$2 {
  constructor(message) {
    super(message);
    this.name = "BodyTimeoutError";
    this.message = message || "Body Timeout Error";
    this.code = "UND_ERR_BODY_TIMEOUT";
  }
};
let ResponseStatusCodeError$1 = class ResponseStatusCodeError2 extends UndiciError$2 {
  constructor(message, statusCode, headers2, body2) {
    super(message);
    this.name = "ResponseStatusCodeError";
    this.message = message || "Response Status Code Error";
    this.code = "UND_ERR_RESPONSE_STATUS_CODE";
    this.body = body2;
    this.status = statusCode;
    this.statusCode = statusCode;
    this.headers = headers2;
  }
};
let InvalidArgumentError$o = class InvalidArgumentError2 extends UndiciError$2 {
  constructor(message) {
    super(message);
    this.name = "InvalidArgumentError";
    this.message = message || "Invalid Argument Error";
    this.code = "UND_ERR_INVALID_ARG";
  }
};
let InvalidReturnValueError$2 = class InvalidReturnValueError2 extends UndiciError$2 {
  constructor(message) {
    super(message);
    this.name = "InvalidReturnValueError";
    this.message = message || "Invalid Return Value Error";
    this.code = "UND_ERR_INVALID_RETURN_VALUE";
  }
};
let AbortError$1 = class AbortError2 extends UndiciError$2 {
  constructor(message) {
    super(message);
    this.name = "AbortError";
    this.message = message || "The operation was aborted";
  }
};
let RequestAbortedError$8 = class RequestAbortedError2 extends AbortError$1 {
  constructor(message) {
    super(message);
    this.name = "AbortError";
    this.message = message || "Request aborted";
    this.code = "UND_ERR_ABORTED";
  }
};
let InformationalError$4 = class InformationalError2 extends UndiciError$2 {
  constructor(message) {
    super(message);
    this.name = "InformationalError";
    this.message = message || "Request information";
    this.code = "UND_ERR_INFO";
  }
};
let RequestContentLengthMismatchError$2 = class RequestContentLengthMismatchError2 extends UndiciError$2 {
  constructor(message) {
    super(message);
    this.name = "RequestContentLengthMismatchError";
    this.message = message || "Request body length does not match content-length header";
    this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
  }
};
let ResponseContentLengthMismatchError$1 = class ResponseContentLengthMismatchError2 extends UndiciError$2 {
  constructor(message) {
    super(message);
    this.name = "ResponseContentLengthMismatchError";
    this.message = message || "Response body length does not match content-length header";
    this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
  }
};
let ClientDestroyedError$2 = class ClientDestroyedError2 extends UndiciError$2 {
  constructor(message) {
    super(message);
    this.name = "ClientDestroyedError";
    this.message = message || "The client is destroyed";
    this.code = "UND_ERR_DESTROYED";
  }
};
let ClientClosedError$1 = class ClientClosedError2 extends UndiciError$2 {
  constructor(message) {
    super(message);
    this.name = "ClientClosedError";
    this.message = message || "The client is closed";
    this.code = "UND_ERR_CLOSED";
  }
};
let SocketError$4 = class SocketError2 extends UndiciError$2 {
  constructor(message, socket) {
    super(message);
    this.name = "SocketError";
    this.message = message || "Socket error";
    this.code = "UND_ERR_SOCKET";
    this.socket = socket;
  }
};
let NotSupportedError$2 = class NotSupportedError2 extends UndiciError$2 {
  constructor(message) {
    super(message);
    this.name = "NotSupportedError";
    this.message = message || "Not supported error";
    this.code = "UND_ERR_NOT_SUPPORTED";
  }
};
let BalancedPoolMissingUpstreamError$1 = class BalancedPoolMissingUpstreamError2 extends UndiciError$2 {
  constructor(message) {
    super(message);
    this.name = "MissingUpstreamError";
    this.message = message || "No upstream has been added to the BalancedPool";
    this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
  }
};
let HTTPParserError$1 = class HTTPParserError2 extends Error {
  constructor(message, code, data) {
    super(message);
    this.name = "HTTPParserError";
    this.code = code ? `HPE_${code}` : void 0;
    this.data = data ? data.toString() : void 0;
  }
};
let ResponseExceededMaxSizeError$1 = class ResponseExceededMaxSizeError2 extends UndiciError$2 {
  constructor(message) {
    super(message);
    this.name = "ResponseExceededMaxSizeError";
    this.message = message || "Response content exceeded max size";
    this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
  }
};
let RequestRetryError$1 = class RequestRetryError2 extends UndiciError$2 {
  constructor(message, code, { headers: headers2, data }) {
    super(message);
    this.name = "RequestRetryError";
    this.message = message || "Request retry error";
    this.code = "UND_ERR_REQ_RETRY";
    this.statusCode = code;
    this.data = data;
    this.headers = headers2;
  }
};
class ResponseError2 extends UndiciError$2 {
  constructor(message, code, { headers: headers2, data }) {
    super(message);
    this.name = "ResponseError";
    this.message = message || "Response error";
    this.code = "UND_ERR_RESPONSE";
    this.statusCode = code;
    this.data = data;
    this.headers = headers2;
  }
}
let SecureProxyConnectionError$1 = class SecureProxyConnectionError2 extends UndiciError$2 {
  constructor(cause, message, options) {
    super(message, { cause, ...options ?? {} });
    this.name = "SecureProxyConnectionError";
    this.message = message || "Secure Proxy Connection failed";
    this.code = "UND_ERR_PRX_TLS";
    this.cause = cause;
  }
};
var errors$1 = {
  AbortError: AbortError$1,
  HTTPParserError: HTTPParserError$1,
  UndiciError: UndiciError$2,
  HeadersTimeoutError: HeadersTimeoutError$1,
  HeadersOverflowError: HeadersOverflowError$1,
  BodyTimeoutError: BodyTimeoutError$1,
  RequestContentLengthMismatchError: RequestContentLengthMismatchError$2,
  ConnectTimeoutError: ConnectTimeoutError$1,
  ResponseStatusCodeError: ResponseStatusCodeError$1,
  InvalidArgumentError: InvalidArgumentError$o,
  InvalidReturnValueError: InvalidReturnValueError$2,
  RequestAbortedError: RequestAbortedError$8,
  ClientDestroyedError: ClientDestroyedError$2,
  ClientClosedError: ClientClosedError$1,
  InformationalError: InformationalError$4,
  SocketError: SocketError$4,
  NotSupportedError: NotSupportedError$2,
  ResponseContentLengthMismatchError: ResponseContentLengthMismatchError$1,
  BalancedPoolMissingUpstreamError: BalancedPoolMissingUpstreamError$1,
  ResponseExceededMaxSizeError: ResponseExceededMaxSizeError$1,
  RequestRetryError: RequestRetryError$1,
  ResponseError: ResponseError2,
  SecureProxyConnectionError: SecureProxyConnectionError$1
};
const headerNameLowerCasedRecord$3 = {};
const wellknownHeaderNames$1 = [
  "Accept",
  "Accept-Encoding",
  "Accept-Language",
  "Accept-Ranges",
  "Access-Control-Allow-Credentials",
  "Access-Control-Allow-Headers",
  "Access-Control-Allow-Methods",
  "Access-Control-Allow-Origin",
  "Access-Control-Expose-Headers",
  "Access-Control-Max-Age",
  "Access-Control-Request-Headers",
  "Access-Control-Request-Method",
  "Age",
  "Allow",
  "Alt-Svc",
  "Alt-Used",
  "Authorization",
  "Cache-Control",
  "Clear-Site-Data",
  "Connection",
  "Content-Disposition",
  "Content-Encoding",
  "Content-Language",
  "Content-Length",
  "Content-Location",
  "Content-Range",
  "Content-Security-Policy",
  "Content-Security-Policy-Report-Only",
  "Content-Type",
  "Cookie",
  "Cross-Origin-Embedder-Policy",
  "Cross-Origin-Opener-Policy",
  "Cross-Origin-Resource-Policy",
  "Date",
  "Device-Memory",
  "Downlink",
  "ECT",
  "ETag",
  "Expect",
  "Expect-CT",
  "Expires",
  "Forwarded",
  "From",
  "Host",
  "If-Match",
  "If-Modified-Since",
  "If-None-Match",
  "If-Range",
  "If-Unmodified-Since",
  "Keep-Alive",
  "Last-Modified",
  "Link",
  "Location",
  "Max-Forwards",
  "Origin",
  "Permissions-Policy",
  "Pragma",
  "Proxy-Authenticate",
  "Proxy-Authorization",
  "RTT",
  "Range",
  "Referer",
  "Referrer-Policy",
  "Refresh",
  "Retry-After",
  "Sec-WebSocket-Accept",
  "Sec-WebSocket-Extensions",
  "Sec-WebSocket-Key",
  "Sec-WebSocket-Protocol",
  "Sec-WebSocket-Version",
  "Server",
  "Server-Timing",
  "Service-Worker-Allowed",
  "Service-Worker-Navigation-Preload",
  "Set-Cookie",
  "SourceMap",
  "Strict-Transport-Security",
  "Supports-Loading-Mode",
  "TE",
  "Timing-Allow-Origin",
  "Trailer",
  "Transfer-Encoding",
  "Upgrade",
  "Upgrade-Insecure-Requests",
  "User-Agent",
  "Vary",
  "Via",
  "WWW-Authenticate",
  "X-Content-Type-Options",
  "X-DNS-Prefetch-Control",
  "X-Frame-Options",
  "X-Permitted-Cross-Domain-Policies",
  "X-Powered-By",
  "X-Requested-With",
  "X-XSS-Protection"
];
for (let i = 0; i < wellknownHeaderNames$1.length; ++i) {
  const key = wellknownHeaderNames$1[i];
  const lowerCasedKey = key.toLowerCase();
  headerNameLowerCasedRecord$3[key] = headerNameLowerCasedRecord$3[lowerCasedKey] = lowerCasedKey;
}
Object.setPrototypeOf(headerNameLowerCasedRecord$3, null);
var constants$5 = {
  wellknownHeaderNames: wellknownHeaderNames$1,
  headerNameLowerCasedRecord: headerNameLowerCasedRecord$3
};
const {
  wellknownHeaderNames,
  headerNameLowerCasedRecord: headerNameLowerCasedRecord$2
} = constants$5;
class TstNode2 {
  /**
   * @param {string} key
   * @param {any} value
   * @param {number} index
   */
  constructor(key, value, index) {
    /** @type {any} */
    __publicField(this, "value", null);
    /** @type {null | TstNode} */
    __publicField(this, "left", null);
    /** @type {null | TstNode} */
    __publicField(this, "middle", null);
    /** @type {null | TstNode} */
    __publicField(this, "right", null);
    /** @type {number} */
    __publicField(this, "code");
    if (index === void 0 || index >= key.length) {
      throw new TypeError("Unreachable");
    }
    const code = this.code = key.charCodeAt(index);
    if (code > 127) {
      throw new TypeError("key must be ascii string");
    }
    if (key.length !== ++index) {
      this.middle = new TstNode2(key, value, index);
    } else {
      this.value = value;
    }
  }
  /**
   * @param {string} key
   * @param {any} value
   */
  add(key, value) {
    const length = key.length;
    if (length === 0) {
      throw new TypeError("Unreachable");
    }
    let index = 0;
    let node2 = this;
    while (true) {
      const code = key.charCodeAt(index);
      if (code > 127) {
        throw new TypeError("key must be ascii string");
      }
      if (node2.code === code) {
        if (length === ++index) {
          node2.value = value;
          break;
        } else if (node2.middle !== null) {
          node2 = node2.middle;
        } else {
          node2.middle = new TstNode2(key, value, index);
          break;
        }
      } else if (node2.code < code) {
        if (node2.left !== null) {
          node2 = node2.left;
        } else {
          node2.left = new TstNode2(key, value, index);
          break;
        }
      } else if (node2.right !== null) {
        node2 = node2.right;
      } else {
        node2.right = new TstNode2(key, value, index);
        break;
      }
    }
  }
  /**
   * @param {Uint8Array} key
   * @return {TstNode | null}
   */
  search(key) {
    const keylength = key.length;
    let index = 0;
    let node2 = this;
    while (node2 !== null && index < keylength) {
      let code = key[index];
      if (code <= 90 && code >= 65) {
        code |= 32;
      }
      while (node2 !== null) {
        if (code === node2.code) {
          if (keylength === ++index) {
            return node2;
          }
          node2 = node2.middle;
          break;
        }
        node2 = node2.code < code ? node2.left : node2.right;
      }
    }
    return null;
  }
}
class TernarySearchTree2 {
  constructor() {
    /** @type {TstNode | null} */
    __publicField(this, "node", null);
  }
  /**
   * @param {string} key
   * @param {any} value
   * */
  insert(key, value) {
    if (this.node === null) {
      this.node = new TstNode2(key, value, 0);
    } else {
      this.node.add(key, value);
    }
  }
  /**
   * @param {Uint8Array} key
   * @return {any}
   */
  lookup(key) {
    var _a2, _b2;
    return ((_b2 = (_a2 = this.node) == null ? void 0 : _a2.search(key)) == null ? void 0 : _b2.value) ?? null;
  }
}
const tree$1 = new TernarySearchTree2();
for (let i = 0; i < wellknownHeaderNames.length; ++i) {
  const key = headerNameLowerCasedRecord$2[wellknownHeaderNames[i]];
  tree$1.insert(key, key);
}
var tree_1 = {
  tree: tree$1
};
const assert$e = require$$0$3;
const { kDestroyed: kDestroyed$2, kBodyUsed: kBodyUsed$1, kListeners, kBody: kBody$2 } = symbols$4;
const { IncomingMessage } = require$$2$1;
const stream$1 = require$$0$4;
const net$2 = require$$0$5;
const { Blob: Blob$1 } = require$$0$1;
const nodeUtil = require$$0$2;
const { stringify } = require$$7;
const { EventEmitter: EE$1 } = require$$8$1;
const { InvalidArgumentError: InvalidArgumentError$n } = errors$1;
const { headerNameLowerCasedRecord: headerNameLowerCasedRecord$1 } = constants$5;
const { tree } = tree_1;
const [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));
let BodyAsyncIterable$1 = class BodyAsyncIterable3 {
  constructor(body2) {
    this[kBody$2] = body2;
    this[kBodyUsed$1] = false;
  }
  async *[Symbol.asyncIterator]() {
    assert$e(!this[kBodyUsed$1], "disturbed");
    this[kBodyUsed$1] = true;
    yield* this[kBody$2];
  }
};
function wrapRequestBody$1(body2) {
  if (isStream$1(body2)) {
    if (bodyLength(body2) === 0) {
      body2.on("data", function() {
        assert$e(false);
      });
    }
    if (typeof body2.readableDidRead !== "boolean") {
      body2[kBodyUsed$1] = false;
      EE$1.prototype.on.call(body2, "data", function() {
        this[kBodyUsed$1] = true;
      });
    }
    return body2;
  } else if (body2 && typeof body2.pipeTo === "function") {
    return new BodyAsyncIterable$1(body2);
  } else if (body2 && typeof body2 !== "string" && !ArrayBuffer.isView(body2) && isIterable$2(body2)) {
    return new BodyAsyncIterable$1(body2);
  } else {
    return body2;
  }
}
function nop() {
}
function isStream$1(obj) {
  return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
}
function isBlobLike$1(object) {
  if (object === null) {
    return false;
  } else if (object instanceof Blob$1) {
    return true;
  } else if (typeof object !== "object") {
    return false;
  } else {
    const sTag = object[Symbol.toStringTag];
    return (sTag === "Blob" || sTag === "File") && ("stream" in object && typeof object.stream === "function" || "arrayBuffer" in object && typeof object.arrayBuffer === "function");
  }
}
function buildURL$3(url, queryParams) {
  if (url.includes("?") || url.includes("#")) {
    throw new Error('Query params cannot be passed when url already contains "?" or "#".');
  }
  const stringified = stringify(queryParams);
  if (stringified) {
    url += "?" + stringified;
  }
  return url;
}
function isValidPort(port) {
  const value = parseInt(port, 10);
  return value === Number(port) && value >= 0 && value <= 65535;
}
function isHttpOrHttpsPrefixed(value) {
  return value != null && value[0] === "h" && value[1] === "t" && value[2] === "t" && value[3] === "p" && (value[4] === ":" || value[4] === "s" && value[5] === ":");
}
function parseURL(url) {
  if (typeof url === "string") {
    url = new URL(url);
    if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
      throw new InvalidArgumentError$n("Invalid URL protocol: the URL must start with `http:` or `https:`.");
    }
    return url;
  }
  if (!url || typeof url !== "object") {
    throw new InvalidArgumentError$n("Invalid URL: The URL argument must be a non-null object.");
  }
  if (!(url instanceof URL)) {
    if (url.port != null && url.port !== "" && isValidPort(url.port) === false) {
      throw new InvalidArgumentError$n("Invalid URL: port must be a valid integer or a string representation of an integer.");
    }
    if (url.path != null && typeof url.path !== "string") {
      throw new InvalidArgumentError$n("Invalid URL path: the path must be a string or null/undefined.");
    }
    if (url.pathname != null && typeof url.pathname !== "string") {
      throw new InvalidArgumentError$n("Invalid URL pathname: the pathname must be a string or null/undefined.");
    }
    if (url.hostname != null && typeof url.hostname !== "string") {
      throw new InvalidArgumentError$n("Invalid URL hostname: the hostname must be a string or null/undefined.");
    }
    if (url.origin != null && typeof url.origin !== "string") {
      throw new InvalidArgumentError$n("Invalid URL origin: the origin must be a string or null/undefined.");
    }
    if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
      throw new InvalidArgumentError$n("Invalid URL protocol: the URL must start with `http:` or `https:`.");
    }
    const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
    let origin = url.origin != null ? url.origin : `${url.protocol || ""}//${url.hostname || ""}:${port}`;
    let path2 = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
    if (origin[origin.length - 1] === "/") {
      origin = origin.slice(0, origin.length - 1);
    }
    if (path2 && path2[0] !== "/") {
      path2 = `/${path2}`;
    }
    return new URL(`${origin}${path2}`);
  }
  if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
    throw new InvalidArgumentError$n("Invalid URL protocol: the URL must start with `http:` or `https:`.");
  }
  return url;
}
function parseOrigin$1(url) {
  url = parseURL(url);
  if (url.pathname !== "/" || url.search || url.hash) {
    throw new InvalidArgumentError$n("invalid url");
  }
  return url;
}
function getHostname(host) {
  if (host[0] === "[") {
    const idx2 = host.indexOf("]");
    assert$e(idx2 !== -1);
    return host.substring(1, idx2);
  }
  const idx = host.indexOf(":");
  if (idx === -1) return host;
  return host.substring(0, idx);
}
function getServerName$1(host) {
  if (!host) {
    return null;
  }
  assert$e(typeof host === "string");
  const servername = getHostname(host);
  if (net$2.isIP(servername)) {
    return "";
  }
  return servername;
}
function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}
function isAsyncIterable(obj) {
  return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
}
function isIterable$2(obj) {
  return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
}
function bodyLength(body2) {
  if (body2 == null) {
    return 0;
  } else if (isStream$1(body2)) {
    const state = body2._readableState;
    return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
  } else if (isBlobLike$1(body2)) {
    return body2.size != null ? body2.size : null;
  } else if (isBuffer$1(body2)) {
    return body2.byteLength;
  }
  return null;
}
function isDestroyed(body2) {
  var _a2;
  return body2 && !!(body2.destroyed || body2[kDestroyed$2] || ((_a2 = stream$1.isDestroyed) == null ? void 0 : _a2.call(stream$1, body2)));
}
function destroy$1(stream2, err) {
  if (stream2 == null || !isStream$1(stream2) || isDestroyed(stream2)) {
    return;
  }
  if (typeof stream2.destroy === "function") {
    if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
      stream2.socket = null;
    }
    stream2.destroy(err);
  } else if (err) {
    queueMicrotask(() => {
      stream2.emit("error", err);
    });
  }
  if (stream2.destroyed !== true) {
    stream2[kDestroyed$2] = true;
  }
}
const KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
function parseKeepAliveTimeout(val) {
  const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
  return m ? parseInt(m[1], 10) * 1e3 : null;
}
function headerNameToString(value) {
  return typeof value === "string" ? headerNameLowerCasedRecord$1[value] ?? value.toLowerCase() : tree.lookup(value) ?? value.toString("latin1").toLowerCase();
}
function bufferToLowerCasedHeaderName(value) {
  return tree.lookup(value) ?? value.toString("latin1").toLowerCase();
}
function parseHeaders$1(headers2, obj) {
  if (obj === void 0) obj = {};
  for (let i = 0; i < headers2.length; i += 2) {
    const key = headerNameToString(headers2[i]);
    let val = obj[key];
    if (val) {
      if (typeof val === "string") {
        val = [val];
        obj[key] = val;
      }
      val.push(headers2[i + 1].toString("utf8"));
    } else {
      const headersValue = headers2[i + 1];
      if (typeof headersValue === "string") {
        obj[key] = headersValue;
      } else {
        obj[key] = Array.isArray(headersValue) ? headersValue.map((x) => x.toString("utf8")) : headersValue.toString("utf8");
      }
    }
  }
  if ("content-length" in obj && "content-disposition" in obj) {
    obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
  }
  return obj;
}
function parseRawHeaders(headers2) {
  const len = headers2.length;
  const ret = new Array(len);
  let hasContentLength = false;
  let contentDispositionIdx = -1;
  let key;
  let val;
  let kLen = 0;
  for (let n = 0; n < headers2.length; n += 2) {
    key = headers2[n];
    val = headers2[n + 1];
    typeof key !== "string" && (key = key.toString());
    typeof val !== "string" && (val = val.toString("utf8"));
    kLen = key.length;
    if (kLen === 14 && key[7] === "-" && (key === "content-length" || key.toLowerCase() === "content-length")) {
      hasContentLength = true;
    } else if (kLen === 19 && key[7] === "-" && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
      contentDispositionIdx = n + 1;
    }
    ret[n] = key;
    ret[n + 1] = val;
  }
  if (hasContentLength && contentDispositionIdx !== -1) {
    ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
  }
  return ret;
}
function isBuffer$1(buffer) {
  return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
}
function validateHandler$1(handler, method, upgrade2) {
  if (!handler || typeof handler !== "object") {
    throw new InvalidArgumentError$n("handler must be an object");
  }
  if (typeof handler.onConnect !== "function") {
    throw new InvalidArgumentError$n("invalid onConnect method");
  }
  if (typeof handler.onError !== "function") {
    throw new InvalidArgumentError$n("invalid onError method");
  }
  if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) {
    throw new InvalidArgumentError$n("invalid onBodySent method");
  }
  if (upgrade2 || method === "CONNECT") {
    if (typeof handler.onUpgrade !== "function") {
      throw new InvalidArgumentError$n("invalid onUpgrade method");
    }
  } else {
    if (typeof handler.onHeaders !== "function") {
      throw new InvalidArgumentError$n("invalid onHeaders method");
    }
    if (typeof handler.onData !== "function") {
      throw new InvalidArgumentError$n("invalid onData method");
    }
    if (typeof handler.onComplete !== "function") {
      throw new InvalidArgumentError$n("invalid onComplete method");
    }
  }
}
function isDisturbed$1(body2) {
  return !!(body2 && (stream$1.isDisturbed(body2) || body2[kBodyUsed$1]));
}
function isErrored(body2) {
  return !!(body2 && stream$1.isErrored(body2));
}
function isReadable(body2) {
  return !!(body2 && stream$1.isReadable(body2));
}
function getSocketInfo(socket) {
  return {
    localAddress: socket.localAddress,
    localPort: socket.localPort,
    remoteAddress: socket.remoteAddress,
    remotePort: socket.remotePort,
    remoteFamily: socket.remoteFamily,
    timeout: socket.timeout,
    bytesWritten: socket.bytesWritten,
    bytesRead: socket.bytesRead
  };
}
function ReadableStreamFrom$1(iterable) {
  let iterator;
  return new ReadableStream(
    {
      async start() {
        iterator = iterable[Symbol.asyncIterator]();
      },
      async pull(controller) {
        const { done, value } = await iterator.next();
        if (done) {
          queueMicrotask(() => {
            var _a2;
            controller.close();
            (_a2 = controller.byobRequest) == null ? void 0 : _a2.respond(0);
          });
        } else {
          const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
          if (buf.byteLength) {
            controller.enqueue(new Uint8Array(buf));
          }
        }
        return controller.desiredSize > 0;
      },
      async cancel(reason) {
        await iterator.return();
      },
      type: "bytes"
    }
  );
}
function isFormDataLike$1(object) {
  return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
}
function addAbortListener$1(signal, listener) {
  if ("addEventListener" in signal) {
    signal.addEventListener("abort", listener, { once: true });
    return () => signal.removeEventListener("abort", listener);
  }
  signal.addListener("abort", listener);
  return () => signal.removeListener("abort", listener);
}
const hasToWellFormed = typeof String.prototype.toWellFormed === "function";
const hasIsWellFormed = typeof String.prototype.isWellFormed === "function";
function toUSVString(val) {
  return hasToWellFormed ? `${val}`.toWellFormed() : nodeUtil.toUSVString(val);
}
function isUSVString(val) {
  return hasIsWellFormed ? `${val}`.isWellFormed() : toUSVString(val) === `${val}`;
}
function isTokenCharCode(c) {
  switch (c) {
    case 34:
    case 40:
    case 41:
    case 44:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 123:
    case 125:
      return false;
    default:
      return c >= 33 && c <= 126;
  }
}
function isValidHTTPToken$1(characters) {
  if (characters.length === 0) {
    return false;
  }
  for (let i = 0; i < characters.length; ++i) {
    if (!isTokenCharCode(characters.charCodeAt(i))) {
      return false;
    }
  }
  return true;
}
const headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
function isValidHeaderValue$1(characters) {
  return !headerCharRegex.test(characters);
}
function parseRangeHeader$1(range) {
  if (range == null || range === "") return { start: 0, end: null, size: null };
  const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
  return m ? {
    start: parseInt(m[1]),
    end: m[2] ? parseInt(m[2]) : null,
    size: m[3] ? parseInt(m[3]) : null
  } : null;
}
function addListener$1(obj, name, listener) {
  const listeners = obj[kListeners] ?? (obj[kListeners] = []);
  listeners.push([name, listener]);
  obj.on(name, listener);
  return obj;
}
function removeAllListeners$1(obj) {
  for (const [name, listener] of obj[kListeners] ?? []) {
    obj.removeListener(name, listener);
  }
  obj[kListeners] = null;
}
function errorRequest(client2, request2, err) {
  try {
    request2.onError(err);
    assert$e(request2.aborted);
  } catch (err2) {
    client2.emit("error", err2);
  }
}
const kEnumerableProperty = /* @__PURE__ */ Object.create(null);
kEnumerableProperty.enumerable = true;
const normalizedMethodRecordsBase = {
  delete: "DELETE",
  DELETE: "DELETE",
  get: "GET",
  GET: "GET",
  head: "HEAD",
  HEAD: "HEAD",
  options: "OPTIONS",
  OPTIONS: "OPTIONS",
  post: "POST",
  POST: "POST",
  put: "PUT",
  PUT: "PUT"
};
const normalizedMethodRecords$1 = {
  ...normalizedMethodRecordsBase,
  patch: "patch",
  PATCH: "PATCH"
};
Object.setPrototypeOf(normalizedMethodRecordsBase, null);
Object.setPrototypeOf(normalizedMethodRecords$1, null);
var util$n = {
  kEnumerableProperty,
  nop,
  isDisturbed: isDisturbed$1,
  isErrored,
  isReadable,
  toUSVString,
  isUSVString,
  isBlobLike: isBlobLike$1,
  parseOrigin: parseOrigin$1,
  parseURL,
  getServerName: getServerName$1,
  isStream: isStream$1,
  isIterable: isIterable$2,
  isAsyncIterable,
  isDestroyed,
  headerNameToString,
  bufferToLowerCasedHeaderName,
  addListener: addListener$1,
  removeAllListeners: removeAllListeners$1,
  errorRequest,
  parseRawHeaders,
  parseHeaders: parseHeaders$1,
  parseKeepAliveTimeout,
  destroy: destroy$1,
  bodyLength,
  deepClone,
  ReadableStreamFrom: ReadableStreamFrom$1,
  isBuffer: isBuffer$1,
  validateHandler: validateHandler$1,
  getSocketInfo,
  isFormDataLike: isFormDataLike$1,
  buildURL: buildURL$3,
  addAbortListener: addAbortListener$1,
  isValidHTTPToken: isValidHTTPToken$1,
  isValidHeaderValue: isValidHeaderValue$1,
  isTokenCharCode,
  parseRangeHeader: parseRangeHeader$1,
  normalizedMethodRecordsBase,
  normalizedMethodRecords: normalizedMethodRecords$1,
  isValidPort,
  isHttpOrHttpsPrefixed,
  nodeMajor,
  nodeMinor,
  safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"],
  wrapRequestBody: wrapRequestBody$1
};
const diagnosticsChannel = require$$0$6;
const util$m = require$$0$2;
const undiciDebugLog = util$m.debuglog("undici");
const fetchDebuglog = util$m.debuglog("fetch");
const websocketDebuglog = util$m.debuglog("websocket");
let isClientSet = false;
const channels$3 = {
  // Client
  beforeConnect: diagnosticsChannel.channel("undici:client:beforeConnect"),
  connected: diagnosticsChannel.channel("undici:client:connected"),
  connectError: diagnosticsChannel.channel("undici:client:connectError"),
  sendHeaders: diagnosticsChannel.channel("undici:client:sendHeaders"),
  // Request
  create: diagnosticsChannel.channel("undici:request:create"),
  bodySent: diagnosticsChannel.channel("undici:request:bodySent"),
  headers: diagnosticsChannel.channel("undici:request:headers"),
  trailers: diagnosticsChannel.channel("undici:request:trailers"),
  error: diagnosticsChannel.channel("undici:request:error"),
  // WebSocket
  open: diagnosticsChannel.channel("undici:websocket:open"),
  close: diagnosticsChannel.channel("undici:websocket:close"),
  socketError: diagnosticsChannel.channel("undici:websocket:socket_error"),
  ping: diagnosticsChannel.channel("undici:websocket:ping"),
  pong: diagnosticsChannel.channel("undici:websocket:pong")
};
if (undiciDebugLog.enabled || fetchDebuglog.enabled) {
  const debuglog = fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog;
  diagnosticsChannel.channel("undici:client:beforeConnect").subscribe((evt) => {
    const {
      connectParams: { version: version2, protocol, port, host }
    } = evt;
    debuglog(
      "connecting to %s using %s%s",
      `${host}${port ? `:${port}` : ""}`,
      protocol,
      version2
    );
  });
  diagnosticsChannel.channel("undici:client:connected").subscribe((evt) => {
    const {
      connectParams: { version: version2, protocol, port, host }
    } = evt;
    debuglog(
      "connected to %s using %s%s",
      `${host}${port ? `:${port}` : ""}`,
      protocol,
      version2
    );
  });
  diagnosticsChannel.channel("undici:client:connectError").subscribe((evt) => {
    const {
      connectParams: { version: version2, protocol, port, host },
      error
    } = evt;
    debuglog(
      "connection to %s using %s%s errored - %s",
      `${host}${port ? `:${port}` : ""}`,
      protocol,
      version2,
      error.message
    );
  });
  diagnosticsChannel.channel("undici:client:sendHeaders").subscribe((evt) => {
    const {
      request: { method, path: path2, origin }
    } = evt;
    debuglog("sending request to %s %s/%s", method, origin, path2);
  });
  diagnosticsChannel.channel("undici:request:headers").subscribe((evt) => {
    const {
      request: { method, path: path2, origin },
      response: { statusCode }
    } = evt;
    debuglog(
      "received response to %s %s/%s - HTTP %d",
      method,
      origin,
      path2,
      statusCode
    );
  });
  diagnosticsChannel.channel("undici:request:trailers").subscribe((evt) => {
    const {
      request: { method, path: path2, origin }
    } = evt;
    debuglog("trailers received from %s %s/%s", method, origin, path2);
  });
  diagnosticsChannel.channel("undici:request:error").subscribe((evt) => {
    const {
      request: { method, path: path2, origin },
      error
    } = evt;
    debuglog(
      "request to %s %s/%s errored - %s",
      method,
      origin,
      path2,
      error.message
    );
  });
  isClientSet = true;
}
if (websocketDebuglog.enabled) {
  if (!isClientSet) {
    const debuglog = undiciDebugLog.enabled ? undiciDebugLog : websocketDebuglog;
    diagnosticsChannel.channel("undici:client:beforeConnect").subscribe((evt) => {
      const {
        connectParams: { version: version2, protocol, port, host }
      } = evt;
      debuglog(
        "connecting to %s%s using %s%s",
        host,
        port ? `:${port}` : "",
        protocol,
        version2
      );
    });
    diagnosticsChannel.channel("undici:client:connected").subscribe((evt) => {
      const {
        connectParams: { version: version2, protocol, port, host }
      } = evt;
      debuglog(
        "connected to %s%s using %s%s",
        host,
        port ? `:${port}` : "",
        protocol,
        version2
      );
    });
    diagnosticsChannel.channel("undici:client:connectError").subscribe((evt) => {
      const {
        connectParams: { version: version2, protocol, port, host },
        error
      } = evt;
      debuglog(
        "connection to %s%s using %s%s errored - %s",
        host,
        port ? `:${port}` : "",
        protocol,
        version2,
        error.message
      );
    });
    diagnosticsChannel.channel("undici:client:sendHeaders").subscribe((evt) => {
      const {
        request: { method, path: path2, origin }
      } = evt;
      debuglog("sending request to %s %s/%s", method, origin, path2);
    });
  }
  diagnosticsChannel.channel("undici:websocket:open").subscribe((evt) => {
    const {
      address: { address, port }
    } = evt;
    websocketDebuglog("connection opened %s%s", address, port ? `:${port}` : "");
  });
  diagnosticsChannel.channel("undici:websocket:close").subscribe((evt) => {
    const { websocket: websocket2, code, reason } = evt;
    websocketDebuglog(
      "closed connection to %s - %s %s",
      websocket2.url,
      code,
      reason
    );
  });
  diagnosticsChannel.channel("undici:websocket:socket_error").subscribe((err) => {
    websocketDebuglog("connection errored - %s", err.message);
  });
  diagnosticsChannel.channel("undici:websocket:ping").subscribe((evt) => {
    websocketDebuglog("ping received");
  });
  diagnosticsChannel.channel("undici:websocket:pong").subscribe((evt) => {
    websocketDebuglog("pong received");
  });
}
var diagnostics = {
  channels: channels$3
};
const {
  InvalidArgumentError: InvalidArgumentError$m,
  NotSupportedError: NotSupportedError$1
} = errors$1;
const assert$d = require$$0$3;
const {
  isValidHTTPToken,
  isValidHeaderValue,
  isStream,
  destroy,
  isBuffer,
  isFormDataLike,
  isIterable: isIterable$1,
  isBlobLike,
  buildURL: buildURL$2,
  validateHandler,
  getServerName,
  normalizedMethodRecords
} = util$n;
const { channels: channels$2 } = diagnostics;
const { headerNameLowerCasedRecord } = constants$5;
const invalidPathRegex = /[^\u0021-\u00ff]/;
const kHandler = Symbol("handler");
let Request$1 = class Request2 {
  constructor(origin, {
    path: path2,
    method,
    body: body2,
    headers: headers2,
    query,
    idempotent,
    blocking,
    upgrade: upgrade2,
    headersTimeout,
    bodyTimeout,
    reset,
    throwOnError,
    expectContinue,
    servername
  }, handler) {
    if (typeof path2 !== "string") {
      throw new InvalidArgumentError$m("path must be a string");
    } else if (path2[0] !== "/" && !(path2.startsWith("http://") || path2.startsWith("https://")) && method !== "CONNECT") {
      throw new InvalidArgumentError$m("path must be an absolute URL or start with a slash");
    } else if (invalidPathRegex.test(path2)) {
      throw new InvalidArgumentError$m("invalid request path");
    }
    if (typeof method !== "string") {
      throw new InvalidArgumentError$m("method must be a string");
    } else if (normalizedMethodRecords[method] === void 0 && !isValidHTTPToken(method)) {
      throw new InvalidArgumentError$m("invalid request method");
    }
    if (upgrade2 && typeof upgrade2 !== "string") {
      throw new InvalidArgumentError$m("upgrade must be a string");
    }
    if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
      throw new InvalidArgumentError$m("invalid headersTimeout");
    }
    if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
      throw new InvalidArgumentError$m("invalid bodyTimeout");
    }
    if (reset != null && typeof reset !== "boolean") {
      throw new InvalidArgumentError$m("invalid reset");
    }
    if (expectContinue != null && typeof expectContinue !== "boolean") {
      throw new InvalidArgumentError$m("invalid expectContinue");
    }
    this.headersTimeout = headersTimeout;
    this.bodyTimeout = bodyTimeout;
    this.throwOnError = throwOnError === true;
    this.method = method;
    this.abort = null;
    if (body2 == null) {
      this.body = null;
    } else if (isStream(body2)) {
      this.body = body2;
      const rState = this.body._readableState;
      if (!rState || !rState.autoDestroy) {
        this.endHandler = function autoDestroy() {
          destroy(this);
        };
        this.body.on("end", this.endHandler);
      }
      this.errorHandler = (err) => {
        if (this.abort) {
          this.abort(err);
        } else {
          this.error = err;
        }
      };
      this.body.on("error", this.errorHandler);
    } else if (isBuffer(body2)) {
      this.body = body2.byteLength ? body2 : null;
    } else if (ArrayBuffer.isView(body2)) {
      this.body = body2.buffer.byteLength ? Buffer.from(body2.buffer, body2.byteOffset, body2.byteLength) : null;
    } else if (body2 instanceof ArrayBuffer) {
      this.body = body2.byteLength ? Buffer.from(body2) : null;
    } else if (typeof body2 === "string") {
      this.body = body2.length ? Buffer.from(body2) : null;
    } else if (isFormDataLike(body2) || isIterable$1(body2) || isBlobLike(body2)) {
      this.body = body2;
    } else {
      throw new InvalidArgumentError$m("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
    }
    this.completed = false;
    this.aborted = false;
    this.upgrade = upgrade2 || null;
    this.path = query ? buildURL$2(path2, query) : path2;
    this.origin = origin;
    this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
    this.blocking = blocking == null ? false : blocking;
    this.reset = reset == null ? null : reset;
    this.host = null;
    this.contentLength = null;
    this.contentType = null;
    this.headers = [];
    this.expectContinue = expectContinue != null ? expectContinue : false;
    if (Array.isArray(headers2)) {
      if (headers2.length % 2 !== 0) {
        throw new InvalidArgumentError$m("headers array must be even");
      }
      for (let i = 0; i < headers2.length; i += 2) {
        processHeader(this, headers2[i], headers2[i + 1]);
      }
    } else if (headers2 && typeof headers2 === "object") {
      if (headers2[Symbol.iterator]) {
        for (const header of headers2) {
          if (!Array.isArray(header) || header.length !== 2) {
            throw new InvalidArgumentError$m("headers must be in key-value pair format");
          }
          processHeader(this, header[0], header[1]);
        }
      } else {
        const keys = Object.keys(headers2);
        for (let i = 0; i < keys.length; ++i) {
          processHeader(this, keys[i], headers2[keys[i]]);
        }
      }
    } else if (headers2 != null) {
      throw new InvalidArgumentError$m("headers must be an object or an array");
    }
    validateHandler(handler, method, upgrade2);
    this.servername = servername || getServerName(this.host);
    this[kHandler] = handler;
    if (channels$2.create.hasSubscribers) {
      channels$2.create.publish({ request: this });
    }
  }
  onBodySent(chunk) {
    if (this[kHandler].onBodySent) {
      try {
        return this[kHandler].onBodySent(chunk);
      } catch (err) {
        this.abort(err);
      }
    }
  }
  onRequestSent() {
    if (channels$2.bodySent.hasSubscribers) {
      channels$2.bodySent.publish({ request: this });
    }
    if (this[kHandler].onRequestSent) {
      try {
        return this[kHandler].onRequestSent();
      } catch (err) {
        this.abort(err);
      }
    }
  }
  onConnect(abort2) {
    assert$d(!this.aborted);
    assert$d(!this.completed);
    if (this.error) {
      abort2(this.error);
    } else {
      this.abort = abort2;
      return this[kHandler].onConnect(abort2);
    }
  }
  onResponseStarted() {
    var _a2, _b2;
    return (_b2 = (_a2 = this[kHandler]).onResponseStarted) == null ? void 0 : _b2.call(_a2);
  }
  onHeaders(statusCode, headers2, resume2, statusText) {
    assert$d(!this.aborted);
    assert$d(!this.completed);
    if (channels$2.headers.hasSubscribers) {
      channels$2.headers.publish({ request: this, response: { statusCode, headers: headers2, statusText } });
    }
    try {
      return this[kHandler].onHeaders(statusCode, headers2, resume2, statusText);
    } catch (err) {
      this.abort(err);
    }
  }
  onData(chunk) {
    assert$d(!this.aborted);
    assert$d(!this.completed);
    try {
      return this[kHandler].onData(chunk);
    } catch (err) {
      this.abort(err);
      return false;
    }
  }
  onUpgrade(statusCode, headers2, socket) {
    assert$d(!this.aborted);
    assert$d(!this.completed);
    return this[kHandler].onUpgrade(statusCode, headers2, socket);
  }
  onComplete(trailers) {
    this.onFinally();
    assert$d(!this.aborted);
    this.completed = true;
    if (channels$2.trailers.hasSubscribers) {
      channels$2.trailers.publish({ request: this, trailers });
    }
    try {
      return this[kHandler].onComplete(trailers);
    } catch (err) {
      this.onError(err);
    }
  }
  onError(error) {
    this.onFinally();
    if (channels$2.error.hasSubscribers) {
      channels$2.error.publish({ request: this, error });
    }
    if (this.aborted) {
      return;
    }
    this.aborted = true;
    return this[kHandler].onError(error);
  }
  onFinally() {
    if (this.errorHandler) {
      this.body.off("error", this.errorHandler);
      this.errorHandler = null;
    }
    if (this.endHandler) {
      this.body.off("end", this.endHandler);
      this.endHandler = null;
    }
  }
  addHeader(key, value) {
    processHeader(this, key, value);
    return this;
  }
};
function processHeader(request2, key, val) {
  if (val && (typeof val === "object" && !Array.isArray(val))) {
    throw new InvalidArgumentError$m(`invalid ${key} header`);
  } else if (val === void 0) {
    return;
  }
  let headerName = headerNameLowerCasedRecord[key];
  if (headerName === void 0) {
    headerName = key.toLowerCase();
    if (headerNameLowerCasedRecord[headerName] === void 0 && !isValidHTTPToken(headerName)) {
      throw new InvalidArgumentError$m("invalid header key");
    }
  }
  if (Array.isArray(val)) {
    const arr = [];
    for (let i = 0; i < val.length; i++) {
      if (typeof val[i] === "string") {
        if (!isValidHeaderValue(val[i])) {
          throw new InvalidArgumentError$m(`invalid ${key} header`);
        }
        arr.push(val[i]);
      } else if (val[i] === null) {
        arr.push("");
      } else if (typeof val[i] === "object") {
        throw new InvalidArgumentError$m(`invalid ${key} header`);
      } else {
        arr.push(`${val[i]}`);
      }
    }
    val = arr;
  } else if (typeof val === "string") {
    if (!isValidHeaderValue(val)) {
      throw new InvalidArgumentError$m(`invalid ${key} header`);
    }
  } else if (val === null) {
    val = "";
  } else {
    val = `${val}`;
  }
  if (request2.host === null && headerName === "host") {
    if (typeof val !== "string") {
      throw new InvalidArgumentError$m("invalid host header");
    }
    request2.host = val;
  } else if (request2.contentLength === null && headerName === "content-length") {
    request2.contentLength = parseInt(val, 10);
    if (!Number.isFinite(request2.contentLength)) {
      throw new InvalidArgumentError$m("invalid content-length header");
    }
  } else if (request2.contentType === null && headerName === "content-type") {
    request2.contentType = val;
    request2.headers.push(key, val);
  } else if (headerName === "transfer-encoding" || headerName === "keep-alive" || headerName === "upgrade") {
    throw new InvalidArgumentError$m(`invalid ${headerName} header`);
  } else if (headerName === "connection") {
    const value = typeof val === "string" ? val.toLowerCase() : null;
    if (value !== "close" && value !== "keep-alive") {
      throw new InvalidArgumentError$m("invalid connection header");
    }
    if (value === "close") {
      request2.reset = true;
    }
  } else if (headerName === "expect") {
    throw new NotSupportedError$1("expect header not supported");
  } else {
    request2.headers.push(key, val);
  }
}
var request$2 = Request$1;
const EventEmitter = require$$8$1;
let Dispatcher$4 = class Dispatcher2 extends EventEmitter {
  dispatch() {
    throw new Error("not implemented");
  }
  close() {
    throw new Error("not implemented");
  }
  destroy() {
    throw new Error("not implemented");
  }
  compose(...args) {
    const interceptors = Array.isArray(args[0]) ? args[0] : args;
    let dispatch = this.dispatch.bind(this);
    for (const interceptor of interceptors) {
      if (interceptor == null) {
        continue;
      }
      if (typeof interceptor !== "function") {
        throw new TypeError(`invalid interceptor, expected function received ${typeof interceptor}`);
      }
      dispatch = interceptor(dispatch);
      if (dispatch == null || typeof dispatch !== "function" || dispatch.length !== 2) {
        throw new TypeError("invalid interceptor");
      }
    }
    return new ComposedDispatcher(this, dispatch);
  }
};
class ComposedDispatcher extends Dispatcher$4 {
  constructor(dispatcher2, dispatch) {
    super();
    __privateAdd(this, _dispatcher, null);
    __privateAdd(this, _dispatch2, null);
    __privateSet(this, _dispatcher, dispatcher2);
    __privateSet(this, _dispatch2, dispatch);
  }
  dispatch(...args) {
    __privateGet(this, _dispatch2).call(this, ...args);
  }
  close(...args) {
    return __privateGet(this, _dispatcher).close(...args);
  }
  destroy(...args) {
    return __privateGet(this, _dispatcher).destroy(...args);
  }
}
_dispatcher = new WeakMap();
_dispatch2 = new WeakMap();
var dispatcher = Dispatcher$4;
const Dispatcher$3 = dispatcher;
const {
  ClientDestroyedError: ClientDestroyedError$1,
  ClientClosedError: ClientClosedError3,
  InvalidArgumentError: InvalidArgumentError$l
} = errors$1;
const { kDestroy: kDestroy$5, kClose: kClose$7, kClosed: kClosed$1, kDestroyed: kDestroyed$1, kDispatch: kDispatch$4, kInterceptors: kInterceptors$5 } = symbols$4;
const kOnDestroyed = Symbol("onDestroyed");
const kOnClosed = Symbol("onClosed");
const kInterceptedDispatch = Symbol("Intercepted Dispatch");
let DispatcherBase$5 = class DispatcherBase2 extends Dispatcher$3 {
  constructor() {
    super();
    this[kDestroyed$1] = false;
    this[kOnDestroyed] = null;
    this[kClosed$1] = false;
    this[kOnClosed] = [];
  }
  get destroyed() {
    return this[kDestroyed$1];
  }
  get closed() {
    return this[kClosed$1];
  }
  get interceptors() {
    return this[kInterceptors$5];
  }
  set interceptors(newInterceptors) {
    if (newInterceptors) {
      for (let i = newInterceptors.length - 1; i >= 0; i--) {
        const interceptor = this[kInterceptors$5][i];
        if (typeof interceptor !== "function") {
          throw new InvalidArgumentError$l("interceptor must be an function");
        }
      }
    }
    this[kInterceptors$5] = newInterceptors;
  }
  close(callback) {
    if (callback === void 0) {
      return new Promise((resolve2, reject) => {
        this.close((err, data) => {
          return err ? reject(err) : resolve2(data);
        });
      });
    }
    if (typeof callback !== "function") {
      throw new InvalidArgumentError$l("invalid callback");
    }
    if (this[kDestroyed$1]) {
      queueMicrotask(() => callback(new ClientDestroyedError$1(), null));
      return;
    }
    if (this[kClosed$1]) {
      if (this[kOnClosed]) {
        this[kOnClosed].push(callback);
      } else {
        queueMicrotask(() => callback(null, null));
      }
      return;
    }
    this[kClosed$1] = true;
    this[kOnClosed].push(callback);
    const onClosed = () => {
      const callbacks = this[kOnClosed];
      this[kOnClosed] = null;
      for (let i = 0; i < callbacks.length; i++) {
        callbacks[i](null, null);
      }
    };
    this[kClose$7]().then(() => this.destroy()).then(() => {
      queueMicrotask(onClosed);
    });
  }
  destroy(err, callback) {
    if (typeof err === "function") {
      callback = err;
      err = null;
    }
    if (callback === void 0) {
      return new Promise((resolve2, reject) => {
        this.destroy(err, (err2, data) => {
          return err2 ? (
            /* istanbul ignore next: should never error */
            reject(err2)
          ) : resolve2(data);
        });
      });
    }
    if (typeof callback !== "function") {
      throw new InvalidArgumentError$l("invalid callback");
    }
    if (this[kDestroyed$1]) {
      if (this[kOnDestroyed]) {
        this[kOnDestroyed].push(callback);
      } else {
        queueMicrotask(() => callback(null, null));
      }
      return;
    }
    if (!err) {
      err = new ClientDestroyedError$1();
    }
    this[kDestroyed$1] = true;
    this[kOnDestroyed] = this[kOnDestroyed] || [];
    this[kOnDestroyed].push(callback);
    const onDestroyed = () => {
      const callbacks = this[kOnDestroyed];
      this[kOnDestroyed] = null;
      for (let i = 0; i < callbacks.length; i++) {
        callbacks[i](null, null);
      }
    };
    this[kDestroy$5](err).then(() => {
      queueMicrotask(onDestroyed);
    });
  }
  [kInterceptedDispatch](opts, handler) {
    if (!this[kInterceptors$5] || this[kInterceptors$5].length === 0) {
      this[kInterceptedDispatch] = this[kDispatch$4];
      return this[kDispatch$4](opts, handler);
    }
    let dispatch = this[kDispatch$4].bind(this);
    for (let i = this[kInterceptors$5].length - 1; i >= 0; i--) {
      dispatch = this[kInterceptors$5][i](dispatch);
    }
    this[kInterceptedDispatch] = dispatch;
    return dispatch(opts, handler);
  }
  dispatch(opts, handler) {
    if (!handler || typeof handler !== "object") {
      throw new InvalidArgumentError$l("handler must be an object");
    }
    try {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError$l("opts must be an object.");
      }
      if (this[kDestroyed$1] || this[kOnDestroyed]) {
        throw new ClientDestroyedError$1();
      }
      if (this[kClosed$1]) {
        throw new ClientClosedError3();
      }
      return this[kInterceptedDispatch](opts, handler);
    } catch (err) {
      if (typeof handler.onError !== "function") {
        throw new InvalidArgumentError$l("invalid onError method");
      }
      handler.onError(err);
      return false;
    }
  }
};
var dispatcherBase = DispatcherBase$5;
let fastNow = 0;
const RESOLUTION_MS = 1e3;
const TICK_MS = (RESOLUTION_MS >> 1) - 1;
let fastNowTimeout;
const kFastTimer = Symbol("kFastTimer");
const fastTimers = [];
const NOT_IN_LIST = -2;
const TO_BE_CLEARED = -1;
const PENDING = 0;
const ACTIVE = 1;
function onTick() {
  fastNow += TICK_MS;
  let idx = 0;
  let len = fastTimers.length;
  while (idx < len) {
    const timer = fastTimers[idx];
    if (timer._state === PENDING) {
      timer._idleStart = fastNow - TICK_MS;
      timer._state = ACTIVE;
    } else if (timer._state === ACTIVE && fastNow >= timer._idleStart + timer._idleTimeout) {
      timer._state = TO_BE_CLEARED;
      timer._idleStart = -1;
      timer._onTimeout(timer._timerArg);
    }
    if (timer._state === TO_BE_CLEARED) {
      timer._state = NOT_IN_LIST;
      if (--len !== 0) {
        fastTimers[idx] = fastTimers[len];
      }
    } else {
      ++idx;
    }
  }
  fastTimers.length = len;
  if (fastTimers.length !== 0) {
    refreshTimeout();
  }
}
function refreshTimeout() {
  if (fastNowTimeout) {
    fastNowTimeout.refresh();
  } else {
    clearTimeout(fastNowTimeout);
    fastNowTimeout = setTimeout(onTick, TICK_MS);
    if (fastNowTimeout.unref) {
      fastNowTimeout.unref();
    }
  }
}
_p = kFastTimer;
class FastTimer2 {
  /**
   * @constructor
   * @param {Function} callback A function to be executed after the timer
   * expires.
   * @param {number} delay The time, in milliseconds that the timer should wait
   * before the specified function or code is executed.
   * @param {*} arg
   */
  constructor(callback, delay, arg) {
    __publicField(this, _p, true);
    /**
     * The state of the timer, which can be one of the following:
     * - NOT_IN_LIST (-2)
     * - TO_BE_CLEARED (-1)
     * - PENDING (0)
     * - ACTIVE (1)
     *
     * @type {-2|-1|0|1}
     * @private
     */
    __publicField(this, "_state", NOT_IN_LIST);
    /**
     * The number of milliseconds to wait before calling the callback.
     *
     * @type {number}
     * @private
     */
    __publicField(this, "_idleTimeout", -1);
    /**
     * The time in milliseconds when the timer was started. This value is used to
     * calculate when the timer should expire.
     *
     * @type {number}
     * @default -1
     * @private
     */
    __publicField(this, "_idleStart", -1);
    /**
     * The function to be executed when the timer expires.
     * @type {Function}
     * @private
     */
    __publicField(this, "_onTimeout");
    /**
     * The argument to be passed to the callback when the timer expires.
     *
     * @type {*}
     * @private
     */
    __publicField(this, "_timerArg");
    this._onTimeout = callback;
    this._idleTimeout = delay;
    this._timerArg = arg;
    this.refresh();
  }
  /**
   * Sets the timer's start time to the current time, and reschedules the timer
   * to call its callback at the previously specified duration adjusted to the
   * current time.
   * Using this on a timer that has already called its callback will reactivate
   * the timer.
   *
   * @returns {void}
   */
  refresh() {
    if (this._state === NOT_IN_LIST) {
      fastTimers.push(this);
    }
    if (!fastNowTimeout || fastTimers.length === 1) {
      refreshTimeout();
    }
    this._state = PENDING;
  }
  /**
   * The `clear` method cancels the timer, preventing it from executing.
   *
   * @returns {void}
   * @private
   */
  clear() {
    this._state = TO_BE_CLEARED;
    this._idleStart = -1;
  }
}
var timers$2 = {
  /**
   * The setTimeout() method sets a timer which executes a function once the
   * timer expires.
   * @param {Function} callback A function to be executed after the timer
   * expires.
   * @param {number} delay The time, in milliseconds that the timer should
   * wait before the specified function or code is executed.
   * @param {*} [arg] An optional argument to be passed to the callback function
   * when the timer expires.
   * @returns {NodeJS.Timeout|FastTimer}
   */
  setTimeout(callback, delay, arg) {
    return delay <= RESOLUTION_MS ? setTimeout(callback, delay, arg) : new FastTimer2(callback, delay, arg);
  },
  /**
   * The clearTimeout method cancels an instantiated Timer previously created
   * by calling setTimeout.
   *
   * @param {NodeJS.Timeout|FastTimer} timeout
   */
  clearTimeout(timeout) {
    if (timeout[kFastTimer]) {
      timeout.clear();
    } else {
      clearTimeout(timeout);
    }
  },
  /**
   * The setFastTimeout() method sets a fastTimer which executes a function once
   * the timer expires.
   * @param {Function} callback A function to be executed after the timer
   * expires.
   * @param {number} delay The time, in milliseconds that the timer should
   * wait before the specified function or code is executed.
   * @param {*} [arg] An optional argument to be passed to the callback function
   * when the timer expires.
   * @returns {FastTimer}
   */
  setFastTimeout(callback, delay, arg) {
    return new FastTimer2(callback, delay, arg);
  },
  /**
   * The clearTimeout method cancels an instantiated FastTimer previously
   * created by calling setFastTimeout.
   *
   * @param {FastTimer} timeout
   */
  clearFastTimeout(timeout) {
    timeout.clear();
  },
  /**
   * The now method returns the value of the internal fast timer clock.
   *
   * @returns {number}
   */
  now() {
    return fastNow;
  },
  /**
   * Trigger the onTick function to process the fastTimers array.
   * Exported for testing purposes only.
   * Marking as deprecated to discourage any use outside of testing.
   * @deprecated
   * @param {number} [delay=0] The delay in milliseconds to add to the now value.
   */
  tick(delay = 0) {
    fastNow += delay - RESOLUTION_MS + 1;
    onTick();
    onTick();
  },
  /**
   * Reset FastTimers.
   * Exported for testing purposes only.
   * Marking as deprecated to discourage any use outside of testing.
   * @deprecated
   */
  reset() {
    fastNow = 0;
    fastTimers.length = 0;
    clearTimeout(fastNowTimeout);
    fastNowTimeout = null;
  },
  /**
   * Exporting for testing purposes only.
   * Marking as deprecated to discourage any use outside of testing.
   * @deprecated
   */
  kFastTimer
};
const net$1 = require$$0$5;
const assert$c = require$$0$3;
const util$l = util$n;
const { InvalidArgumentError: InvalidArgumentError$k, ConnectTimeoutError: ConnectTimeoutError3 } = errors$1;
const timers$1 = timers$2;
function noop$3() {
}
let tls;
let SessionCache;
if (commonjsGlobal.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG)) {
  SessionCache = class WeakSessionCache {
    constructor(maxCachedSessions) {
      this._maxCachedSessions = maxCachedSessions;
      this._sessionCache = /* @__PURE__ */ new Map();
      this._sessionRegistry = new commonjsGlobal.FinalizationRegistry((key) => {
        if (this._sessionCache.size < this._maxCachedSessions) {
          return;
        }
        const ref = this._sessionCache.get(key);
        if (ref !== void 0 && ref.deref() === void 0) {
          this._sessionCache.delete(key);
        }
      });
    }
    get(sessionKey) {
      const ref = this._sessionCache.get(sessionKey);
      return ref ? ref.deref() : null;
    }
    set(sessionKey, session) {
      if (this._maxCachedSessions === 0) {
        return;
      }
      this._sessionCache.set(sessionKey, new WeakRef(session));
      this._sessionRegistry.register(session, sessionKey);
    }
  };
} else {
  SessionCache = class SimpleSessionCache {
    constructor(maxCachedSessions) {
      this._maxCachedSessions = maxCachedSessions;
      this._sessionCache = /* @__PURE__ */ new Map();
    }
    get(sessionKey) {
      return this._sessionCache.get(sessionKey);
    }
    set(sessionKey, session) {
      if (this._maxCachedSessions === 0) {
        return;
      }
      if (this._sessionCache.size >= this._maxCachedSessions) {
        const { value: oldestKey } = this._sessionCache.keys().next();
        this._sessionCache.delete(oldestKey);
      }
      this._sessionCache.set(sessionKey, session);
    }
  };
}
function buildConnector$4({ allowH2, maxCachedSessions, socketPath, timeout, session: customSession, ...opts }) {
  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
    throw new InvalidArgumentError$k("maxCachedSessions must be a positive integer or zero");
  }
  const options = { path: socketPath, ...opts };
  const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
  timeout = timeout == null ? 1e4 : timeout;
  allowH2 = allowH2 != null ? allowH2 : false;
  return function connect2({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
    let socket;
    if (protocol === "https:") {
      if (!tls) {
        tls = require$$5;
      }
      servername = servername || options.servername || util$l.getServerName(host) || null;
      const sessionKey = servername || hostname;
      assert$c(sessionKey);
      const session = customSession || sessionCache.get(sessionKey) || null;
      port = port || 443;
      socket = tls.connect({
        highWaterMark: 16384,
        // TLS in node can't have bigger HWM anyway...
        ...options,
        servername,
        session,
        localAddress,
        // TODO(HTTP/2): Add support for h2c
        ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
        socket: httpSocket,
        // upgrade socket connection
        port,
        host: hostname
      });
      socket.on("session", function(session2) {
        sessionCache.set(sessionKey, session2);
      });
    } else {
      assert$c(!httpSocket, "httpSocket can only be sent on TLS update");
      port = port || 80;
      socket = net$1.connect({
        highWaterMark: 64 * 1024,
        // Same as nodejs fs streams.
        ...options,
        localAddress,
        port,
        host: hostname
      });
    }
    if (options.keepAlive == null || options.keepAlive) {
      const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
      socket.setKeepAlive(true, keepAliveInitialDelay);
    }
    const clearConnectTimeout = setupConnectTimeout(new WeakRef(socket), { timeout, hostname, port });
    socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
      queueMicrotask(clearConnectTimeout);
      if (callback) {
        const cb = callback;
        callback = null;
        cb(null, this);
      }
    }).on("error", function(err) {
      queueMicrotask(clearConnectTimeout);
      if (callback) {
        const cb = callback;
        callback = null;
        cb(err);
      }
    });
    return socket;
  };
}
const setupConnectTimeout = process.platform === "win32" ? (socketWeakRef, opts) => {
  if (!opts.timeout) {
    return noop$3;
  }
  let s1 = null;
  let s2 = null;
  const fastTimer = timers$1.setFastTimeout(() => {
    s1 = setImmediate(() => {
      s2 = setImmediate(() => onConnectTimeout(socketWeakRef.deref(), opts));
    });
  }, opts.timeout);
  return () => {
    timers$1.clearFastTimeout(fastTimer);
    clearImmediate(s1);
    clearImmediate(s2);
  };
} : (socketWeakRef, opts) => {
  if (!opts.timeout) {
    return noop$3;
  }
  let s1 = null;
  const fastTimer = timers$1.setFastTimeout(() => {
    s1 = setImmediate(() => {
      onConnectTimeout(socketWeakRef.deref(), opts);
    });
  }, opts.timeout);
  return () => {
    timers$1.clearFastTimeout(fastTimer);
    clearImmediate(s1);
  };
};
function onConnectTimeout(socket, opts) {
  if (socket == null) {
    return;
  }
  let message = "Connect Timeout Error";
  if (Array.isArray(socket.autoSelectFamilyAttemptedAddresses)) {
    message += ` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(", ")},`;
  } else {
    message += ` (attempted address: ${opts.hostname}:${opts.port},`;
  }
  message += ` timeout: ${opts.timeout}ms)`;
  util$l.destroy(socket, new ConnectTimeoutError3(message));
}
var connect$3 = buildConnector$4;
var constants$4 = {};
var utils$2 = {};
Object.defineProperty(utils$2, "__esModule", { value: true });
utils$2.enumToMap = void 0;
function enumToMap(obj) {
  const res = {};
  Object.keys(obj).forEach((key) => {
    const value = obj[key];
    if (typeof value === "number") {
      res[key] = value;
    }
  });
  return res;
}
utils$2.enumToMap = enumToMap;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;
  const utils_12 = utils$2;
  (function(ERROR) {
    ERROR[ERROR["OK"] = 0] = "OK";
    ERROR[ERROR["INTERNAL"] = 1] = "INTERNAL";
    ERROR[ERROR["STRICT"] = 2] = "STRICT";
    ERROR[ERROR["LF_EXPECTED"] = 3] = "LF_EXPECTED";
    ERROR[ERROR["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
    ERROR[ERROR["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
    ERROR[ERROR["INVALID_METHOD"] = 6] = "INVALID_METHOD";
    ERROR[ERROR["INVALID_URL"] = 7] = "INVALID_URL";
    ERROR[ERROR["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
    ERROR[ERROR["INVALID_VERSION"] = 9] = "INVALID_VERSION";
    ERROR[ERROR["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
    ERROR[ERROR["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
    ERROR[ERROR["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
    ERROR[ERROR["INVALID_STATUS"] = 13] = "INVALID_STATUS";
    ERROR[ERROR["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
    ERROR[ERROR["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
    ERROR[ERROR["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
    ERROR[ERROR["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
    ERROR[ERROR["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
    ERROR[ERROR["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
    ERROR[ERROR["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
    ERROR[ERROR["PAUSED"] = 21] = "PAUSED";
    ERROR[ERROR["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
    ERROR[ERROR["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
    ERROR[ERROR["USER"] = 24] = "USER";
  })(exports.ERROR || (exports.ERROR = {}));
  (function(TYPE) {
    TYPE[TYPE["BOTH"] = 0] = "BOTH";
    TYPE[TYPE["REQUEST"] = 1] = "REQUEST";
    TYPE[TYPE["RESPONSE"] = 2] = "RESPONSE";
  })(exports.TYPE || (exports.TYPE = {}));
  (function(FLAGS) {
    FLAGS[FLAGS["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
    FLAGS[FLAGS["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
    FLAGS[FLAGS["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
    FLAGS[FLAGS["CHUNKED"] = 8] = "CHUNKED";
    FLAGS[FLAGS["UPGRADE"] = 16] = "UPGRADE";
    FLAGS[FLAGS["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
    FLAGS[FLAGS["SKIPBODY"] = 64] = "SKIPBODY";
    FLAGS[FLAGS["TRAILING"] = 128] = "TRAILING";
    FLAGS[FLAGS["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
  })(exports.FLAGS || (exports.FLAGS = {}));
  (function(LENIENT_FLAGS) {
    LENIENT_FLAGS[LENIENT_FLAGS["HEADERS"] = 1] = "HEADERS";
    LENIENT_FLAGS[LENIENT_FLAGS["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
    LENIENT_FLAGS[LENIENT_FLAGS["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
  })(exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
  var METHODS;
  (function(METHODS2) {
    METHODS2[METHODS2["DELETE"] = 0] = "DELETE";
    METHODS2[METHODS2["GET"] = 1] = "GET";
    METHODS2[METHODS2["HEAD"] = 2] = "HEAD";
    METHODS2[METHODS2["POST"] = 3] = "POST";
    METHODS2[METHODS2["PUT"] = 4] = "PUT";
    METHODS2[METHODS2["CONNECT"] = 5] = "CONNECT";
    METHODS2[METHODS2["OPTIONS"] = 6] = "OPTIONS";
    METHODS2[METHODS2["TRACE"] = 7] = "TRACE";
    METHODS2[METHODS2["COPY"] = 8] = "COPY";
    METHODS2[METHODS2["LOCK"] = 9] = "LOCK";
    METHODS2[METHODS2["MKCOL"] = 10] = "MKCOL";
    METHODS2[METHODS2["MOVE"] = 11] = "MOVE";
    METHODS2[METHODS2["PROPFIND"] = 12] = "PROPFIND";
    METHODS2[METHODS2["PROPPATCH"] = 13] = "PROPPATCH";
    METHODS2[METHODS2["SEARCH"] = 14] = "SEARCH";
    METHODS2[METHODS2["UNLOCK"] = 15] = "UNLOCK";
    METHODS2[METHODS2["BIND"] = 16] = "BIND";
    METHODS2[METHODS2["REBIND"] = 17] = "REBIND";
    METHODS2[METHODS2["UNBIND"] = 18] = "UNBIND";
    METHODS2[METHODS2["ACL"] = 19] = "ACL";
    METHODS2[METHODS2["REPORT"] = 20] = "REPORT";
    METHODS2[METHODS2["MKACTIVITY"] = 21] = "MKACTIVITY";
    METHODS2[METHODS2["CHECKOUT"] = 22] = "CHECKOUT";
    METHODS2[METHODS2["MERGE"] = 23] = "MERGE";
    METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH";
    METHODS2[METHODS2["NOTIFY"] = 25] = "NOTIFY";
    METHODS2[METHODS2["SUBSCRIBE"] = 26] = "SUBSCRIBE";
    METHODS2[METHODS2["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
    METHODS2[METHODS2["PATCH"] = 28] = "PATCH";
    METHODS2[METHODS2["PURGE"] = 29] = "PURGE";
    METHODS2[METHODS2["MKCALENDAR"] = 30] = "MKCALENDAR";
    METHODS2[METHODS2["LINK"] = 31] = "LINK";
    METHODS2[METHODS2["UNLINK"] = 32] = "UNLINK";
    METHODS2[METHODS2["SOURCE"] = 33] = "SOURCE";
    METHODS2[METHODS2["PRI"] = 34] = "PRI";
    METHODS2[METHODS2["DESCRIBE"] = 35] = "DESCRIBE";
    METHODS2[METHODS2["ANNOUNCE"] = 36] = "ANNOUNCE";
    METHODS2[METHODS2["SETUP"] = 37] = "SETUP";
    METHODS2[METHODS2["PLAY"] = 38] = "PLAY";
    METHODS2[METHODS2["PAUSE"] = 39] = "PAUSE";
    METHODS2[METHODS2["TEARDOWN"] = 40] = "TEARDOWN";
    METHODS2[METHODS2["GET_PARAMETER"] = 41] = "GET_PARAMETER";
    METHODS2[METHODS2["SET_PARAMETER"] = 42] = "SET_PARAMETER";
    METHODS2[METHODS2["REDIRECT"] = 43] = "REDIRECT";
    METHODS2[METHODS2["RECORD"] = 44] = "RECORD";
    METHODS2[METHODS2["FLUSH"] = 45] = "FLUSH";
  })(METHODS = exports.METHODS || (exports.METHODS = {}));
  exports.METHODS_HTTP = [
    METHODS.DELETE,
    METHODS.GET,
    METHODS.HEAD,
    METHODS.POST,
    METHODS.PUT,
    METHODS.CONNECT,
    METHODS.OPTIONS,
    METHODS.TRACE,
    METHODS.COPY,
    METHODS.LOCK,
    METHODS.MKCOL,
    METHODS.MOVE,
    METHODS.PROPFIND,
    METHODS.PROPPATCH,
    METHODS.SEARCH,
    METHODS.UNLOCK,
    METHODS.BIND,
    METHODS.REBIND,
    METHODS.UNBIND,
    METHODS.ACL,
    METHODS.REPORT,
    METHODS.MKACTIVITY,
    METHODS.CHECKOUT,
    METHODS.MERGE,
    METHODS["M-SEARCH"],
    METHODS.NOTIFY,
    METHODS.SUBSCRIBE,
    METHODS.UNSUBSCRIBE,
    METHODS.PATCH,
    METHODS.PURGE,
    METHODS.MKCALENDAR,
    METHODS.LINK,
    METHODS.UNLINK,
    METHODS.PRI,
    // TODO(indutny): should we allow it with HTTP?
    METHODS.SOURCE
  ];
  exports.METHODS_ICE = [
    METHODS.SOURCE
  ];
  exports.METHODS_RTSP = [
    METHODS.OPTIONS,
    METHODS.DESCRIBE,
    METHODS.ANNOUNCE,
    METHODS.SETUP,
    METHODS.PLAY,
    METHODS.PAUSE,
    METHODS.TEARDOWN,
    METHODS.GET_PARAMETER,
    METHODS.SET_PARAMETER,
    METHODS.REDIRECT,
    METHODS.RECORD,
    METHODS.FLUSH,
    // For AirPlay
    METHODS.GET,
    METHODS.POST
  ];
  exports.METHOD_MAP = utils_12.enumToMap(METHODS);
  exports.H_METHOD_MAP = {};
  Object.keys(exports.METHOD_MAP).forEach((key) => {
    if (/^H/.test(key)) {
      exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
    }
  });
  (function(FINISH) {
    FINISH[FINISH["SAFE"] = 0] = "SAFE";
    FINISH[FINISH["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
    FINISH[FINISH["UNSAFE"] = 2] = "UNSAFE";
  })(exports.FINISH || (exports.FINISH = {}));
  exports.ALPHA = [];
  for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
    exports.ALPHA.push(String.fromCharCode(i));
    exports.ALPHA.push(String.fromCharCode(i + 32));
  }
  exports.NUM_MAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9
  };
  exports.HEX_MAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15
  };
  exports.NUM = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9"
  ];
  exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
  exports.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
  exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
  exports.STRICT_URL_CHAR = [
    "!",
    '"',
    "$",
    "%",
    "&",
    "'",
    "(",
    ")",
    "*",
    "+",
    ",",
    "-",
    ".",
    "/",
    ":",
    ";",
    "<",
    "=",
    ">",
    "@",
    "[",
    "\\",
    "]",
    "^",
    "_",
    "`",
    "{",
    "|",
    "}",
    "~"
  ].concat(exports.ALPHANUM);
  exports.URL_CHAR = exports.STRICT_URL_CHAR.concat(["	", "\f"]);
  for (let i = 128; i <= 255; i++) {
    exports.URL_CHAR.push(i);
  }
  exports.HEX = exports.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
  exports.STRICT_TOKEN = [
    "!",
    "#",
    "$",
    "%",
    "&",
    "'",
    "*",
    "+",
    "-",
    ".",
    "^",
    "_",
    "`",
    "|",
    "~"
  ].concat(exports.ALPHANUM);
  exports.TOKEN = exports.STRICT_TOKEN.concat([" "]);
  exports.HEADER_CHARS = ["	"];
  for (let i = 32; i <= 255; i++) {
    if (i !== 127) {
      exports.HEADER_CHARS.push(i);
    }
  }
  exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
  exports.MAJOR = exports.NUM_MAP;
  exports.MINOR = exports.MAJOR;
  var HEADER_STATE;
  (function(HEADER_STATE2) {
    HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
    HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
    HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
    HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
    HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
    HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
    HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
    HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
    HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
  })(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
  exports.SPECIAL_HEADERS = {
    "connection": HEADER_STATE.CONNECTION,
    "content-length": HEADER_STATE.CONTENT_LENGTH,
    "proxy-connection": HEADER_STATE.CONNECTION,
    "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
    "upgrade": HEADER_STATE.UPGRADE
  };
})(constants$4);
var llhttpWasm;
var hasRequiredLlhttpWasm;
function requireLlhttpWasm() {
  if (hasRequiredLlhttpWasm) return llhttpWasm;
  hasRequiredLlhttpWasm = 1;
  const { Buffer: Buffer2 } = require$$0$1;
  llhttpWasm = Buffer2.from("AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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PgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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iQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEV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JSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxB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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB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CABB3AgLii1JbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AFJlc3BvbnNlIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fbWV0aG9kAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAF4TAAAmEwAAMBAAAPAXAACdEwAAFRIAADkXAADwEgAAChAAAHUSAACtEgAAghMAAE8UAAB/EAAAoBUAACMUAACJEgAAixQAAE0VAADUEQAAzxQAABAYAADJFgAA3BYAAMERAADgFwAAuxQAAHQUAAB8FQAA5RQAAAgXAAAfEAAAZRUAAKMUAAAoFQAAAhUAAJkVAAAsEAAAixkAAE8PAADUDgAAahAAAM4QAAACFwAAiQ4AAG4TAAAcEwAAZhQAAFYXAADBEwAAzRMAAGwTAABoFwAAZhcAAF8XAAAiEwAAzg8AAGkOAADYDgAAYxYAAMsTAACqDgAAKBcAACYXAADFEwAAXRYAAOgRAABnEwAAZRMAAPIWAABzEwAAHRcAAPkWAADzEQAAzw4AAM4VAAAMEgAAsxEAAKURAABhEAAAMhcAALsTAEH5NQsBAQBBkDYL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB/TcLAQEAQZE4C14CAwICAgICAAACAgACAgACAgICAgICAgICAAQAAAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEH9OQsBAQBBkToLXgIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAQfA7Cw1sb3NlZWVwLWFsaXZlAEGJPAsBAQBBoDwL4AEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBiT4LAQEAQaA+C+cBAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAEGwwAALXwEBAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAEGQwgALIWVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgBBwMIACy1yYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AQfnCAAsFAQIAAQMAQZDDAAvgAQQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH5xAALBQECAAEDAEGQxQAL4AEEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cYACwQBAAABAEGRxwAL3wEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH6yAALBAEAAAIAQZDJAAtfAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAQfrKAAsEAQAAAQBBkMsACwEBAEGqywALQQIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAEH6zAALBAEAAAEAQZDNAAsBAQBBms0ACwYCAAAAAAIAQbHNAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB8M4AC5YBTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv", "base64");
  return llhttpWasm;
}
var llhttp_simdWasm;
var hasRequiredLlhttp_simdWasm;
function requireLlhttp_simdWasm() {
  if (hasRequiredLlhttp_simdWasm) return llhttp_simdWasm;
  hasRequiredLlhttp_simdWasm = 1;
  const { Buffer: Buffer2 } = require$$0$1;
  llhttp_simdWasm = Buffer2.from("AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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PgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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iQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEV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JSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxB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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB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AAADAEGUCAsFBAAAAAUAQaQICwkGAAAABwAAAAgAQdwIC4otSW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwBB+TULAQEAQZA2C+ABAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQf03CwEBAEGROAteAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgBB/TkLAQEAQZE6C14CAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEHwOwsNbG9zZWVlcC1hbGl2ZQBBiTwLAQEAQaA8C+ABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQYk+CwEBAEGgPgvnAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZABBsMAAC18BAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQBBkMIACyFlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AQcDCAAstcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQoNClNNDQoNClRUUC9DRS9UU1AvAEH5wgALBQECAAEDAEGQwwAL4AEEAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cQACwUBAgABAwBBkMUAC+ABBAEBBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQfnGAAsEAQAAAQBBkccAC98BAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+sgACwQBAAACAEGQyQALXwMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAEH6ygALBAEAAAEAQZDLAAsBAQBBqssAC0ECAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB+swACwQBAAABAEGQzQALAQEAQZrNAAsGAgAAAAACAEGxzQALOgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQfDOAAuWAU5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==", "base64");
  return llhttp_simdWasm;
}
var constants$3;
var hasRequiredConstants$2;
function requireConstants$2() {
  if (hasRequiredConstants$2) return constants$3;
  hasRequiredConstants$2 = 1;
  const corsSafeListedMethods = (
    /** @type {const} */
    ["GET", "HEAD", "POST"]
  );
  const corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
  const nullBodyStatus = (
    /** @type {const} */
    [101, 204, 205, 304]
  );
  const redirectStatus = (
    /** @type {const} */
    [301, 302, 303, 307, 308]
  );
  const redirectStatusSet = new Set(redirectStatus);
  const badPorts = (
    /** @type {const} */
    [
      "1",
      "7",
      "9",
      "11",
      "13",
      "15",
      "17",
      "19",
      "20",
      "21",
      "22",
      "23",
      "25",
      "37",
      "42",
      "43",
      "53",
      "69",
      "77",
      "79",
      "87",
      "95",
      "101",
      "102",
      "103",
      "104",
      "109",
      "110",
      "111",
      "113",
      "115",
      "117",
      "119",
      "123",
      "135",
      "137",
      "139",
      "143",
      "161",
      "179",
      "389",
      "427",
      "465",
      "512",
      "513",
      "514",
      "515",
      "526",
      "530",
      "531",
      "532",
      "540",
      "548",
      "554",
      "556",
      "563",
      "587",
      "601",
      "636",
      "989",
      "990",
      "993",
      "995",
      "1719",
      "1720",
      "1723",
      "2049",
      "3659",
      "4045",
      "4190",
      "5060",
      "5061",
      "6000",
      "6566",
      "6665",
      "6666",
      "6667",
      "6668",
      "6669",
      "6679",
      "6697",
      "10080"
    ]
  );
  const badPortsSet = new Set(badPorts);
  const referrerPolicy = (
    /** @type {const} */
    [
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ]
  );
  const referrerPolicySet = new Set(referrerPolicy);
  const requestRedirect = (
    /** @type {const} */
    ["follow", "manual", "error"]
  );
  const safeMethods = (
    /** @type {const} */
    ["GET", "HEAD", "OPTIONS", "TRACE"]
  );
  const safeMethodsSet = new Set(safeMethods);
  const requestMode = (
    /** @type {const} */
    ["navigate", "same-origin", "no-cors", "cors"]
  );
  const requestCredentials = (
    /** @type {const} */
    ["omit", "same-origin", "include"]
  );
  const requestCache = (
    /** @type {const} */
    [
      "default",
      "no-store",
      "reload",
      "no-cache",
      "force-cache",
      "only-if-cached"
    ]
  );
  const requestBodyHeader = (
    /** @type {const} */
    [
      "content-encoding",
      "content-language",
      "content-location",
      "content-type",
      // See https://github.com/nodejs/undici/issues/2021
      // 'Content-Length' is a forbidden header name, which is typically
      // removed in the Headers implementation. However, undici doesn't
      // filter out headers, so we add it here.
      "content-length"
    ]
  );
  const requestDuplex = (
    /** @type {const} */
    [
      "half"
    ]
  );
  const forbiddenMethods = (
    /** @type {const} */
    ["CONNECT", "TRACE", "TRACK"]
  );
  const forbiddenMethodsSet = new Set(forbiddenMethods);
  const subresource = (
    /** @type {const} */
    [
      "audio",
      "audioworklet",
      "font",
      "image",
      "manifest",
      "paintworklet",
      "script",
      "style",
      "track",
      "video",
      "xslt",
      ""
    ]
  );
  const subresourceSet = new Set(subresource);
  constants$3 = {
    subresource,
    forbiddenMethods,
    requestBodyHeader,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    redirectStatus,
    corsSafeListedMethods,
    nullBodyStatus,
    safeMethods,
    badPorts,
    requestDuplex,
    subresourceSet,
    badPortsSet,
    redirectStatusSet,
    corsSafeListedMethodsSet,
    safeMethodsSet,
    forbiddenMethodsSet,
    referrerPolicySet
  };
  return constants$3;
}
var global$2;
var hasRequiredGlobal;
function requireGlobal() {
  if (hasRequiredGlobal) return global$2;
  hasRequiredGlobal = 1;
  const globalOrigin = Symbol.for("undici.globalOrigin.1");
  function getGlobalOrigin2() {
    return globalThis[globalOrigin];
  }
  function setGlobalOrigin2(newOrigin) {
    if (newOrigin === void 0) {
      Object.defineProperty(globalThis, globalOrigin, {
        value: void 0,
        writable: true,
        enumerable: false,
        configurable: false
      });
      return;
    }
    const parsedURL = new URL(newOrigin);
    if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
      throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
    }
    Object.defineProperty(globalThis, globalOrigin, {
      value: parsedURL,
      writable: true,
      enumerable: false,
      configurable: false
    });
  }
  global$2 = {
    getGlobalOrigin: getGlobalOrigin2,
    setGlobalOrigin: setGlobalOrigin2
  };
  return global$2;
}
var dataUrl;
var hasRequiredDataUrl;
function requireDataUrl() {
  if (hasRequiredDataUrl) return dataUrl;
  hasRequiredDataUrl = 1;
  const assert2 = require$$0$3;
  const encoder = new TextEncoder();
  const HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+\-.^_|~A-Za-z0-9]+$/;
  const HTTP_WHITESPACE_REGEX = /[\u000A\u000D\u0009\u0020]/;
  const ASCII_WHITESPACE_REPLACE_REGEX = /[\u0009\u000A\u000C\u000D\u0020]/g;
  const HTTP_QUOTED_STRING_TOKENS = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
  function dataURLProcessor(dataURL) {
    assert2(dataURL.protocol === "data:");
    let input = URLSerializer(dataURL, true);
    input = input.slice(5);
    const position = { position: 0 };
    let mimeType = collectASequenceOfCodePointsFast(
      ",",
      input,
      position
    );
    const mimeTypeLength = mimeType.length;
    mimeType = removeASCIIWhitespace(mimeType, true, true);
    if (position.position >= input.length) {
      return "failure";
    }
    position.position++;
    const encodedBody = input.slice(mimeTypeLength + 1);
    let body2 = stringPercentDecode(encodedBody);
    if (/;(\u0020){0,}base64$/i.test(mimeType)) {
      const stringBody = isomorphicDecode(body2);
      body2 = forgivingBase64(stringBody);
      if (body2 === "failure") {
        return "failure";
      }
      mimeType = mimeType.slice(0, -6);
      mimeType = mimeType.replace(/(\u0020)+$/, "");
      mimeType = mimeType.slice(0, -1);
    }
    if (mimeType.startsWith(";")) {
      mimeType = "text/plain" + mimeType;
    }
    let mimeTypeRecord = parseMIMEType2(mimeType);
    if (mimeTypeRecord === "failure") {
      mimeTypeRecord = parseMIMEType2("text/plain;charset=US-ASCII");
    }
    return { mimeType: mimeTypeRecord, body: body2 };
  }
  function URLSerializer(url, excludeFragment = false) {
    if (!excludeFragment) {
      return url.href;
    }
    const href = url.href;
    const hashLength = url.hash.length;
    const serialized = hashLength === 0 ? href : href.substring(0, href.length - hashLength);
    if (!hashLength && href.endsWith("#")) {
      return serialized.slice(0, -1);
    }
    return serialized;
  }
  function collectASequenceOfCodePoints(condition, input, position) {
    let result = "";
    while (position.position < input.length && condition(input[position.position])) {
      result += input[position.position];
      position.position++;
    }
    return result;
  }
  function collectASequenceOfCodePointsFast(char, input, position) {
    const idx = input.indexOf(char, position.position);
    const start = position.position;
    if (idx === -1) {
      position.position = input.length;
      return input.slice(start);
    }
    position.position = idx;
    return input.slice(start, position.position);
  }
  function stringPercentDecode(input) {
    const bytes = encoder.encode(input);
    return percentDecode(bytes);
  }
  function isHexCharByte(byte) {
    return byte >= 48 && byte <= 57 || byte >= 65 && byte <= 70 || byte >= 97 && byte <= 102;
  }
  function hexByteToNumber(byte) {
    return (
      // 0-9
      byte >= 48 && byte <= 57 ? byte - 48 : (byte & 223) - 55
    );
  }
  function percentDecode(input) {
    const length = input.length;
    const output = new Uint8Array(length);
    let j = 0;
    for (let i = 0; i < length; ++i) {
      const byte = input[i];
      if (byte !== 37) {
        output[j++] = byte;
      } else if (byte === 37 && !(isHexCharByte(input[i + 1]) && isHexCharByte(input[i + 2]))) {
        output[j++] = 37;
      } else {
        output[j++] = hexByteToNumber(input[i + 1]) << 4 | hexByteToNumber(input[i + 2]);
        i += 2;
      }
    }
    return length === j ? output : output.subarray(0, j);
  }
  function parseMIMEType2(input) {
    input = removeHTTPWhitespace(input, true, true);
    const position = { position: 0 };
    const type = collectASequenceOfCodePointsFast(
      "/",
      input,
      position
    );
    if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
      return "failure";
    }
    if (position.position > input.length) {
      return "failure";
    }
    position.position++;
    let subtype = collectASequenceOfCodePointsFast(
      ";",
      input,
      position
    );
    subtype = removeHTTPWhitespace(subtype, false, true);
    if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
      return "failure";
    }
    const typeLowercase = type.toLowerCase();
    const subtypeLowercase = subtype.toLowerCase();
    const mimeType = {
      type: typeLowercase,
      subtype: subtypeLowercase,
      /** @type {Map<string, string>} */
      parameters: /* @__PURE__ */ new Map(),
      // https://mimesniff.spec.whatwg.org/#mime-type-essence
      essence: `${typeLowercase}/${subtypeLowercase}`
    };
    while (position.position < input.length) {
      position.position++;
      collectASequenceOfCodePoints(
        // https://fetch.spec.whatwg.org/#http-whitespace
        (char) => HTTP_WHITESPACE_REGEX.test(char),
        input,
        position
      );
      let parameterName = collectASequenceOfCodePoints(
        (char) => char !== ";" && char !== "=",
        input,
        position
      );
      parameterName = parameterName.toLowerCase();
      if (position.position < input.length) {
        if (input[position.position] === ";") {
          continue;
        }
        position.position++;
      }
      if (position.position > input.length) {
        break;
      }
      let parameterValue = null;
      if (input[position.position] === '"') {
        parameterValue = collectAnHTTPQuotedString(input, position, true);
        collectASequenceOfCodePointsFast(
          ";",
          input,
          position
        );
      } else {
        parameterValue = collectASequenceOfCodePointsFast(
          ";",
          input,
          position
        );
        parameterValue = removeHTTPWhitespace(parameterValue, false, true);
        if (parameterValue.length === 0) {
          continue;
        }
      }
      if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
        mimeType.parameters.set(parameterName, parameterValue);
      }
    }
    return mimeType;
  }
  function forgivingBase64(data) {
    data = data.replace(ASCII_WHITESPACE_REPLACE_REGEX, "");
    let dataLength = data.length;
    if (dataLength % 4 === 0) {
      if (data.charCodeAt(dataLength - 1) === 61) {
        --dataLength;
        if (data.charCodeAt(dataLength - 1) === 61) {
          --dataLength;
        }
      }
    }
    if (dataLength % 4 === 1) {
      return "failure";
    }
    if (/[^+/0-9A-Za-z]/.test(data.length === dataLength ? data : data.substring(0, dataLength))) {
      return "failure";
    }
    const buffer = Buffer.from(data, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  }
  function collectAnHTTPQuotedString(input, position, extractValue) {
    const positionStart = position.position;
    let value = "";
    assert2(input[position.position] === '"');
    position.position++;
    while (true) {
      value += collectASequenceOfCodePoints(
        (char) => char !== '"' && char !== "\\",
        input,
        position
      );
      if (position.position >= input.length) {
        break;
      }
      const quoteOrBackslash = input[position.position];
      position.position++;
      if (quoteOrBackslash === "\\") {
        if (position.position >= input.length) {
          value += "\\";
          break;
        }
        value += input[position.position];
        position.position++;
      } else {
        assert2(quoteOrBackslash === '"');
        break;
      }
    }
    if (extractValue) {
      return value;
    }
    return input.slice(positionStart, position.position);
  }
  function serializeAMimeType2(mimeType) {
    assert2(mimeType !== "failure");
    const { parameters, essence } = mimeType;
    let serialization = essence;
    for (let [name, value] of parameters.entries()) {
      serialization += ";";
      serialization += name;
      serialization += "=";
      if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
        value = value.replace(/(\\|")/g, "\\$1");
        value = '"' + value;
        value += '"';
      }
      serialization += value;
    }
    return serialization;
  }
  function isHTTPWhiteSpace(char) {
    return char === 13 || char === 10 || char === 9 || char === 32;
  }
  function removeHTTPWhitespace(str, leading = true, trailing = true) {
    return removeChars(str, leading, trailing, isHTTPWhiteSpace);
  }
  function isASCIIWhitespace(char) {
    return char === 13 || char === 10 || char === 9 || char === 12 || char === 32;
  }
  function removeASCIIWhitespace(str, leading = true, trailing = true) {
    return removeChars(str, leading, trailing, isASCIIWhitespace);
  }
  function removeChars(str, leading, trailing, predicate) {
    let lead = 0;
    let trail = str.length - 1;
    if (leading) {
      while (lead < str.length && predicate(str.charCodeAt(lead))) lead++;
    }
    if (trailing) {
      while (trail > 0 && predicate(str.charCodeAt(trail))) trail--;
    }
    return lead === 0 && trail === str.length - 1 ? str : str.slice(lead, trail + 1);
  }
  function isomorphicDecode(input) {
    const length = input.length;
    if ((2 << 15) - 1 > length) {
      return String.fromCharCode.apply(null, input);
    }
    let result = "";
    let i = 0;
    let addition = (2 << 15) - 1;
    while (i < length) {
      if (i + addition > length) {
        addition = length - i;
      }
      result += String.fromCharCode.apply(null, input.subarray(i, i += addition));
    }
    return result;
  }
  function minimizeSupportedMimeType(mimeType) {
    switch (mimeType.essence) {
      case "application/ecmascript":
      case "application/javascript":
      case "application/x-ecmascript":
      case "application/x-javascript":
      case "text/ecmascript":
      case "text/javascript":
      case "text/javascript1.0":
      case "text/javascript1.1":
      case "text/javascript1.2":
      case "text/javascript1.3":
      case "text/javascript1.4":
      case "text/javascript1.5":
      case "text/jscript":
      case "text/livescript":
      case "text/x-ecmascript":
      case "text/x-javascript":
        return "text/javascript";
      case "application/json":
      case "text/json":
        return "application/json";
      case "image/svg+xml":
        return "image/svg+xml";
      case "text/xml":
      case "application/xml":
        return "application/xml";
    }
    if (mimeType.subtype.endsWith("+json")) {
      return "application/json";
    }
    if (mimeType.subtype.endsWith("+xml")) {
      return "application/xml";
    }
    return "";
  }
  dataUrl = {
    dataURLProcessor,
    URLSerializer,
    collectASequenceOfCodePoints,
    collectASequenceOfCodePointsFast,
    stringPercentDecode,
    parseMIMEType: parseMIMEType2,
    collectAnHTTPQuotedString,
    serializeAMimeType: serializeAMimeType2,
    removeChars,
    removeHTTPWhitespace,
    minimizeSupportedMimeType,
    HTTP_TOKEN_CODEPOINTS,
    isomorphicDecode
  };
  return dataUrl;
}
var webidl_1;
var hasRequiredWebidl;
function requireWebidl() {
  if (hasRequiredWebidl) return webidl_1;
  hasRequiredWebidl = 1;
  const { types, inspect } = require$$0$2;
  const { markAsUncloneable } = require$$1$1;
  const { toUSVString: toUSVString2 } = util$n;
  const webidl = {};
  webidl.converters = {};
  webidl.util = {};
  webidl.errors = {};
  webidl.errors.exception = function(message) {
    return new TypeError(`${message.header}: ${message.message}`);
  };
  webidl.errors.conversionFailed = function(context) {
    const plural = context.types.length === 1 ? "" : " one of";
    const message = `${context.argument} could not be converted to${plural}: ${context.types.join(", ")}.`;
    return webidl.errors.exception({
      header: context.prefix,
      message
    });
  };
  webidl.errors.invalidArgument = function(context) {
    return webidl.errors.exception({
      header: context.prefix,
      message: `"${context.value}" is an invalid ${context.type}.`
    });
  };
  webidl.brandCheck = function(V, I, opts) {
    if ((opts == null ? void 0 : opts.strict) !== false) {
      if (!(V instanceof I)) {
        const err = new TypeError("Illegal invocation");
        err.code = "ERR_INVALID_THIS";
        throw err;
      }
    } else {
      if ((V == null ? void 0 : V[Symbol.toStringTag]) !== I.prototype[Symbol.toStringTag]) {
        const err = new TypeError("Illegal invocation");
        err.code = "ERR_INVALID_THIS";
        throw err;
      }
    }
  };
  webidl.argumentLengthCheck = function({ length }, min, ctx) {
    if (length < min) {
      throw webidl.errors.exception({
        message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
        header: ctx
      });
    }
  };
  webidl.illegalConstructor = function() {
    throw webidl.errors.exception({
      header: "TypeError",
      message: "Illegal constructor"
    });
  };
  webidl.util.Type = function(V) {
    switch (typeof V) {
      case "undefined":
        return "Undefined";
      case "boolean":
        return "Boolean";
      case "string":
        return "String";
      case "symbol":
        return "Symbol";
      case "number":
        return "Number";
      case "bigint":
        return "BigInt";
      case "function":
      case "object": {
        if (V === null) {
          return "Null";
        }
        return "Object";
      }
    }
  };
  webidl.util.markAsUncloneable = markAsUncloneable || (() => {
  });
  webidl.util.ConvertToInt = function(V, bitLength, signedness, opts) {
    let upperBound;
    let lowerBound;
    if (bitLength === 64) {
      upperBound = Math.pow(2, 53) - 1;
      if (signedness === "unsigned") {
        lowerBound = 0;
      } else {
        lowerBound = Math.pow(-2, 53) + 1;
      }
    } else if (signedness === "unsigned") {
      lowerBound = 0;
      upperBound = Math.pow(2, bitLength) - 1;
    } else {
      lowerBound = Math.pow(-2, bitLength) - 1;
      upperBound = Math.pow(2, bitLength - 1) - 1;
    }
    let x = Number(V);
    if (x === 0) {
      x = 0;
    }
    if ((opts == null ? void 0 : opts.enforceRange) === true) {
      if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Could not convert ${webidl.util.Stringify(V)} to an integer.`
        });
      }
      x = webidl.util.IntegerPart(x);
      if (x < lowerBound || x > upperBound) {
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
        });
      }
      return x;
    }
    if (!Number.isNaN(x) && (opts == null ? void 0 : opts.clamp) === true) {
      x = Math.min(Math.max(x, lowerBound), upperBound);
      if (Math.floor(x) % 2 === 0) {
        x = Math.floor(x);
      } else {
        x = Math.ceil(x);
      }
      return x;
    }
    if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
      return 0;
    }
    x = webidl.util.IntegerPart(x);
    x = x % Math.pow(2, bitLength);
    if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
      return x - Math.pow(2, bitLength);
    }
    return x;
  };
  webidl.util.IntegerPart = function(n) {
    const r = Math.floor(Math.abs(n));
    if (n < 0) {
      return -1 * r;
    }
    return r;
  };
  webidl.util.Stringify = function(V) {
    const type = webidl.util.Type(V);
    switch (type) {
      case "Symbol":
        return `Symbol(${V.description})`;
      case "Object":
        return inspect(V);
      case "String":
        return `"${V}"`;
      default:
        return `${V}`;
    }
  };
  webidl.sequenceConverter = function(converter) {
    return (V, prefix, argument, Iterable) => {
      var _a2;
      if (webidl.util.Type(V) !== "Object") {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} (${webidl.util.Stringify(V)}) is not iterable.`
        });
      }
      const method = typeof Iterable === "function" ? Iterable() : (_a2 = V == null ? void 0 : V[Symbol.iterator]) == null ? void 0 : _a2.call(V);
      const seq = [];
      let index = 0;
      if (method === void 0 || typeof method.next !== "function") {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} is not iterable.`
        });
      }
      while (true) {
        const { done, value } = method.next();
        if (done) {
          break;
        }
        seq.push(converter(value, prefix, `${argument}[${index++}]`));
      }
      return seq;
    };
  };
  webidl.recordConverter = function(keyConverter, valueConverter) {
    return (O, prefix, argument) => {
      if (webidl.util.Type(O) !== "Object") {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} ("${webidl.util.Type(O)}") is not an Object.`
        });
      }
      const result = {};
      if (!types.isProxy(O)) {
        const keys2 = [...Object.getOwnPropertyNames(O), ...Object.getOwnPropertySymbols(O)];
        for (const key of keys2) {
          const typedKey = keyConverter(key, prefix, argument);
          const typedValue = valueConverter(O[key], prefix, argument);
          result[typedKey] = typedValue;
        }
        return result;
      }
      const keys = Reflect.ownKeys(O);
      for (const key of keys) {
        const desc = Reflect.getOwnPropertyDescriptor(O, key);
        if (desc == null ? void 0 : desc.enumerable) {
          const typedKey = keyConverter(key, prefix, argument);
          const typedValue = valueConverter(O[key], prefix, argument);
          result[typedKey] = typedValue;
        }
      }
      return result;
    };
  };
  webidl.interfaceConverter = function(i) {
    return (V, prefix, argument, opts) => {
      if ((opts == null ? void 0 : opts.strict) !== false && !(V instanceof i)) {
        throw webidl.errors.exception({
          header: prefix,
          message: `Expected ${argument} ("${webidl.util.Stringify(V)}") to be an instance of ${i.name}.`
        });
      }
      return V;
    };
  };
  webidl.dictionaryConverter = function(converters) {
    return (dictionary, prefix, argument) => {
      const type = webidl.util.Type(dictionary);
      const dict = {};
      if (type === "Null" || type === "Undefined") {
        return dict;
      } else if (type !== "Object") {
        throw webidl.errors.exception({
          header: prefix,
          message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
        });
      }
      for (const options of converters) {
        const { key, defaultValue, required, converter } = options;
        if (required === true) {
          if (!Object.hasOwn(dictionary, key)) {
            throw webidl.errors.exception({
              header: prefix,
              message: `Missing required key "${key}".`
            });
          }
        }
        let value = dictionary[key];
        const hasDefault = Object.hasOwn(options, "defaultValue");
        if (hasDefault && value !== null) {
          value ?? (value = defaultValue());
        }
        if (required || hasDefault || value !== void 0) {
          value = converter(value, prefix, `${argument}.${key}`);
          if (options.allowedValues && !options.allowedValues.includes(value)) {
            throw webidl.errors.exception({
              header: prefix,
              message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
            });
          }
          dict[key] = value;
        }
      }
      return dict;
    };
  };
  webidl.nullableConverter = function(converter) {
    return (V, prefix, argument) => {
      if (V === null) {
        return V;
      }
      return converter(V, prefix, argument);
    };
  };
  webidl.converters.DOMString = function(V, prefix, argument, opts) {
    if (V === null && (opts == null ? void 0 : opts.legacyNullToEmptyString)) {
      return "";
    }
    if (typeof V === "symbol") {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} is a symbol, which cannot be converted to a DOMString.`
      });
    }
    return String(V);
  };
  webidl.converters.ByteString = function(V, prefix, argument) {
    const x = webidl.converters.DOMString(V, prefix, argument);
    for (let index = 0; index < x.length; index++) {
      if (x.charCodeAt(index) > 255) {
        throw new TypeError(
          `Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`
        );
      }
    }
    return x;
  };
  webidl.converters.USVString = toUSVString2;
  webidl.converters.boolean = function(V) {
    const x = Boolean(V);
    return x;
  };
  webidl.converters.any = function(V) {
    return V;
  };
  webidl.converters["long long"] = function(V, prefix, argument) {
    const x = webidl.util.ConvertToInt(V, 64, "signed", void 0, prefix, argument);
    return x;
  };
  webidl.converters["unsigned long long"] = function(V, prefix, argument) {
    const x = webidl.util.ConvertToInt(V, 64, "unsigned", void 0, prefix, argument);
    return x;
  };
  webidl.converters["unsigned long"] = function(V, prefix, argument) {
    const x = webidl.util.ConvertToInt(V, 32, "unsigned", void 0, prefix, argument);
    return x;
  };
  webidl.converters["unsigned short"] = function(V, prefix, argument, opts) {
    const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts, prefix, argument);
    return x;
  };
  webidl.converters.ArrayBuffer = function(V, prefix, argument, opts) {
    if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V)) {
      throw webidl.errors.conversionFailed({
        prefix,
        argument: `${argument} ("${webidl.util.Stringify(V)}")`,
        types: ["ArrayBuffer"]
      });
    }
    if ((opts == null ? void 0 : opts.allowShared) === false && types.isSharedArrayBuffer(V)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    if (V.resizable || V.growable) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "Received a resizable ArrayBuffer."
      });
    }
    return V;
  };
  webidl.converters.TypedArray = function(V, T, prefix, name, opts) {
    if (webidl.util.Type(V) !== "Object" || !types.isTypedArray(V) || V.constructor.name !== T.name) {
      throw webidl.errors.conversionFailed({
        prefix,
        argument: `${name} ("${webidl.util.Stringify(V)}")`,
        types: [T.name]
      });
    }
    if ((opts == null ? void 0 : opts.allowShared) === false && types.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    if (V.buffer.resizable || V.buffer.growable) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "Received a resizable ArrayBuffer."
      });
    }
    return V;
  };
  webidl.converters.DataView = function(V, prefix, name, opts) {
    if (webidl.util.Type(V) !== "Object" || !types.isDataView(V)) {
      throw webidl.errors.exception({
        header: prefix,
        message: `${name} is not a DataView.`
      });
    }
    if ((opts == null ? void 0 : opts.allowShared) === false && types.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    if (V.buffer.resizable || V.buffer.growable) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "Received a resizable ArrayBuffer."
      });
    }
    return V;
  };
  webidl.converters.BufferSource = function(V, prefix, name, opts) {
    if (types.isAnyArrayBuffer(V)) {
      return webidl.converters.ArrayBuffer(V, prefix, name, { ...opts, allowShared: false });
    }
    if (types.isTypedArray(V)) {
      return webidl.converters.TypedArray(V, V.constructor, prefix, name, { ...opts, allowShared: false });
    }
    if (types.isDataView(V)) {
      return webidl.converters.DataView(V, prefix, name, { ...opts, allowShared: false });
    }
    throw webidl.errors.conversionFailed({
      prefix,
      argument: `${name} ("${webidl.util.Stringify(V)}")`,
      types: ["BufferSource"]
    });
  };
  webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
    webidl.converters.ByteString
  );
  webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(
    webidl.converters["sequence<ByteString>"]
  );
  webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(
    webidl.converters.ByteString,
    webidl.converters.ByteString
  );
  webidl_1 = {
    webidl
  };
  return webidl_1;
}
var util$k;
var hasRequiredUtil$5;
function requireUtil$5() {
  var _zlibOptions;
  if (hasRequiredUtil$5) return util$k;
  hasRequiredUtil$5 = 1;
  const { Transform: Transform2 } = require$$0$4;
  const zlib = require$$1$2;
  const { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = requireConstants$2();
  const { getGlobalOrigin: getGlobalOrigin2 } = requireGlobal();
  const { collectASequenceOfCodePoints, collectAnHTTPQuotedString, removeChars, parseMIMEType: parseMIMEType2 } = requireDataUrl();
  const { performance: performance2 } = require$$5$1;
  const { isBlobLike: isBlobLike2, ReadableStreamFrom: ReadableStreamFrom2, isValidHTTPToken: isValidHTTPToken2, normalizedMethodRecordsBase: normalizedMethodRecordsBase2 } = util$n;
  const assert2 = require$$0$3;
  const { isUint8Array } = require$$8$2;
  const { webidl } = requireWebidl();
  let supportedHashes = [];
  let crypto2;
  try {
    crypto2 = require("node:crypto");
    const possibleRelevantHashes = ["sha256", "sha384", "sha512"];
    supportedHashes = crypto2.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
  } catch {
  }
  function responseURL(response2) {
    const urlList = response2.urlList;
    const length = urlList.length;
    return length === 0 ? null : urlList[length - 1].toString();
  }
  function responseLocationURL(response2, requestFragment) {
    if (!redirectStatusSet.has(response2.status)) {
      return null;
    }
    let location = response2.headersList.get("location", true);
    if (location !== null && isValidHeaderValue2(location)) {
      if (!isValidEncodedURL(location)) {
        location = normalizeBinaryStringToUtf8(location);
      }
      location = new URL(location, responseURL(response2));
    }
    if (location && !location.hash) {
      location.hash = requestFragment;
    }
    return location;
  }
  function isValidEncodedURL(url) {
    for (let i = 0; i < url.length; ++i) {
      const code = url.charCodeAt(i);
      if (code > 126 || // Non-US-ASCII + DEL
      code < 32) {
        return false;
      }
    }
    return true;
  }
  function normalizeBinaryStringToUtf8(value) {
    return Buffer.from(value, "binary").toString("utf8");
  }
  function requestCurrentURL(request2) {
    return request2.urlList[request2.urlList.length - 1];
  }
  function requestBadPort(request2) {
    const url = requestCurrentURL(request2);
    if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
      return "blocked";
    }
    return "allowed";
  }
  function isErrorLike(object) {
    var _a2, _b2;
    return object instanceof Error || (((_a2 = object == null ? void 0 : object.constructor) == null ? void 0 : _a2.name) === "Error" || ((_b2 = object == null ? void 0 : object.constructor) == null ? void 0 : _b2.name) === "DOMException");
  }
  function isValidReasonPhrase(statusText) {
    for (let i = 0; i < statusText.length; ++i) {
      const c = statusText.charCodeAt(i);
      if (!(c === 9 || // HTAB
      c >= 32 && c <= 126 || // SP / VCHAR
      c >= 128 && c <= 255)) {
        return false;
      }
    }
    return true;
  }
  const isValidHeaderName = isValidHTTPToken2;
  function isValidHeaderValue2(potentialValue) {
    return (potentialValue[0] === "	" || potentialValue[0] === " " || potentialValue[potentialValue.length - 1] === "	" || potentialValue[potentialValue.length - 1] === " " || potentialValue.includes("\n") || potentialValue.includes("\r") || potentialValue.includes("\0")) === false;
  }
  function setRequestReferrerPolicyOnRedirect(request2, actualResponse) {
    const { headersList } = actualResponse;
    const policyHeader = (headersList.get("referrer-policy", true) ?? "").split(",");
    let policy = "";
    if (policyHeader.length > 0) {
      for (let i = policyHeader.length; i !== 0; i--) {
        const token = policyHeader[i - 1].trim();
        if (referrerPolicyTokens.has(token)) {
          policy = token;
          break;
        }
      }
    }
    if (policy !== "") {
      request2.referrerPolicy = policy;
    }
  }
  function crossOriginResourcePolicyCheck() {
    return "allowed";
  }
  function corsCheck() {
    return "success";
  }
  function TAOCheck() {
    return "success";
  }
  function appendFetchMetadata(httpRequest) {
    let header = null;
    header = httpRequest.mode;
    httpRequest.headersList.set("sec-fetch-mode", header, true);
  }
  function appendRequestOriginHeader(request2) {
    let serializedOrigin = request2.origin;
    if (serializedOrigin === "client" || serializedOrigin === void 0) {
      return;
    }
    if (request2.responseTainting === "cors" || request2.mode === "websocket") {
      request2.headersList.append("origin", serializedOrigin, true);
    } else if (request2.method !== "GET" && request2.method !== "HEAD") {
      switch (request2.referrerPolicy) {
        case "no-referrer":
          serializedOrigin = null;
          break;
        case "no-referrer-when-downgrade":
        case "strict-origin":
        case "strict-origin-when-cross-origin":
          if (request2.origin && urlHasHttpsScheme(request2.origin) && !urlHasHttpsScheme(requestCurrentURL(request2))) {
            serializedOrigin = null;
          }
          break;
        case "same-origin":
          if (!sameOrigin(request2, requestCurrentURL(request2))) {
            serializedOrigin = null;
          }
          break;
      }
      request2.headersList.append("origin", serializedOrigin, true);
    }
  }
  function coarsenTime(timestamp, crossOriginIsolatedCapability) {
    return timestamp;
  }
  function clampAndCoarsenConnectionTimingInfo(connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {
    if (!(connectionTimingInfo == null ? void 0 : connectionTimingInfo.startTime) || connectionTimingInfo.startTime < defaultStartTime) {
      return {
        domainLookupStartTime: defaultStartTime,
        domainLookupEndTime: defaultStartTime,
        connectionStartTime: defaultStartTime,
        connectionEndTime: defaultStartTime,
        secureConnectionStartTime: defaultStartTime,
        ALPNNegotiatedProtocol: connectionTimingInfo == null ? void 0 : connectionTimingInfo.ALPNNegotiatedProtocol
      };
    }
    return {
      domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime),
      domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime),
      connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime),
      connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime),
      secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime),
      ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol
    };
  }
  function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
    return coarsenTime(performance2.now());
  }
  function createOpaqueTimingInfo(timingInfo) {
    return {
      startTime: timingInfo.startTime ?? 0,
      redirectStartTime: 0,
      redirectEndTime: 0,
      postRedirectStartTime: timingInfo.startTime ?? 0,
      finalServiceWorkerStartTime: 0,
      finalNetworkResponseStartTime: 0,
      finalNetworkRequestStartTime: 0,
      endTime: 0,
      encodedBodySize: 0,
      decodedBodySize: 0,
      finalConnectionTimingInfo: null
    };
  }
  function makePolicyContainer() {
    return {
      referrerPolicy: "strict-origin-when-cross-origin"
    };
  }
  function clonePolicyContainer(policyContainer) {
    return {
      referrerPolicy: policyContainer.referrerPolicy
    };
  }
  function determineRequestsReferrer(request2) {
    const policy = request2.referrerPolicy;
    assert2(policy);
    let referrerSource = null;
    if (request2.referrer === "client") {
      const globalOrigin = getGlobalOrigin2();
      if (!globalOrigin || globalOrigin.origin === "null") {
        return "no-referrer";
      }
      referrerSource = new URL(globalOrigin);
    } else if (request2.referrer instanceof URL) {
      referrerSource = request2.referrer;
    }
    let referrerURL = stripURLForReferrer(referrerSource);
    const referrerOrigin = stripURLForReferrer(referrerSource, true);
    if (referrerURL.toString().length > 4096) {
      referrerURL = referrerOrigin;
    }
    const areSameOrigin = sameOrigin(request2, referrerURL);
    const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request2.url);
    switch (policy) {
      case "origin":
        return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
      case "unsafe-url":
        return referrerURL;
      case "same-origin":
        return areSameOrigin ? referrerOrigin : "no-referrer";
      case "origin-when-cross-origin":
        return areSameOrigin ? referrerURL : referrerOrigin;
      case "strict-origin-when-cross-origin": {
        const currentURL = requestCurrentURL(request2);
        if (sameOrigin(referrerURL, currentURL)) {
          return referrerURL;
        }
        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
          return "no-referrer";
        }
        return referrerOrigin;
      }
      case "strict-origin":
      case "no-referrer-when-downgrade":
      default:
        return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
    }
  }
  function stripURLForReferrer(url, originOnly) {
    assert2(url instanceof URL);
    url = new URL(url);
    if (url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:") {
      return "no-referrer";
    }
    url.username = "";
    url.password = "";
    url.hash = "";
    if (originOnly) {
      url.pathname = "";
      url.search = "";
    }
    return url;
  }
  function isURLPotentiallyTrustworthy(url) {
    if (!(url instanceof URL)) {
      return false;
    }
    if (url.href === "about:blank" || url.href === "about:srcdoc") {
      return true;
    }
    if (url.protocol === "data:") return true;
    if (url.protocol === "file:") return true;
    return isOriginPotentiallyTrustworthy(url.origin);
    function isOriginPotentiallyTrustworthy(origin) {
      if (origin == null || origin === "null") return false;
      const originAsURL = new URL(origin);
      if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {
        return true;
      }
      if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost")) {
        return true;
      }
      return false;
    }
  }
  function bytesMatch(bytes, metadataList) {
    if (crypto2 === void 0) {
      return true;
    }
    const parsedMetadata = parseMetadata(metadataList);
    if (parsedMetadata === "no metadata") {
      return true;
    }
    if (parsedMetadata.length === 0) {
      return true;
    }
    const strongest = getStrongestMetadata(parsedMetadata);
    const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
    for (const item of metadata) {
      const algorithm = item.algo;
      const expectedValue = item.hash;
      let actualValue = crypto2.createHash(algorithm).update(bytes).digest("base64");
      if (actualValue[actualValue.length - 1] === "=") {
        if (actualValue[actualValue.length - 2] === "=") {
          actualValue = actualValue.slice(0, -2);
        } else {
          actualValue = actualValue.slice(0, -1);
        }
      }
      if (compareBase64Mixed(actualValue, expectedValue)) {
        return true;
      }
    }
    return false;
  }
  const parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
  function parseMetadata(metadata) {
    const result = [];
    let empty = true;
    for (const token of metadata.split(" ")) {
      empty = false;
      const parsedToken = parseHashWithOptions.exec(token);
      if (parsedToken === null || parsedToken.groups === void 0 || parsedToken.groups.algo === void 0) {
        continue;
      }
      const algorithm = parsedToken.groups.algo.toLowerCase();
      if (supportedHashes.includes(algorithm)) {
        result.push(parsedToken.groups);
      }
    }
    if (empty === true) {
      return "no metadata";
    }
    return result;
  }
  function getStrongestMetadata(metadataList) {
    let algorithm = metadataList[0].algo;
    if (algorithm[3] === "5") {
      return algorithm;
    }
    for (let i = 1; i < metadataList.length; ++i) {
      const metadata = metadataList[i];
      if (metadata.algo[3] === "5") {
        algorithm = "sha512";
        break;
      } else if (algorithm[3] === "3") {
        continue;
      } else if (metadata.algo[3] === "3") {
        algorithm = "sha384";
      }
    }
    return algorithm;
  }
  function filterMetadataListByAlgorithm(metadataList, algorithm) {
    if (metadataList.length === 1) {
      return metadataList;
    }
    let pos = 0;
    for (let i = 0; i < metadataList.length; ++i) {
      if (metadataList[i].algo === algorithm) {
        metadataList[pos++] = metadataList[i];
      }
    }
    metadataList.length = pos;
    return metadataList;
  }
  function compareBase64Mixed(actualValue, expectedValue) {
    if (actualValue.length !== expectedValue.length) {
      return false;
    }
    for (let i = 0; i < actualValue.length; ++i) {
      if (actualValue[i] !== expectedValue[i]) {
        if (actualValue[i] === "+" && expectedValue[i] === "-" || actualValue[i] === "/" && expectedValue[i] === "_") {
          continue;
        }
        return false;
      }
    }
    return true;
  }
  function tryUpgradeRequestToAPotentiallyTrustworthyURL(request2) {
  }
  function sameOrigin(A, B) {
    if (A.origin === B.origin && A.origin === "null") {
      return true;
    }
    if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
      return true;
    }
    return false;
  }
  function createDeferredPromise() {
    let res;
    let rej;
    const promise = new Promise((resolve2, reject) => {
      res = resolve2;
      rej = reject;
    });
    return { promise, resolve: res, reject: rej };
  }
  function isAborted(fetchParams) {
    return fetchParams.controller.state === "aborted";
  }
  function isCancelled(fetchParams) {
    return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
  }
  function normalizeMethod(method) {
    return normalizedMethodRecordsBase2[method.toLowerCase()] ?? method;
  }
  function serializeJavascriptValueToJSONString(value) {
    const result = JSON.stringify(value);
    if (result === void 0) {
      throw new TypeError("Value is not JSON serializable");
    }
    assert2(typeof result === "string");
    return result;
  }
  const esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
  function createIterator(name, kInternalIterator, keyIndex = 0, valueIndex = 1) {
    var _target, _kind, _index;
    class FastIterableIterator {
      /**
       * @see https://webidl.spec.whatwg.org/#dfn-default-iterator-object
       * @param {unknown} target
       * @param {'key' | 'value' | 'key+value'} kind
       */
      constructor(target, kind) {
        /** @type {any} */
        __privateAdd(this, _target);
        /** @type {'key' | 'value' | 'key+value'} */
        __privateAdd(this, _kind);
        /** @type {number} */
        __privateAdd(this, _index);
        __privateSet(this, _target, target);
        __privateSet(this, _kind, kind);
        __privateSet(this, _index, 0);
      }
      next() {
        if (typeof this !== "object" || this === null || !__privateIn(_target, this)) {
          throw new TypeError(
            `'next' called on an object that does not implement interface ${name} Iterator.`
          );
        }
        const index = __privateGet(this, _index);
        const values = __privateGet(this, _target)[kInternalIterator];
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        const { [keyIndex]: key, [valueIndex]: value } = values[index];
        __privateSet(this, _index, index + 1);
        let result;
        switch (__privateGet(this, _kind)) {
          case "key":
            result = key;
            break;
          case "value":
            result = value;
            break;
          case "key+value":
            result = [key, value];
            break;
        }
        return {
          value: result,
          done: false
        };
      }
    }
    _target = new WeakMap();
    _kind = new WeakMap();
    _index = new WeakMap();
    delete FastIterableIterator.prototype.constructor;
    Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype);
    Object.defineProperties(FastIterableIterator.prototype, {
      [Symbol.toStringTag]: {
        writable: false,
        enumerable: false,
        configurable: true,
        value: `${name} Iterator`
      },
      next: { writable: true, enumerable: true, configurable: true }
    });
    return function(target, kind) {
      return new FastIterableIterator(target, kind);
    };
  }
  function iteratorMixin(name, object, kInternalIterator, keyIndex = 0, valueIndex = 1) {
    const makeIterator = createIterator(name, kInternalIterator, keyIndex, valueIndex);
    const properties = {
      keys: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function keys() {
          webidl.brandCheck(this, object);
          return makeIterator(this, "key");
        }
      },
      values: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function values() {
          webidl.brandCheck(this, object);
          return makeIterator(this, "value");
        }
      },
      entries: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function entries() {
          webidl.brandCheck(this, object);
          return makeIterator(this, "key+value");
        }
      },
      forEach: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function forEach(callbackfn, thisArg = globalThis) {
          webidl.brandCheck(this, object);
          webidl.argumentLengthCheck(arguments, 1, `${name}.forEach`);
          if (typeof callbackfn !== "function") {
            throw new TypeError(
              `Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`
            );
          }
          for (const { 0: key, 1: value } of makeIterator(this, "key+value")) {
            callbackfn.call(thisArg, value, key, this);
          }
        }
      }
    };
    return Object.defineProperties(object.prototype, {
      ...properties,
      [Symbol.iterator]: {
        writable: true,
        enumerable: false,
        configurable: true,
        value: properties.entries.value
      }
    });
  }
  async function fullyReadBody(body2, processBody, processBodyError) {
    const successSteps = processBody;
    const errorSteps = processBodyError;
    let reader;
    try {
      reader = body2.stream.getReader();
    } catch (e) {
      errorSteps(e);
      return;
    }
    try {
      successSteps(await readAllBytes(reader));
    } catch (e) {
      errorSteps(e);
    }
  }
  function isReadableStreamLike(stream2) {
    return stream2 instanceof ReadableStream || stream2[Symbol.toStringTag] === "ReadableStream" && typeof stream2.tee === "function";
  }
  function readableStreamClose(controller) {
    var _a2;
    try {
      controller.close();
      (_a2 = controller.byobRequest) == null ? void 0 : _a2.respond(0);
    } catch (err) {
      if (!err.message.includes("Controller is already closed") && !err.message.includes("ReadableStream is already closed")) {
        throw err;
      }
    }
  }
  const invalidIsomorphicEncodeValueRegex = /[^\x00-\xFF]/;
  function isomorphicEncode(input) {
    assert2(!invalidIsomorphicEncodeValueRegex.test(input));
    return input;
  }
  async function readAllBytes(reader) {
    const bytes = [];
    let byteLength = 0;
    while (true) {
      const { done, value: chunk } = await reader.read();
      if (done) {
        return Buffer.concat(bytes, byteLength);
      }
      if (!isUint8Array(chunk)) {
        throw new TypeError("Received non-Uint8Array chunk");
      }
      bytes.push(chunk);
      byteLength += chunk.length;
    }
  }
  function urlIsLocal(url) {
    assert2("protocol" in url);
    const protocol = url.protocol;
    return protocol === "about:" || protocol === "blob:" || protocol === "data:";
  }
  function urlHasHttpsScheme(url) {
    return typeof url === "string" && url[5] === ":" && url[0] === "h" && url[1] === "t" && url[2] === "t" && url[3] === "p" && url[4] === "s" || url.protocol === "https:";
  }
  function urlIsHttpHttpsScheme(url) {
    assert2("protocol" in url);
    const protocol = url.protocol;
    return protocol === "http:" || protocol === "https:";
  }
  function simpleRangeHeaderValue(value, allowWhitespace) {
    const data = value;
    if (!data.startsWith("bytes")) {
      return "failure";
    }
    const position = { position: 5 };
    if (allowWhitespace) {
      collectASequenceOfCodePoints(
        (char) => char === "	" || char === " ",
        data,
        position
      );
    }
    if (data.charCodeAt(position.position) !== 61) {
      return "failure";
    }
    position.position++;
    if (allowWhitespace) {
      collectASequenceOfCodePoints(
        (char) => char === "	" || char === " ",
        data,
        position
      );
    }
    const rangeStart = collectASequenceOfCodePoints(
      (char) => {
        const code = char.charCodeAt(0);
        return code >= 48 && code <= 57;
      },
      data,
      position
    );
    const rangeStartValue = rangeStart.length ? Number(rangeStart) : null;
    if (allowWhitespace) {
      collectASequenceOfCodePoints(
        (char) => char === "	" || char === " ",
        data,
        position
      );
    }
    if (data.charCodeAt(position.position) !== 45) {
      return "failure";
    }
    position.position++;
    if (allowWhitespace) {
      collectASequenceOfCodePoints(
        (char) => char === "	" || char === " ",
        data,
        position
      );
    }
    const rangeEnd = collectASequenceOfCodePoints(
      (char) => {
        const code = char.charCodeAt(0);
        return code >= 48 && code <= 57;
      },
      data,
      position
    );
    const rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null;
    if (position.position < data.length) {
      return "failure";
    }
    if (rangeEndValue === null && rangeStartValue === null) {
      return "failure";
    }
    if (rangeStartValue > rangeEndValue) {
      return "failure";
    }
    return { rangeStartValue, rangeEndValue };
  }
  function buildContentRange(rangeStart, rangeEnd, fullLength) {
    let contentRange = "bytes ";
    contentRange += isomorphicEncode(`${rangeStart}`);
    contentRange += "-";
    contentRange += isomorphicEncode(`${rangeEnd}`);
    contentRange += "/";
    contentRange += isomorphicEncode(`${fullLength}`);
    return contentRange;
  }
  class InflateStream extends Transform2 {
    /** @param {zlib.ZlibOptions} [zlibOptions] */
    constructor(zlibOptions) {
      super();
      __privateAdd(this, _zlibOptions);
      __privateSet(this, _zlibOptions, zlibOptions);
    }
    _transform(chunk, encoding2, callback) {
      if (!this._inflateStream) {
        if (chunk.length === 0) {
          callback();
          return;
        }
        this._inflateStream = (chunk[0] & 15) === 8 ? zlib.createInflate(__privateGet(this, _zlibOptions)) : zlib.createInflateRaw(__privateGet(this, _zlibOptions));
        this._inflateStream.on("data", this.push.bind(this));
        this._inflateStream.on("end", () => this.push(null));
        this._inflateStream.on("error", (err) => this.destroy(err));
      }
      this._inflateStream.write(chunk, encoding2, callback);
    }
    _final(callback) {
      if (this._inflateStream) {
        this._inflateStream.end();
        this._inflateStream = null;
      }
      callback();
    }
  }
  _zlibOptions = new WeakMap();
  function createInflate(zlibOptions) {
    return new InflateStream(zlibOptions);
  }
  function extractMimeType(headers2) {
    let charset = null;
    let essence = null;
    let mimeType = null;
    const values = getDecodeSplit("content-type", headers2);
    if (values === null) {
      return "failure";
    }
    for (const value of values) {
      const temporaryMimeType = parseMIMEType2(value);
      if (temporaryMimeType === "failure" || temporaryMimeType.essence === "*/*") {
        continue;
      }
      mimeType = temporaryMimeType;
      if (mimeType.essence !== essence) {
        charset = null;
        if (mimeType.parameters.has("charset")) {
          charset = mimeType.parameters.get("charset");
        }
        essence = mimeType.essence;
      } else if (!mimeType.parameters.has("charset") && charset !== null) {
        mimeType.parameters.set("charset", charset);
      }
    }
    if (mimeType == null) {
      return "failure";
    }
    return mimeType;
  }
  function gettingDecodingSplitting(value) {
    const input = value;
    const position = { position: 0 };
    const values = [];
    let temporaryValue = "";
    while (position.position < input.length) {
      temporaryValue += collectASequenceOfCodePoints(
        (char) => char !== '"' && char !== ",",
        input,
        position
      );
      if (position.position < input.length) {
        if (input.charCodeAt(position.position) === 34) {
          temporaryValue += collectAnHTTPQuotedString(
            input,
            position
          );
          if (position.position < input.length) {
            continue;
          }
        } else {
          assert2(input.charCodeAt(position.position) === 44);
          position.position++;
        }
      }
      temporaryValue = removeChars(temporaryValue, true, true, (char) => char === 9 || char === 32);
      values.push(temporaryValue);
      temporaryValue = "";
    }
    return values;
  }
  function getDecodeSplit(name, list) {
    const value = list.get(name, true);
    if (value === null) {
      return null;
    }
    return gettingDecodingSplitting(value);
  }
  const textDecoder = new TextDecoder();
  function utf8DecodeBytes(buffer) {
    if (buffer.length === 0) {
      return "";
    }
    if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
      buffer = buffer.subarray(3);
    }
    const output = textDecoder.decode(buffer);
    return output;
  }
  class EnvironmentSettingsObjectBase {
    constructor() {
      __publicField(this, "policyContainer", makePolicyContainer());
    }
    get baseUrl() {
      return getGlobalOrigin2();
    }
    get origin() {
      var _a2;
      return (_a2 = this.baseUrl) == null ? void 0 : _a2.origin;
    }
  }
  class EnvironmentSettingsObject {
    constructor() {
      __publicField(this, "settingsObject", new EnvironmentSettingsObjectBase());
    }
  }
  const environmentSettingsObject = new EnvironmentSettingsObject();
  util$k = {
    isAborted,
    isCancelled,
    isValidEncodedURL,
    createDeferredPromise,
    ReadableStreamFrom: ReadableStreamFrom2,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    clampAndCoarsenConnectionTimingInfo,
    coarsenedSharedCurrentTime,
    determineRequestsReferrer,
    makePolicyContainer,
    clonePolicyContainer,
    appendFetchMetadata,
    appendRequestOriginHeader,
    TAOCheck,
    corsCheck,
    crossOriginResourcePolicyCheck,
    createOpaqueTimingInfo,
    setRequestReferrerPolicyOnRedirect,
    isValidHTTPToken: isValidHTTPToken2,
    requestBadPort,
    requestCurrentURL,
    responseURL,
    responseLocationURL,
    isBlobLike: isBlobLike2,
    isURLPotentiallyTrustworthy,
    isValidReasonPhrase,
    sameOrigin,
    normalizeMethod,
    serializeJavascriptValueToJSONString,
    iteratorMixin,
    createIterator,
    isValidHeaderName,
    isValidHeaderValue: isValidHeaderValue2,
    isErrorLike,
    fullyReadBody,
    bytesMatch,
    isReadableStreamLike,
    readableStreamClose,
    isomorphicEncode,
    urlIsLocal,
    urlHasHttpsScheme,
    urlIsHttpHttpsScheme,
    readAllBytes,
    simpleRangeHeaderValue,
    buildContentRange,
    parseMetadata,
    createInflate,
    extractMimeType,
    getDecodeSplit,
    utf8DecodeBytes,
    environmentSettingsObject
  };
  return util$k;
}
var symbols$3;
var hasRequiredSymbols$3;
function requireSymbols$3() {
  if (hasRequiredSymbols$3) return symbols$3;
  hasRequiredSymbols$3 = 1;
  symbols$3 = {
    kUrl: Symbol("url"),
    kHeaders: Symbol("headers"),
    kSignal: Symbol("signal"),
    kState: Symbol("state"),
    kDispatcher: Symbol("dispatcher")
  };
  return symbols$3;
}
var file;
var hasRequiredFile;
function requireFile() {
  if (hasRequiredFile) return file;
  hasRequiredFile = 1;
  const { Blob: Blob2, File } = require$$0$1;
  const { kState } = requireSymbols$3();
  const { webidl } = requireWebidl();
  class FileLike {
    constructor(blobLike, fileName, options = {}) {
      const n = fileName;
      const t = options.type;
      const d = options.lastModified ?? Date.now();
      this[kState] = {
        blobLike,
        name: n,
        type: t,
        lastModified: d
      };
    }
    stream(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.stream(...args);
    }
    arrayBuffer(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.arrayBuffer(...args);
    }
    slice(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.slice(...args);
    }
    text(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.text(...args);
    }
    get size() {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.size;
    }
    get type() {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.type;
    }
    get name() {
      webidl.brandCheck(this, FileLike);
      return this[kState].name;
    }
    get lastModified() {
      webidl.brandCheck(this, FileLike);
      return this[kState].lastModified;
    }
    get [Symbol.toStringTag]() {
      return "File";
    }
  }
  webidl.converters.Blob = webidl.interfaceConverter(Blob2);
  function isFileLike(object) {
    return object instanceof File || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
  }
  file = { FileLike, isFileLike };
  return file;
}
var formdata;
var hasRequiredFormdata;
function requireFormdata() {
  if (hasRequiredFormdata) return formdata;
  hasRequiredFormdata = 1;
  const { isBlobLike: isBlobLike2, iteratorMixin } = requireUtil$5();
  const { kState } = requireSymbols$3();
  const { kEnumerableProperty: kEnumerableProperty2 } = util$n;
  const { FileLike, isFileLike } = requireFile();
  const { webidl } = requireWebidl();
  const { File: NativeFile } = require$$0$1;
  const nodeUtil2 = require$$0$2;
  const File = globalThis.File ?? NativeFile;
  class FormData {
    constructor(form) {
      webidl.util.markAsUncloneable(this);
      if (form !== void 0) {
        throw webidl.errors.conversionFailed({
          prefix: "FormData constructor",
          argument: "Argument 1",
          types: ["undefined"]
        });
      }
      this[kState] = [];
    }
    append(name, value, filename = void 0) {
      webidl.brandCheck(this, FormData);
      const prefix = "FormData.append";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      if (arguments.length === 3 && !isBlobLike2(value)) {
        throw new TypeError(
          "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
        );
      }
      name = webidl.converters.USVString(name, prefix, "name");
      value = isBlobLike2(value) ? webidl.converters.Blob(value, prefix, "value", { strict: false }) : webidl.converters.USVString(value, prefix, "value");
      filename = arguments.length === 3 ? webidl.converters.USVString(filename, prefix, "filename") : void 0;
      const entry = makeEntry(name, value, filename);
      this[kState].push(entry);
    }
    delete(name) {
      webidl.brandCheck(this, FormData);
      const prefix = "FormData.delete";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name, prefix, "name");
      this[kState] = this[kState].filter((entry) => entry.name !== name);
    }
    get(name) {
      webidl.brandCheck(this, FormData);
      const prefix = "FormData.get";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name, prefix, "name");
      const idx = this[kState].findIndex((entry) => entry.name === name);
      if (idx === -1) {
        return null;
      }
      return this[kState][idx].value;
    }
    getAll(name) {
      webidl.brandCheck(this, FormData);
      const prefix = "FormData.getAll";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name, prefix, "name");
      return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
    }
    has(name) {
      webidl.brandCheck(this, FormData);
      const prefix = "FormData.has";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name, prefix, "name");
      return this[kState].findIndex((entry) => entry.name === name) !== -1;
    }
    set(name, value, filename = void 0) {
      webidl.brandCheck(this, FormData);
      const prefix = "FormData.set";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      if (arguments.length === 3 && !isBlobLike2(value)) {
        throw new TypeError(
          "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
        );
      }
      name = webidl.converters.USVString(name, prefix, "name");
      value = isBlobLike2(value) ? webidl.converters.Blob(value, prefix, "name", { strict: false }) : webidl.converters.USVString(value, prefix, "name");
      filename = arguments.length === 3 ? webidl.converters.USVString(filename, prefix, "name") : void 0;
      const entry = makeEntry(name, value, filename);
      const idx = this[kState].findIndex((entry2) => entry2.name === name);
      if (idx !== -1) {
        this[kState] = [
          ...this[kState].slice(0, idx),
          entry,
          ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
        ];
      } else {
        this[kState].push(entry);
      }
    }
    [nodeUtil2.inspect.custom](depth, options) {
      const state = this[kState].reduce((a, b) => {
        if (a[b.name]) {
          if (Array.isArray(a[b.name])) {
            a[b.name].push(b.value);
          } else {
            a[b.name] = [a[b.name], b.value];
          }
        } else {
          a[b.name] = b.value;
        }
        return a;
      }, { __proto__: null });
      options.depth ?? (options.depth = depth);
      options.colors ?? (options.colors = true);
      const output = nodeUtil2.formatWithOptions(options, state);
      return `FormData ${output.slice(output.indexOf("]") + 2)}`;
    }
  }
  iteratorMixin("FormData", FormData, kState, "name", "value");
  Object.defineProperties(FormData.prototype, {
    append: kEnumerableProperty2,
    delete: kEnumerableProperty2,
    get: kEnumerableProperty2,
    getAll: kEnumerableProperty2,
    has: kEnumerableProperty2,
    set: kEnumerableProperty2,
    [Symbol.toStringTag]: {
      value: "FormData",
      configurable: true
    }
  });
  function makeEntry(name, value, filename) {
    if (typeof value === "string") ;
    else {
      if (!isFileLike(value)) {
        value = value instanceof Blob ? new File([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
      }
      if (filename !== void 0) {
        const options = {
          type: value.type,
          lastModified: value.lastModified
        };
        value = value instanceof NativeFile ? new File([value], filename, options) : new FileLike(value, filename, options);
      }
    }
    return { name, value };
  }
  formdata = { FormData, makeEntry };
  return formdata;
}
var formdataParser;
var hasRequiredFormdataParser;
function requireFormdataParser() {
  if (hasRequiredFormdataParser) return formdataParser;
  hasRequiredFormdataParser = 1;
  const { isUSVString: isUSVString2, bufferToLowerCasedHeaderName: bufferToLowerCasedHeaderName2 } = util$n;
  const { utf8DecodeBytes } = requireUtil$5();
  const { HTTP_TOKEN_CODEPOINTS, isomorphicDecode } = requireDataUrl();
  const { isFileLike } = requireFile();
  const { makeEntry } = requireFormdata();
  const assert2 = require$$0$3;
  const { File: NodeFile } = require$$0$1;
  const File = globalThis.File ?? NodeFile;
  const formDataNameBuffer = Buffer.from('form-data; name="');
  const filenameBuffer = Buffer.from("; filename");
  const dd = Buffer.from("--");
  const ddcrlf = Buffer.from("--\r\n");
  function isAsciiString(chars) {
    for (let i = 0; i < chars.length; ++i) {
      if ((chars.charCodeAt(i) & -128) !== 0) {
        return false;
      }
    }
    return true;
  }
  function validateBoundary(boundary) {
    const length = boundary.length;
    if (length < 27 || length > 70) {
      return false;
    }
    for (let i = 0; i < length; ++i) {
      const cp = boundary.charCodeAt(i);
      if (!(cp >= 48 && cp <= 57 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 39 || cp === 45 || cp === 95)) {
        return false;
      }
    }
    return true;
  }
  function multipartFormDataParser(input, mimeType) {
    assert2(mimeType !== "failure" && mimeType.essence === "multipart/form-data");
    const boundaryString = mimeType.parameters.get("boundary");
    if (boundaryString === void 0) {
      return "failure";
    }
    const boundary = Buffer.from(`--${boundaryString}`, "utf8");
    const entryList = [];
    const position = { position: 0 };
    while (input[position.position] === 13 && input[position.position + 1] === 10) {
      position.position += 2;
    }
    let trailing = input.length;
    while (input[trailing - 1] === 10 && input[trailing - 2] === 13) {
      trailing -= 2;
    }
    if (trailing !== input.length) {
      input = input.subarray(0, trailing);
    }
    while (true) {
      if (input.subarray(position.position, position.position + boundary.length).equals(boundary)) {
        position.position += boundary.length;
      } else {
        return "failure";
      }
      if (position.position === input.length - 2 && bufferStartsWith(input, dd, position) || position.position === input.length - 4 && bufferStartsWith(input, ddcrlf, position)) {
        return entryList;
      }
      if (input[position.position] !== 13 || input[position.position + 1] !== 10) {
        return "failure";
      }
      position.position += 2;
      const result = parseMultipartFormDataHeaders(input, position);
      if (result === "failure") {
        return "failure";
      }
      let { name, filename, contentType, encoding: encoding2 } = result;
      position.position += 2;
      let body2;
      {
        const boundaryIndex = input.indexOf(boundary.subarray(2), position.position);
        if (boundaryIndex === -1) {
          return "failure";
        }
        body2 = input.subarray(position.position, boundaryIndex - 4);
        position.position += body2.length;
        if (encoding2 === "base64") {
          body2 = Buffer.from(body2.toString(), "base64");
        }
      }
      if (input[position.position] !== 13 || input[position.position + 1] !== 10) {
        return "failure";
      } else {
        position.position += 2;
      }
      let value;
      if (filename !== null) {
        contentType ?? (contentType = "text/plain");
        if (!isAsciiString(contentType)) {
          contentType = "";
        }
        value = new File([body2], filename, { type: contentType });
      } else {
        value = utf8DecodeBytes(Buffer.from(body2));
      }
      assert2(isUSVString2(name));
      assert2(typeof value === "string" && isUSVString2(value) || isFileLike(value));
      entryList.push(makeEntry(name, value, filename));
    }
  }
  function parseMultipartFormDataHeaders(input, position) {
    let name = null;
    let filename = null;
    let contentType = null;
    let encoding2 = null;
    while (true) {
      if (input[position.position] === 13 && input[position.position + 1] === 10) {
        if (name === null) {
          return "failure";
        }
        return { name, filename, contentType, encoding: encoding2 };
      }
      let headerName = collectASequenceOfBytes(
        (char) => char !== 10 && char !== 13 && char !== 58,
        input,
        position
      );
      headerName = removeChars(headerName, true, true, (char) => char === 9 || char === 32);
      if (!HTTP_TOKEN_CODEPOINTS.test(headerName.toString())) {
        return "failure";
      }
      if (input[position.position] !== 58) {
        return "failure";
      }
      position.position++;
      collectASequenceOfBytes(
        (char) => char === 32 || char === 9,
        input,
        position
      );
      switch (bufferToLowerCasedHeaderName2(headerName)) {
        case "content-disposition": {
          name = filename = null;
          if (!bufferStartsWith(input, formDataNameBuffer, position)) {
            return "failure";
          }
          position.position += 17;
          name = parseMultipartFormDataName(input, position);
          if (name === null) {
            return "failure";
          }
          if (bufferStartsWith(input, filenameBuffer, position)) {
            let check = position.position + filenameBuffer.length;
            if (input[check] === 42) {
              position.position += 1;
              check += 1;
            }
            if (input[check] !== 61 || input[check + 1] !== 34) {
              return "failure";
            }
            position.position += 12;
            filename = parseMultipartFormDataName(input, position);
            if (filename === null) {
              return "failure";
            }
          }
          break;
        }
        case "content-type": {
          let headerValue = collectASequenceOfBytes(
            (char) => char !== 10 && char !== 13,
            input,
            position
          );
          headerValue = removeChars(headerValue, false, true, (char) => char === 9 || char === 32);
          contentType = isomorphicDecode(headerValue);
          break;
        }
        case "content-transfer-encoding": {
          let headerValue = collectASequenceOfBytes(
            (char) => char !== 10 && char !== 13,
            input,
            position
          );
          headerValue = removeChars(headerValue, false, true, (char) => char === 9 || char === 32);
          encoding2 = isomorphicDecode(headerValue);
          break;
        }
        default: {
          collectASequenceOfBytes(
            (char) => char !== 10 && char !== 13,
            input,
            position
          );
        }
      }
      if (input[position.position] !== 13 && input[position.position + 1] !== 10) {
        return "failure";
      } else {
        position.position += 2;
      }
    }
  }
  function parseMultipartFormDataName(input, position) {
    assert2(input[position.position - 1] === 34);
    let name = collectASequenceOfBytes(
      (char) => char !== 10 && char !== 13 && char !== 34,
      input,
      position
    );
    if (input[position.position] !== 34) {
      return null;
    } else {
      position.position++;
    }
    name = new TextDecoder().decode(name).replace(/%0A/ig, "\n").replace(/%0D/ig, "\r").replace(/%22/g, '"');
    return name;
  }
  function collectASequenceOfBytes(condition, input, position) {
    let start = position.position;
    while (start < input.length && condition(input[start])) {
      ++start;
    }
    return input.subarray(position.position, position.position = start);
  }
  function removeChars(buf, leading, trailing, predicate) {
    let lead = 0;
    let trail = buf.length - 1;
    if (leading) {
      while (lead < buf.length && predicate(buf[lead])) lead++;
    }
    {
      while (trail > 0 && predicate(buf[trail])) trail--;
    }
    return lead === 0 && trail === buf.length - 1 ? buf : buf.subarray(lead, trail + 1);
  }
  function bufferStartsWith(buffer, start, position) {
    if (buffer.length < start.length) {
      return false;
    }
    for (let i = 0; i < start.length; i++) {
      if (start[i] !== buffer[position.position + i]) {
        return false;
      }
    }
    return true;
  }
  formdataParser = {
    multipartFormDataParser,
    validateBoundary
  };
  return formdataParser;
}
var body;
var hasRequiredBody;
function requireBody() {
  if (hasRequiredBody) return body;
  hasRequiredBody = 1;
  const util2 = util$n;
  const {
    ReadableStreamFrom: ReadableStreamFrom2,
    isBlobLike: isBlobLike2,
    isReadableStreamLike,
    readableStreamClose,
    createDeferredPromise,
    fullyReadBody,
    extractMimeType,
    utf8DecodeBytes
  } = requireUtil$5();
  const { FormData } = requireFormdata();
  const { kState } = requireSymbols$3();
  const { webidl } = requireWebidl();
  const { Blob: Blob2 } = require$$0$1;
  const assert2 = require$$0$3;
  const { isErrored: isErrored2, isDisturbed: isDisturbed2 } = require$$0$4;
  const { isArrayBuffer } = require$$8$2;
  const { serializeAMimeType: serializeAMimeType2 } = requireDataUrl();
  const { multipartFormDataParser } = requireFormdataParser();
  let random;
  try {
    const crypto2 = require("node:crypto");
    random = (max) => crypto2.randomInt(0, max);
  } catch {
    random = (max) => Math.floor(Math.random(max));
  }
  const textEncoder = new TextEncoder();
  function noop2() {
  }
  const hasFinalizationRegistry = globalThis.FinalizationRegistry && process.version.indexOf("v18") !== 0;
  let streamRegistry;
  if (hasFinalizationRegistry) {
    streamRegistry = new FinalizationRegistry((weakRef) => {
      const stream2 = weakRef.deref();
      if (stream2 && !stream2.locked && !isDisturbed2(stream2) && !isErrored2(stream2)) {
        stream2.cancel("Response object has been garbage collected").catch(noop2);
      }
    });
  }
  function extractBody2(object, keepalive = false) {
    let stream2 = null;
    if (object instanceof ReadableStream) {
      stream2 = object;
    } else if (isBlobLike2(object)) {
      stream2 = object.stream();
    } else {
      stream2 = new ReadableStream({
        async pull(controller) {
          const buffer = typeof source === "string" ? textEncoder.encode(source) : source;
          if (buffer.byteLength) {
            controller.enqueue(buffer);
          }
          queueMicrotask(() => readableStreamClose(controller));
        },
        start() {
        },
        type: "bytes"
      });
    }
    assert2(isReadableStreamLike(stream2));
    let action = null;
    let source = null;
    let length = null;
    let type = null;
    if (typeof object === "string") {
      source = object;
      type = "text/plain;charset=UTF-8";
    } else if (object instanceof URLSearchParams) {
      source = object.toString();
      type = "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isArrayBuffer(object)) {
      source = new Uint8Array(object.slice());
    } else if (ArrayBuffer.isView(object)) {
      source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
    } else if (util2.isFormDataLike(object)) {
      const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, "0")}`;
      const prefix = `--${boundary}\r
Content-Disposition: form-data`;
      /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
      const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
      const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
      const blobParts = [];
      const rn = new Uint8Array([13, 10]);
      length = 0;
      let hasUnknownSizeValue = false;
      for (const [name, value] of object) {
        if (typeof value === "string") {
          const chunk2 = textEncoder.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
          blobParts.push(chunk2);
          length += chunk2.byteLength;
        } else {
          const chunk2 = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
          blobParts.push(chunk2, value, rn);
          if (typeof value.size === "number") {
            length += chunk2.byteLength + value.size + rn.byteLength;
          } else {
            hasUnknownSizeValue = true;
          }
        }
      }
      const chunk = textEncoder.encode(`--${boundary}--`);
      blobParts.push(chunk);
      length += chunk.byteLength;
      if (hasUnknownSizeValue) {
        length = null;
      }
      source = object;
      action = async function* () {
        for (const part of blobParts) {
          if (part.stream) {
            yield* part.stream();
          } else {
            yield part;
          }
        }
      };
      type = `multipart/form-data; boundary=${boundary}`;
    } else if (isBlobLike2(object)) {
      source = object;
      length = object.size;
      if (object.type) {
        type = object.type;
      }
    } else if (typeof object[Symbol.asyncIterator] === "function") {
      if (keepalive) {
        throw new TypeError("keepalive");
      }
      if (util2.isDisturbed(object) || object.locked) {
        throw new TypeError(
          "Response body object should not be disturbed or locked"
        );
      }
      stream2 = object instanceof ReadableStream ? object : ReadableStreamFrom2(object);
    }
    if (typeof source === "string" || util2.isBuffer(source)) {
      length = Buffer.byteLength(source);
    }
    if (action != null) {
      let iterator;
      stream2 = new ReadableStream({
        async start() {
          iterator = action(object)[Symbol.asyncIterator]();
        },
        async pull(controller) {
          const { value, done } = await iterator.next();
          if (done) {
            queueMicrotask(() => {
              var _a2;
              controller.close();
              (_a2 = controller.byobRequest) == null ? void 0 : _a2.respond(0);
            });
          } else {
            if (!isErrored2(stream2)) {
              const buffer = new Uint8Array(value);
              if (buffer.byteLength) {
                controller.enqueue(buffer);
              }
            }
          }
          return controller.desiredSize > 0;
        },
        async cancel(reason) {
          await iterator.return();
        },
        type: "bytes"
      });
    }
    const body2 = { stream: stream2, source, length };
    return [body2, type];
  }
  function safelyExtractBody(object, keepalive = false) {
    if (object instanceof ReadableStream) {
      assert2(!util2.isDisturbed(object), "The body has already been consumed.");
      assert2(!object.locked, "The stream is locked.");
    }
    return extractBody2(object, keepalive);
  }
  function cloneBody(instance, body2) {
    const [out1, out2] = body2.stream.tee();
    if (hasFinalizationRegistry) {
      streamRegistry.register(instance, new WeakRef(out1));
    }
    body2.stream = out1;
    return {
      stream: out2,
      length: body2.length,
      source: body2.source
    };
  }
  function throwIfAborted(state) {
    if (state.aborted) {
      throw new DOMException("The operation was aborted.", "AbortError");
    }
  }
  function bodyMixinMethods(instance) {
    const methods = {
      blob() {
        return consumeBody(this, (bytes) => {
          let mimeType = bodyMimeType(this);
          if (mimeType === null) {
            mimeType = "";
          } else if (mimeType) {
            mimeType = serializeAMimeType2(mimeType);
          }
          return new Blob2([bytes], { type: mimeType });
        }, instance);
      },
      arrayBuffer() {
        return consumeBody(this, (bytes) => {
          return new Uint8Array(bytes).buffer;
        }, instance);
      },
      text() {
        return consumeBody(this, utf8DecodeBytes, instance);
      },
      json() {
        return consumeBody(this, parseJSONFromBytes, instance);
      },
      formData() {
        return consumeBody(this, (value) => {
          const mimeType = bodyMimeType(this);
          if (mimeType !== null) {
            switch (mimeType.essence) {
              case "multipart/form-data": {
                const parsed = multipartFormDataParser(value, mimeType);
                if (parsed === "failure") {
                  throw new TypeError("Failed to parse body as FormData.");
                }
                const fd = new FormData();
                fd[kState] = parsed;
                return fd;
              }
              case "application/x-www-form-urlencoded": {
                const entries = new URLSearchParams(value.toString());
                const fd = new FormData();
                for (const [name, value2] of entries) {
                  fd.append(name, value2);
                }
                return fd;
              }
            }
          }
          throw new TypeError(
            'Content-Type was not one of "multipart/form-data" or "application/x-www-form-urlencoded".'
          );
        }, instance);
      },
      bytes() {
        return consumeBody(this, (bytes) => {
          return new Uint8Array(bytes);
        }, instance);
      }
    };
    return methods;
  }
  function mixinBody(prototype) {
    Object.assign(prototype.prototype, bodyMixinMethods(prototype));
  }
  async function consumeBody(object, convertBytesToJSValue, instance) {
    webidl.brandCheck(object, instance);
    if (bodyUnusable(object)) {
      throw new TypeError("Body is unusable: Body has already been read");
    }
    throwIfAborted(object[kState]);
    const promise = createDeferredPromise();
    const errorSteps = (error) => promise.reject(error);
    const successSteps = (data) => {
      try {
        promise.resolve(convertBytesToJSValue(data));
      } catch (e) {
        errorSteps(e);
      }
    };
    if (object[kState].body == null) {
      successSteps(Buffer.allocUnsafe(0));
      return promise.promise;
    }
    await fullyReadBody(object[kState].body, successSteps, errorSteps);
    return promise.promise;
  }
  function bodyUnusable(object) {
    const body2 = object[kState].body;
    return body2 != null && (body2.stream.locked || util2.isDisturbed(body2.stream));
  }
  function parseJSONFromBytes(bytes) {
    return JSON.parse(utf8DecodeBytes(bytes));
  }
  function bodyMimeType(requestOrResponse) {
    const headers2 = requestOrResponse[kState].headersList;
    const mimeType = extractMimeType(headers2);
    if (mimeType === "failure") {
      return null;
    }
    return mimeType;
  }
  body = {
    extractBody: extractBody2,
    safelyExtractBody,
    cloneBody,
    mixinBody,
    streamRegistry,
    hasFinalizationRegistry,
    bodyUnusable
  };
  return body;
}
const assert$b = require$$0$3;
const util$j = util$n;
const { channels: channels$1 } = diagnostics;
const timers = timers$2;
const {
  RequestContentLengthMismatchError: RequestContentLengthMismatchError$1,
  ResponseContentLengthMismatchError: ResponseContentLengthMismatchError3,
  RequestAbortedError: RequestAbortedError$7,
  HeadersTimeoutError: HeadersTimeoutError3,
  HeadersOverflowError: HeadersOverflowError3,
  SocketError: SocketError$3,
  InformationalError: InformationalError$3,
  BodyTimeoutError: BodyTimeoutError3,
  HTTPParserError: HTTPParserError3,
  ResponseExceededMaxSizeError: ResponseExceededMaxSizeError3
} = errors$1;
const {
  kUrl: kUrl$5,
  kReset: kReset$1,
  kClient: kClient$3,
  kParser,
  kBlocking,
  kRunning: kRunning$5,
  kPending: kPending$4,
  kSize: kSize$5,
  kWriting,
  kQueue: kQueue$3,
  kNoRef,
  kKeepAliveDefaultTimeout: kKeepAliveDefaultTimeout$1,
  kHostHeader: kHostHeader$1,
  kPendingIdx: kPendingIdx$2,
  kRunningIdx: kRunningIdx$2,
  kError: kError$2,
  kPipelining: kPipelining$1,
  kSocket: kSocket$1,
  kKeepAliveTimeoutValue: kKeepAliveTimeoutValue$1,
  kMaxHeadersSize: kMaxHeadersSize$1,
  kKeepAliveMaxTimeout: kKeepAliveMaxTimeout$1,
  kKeepAliveTimeoutThreshold: kKeepAliveTimeoutThreshold$1,
  kHeadersTimeout: kHeadersTimeout$1,
  kBodyTimeout: kBodyTimeout$1,
  kStrictContentLength: kStrictContentLength$2,
  kMaxRequests: kMaxRequests$1,
  kCounter: kCounter$1,
  kMaxResponseSize: kMaxResponseSize$1,
  kOnError: kOnError$2,
  kResume: kResume$3,
  kHTTPContext: kHTTPContext$2
} = symbols$4;
const constants$2 = constants$4;
const EMPTY_BUF = Buffer.alloc(0);
const FastBuffer = Buffer[Symbol.species];
const addListener = util$j.addListener;
const removeAllListeners = util$j.removeAllListeners;
let extractBody$1;
async function lazyllhttp() {
  const llhttpWasmData = process.env.JEST_WORKER_ID ? requireLlhttpWasm() : void 0;
  let mod;
  try {
    mod = await WebAssembly.compile(requireLlhttp_simdWasm());
  } catch (e) {
    mod = await WebAssembly.compile(llhttpWasmData || requireLlhttpWasm());
  }
  return await WebAssembly.instantiate(mod, {
    env: {
      /* eslint-disable camelcase */
      wasm_on_url: (p, at, len) => {
        return 0;
      },
      wasm_on_status: (p, at, len) => {
        assert$b(currentParser.ptr === p);
        const start = at - currentBufferPtr + currentBufferRef.byteOffset;
        return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
      },
      wasm_on_message_begin: (p) => {
        assert$b(currentParser.ptr === p);
        return currentParser.onMessageBegin() || 0;
      },
      wasm_on_header_field: (p, at, len) => {
        assert$b(currentParser.ptr === p);
        const start = at - currentBufferPtr + currentBufferRef.byteOffset;
        return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
      },
      wasm_on_header_value: (p, at, len) => {
        assert$b(currentParser.ptr === p);
        const start = at - currentBufferPtr + currentBufferRef.byteOffset;
        return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
      },
      wasm_on_headers_complete: (p, statusCode, upgrade2, shouldKeepAlive) => {
        assert$b(currentParser.ptr === p);
        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade2), Boolean(shouldKeepAlive)) || 0;
      },
      wasm_on_body: (p, at, len) => {
        assert$b(currentParser.ptr === p);
        const start = at - currentBufferPtr + currentBufferRef.byteOffset;
        return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
      },
      wasm_on_message_complete: (p) => {
        assert$b(currentParser.ptr === p);
        return currentParser.onMessageComplete() || 0;
      }
      /* eslint-enable camelcase */
    }
  });
}
let llhttpInstance = null;
let llhttpPromise = lazyllhttp();
llhttpPromise.catch();
let currentParser = null;
let currentBufferRef = null;
let currentBufferSize = 0;
let currentBufferPtr = null;
const USE_NATIVE_TIMER = 0;
const USE_FAST_TIMER = 1;
const TIMEOUT_HEADERS = 2 | USE_FAST_TIMER;
const TIMEOUT_BODY = 4 | USE_FAST_TIMER;
const TIMEOUT_KEEP_ALIVE = 8 | USE_NATIVE_TIMER;
class Parser2 {
  constructor(client2, socket, { exports }) {
    assert$b(Number.isFinite(client2[kMaxHeadersSize$1]) && client2[kMaxHeadersSize$1] > 0);
    this.llhttp = exports;
    this.ptr = this.llhttp.llhttp_alloc(constants$2.TYPE.RESPONSE);
    this.client = client2;
    this.socket = socket;
    this.timeout = null;
    this.timeoutValue = null;
    this.timeoutType = null;
    this.statusCode = null;
    this.statusText = "";
    this.upgrade = false;
    this.headers = [];
    this.headersSize = 0;
    this.headersMaxSize = client2[kMaxHeadersSize$1];
    this.shouldKeepAlive = false;
    this.paused = false;
    this.resume = this.resume.bind(this);
    this.bytesRead = 0;
    this.keepAlive = "";
    this.contentLength = "";
    this.connection = "";
    this.maxResponseSize = client2[kMaxResponseSize$1];
  }
  setTimeout(delay, type) {
    if (delay !== this.timeoutValue || type & USE_FAST_TIMER ^ this.timeoutType & USE_FAST_TIMER) {
      if (this.timeout) {
        timers.clearTimeout(this.timeout);
        this.timeout = null;
      }
      if (delay) {
        if (type & USE_FAST_TIMER) {
          this.timeout = timers.setFastTimeout(onParserTimeout, delay, new WeakRef(this));
        } else {
          this.timeout = setTimeout(onParserTimeout, delay, new WeakRef(this));
          this.timeout.unref();
        }
      }
      this.timeoutValue = delay;
    } else if (this.timeout) {
      if (this.timeout.refresh) {
        this.timeout.refresh();
      }
    }
    this.timeoutType = type;
  }
  resume() {
    if (this.socket.destroyed || !this.paused) {
      return;
    }
    assert$b(this.ptr != null);
    assert$b(currentParser == null);
    this.llhttp.llhttp_resume(this.ptr);
    assert$b(this.timeoutType === TIMEOUT_BODY);
    if (this.timeout) {
      if (this.timeout.refresh) {
        this.timeout.refresh();
      }
    }
    this.paused = false;
    this.execute(this.socket.read() || EMPTY_BUF);
    this.readMore();
  }
  readMore() {
    while (!this.paused && this.ptr) {
      const chunk = this.socket.read();
      if (chunk === null) {
        break;
      }
      this.execute(chunk);
    }
  }
  execute(data) {
    assert$b(this.ptr != null);
    assert$b(currentParser == null);
    assert$b(!this.paused);
    const { socket, llhttp } = this;
    if (data.length > currentBufferSize) {
      if (currentBufferPtr) {
        llhttp.free(currentBufferPtr);
      }
      currentBufferSize = Math.ceil(data.length / 4096) * 4096;
      currentBufferPtr = llhttp.malloc(currentBufferSize);
    }
    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
    try {
      let ret;
      try {
        currentBufferRef = data;
        currentParser = this;
        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
      } catch (err) {
        throw err;
      } finally {
        currentParser = null;
        currentBufferRef = null;
      }
      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
      if (ret === constants$2.ERROR.PAUSED_UPGRADE) {
        this.onUpgrade(data.slice(offset));
      } else if (ret === constants$2.ERROR.PAUSED) {
        this.paused = true;
        socket.unshift(data.slice(offset));
      } else if (ret !== constants$2.ERROR.OK) {
        const ptr = llhttp.llhttp_get_error_reason(this.ptr);
        let message = "";
        if (ptr) {
          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
          message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
        }
        throw new HTTPParserError3(message, constants$2.ERROR[ret], data.slice(offset));
      }
    } catch (err) {
      util$j.destroy(socket, err);
    }
  }
  destroy() {
    assert$b(this.ptr != null);
    assert$b(currentParser == null);
    this.llhttp.llhttp_free(this.ptr);
    this.ptr = null;
    this.timeout && timers.clearTimeout(this.timeout);
    this.timeout = null;
    this.timeoutValue = null;
    this.timeoutType = null;
    this.paused = false;
  }
  onStatus(buf) {
    this.statusText = buf.toString();
  }
  onMessageBegin() {
    const { socket, client: client2 } = this;
    if (socket.destroyed) {
      return -1;
    }
    const request2 = client2[kQueue$3][client2[kRunningIdx$2]];
    if (!request2) {
      return -1;
    }
    request2.onResponseStarted();
  }
  onHeaderField(buf) {
    const len = this.headers.length;
    if ((len & 1) === 0) {
      this.headers.push(buf);
    } else {
      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
    }
    this.trackHeader(buf.length);
  }
  onHeaderValue(buf) {
    let len = this.headers.length;
    if ((len & 1) === 1) {
      this.headers.push(buf);
      len += 1;
    } else {
      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
    }
    const key = this.headers[len - 2];
    if (key.length === 10) {
      const headerName = util$j.bufferToLowerCasedHeaderName(key);
      if (headerName === "keep-alive") {
        this.keepAlive += buf.toString();
      } else if (headerName === "connection") {
        this.connection += buf.toString();
      }
    } else if (key.length === 14 && util$j.bufferToLowerCasedHeaderName(key) === "content-length") {
      this.contentLength += buf.toString();
    }
    this.trackHeader(buf.length);
  }
  trackHeader(len) {
    this.headersSize += len;
    if (this.headersSize >= this.headersMaxSize) {
      util$j.destroy(this.socket, new HeadersOverflowError3());
    }
  }
  onUpgrade(head) {
    const { upgrade: upgrade2, client: client2, socket, headers: headers2, statusCode } = this;
    assert$b(upgrade2);
    assert$b(client2[kSocket$1] === socket);
    assert$b(!socket.destroyed);
    assert$b(!this.paused);
    assert$b((headers2.length & 1) === 0);
    const request2 = client2[kQueue$3][client2[kRunningIdx$2]];
    assert$b(request2);
    assert$b(request2.upgrade || request2.method === "CONNECT");
    this.statusCode = null;
    this.statusText = "";
    this.shouldKeepAlive = null;
    this.headers = [];
    this.headersSize = 0;
    socket.unshift(head);
    socket[kParser].destroy();
    socket[kParser] = null;
    socket[kClient$3] = null;
    socket[kError$2] = null;
    removeAllListeners(socket);
    client2[kSocket$1] = null;
    client2[kHTTPContext$2] = null;
    client2[kQueue$3][client2[kRunningIdx$2]++] = null;
    client2.emit("disconnect", client2[kUrl$5], [client2], new InformationalError$3("upgrade"));
    try {
      request2.onUpgrade(statusCode, headers2, socket);
    } catch (err) {
      util$j.destroy(socket, err);
    }
    client2[kResume$3]();
  }
  onHeadersComplete(statusCode, upgrade2, shouldKeepAlive) {
    const { client: client2, socket, headers: headers2, statusText } = this;
    if (socket.destroyed) {
      return -1;
    }
    const request2 = client2[kQueue$3][client2[kRunningIdx$2]];
    if (!request2) {
      return -1;
    }
    assert$b(!this.upgrade);
    assert$b(this.statusCode < 200);
    if (statusCode === 100) {
      util$j.destroy(socket, new SocketError$3("bad response", util$j.getSocketInfo(socket)));
      return -1;
    }
    if (upgrade2 && !request2.upgrade) {
      util$j.destroy(socket, new SocketError$3("bad upgrade", util$j.getSocketInfo(socket)));
      return -1;
    }
    assert$b(this.timeoutType === TIMEOUT_HEADERS);
    this.statusCode = statusCode;
    this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.
    request2.method === "HEAD" && !socket[kReset$1] && this.connection.toLowerCase() === "keep-alive";
    if (this.statusCode >= 200) {
      const bodyTimeout = request2.bodyTimeout != null ? request2.bodyTimeout : client2[kBodyTimeout$1];
      this.setTimeout(bodyTimeout, TIMEOUT_BODY);
    } else if (this.timeout) {
      if (this.timeout.refresh) {
        this.timeout.refresh();
      }
    }
    if (request2.method === "CONNECT") {
      assert$b(client2[kRunning$5] === 1);
      this.upgrade = true;
      return 2;
    }
    if (upgrade2) {
      assert$b(client2[kRunning$5] === 1);
      this.upgrade = true;
      return 2;
    }
    assert$b((this.headers.length & 1) === 0);
    this.headers = [];
    this.headersSize = 0;
    if (this.shouldKeepAlive && client2[kPipelining$1]) {
      const keepAliveTimeout = this.keepAlive ? util$j.parseKeepAliveTimeout(this.keepAlive) : null;
      if (keepAliveTimeout != null) {
        const timeout = Math.min(
          keepAliveTimeout - client2[kKeepAliveTimeoutThreshold$1],
          client2[kKeepAliveMaxTimeout$1]
        );
        if (timeout <= 0) {
          socket[kReset$1] = true;
        } else {
          client2[kKeepAliveTimeoutValue$1] = timeout;
        }
      } else {
        client2[kKeepAliveTimeoutValue$1] = client2[kKeepAliveDefaultTimeout$1];
      }
    } else {
      socket[kReset$1] = true;
    }
    const pause = request2.onHeaders(statusCode, headers2, this.resume, statusText) === false;
    if (request2.aborted) {
      return -1;
    }
    if (request2.method === "HEAD") {
      return 1;
    }
    if (statusCode < 200) {
      return 1;
    }
    if (socket[kBlocking]) {
      socket[kBlocking] = false;
      client2[kResume$3]();
    }
    return pause ? constants$2.ERROR.PAUSED : 0;
  }
  onBody(buf) {
    const { client: client2, socket, statusCode, maxResponseSize } = this;
    if (socket.destroyed) {
      return -1;
    }
    const request2 = client2[kQueue$3][client2[kRunningIdx$2]];
    assert$b(request2);
    assert$b(this.timeoutType === TIMEOUT_BODY);
    if (this.timeout) {
      if (this.timeout.refresh) {
        this.timeout.refresh();
      }
    }
    assert$b(statusCode >= 200);
    if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
      util$j.destroy(socket, new ResponseExceededMaxSizeError3());
      return -1;
    }
    this.bytesRead += buf.length;
    if (request2.onData(buf) === false) {
      return constants$2.ERROR.PAUSED;
    }
  }
  onMessageComplete() {
    const { client: client2, socket, statusCode, upgrade: upgrade2, headers: headers2, contentLength, bytesRead, shouldKeepAlive } = this;
    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
      return -1;
    }
    if (upgrade2) {
      return;
    }
    assert$b(statusCode >= 100);
    assert$b((this.headers.length & 1) === 0);
    const request2 = client2[kQueue$3][client2[kRunningIdx$2]];
    assert$b(request2);
    this.statusCode = null;
    this.statusText = "";
    this.bytesRead = 0;
    this.contentLength = "";
    this.keepAlive = "";
    this.connection = "";
    this.headers = [];
    this.headersSize = 0;
    if (statusCode < 200) {
      return;
    }
    if (request2.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
      util$j.destroy(socket, new ResponseContentLengthMismatchError3());
      return -1;
    }
    request2.onComplete(headers2);
    client2[kQueue$3][client2[kRunningIdx$2]++] = null;
    if (socket[kWriting]) {
      assert$b(client2[kRunning$5] === 0);
      util$j.destroy(socket, new InformationalError$3("reset"));
      return constants$2.ERROR.PAUSED;
    } else if (!shouldKeepAlive) {
      util$j.destroy(socket, new InformationalError$3("reset"));
      return constants$2.ERROR.PAUSED;
    } else if (socket[kReset$1] && client2[kRunning$5] === 0) {
      util$j.destroy(socket, new InformationalError$3("reset"));
      return constants$2.ERROR.PAUSED;
    } else if (client2[kPipelining$1] == null || client2[kPipelining$1] === 1) {
      setImmediate(() => client2[kResume$3]());
    } else {
      client2[kResume$3]();
    }
  }
}
function onParserTimeout(parser) {
  const { socket, timeoutType, client: client2, paused } = parser.deref();
  if (timeoutType === TIMEOUT_HEADERS) {
    if (!socket[kWriting] || socket.writableNeedDrain || client2[kRunning$5] > 1) {
      assert$b(!paused, "cannot be paused while waiting for headers");
      util$j.destroy(socket, new HeadersTimeoutError3());
    }
  } else if (timeoutType === TIMEOUT_BODY) {
    if (!paused) {
      util$j.destroy(socket, new BodyTimeoutError3());
    }
  } else if (timeoutType === TIMEOUT_KEEP_ALIVE) {
    assert$b(client2[kRunning$5] === 0 && client2[kKeepAliveTimeoutValue$1]);
    util$j.destroy(socket, new InformationalError$3("socket idle timeout"));
  }
}
async function connectH1$1(client2, socket) {
  client2[kSocket$1] = socket;
  if (!llhttpInstance) {
    llhttpInstance = await llhttpPromise;
    llhttpPromise = null;
  }
  socket[kNoRef] = false;
  socket[kWriting] = false;
  socket[kReset$1] = false;
  socket[kBlocking] = false;
  socket[kParser] = new Parser2(client2, socket, llhttpInstance);
  addListener(socket, "error", function(err) {
    assert$b(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
    const parser = this[kParser];
    if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
      parser.onMessageComplete();
      return;
    }
    this[kError$2] = err;
    this[kClient$3][kOnError$2](err);
  });
  addListener(socket, "readable", function() {
    const parser = this[kParser];
    if (parser) {
      parser.readMore();
    }
  });
  addListener(socket, "end", function() {
    const parser = this[kParser];
    if (parser.statusCode && !parser.shouldKeepAlive) {
      parser.onMessageComplete();
      return;
    }
    util$j.destroy(this, new SocketError$3("other side closed", util$j.getSocketInfo(this)));
  });
  addListener(socket, "close", function() {
    const client22 = this[kClient$3];
    const parser = this[kParser];
    if (parser) {
      if (!this[kError$2] && parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
      }
      this[kParser].destroy();
      this[kParser] = null;
    }
    const err = this[kError$2] || new SocketError$3("closed", util$j.getSocketInfo(this));
    client22[kSocket$1] = null;
    client22[kHTTPContext$2] = null;
    if (client22.destroyed) {
      assert$b(client22[kPending$4] === 0);
      const requests = client22[kQueue$3].splice(client22[kRunningIdx$2]);
      for (let i = 0; i < requests.length; i++) {
        const request2 = requests[i];
        util$j.errorRequest(client22, request2, err);
      }
    } else if (client22[kRunning$5] > 0 && err.code !== "UND_ERR_INFO") {
      const request2 = client22[kQueue$3][client22[kRunningIdx$2]];
      client22[kQueue$3][client22[kRunningIdx$2]++] = null;
      util$j.errorRequest(client22, request2, err);
    }
    client22[kPendingIdx$2] = client22[kRunningIdx$2];
    assert$b(client22[kRunning$5] === 0);
    client22.emit("disconnect", client22[kUrl$5], [client22], err);
    client22[kResume$3]();
  });
  let closed = false;
  socket.on("close", () => {
    closed = true;
  });
  return {
    version: "h1",
    defaultPipelining: 1,
    write(...args) {
      return writeH1(client2, ...args);
    },
    resume() {
      resumeH1(client2);
    },
    destroy(err, callback) {
      if (closed) {
        queueMicrotask(callback);
      } else {
        socket.destroy(err).on("close", callback);
      }
    },
    get destroyed() {
      return socket.destroyed;
    },
    busy(request2) {
      if (socket[kWriting] || socket[kReset$1] || socket[kBlocking]) {
        return true;
      }
      if (request2) {
        if (client2[kRunning$5] > 0 && !request2.idempotent) {
          return true;
        }
        if (client2[kRunning$5] > 0 && (request2.upgrade || request2.method === "CONNECT")) {
          return true;
        }
        if (client2[kRunning$5] > 0 && util$j.bodyLength(request2.body) !== 0 && (util$j.isStream(request2.body) || util$j.isAsyncIterable(request2.body) || util$j.isFormDataLike(request2.body))) {
          return true;
        }
      }
      return false;
    }
  };
}
function resumeH1(client2) {
  const socket = client2[kSocket$1];
  if (socket && !socket.destroyed) {
    if (client2[kSize$5] === 0) {
      if (!socket[kNoRef] && socket.unref) {
        socket.unref();
        socket[kNoRef] = true;
      }
    } else if (socket[kNoRef] && socket.ref) {
      socket.ref();
      socket[kNoRef] = false;
    }
    if (client2[kSize$5] === 0) {
      if (socket[kParser].timeoutType !== TIMEOUT_KEEP_ALIVE) {
        socket[kParser].setTimeout(client2[kKeepAliveTimeoutValue$1], TIMEOUT_KEEP_ALIVE);
      }
    } else if (client2[kRunning$5] > 0 && socket[kParser].statusCode < 200) {
      if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
        const request2 = client2[kQueue$3][client2[kRunningIdx$2]];
        const headersTimeout = request2.headersTimeout != null ? request2.headersTimeout : client2[kHeadersTimeout$1];
        socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
      }
    }
  }
}
function shouldSendContentLength$1(method) {
  return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
}
function writeH1(client2, request2) {
  const { method, path: path2, host, upgrade: upgrade2, blocking, reset } = request2;
  let { body: body2, headers: headers2, contentLength } = request2;
  const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH" || method === "QUERY" || method === "PROPFIND" || method === "PROPPATCH";
  if (util$j.isFormDataLike(body2)) {
    if (!extractBody$1) {
      extractBody$1 = requireBody().extractBody;
    }
    const [bodyStream, contentType] = extractBody$1(body2);
    if (request2.contentType == null) {
      headers2.push("content-type", contentType);
    }
    body2 = bodyStream.stream;
    contentLength = bodyStream.length;
  } else if (util$j.isBlobLike(body2) && request2.contentType == null && body2.type) {
    headers2.push("content-type", body2.type);
  }
  if (body2 && typeof body2.read === "function") {
    body2.read(0);
  }
  const bodyLength2 = util$j.bodyLength(body2);
  contentLength = bodyLength2 ?? contentLength;
  if (contentLength === null) {
    contentLength = request2.contentLength;
  }
  if (contentLength === 0 && !expectsPayload) {
    contentLength = null;
  }
  if (shouldSendContentLength$1(method) && contentLength > 0 && request2.contentLength !== null && request2.contentLength !== contentLength) {
    if (client2[kStrictContentLength$2]) {
      util$j.errorRequest(client2, request2, new RequestContentLengthMismatchError$1());
      return false;
    }
    process.emitWarning(new RequestContentLengthMismatchError$1());
  }
  const socket = client2[kSocket$1];
  const abort2 = (err) => {
    if (request2.aborted || request2.completed) {
      return;
    }
    util$j.errorRequest(client2, request2, err || new RequestAbortedError$7());
    util$j.destroy(body2);
    util$j.destroy(socket, new InformationalError$3("aborted"));
  };
  try {
    request2.onConnect(abort2);
  } catch (err) {
    util$j.errorRequest(client2, request2, err);
  }
  if (request2.aborted) {
    return false;
  }
  if (method === "HEAD") {
    socket[kReset$1] = true;
  }
  if (upgrade2 || method === "CONNECT") {
    socket[kReset$1] = true;
  }
  if (reset != null) {
    socket[kReset$1] = reset;
  }
  if (client2[kMaxRequests$1] && socket[kCounter$1]++ >= client2[kMaxRequests$1]) {
    socket[kReset$1] = true;
  }
  if (blocking) {
    socket[kBlocking] = true;
  }
  let header = `${method} ${path2} HTTP/1.1\r
`;
  if (typeof host === "string") {
    header += `host: ${host}\r
`;
  } else {
    header += client2[kHostHeader$1];
  }
  if (upgrade2) {
    header += `connection: upgrade\r
upgrade: ${upgrade2}\r
`;
  } else if (client2[kPipelining$1] && !socket[kReset$1]) {
    header += "connection: keep-alive\r\n";
  } else {
    header += "connection: close\r\n";
  }
  if (Array.isArray(headers2)) {
    for (let n = 0; n < headers2.length; n += 2) {
      const key = headers2[n + 0];
      const val = headers2[n + 1];
      if (Array.isArray(val)) {
        for (let i = 0; i < val.length; i++) {
          header += `${key}: ${val[i]}\r
`;
        }
      } else {
        header += `${key}: ${val}\r
`;
      }
    }
  }
  if (channels$1.sendHeaders.hasSubscribers) {
    channels$1.sendHeaders.publish({ request: request2, headers: header, socket });
  }
  if (!body2 || bodyLength2 === 0) {
    writeBuffer$1(abort2, null, client2, request2, socket, contentLength, header, expectsPayload);
  } else if (util$j.isBuffer(body2)) {
    writeBuffer$1(abort2, body2, client2, request2, socket, contentLength, header, expectsPayload);
  } else if (util$j.isBlobLike(body2)) {
    if (typeof body2.stream === "function") {
      writeIterable$1(abort2, body2.stream(), client2, request2, socket, contentLength, header, expectsPayload);
    } else {
      writeBlob$1(abort2, body2, client2, request2, socket, contentLength, header, expectsPayload);
    }
  } else if (util$j.isStream(body2)) {
    writeStream$1(abort2, body2, client2, request2, socket, contentLength, header, expectsPayload);
  } else if (util$j.isIterable(body2)) {
    writeIterable$1(abort2, body2, client2, request2, socket, contentLength, header, expectsPayload);
  } else {
    assert$b(false);
  }
  return true;
}
function writeStream$1(abort2, body2, client2, request2, socket, contentLength, header, expectsPayload) {
  assert$b(contentLength !== 0 || client2[kRunning$5] === 0, "stream body cannot be pipelined");
  let finished2 = false;
  const writer = new AsyncWriter2({ abort: abort2, socket, request: request2, contentLength, client: client2, expectsPayload, header });
  const onData = function(chunk) {
    if (finished2) {
      return;
    }
    try {
      if (!writer.write(chunk) && this.pause) {
        this.pause();
      }
    } catch (err) {
      util$j.destroy(this, err);
    }
  };
  const onDrain = function() {
    if (finished2) {
      return;
    }
    if (body2.resume) {
      body2.resume();
    }
  };
  const onClose = function() {
    queueMicrotask(() => {
      body2.removeListener("error", onFinished);
    });
    if (!finished2) {
      const err = new RequestAbortedError$7();
      queueMicrotask(() => onFinished(err));
    }
  };
  const onFinished = function(err) {
    if (finished2) {
      return;
    }
    finished2 = true;
    assert$b(socket.destroyed || socket[kWriting] && client2[kRunning$5] <= 1);
    socket.off("drain", onDrain).off("error", onFinished);
    body2.removeListener("data", onData).removeListener("end", onFinished).removeListener("close", onClose);
    if (!err) {
      try {
        writer.end();
      } catch (er) {
        err = er;
      }
    }
    writer.destroy(err);
    if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
      util$j.destroy(body2, err);
    } else {
      util$j.destroy(body2);
    }
  };
  body2.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onClose);
  if (body2.resume) {
    body2.resume();
  }
  socket.on("drain", onDrain).on("error", onFinished);
  if (body2.errorEmitted ?? body2.errored) {
    setImmediate(() => onFinished(body2.errored));
  } else if (body2.endEmitted ?? body2.readableEnded) {
    setImmediate(() => onFinished(null));
  }
  if (body2.closeEmitted ?? body2.closed) {
    setImmediate(onClose);
  }
}
function writeBuffer$1(abort2, body2, client2, request2, socket, contentLength, header, expectsPayload) {
  try {
    if (!body2) {
      if (contentLength === 0) {
        socket.write(`${header}content-length: 0\r
\r
`, "latin1");
      } else {
        assert$b(contentLength === null, "no body must not have content length");
        socket.write(`${header}\r
`, "latin1");
      }
    } else if (util$j.isBuffer(body2)) {
      assert$b(contentLength === body2.byteLength, "buffer body must have content length");
      socket.cork();
      socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
      socket.write(body2);
      socket.uncork();
      request2.onBodySent(body2);
      if (!expectsPayload && request2.reset !== false) {
        socket[kReset$1] = true;
      }
    }
    request2.onRequestSent();
    client2[kResume$3]();
  } catch (err) {
    abort2(err);
  }
}
async function writeBlob$1(abort2, body2, client2, request2, socket, contentLength, header, expectsPayload) {
  assert$b(contentLength === body2.size, "blob body must have content length");
  try {
    if (contentLength != null && contentLength !== body2.size) {
      throw new RequestContentLengthMismatchError$1();
    }
    const buffer = Buffer.from(await body2.arrayBuffer());
    socket.cork();
    socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
    socket.write(buffer);
    socket.uncork();
    request2.onBodySent(buffer);
    request2.onRequestSent();
    if (!expectsPayload && request2.reset !== false) {
      socket[kReset$1] = true;
    }
    client2[kResume$3]();
  } catch (err) {
    abort2(err);
  }
}
async function writeIterable$1(abort2, body2, client2, request2, socket, contentLength, header, expectsPayload) {
  assert$b(contentLength !== 0 || client2[kRunning$5] === 0, "iterator body cannot be pipelined");
  let callback = null;
  function onDrain() {
    if (callback) {
      const cb = callback;
      callback = null;
      cb();
    }
  }
  const waitForDrain = () => new Promise((resolve2, reject) => {
    assert$b(callback === null);
    if (socket[kError$2]) {
      reject(socket[kError$2]);
    } else {
      callback = resolve2;
    }
  });
  socket.on("close", onDrain).on("drain", onDrain);
  const writer = new AsyncWriter2({ abort: abort2, socket, request: request2, contentLength, client: client2, expectsPayload, header });
  try {
    for await (const chunk of body2) {
      if (socket[kError$2]) {
        throw socket[kError$2];
      }
      if (!writer.write(chunk)) {
        await waitForDrain();
      }
    }
    writer.end();
  } catch (err) {
    writer.destroy(err);
  } finally {
    socket.off("close", onDrain).off("drain", onDrain);
  }
}
class AsyncWriter2 {
  constructor({ abort: abort2, socket, request: request2, contentLength, client: client2, expectsPayload, header }) {
    this.socket = socket;
    this.request = request2;
    this.contentLength = contentLength;
    this.client = client2;
    this.bytesWritten = 0;
    this.expectsPayload = expectsPayload;
    this.header = header;
    this.abort = abort2;
    socket[kWriting] = true;
  }
  write(chunk) {
    const { socket, request: request2, contentLength, client: client2, bytesWritten, expectsPayload, header } = this;
    if (socket[kError$2]) {
      throw socket[kError$2];
    }
    if (socket.destroyed) {
      return false;
    }
    const len = Buffer.byteLength(chunk);
    if (!len) {
      return true;
    }
    if (contentLength !== null && bytesWritten + len > contentLength) {
      if (client2[kStrictContentLength$2]) {
        throw new RequestContentLengthMismatchError$1();
      }
      process.emitWarning(new RequestContentLengthMismatchError$1());
    }
    socket.cork();
    if (bytesWritten === 0) {
      if (!expectsPayload && request2.reset !== false) {
        socket[kReset$1] = true;
      }
      if (contentLength === null) {
        socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
      } else {
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
      }
    }
    if (contentLength === null) {
      socket.write(`\r
${len.toString(16)}\r
`, "latin1");
    }
    this.bytesWritten += len;
    const ret = socket.write(chunk);
    socket.uncork();
    request2.onBodySent(chunk);
    if (!ret) {
      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
        if (socket[kParser].timeout.refresh) {
          socket[kParser].timeout.refresh();
        }
      }
    }
    return ret;
  }
  end() {
    const { socket, contentLength, client: client2, bytesWritten, expectsPayload, header, request: request2 } = this;
    request2.onRequestSent();
    socket[kWriting] = false;
    if (socket[kError$2]) {
      throw socket[kError$2];
    }
    if (socket.destroyed) {
      return;
    }
    if (bytesWritten === 0) {
      if (expectsPayload) {
        socket.write(`${header}content-length: 0\r
\r
`, "latin1");
      } else {
        socket.write(`${header}\r
`, "latin1");
      }
    } else if (contentLength === null) {
      socket.write("\r\n0\r\n\r\n", "latin1");
    }
    if (contentLength !== null && bytesWritten !== contentLength) {
      if (client2[kStrictContentLength$2]) {
        throw new RequestContentLengthMismatchError$1();
      } else {
        process.emitWarning(new RequestContentLengthMismatchError$1());
      }
    }
    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
      if (socket[kParser].timeout.refresh) {
        socket[kParser].timeout.refresh();
      }
    }
    client2[kResume$3]();
  }
  destroy(err) {
    const { socket, client: client2, abort: abort2 } = this;
    socket[kWriting] = false;
    if (err) {
      assert$b(client2[kRunning$5] <= 1, "pipeline should only contain this request");
      abort2(err);
    }
  }
}
var clientH1 = connectH1$1;
const assert$a = require$$0$3;
const { pipeline: pipeline$1 } = require$$0$4;
const util$i = util$n;
const {
  RequestContentLengthMismatchError: RequestContentLengthMismatchError3,
  RequestAbortedError: RequestAbortedError$6,
  SocketError: SocketError$2,
  InformationalError: InformationalError$2
} = errors$1;
const {
  kUrl: kUrl$4,
  kReset,
  kClient: kClient$2,
  kRunning: kRunning$4,
  kPending: kPending$3,
  kQueue: kQueue$2,
  kPendingIdx: kPendingIdx$1,
  kRunningIdx: kRunningIdx$1,
  kError: kError$1,
  kSocket,
  kStrictContentLength: kStrictContentLength$1,
  kOnError: kOnError$1,
  kMaxConcurrentStreams: kMaxConcurrentStreams$1,
  kHTTP2Session,
  kResume: kResume$2,
  kSize: kSize$4,
  kHTTPContext: kHTTPContext$1
} = symbols$4;
const kOpenStreams = Symbol("open streams");
let extractBody;
let h2ExperimentalWarned = false;
let http2;
try {
  http2 = require("node:http2");
} catch {
  http2 = { constants: {} };
}
const {
  constants: {
    HTTP2_HEADER_AUTHORITY,
    HTTP2_HEADER_METHOD,
    HTTP2_HEADER_PATH,
    HTTP2_HEADER_SCHEME,
    HTTP2_HEADER_CONTENT_LENGTH,
    HTTP2_HEADER_EXPECT,
    HTTP2_HEADER_STATUS
  }
} = http2;
function parseH2Headers(headers2) {
  const result = [];
  for (const [name, value] of Object.entries(headers2)) {
    if (Array.isArray(value)) {
      for (const subvalue of value) {
        result.push(Buffer.from(name), Buffer.from(subvalue));
      }
    } else {
      result.push(Buffer.from(name), Buffer.from(value));
    }
  }
  return result;
}
async function connectH2$1(client2, socket) {
  client2[kSocket] = socket;
  if (!h2ExperimentalWarned) {
    h2ExperimentalWarned = true;
    process.emitWarning("H2 support is experimental, expect them to change at any time.", {
      code: "UNDICI-H2"
    });
  }
  const session = http2.connect(client2[kUrl$4], {
    createConnection: () => socket,
    peerMaxConcurrentStreams: client2[kMaxConcurrentStreams$1]
  });
  session[kOpenStreams] = 0;
  session[kClient$2] = client2;
  session[kSocket] = socket;
  util$i.addListener(session, "error", onHttp2SessionError);
  util$i.addListener(session, "frameError", onHttp2FrameError);
  util$i.addListener(session, "end", onHttp2SessionEnd);
  util$i.addListener(session, "goaway", onHTTP2GoAway);
  util$i.addListener(session, "close", function() {
    const { [kClient$2]: client3 } = this;
    const { [kSocket]: socket2 } = client3;
    const err = this[kSocket][kError$1] || this[kError$1] || new SocketError$2("closed", util$i.getSocketInfo(socket2));
    client3[kHTTP2Session] = null;
    if (client3.destroyed) {
      assert$a(client3[kPending$3] === 0);
      const requests = client3[kQueue$2].splice(client3[kRunningIdx$1]);
      for (let i = 0; i < requests.length; i++) {
        const request2 = requests[i];
        util$i.errorRequest(client3, request2, err);
      }
    }
  });
  session.unref();
  client2[kHTTP2Session] = session;
  socket[kHTTP2Session] = session;
  util$i.addListener(socket, "error", function(err) {
    assert$a(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
    this[kError$1] = err;
    this[kClient$2][kOnError$1](err);
  });
  util$i.addListener(socket, "end", function() {
    util$i.destroy(this, new SocketError$2("other side closed", util$i.getSocketInfo(this)));
  });
  util$i.addListener(socket, "close", function() {
    const err = this[kError$1] || new SocketError$2("closed", util$i.getSocketInfo(this));
    client2[kSocket] = null;
    if (this[kHTTP2Session] != null) {
      this[kHTTP2Session].destroy(err);
    }
    client2[kPendingIdx$1] = client2[kRunningIdx$1];
    assert$a(client2[kRunning$4] === 0);
    client2.emit("disconnect", client2[kUrl$4], [client2], err);
    client2[kResume$2]();
  });
  let closed = false;
  socket.on("close", () => {
    closed = true;
  });
  return {
    version: "h2",
    defaultPipelining: Infinity,
    write(...args) {
      return writeH2(client2, ...args);
    },
    resume() {
      resumeH2(client2);
    },
    destroy(err, callback) {
      if (closed) {
        queueMicrotask(callback);
      } else {
        socket.destroy(err).on("close", callback);
      }
    },
    get destroyed() {
      return socket.destroyed;
    },
    busy() {
      return false;
    }
  };
}
function resumeH2(client2) {
  const socket = client2[kSocket];
  if ((socket == null ? void 0 : socket.destroyed) === false) {
    if (client2[kSize$4] === 0 && client2[kMaxConcurrentStreams$1] === 0) {
      socket.unref();
      client2[kHTTP2Session].unref();
    } else {
      socket.ref();
      client2[kHTTP2Session].ref();
    }
  }
}
function onHttp2SessionError(err) {
  assert$a(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
  this[kSocket][kError$1] = err;
  this[kClient$2][kOnError$1](err);
}
function onHttp2FrameError(type, code, id) {
  if (id === 0) {
    const err = new InformationalError$2(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
    this[kSocket][kError$1] = err;
    this[kClient$2][kOnError$1](err);
  }
}
function onHttp2SessionEnd() {
  const err = new SocketError$2("other side closed", util$i.getSocketInfo(this[kSocket]));
  this.destroy(err);
  util$i.destroy(this[kSocket], err);
}
function onHTTP2GoAway(code) {
  const err = this[kError$1] || new SocketError$2(`HTTP/2: "GOAWAY" frame received with code ${code}`, util$i.getSocketInfo(this));
  const client2 = this[kClient$2];
  client2[kSocket] = null;
  client2[kHTTPContext$1] = null;
  if (this[kHTTP2Session] != null) {
    this[kHTTP2Session].destroy(err);
    this[kHTTP2Session] = null;
  }
  util$i.destroy(this[kSocket], err);
  if (client2[kRunningIdx$1] < client2[kQueue$2].length) {
    const request2 = client2[kQueue$2][client2[kRunningIdx$1]];
    client2[kQueue$2][client2[kRunningIdx$1]++] = null;
    util$i.errorRequest(client2, request2, err);
    client2[kPendingIdx$1] = client2[kRunningIdx$1];
  }
  assert$a(client2[kRunning$4] === 0);
  client2.emit("disconnect", client2[kUrl$4], [client2], err);
  client2[kResume$2]();
}
function shouldSendContentLength(method) {
  return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
}
function writeH2(client2, request2) {
  const session = client2[kHTTP2Session];
  const { method, path: path2, host, upgrade: upgrade2, expectContinue, signal, headers: reqHeaders } = request2;
  let { body: body2 } = request2;
  if (upgrade2) {
    util$i.errorRequest(client2, request2, new Error("Upgrade not supported for H2"));
    return false;
  }
  const headers2 = {};
  for (let n = 0; n < reqHeaders.length; n += 2) {
    const key = reqHeaders[n + 0];
    const val = reqHeaders[n + 1];
    if (Array.isArray(val)) {
      for (let i = 0; i < val.length; i++) {
        if (headers2[key]) {
          headers2[key] += `,${val[i]}`;
        } else {
          headers2[key] = val[i];
        }
      }
    } else {
      headers2[key] = val;
    }
  }
  let stream2;
  const { hostname, port } = client2[kUrl$4];
  headers2[HTTP2_HEADER_AUTHORITY] = host || `${hostname}${port ? `:${port}` : ""}`;
  headers2[HTTP2_HEADER_METHOD] = method;
  const abort2 = (err) => {
    if (request2.aborted || request2.completed) {
      return;
    }
    err = err || new RequestAbortedError$6();
    util$i.errorRequest(client2, request2, err);
    if (stream2 != null) {
      util$i.destroy(stream2, err);
    }
    util$i.destroy(body2, err);
    client2[kQueue$2][client2[kRunningIdx$1]++] = null;
    client2[kResume$2]();
  };
  try {
    request2.onConnect(abort2);
  } catch (err) {
    util$i.errorRequest(client2, request2, err);
  }
  if (request2.aborted) {
    return false;
  }
  if (method === "CONNECT") {
    session.ref();
    stream2 = session.request(headers2, { endStream: false, signal });
    if (stream2.id && !stream2.pending) {
      request2.onUpgrade(null, null, stream2);
      ++session[kOpenStreams];
      client2[kQueue$2][client2[kRunningIdx$1]++] = null;
    } else {
      stream2.once("ready", () => {
        request2.onUpgrade(null, null, stream2);
        ++session[kOpenStreams];
        client2[kQueue$2][client2[kRunningIdx$1]++] = null;
      });
    }
    stream2.once("close", () => {
      session[kOpenStreams] -= 1;
      if (session[kOpenStreams] === 0) session.unref();
    });
    return true;
  }
  headers2[HTTP2_HEADER_PATH] = path2;
  headers2[HTTP2_HEADER_SCHEME] = "https";
  const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
  if (body2 && typeof body2.read === "function") {
    body2.read(0);
  }
  let contentLength = util$i.bodyLength(body2);
  if (util$i.isFormDataLike(body2)) {
    extractBody ?? (extractBody = requireBody().extractBody);
    const [bodyStream, contentType] = extractBody(body2);
    headers2["content-type"] = contentType;
    body2 = bodyStream.stream;
    contentLength = bodyStream.length;
  }
  if (contentLength == null) {
    contentLength = request2.contentLength;
  }
  if (contentLength === 0 || !expectsPayload) {
    contentLength = null;
  }
  if (shouldSendContentLength(method) && contentLength > 0 && request2.contentLength != null && request2.contentLength !== contentLength) {
    if (client2[kStrictContentLength$1]) {
      util$i.errorRequest(client2, request2, new RequestContentLengthMismatchError3());
      return false;
    }
    process.emitWarning(new RequestContentLengthMismatchError3());
  }
  if (contentLength != null) {
    assert$a(body2, "no body must not have content length");
    headers2[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
  }
  session.ref();
  const shouldEndStream = method === "GET" || method === "HEAD" || body2 === null;
  if (expectContinue) {
    headers2[HTTP2_HEADER_EXPECT] = "100-continue";
    stream2 = session.request(headers2, { endStream: shouldEndStream, signal });
    stream2.once("continue", writeBodyH2);
  } else {
    stream2 = session.request(headers2, {
      endStream: shouldEndStream,
      signal
    });
    writeBodyH2();
  }
  ++session[kOpenStreams];
  stream2.once("response", (headers3) => {
    const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers3;
    request2.onResponseStarted();
    if (request2.aborted) {
      const err = new RequestAbortedError$6();
      util$i.errorRequest(client2, request2, err);
      util$i.destroy(stream2, err);
      return;
    }
    if (request2.onHeaders(Number(statusCode), parseH2Headers(realHeaders), stream2.resume.bind(stream2), "") === false) {
      stream2.pause();
    }
    stream2.on("data", (chunk) => {
      if (request2.onData(chunk) === false) {
        stream2.pause();
      }
    });
  });
  stream2.once("end", () => {
    var _a2;
    if (((_a2 = stream2.state) == null ? void 0 : _a2.state) == null || stream2.state.state < 6) {
      request2.onComplete([]);
    }
    if (session[kOpenStreams] === 0) {
      session.unref();
    }
    abort2(new InformationalError$2("HTTP/2: stream half-closed (remote)"));
    client2[kQueue$2][client2[kRunningIdx$1]++] = null;
    client2[kPendingIdx$1] = client2[kRunningIdx$1];
    client2[kResume$2]();
  });
  stream2.once("close", () => {
    session[kOpenStreams] -= 1;
    if (session[kOpenStreams] === 0) {
      session.unref();
    }
  });
  stream2.once("error", function(err) {
    abort2(err);
  });
  stream2.once("frameError", (type, code) => {
    abort2(new InformationalError$2(`HTTP/2: "frameError" received - type ${type}, code ${code}`));
  });
  return true;
  function writeBodyH2() {
    if (!body2 || contentLength === 0) {
      writeBuffer(
        abort2,
        stream2,
        null,
        client2,
        request2,
        client2[kSocket],
        contentLength,
        expectsPayload
      );
    } else if (util$i.isBuffer(body2)) {
      writeBuffer(
        abort2,
        stream2,
        body2,
        client2,
        request2,
        client2[kSocket],
        contentLength,
        expectsPayload
      );
    } else if (util$i.isBlobLike(body2)) {
      if (typeof body2.stream === "function") {
        writeIterable(
          abort2,
          stream2,
          body2.stream(),
          client2,
          request2,
          client2[kSocket],
          contentLength,
          expectsPayload
        );
      } else {
        writeBlob(
          abort2,
          stream2,
          body2,
          client2,
          request2,
          client2[kSocket],
          contentLength,
          expectsPayload
        );
      }
    } else if (util$i.isStream(body2)) {
      writeStream(
        abort2,
        client2[kSocket],
        expectsPayload,
        stream2,
        body2,
        client2,
        request2,
        contentLength
      );
    } else if (util$i.isIterable(body2)) {
      writeIterable(
        abort2,
        stream2,
        body2,
        client2,
        request2,
        client2[kSocket],
        contentLength,
        expectsPayload
      );
    } else {
      assert$a(false);
    }
  }
}
function writeBuffer(abort2, h2stream, body2, client2, request2, socket, contentLength, expectsPayload) {
  try {
    if (body2 != null && util$i.isBuffer(body2)) {
      assert$a(contentLength === body2.byteLength, "buffer body must have content length");
      h2stream.cork();
      h2stream.write(body2);
      h2stream.uncork();
      h2stream.end();
      request2.onBodySent(body2);
    }
    if (!expectsPayload) {
      socket[kReset] = true;
    }
    request2.onRequestSent();
    client2[kResume$2]();
  } catch (error) {
    abort2(error);
  }
}
function writeStream(abort2, socket, expectsPayload, h2stream, body2, client2, request2, contentLength) {
  assert$a(contentLength !== 0 || client2[kRunning$4] === 0, "stream body cannot be pipelined");
  const pipe = pipeline$1(
    body2,
    h2stream,
    (err) => {
      if (err) {
        util$i.destroy(pipe, err);
        abort2(err);
      } else {
        util$i.removeAllListeners(pipe);
        request2.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        client2[kResume$2]();
      }
    }
  );
  util$i.addListener(pipe, "data", onPipeData);
  function onPipeData(chunk) {
    request2.onBodySent(chunk);
  }
}
async function writeBlob(abort2, h2stream, body2, client2, request2, socket, contentLength, expectsPayload) {
  assert$a(contentLength === body2.size, "blob body must have content length");
  try {
    if (contentLength != null && contentLength !== body2.size) {
      throw new RequestContentLengthMismatchError3();
    }
    const buffer = Buffer.from(await body2.arrayBuffer());
    h2stream.cork();
    h2stream.write(buffer);
    h2stream.uncork();
    h2stream.end();
    request2.onBodySent(buffer);
    request2.onRequestSent();
    if (!expectsPayload) {
      socket[kReset] = true;
    }
    client2[kResume$2]();
  } catch (err) {
    abort2(err);
  }
}
async function writeIterable(abort2, h2stream, body2, client2, request2, socket, contentLength, expectsPayload) {
  assert$a(contentLength !== 0 || client2[kRunning$4] === 0, "iterator body cannot be pipelined");
  let callback = null;
  function onDrain() {
    if (callback) {
      const cb = callback;
      callback = null;
      cb();
    }
  }
  const waitForDrain = () => new Promise((resolve2, reject) => {
    assert$a(callback === null);
    if (socket[kError$1]) {
      reject(socket[kError$1]);
    } else {
      callback = resolve2;
    }
  });
  h2stream.on("close", onDrain).on("drain", onDrain);
  try {
    for await (const chunk of body2) {
      if (socket[kError$1]) {
        throw socket[kError$1];
      }
      const res = h2stream.write(chunk);
      request2.onBodySent(chunk);
      if (!res) {
        await waitForDrain();
      }
    }
    h2stream.end();
    request2.onRequestSent();
    if (!expectsPayload) {
      socket[kReset] = true;
    }
    client2[kResume$2]();
  } catch (err) {
    abort2(err);
  } finally {
    h2stream.off("close", onDrain).off("drain", onDrain);
  }
}
var clientH2 = connectH2$1;
const util$h = util$n;
const { kBodyUsed } = symbols$4;
const assert$9 = require$$0$3;
const { InvalidArgumentError: InvalidArgumentError$j } = errors$1;
const EE = require$$8$1;
const redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
const kBody$1 = Symbol("body");
class BodyAsyncIterable4 {
  constructor(body2) {
    this[kBody$1] = body2;
    this[kBodyUsed] = false;
  }
  async *[Symbol.asyncIterator]() {
    assert$9(!this[kBodyUsed], "disturbed");
    this[kBodyUsed] = true;
    yield* this[kBody$1];
  }
}
let RedirectHandler$3 = class RedirectHandler2 {
  constructor(dispatch, maxRedirections, opts, handler) {
    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
      throw new InvalidArgumentError$j("maxRedirections must be a positive number");
    }
    util$h.validateHandler(handler, opts.method, opts.upgrade);
    this.dispatch = dispatch;
    this.location = null;
    this.abort = null;
    this.opts = { ...opts, maxRedirections: 0 };
    this.maxRedirections = maxRedirections;
    this.handler = handler;
    this.history = [];
    this.redirectionLimitReached = false;
    if (util$h.isStream(this.opts.body)) {
      if (util$h.bodyLength(this.opts.body) === 0) {
        this.opts.body.on("data", function() {
          assert$9(false);
        });
      }
      if (typeof this.opts.body.readableDidRead !== "boolean") {
        this.opts.body[kBodyUsed] = false;
        EE.prototype.on.call(this.opts.body, "data", function() {
          this[kBodyUsed] = true;
        });
      }
    } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
      this.opts.body = new BodyAsyncIterable4(this.opts.body);
    } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util$h.isIterable(this.opts.body)) {
      this.opts.body = new BodyAsyncIterable4(this.opts.body);
    }
  }
  onConnect(abort2) {
    this.abort = abort2;
    this.handler.onConnect(abort2, { history: this.history });
  }
  onUpgrade(statusCode, headers2, socket) {
    this.handler.onUpgrade(statusCode, headers2, socket);
  }
  onError(error) {
    this.handler.onError(error);
  }
  onHeaders(statusCode, headers2, resume2, statusText) {
    this.location = this.history.length >= this.maxRedirections || util$h.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers2);
    if (this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {
      if (this.request) {
        this.request.abort(new Error("max redirects"));
      }
      this.redirectionLimitReached = true;
      this.abort(new Error("max redirects"));
      return;
    }
    if (this.opts.origin) {
      this.history.push(new URL(this.opts.path, this.opts.origin));
    }
    if (!this.location) {
      return this.handler.onHeaders(statusCode, headers2, resume2, statusText);
    }
    const { origin, pathname, search } = util$h.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
    const path2 = search ? `${pathname}${search}` : pathname;
    this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
    this.opts.path = path2;
    this.opts.origin = origin;
    this.opts.maxRedirections = 0;
    this.opts.query = null;
    if (statusCode === 303 && this.opts.method !== "HEAD") {
      this.opts.method = "GET";
      this.opts.body = null;
    }
  }
  onData(chunk) {
    if (this.location) ;
    else {
      return this.handler.onData(chunk);
    }
  }
  onComplete(trailers) {
    if (this.location) {
      this.location = null;
      this.abort = null;
      this.dispatch(this.opts, this);
    } else {
      this.handler.onComplete(trailers);
    }
  }
  onBodySent(chunk) {
    if (this.handler.onBodySent) {
      this.handler.onBodySent(chunk);
    }
  }
};
function parseLocation(statusCode, headers2) {
  if (redirectableStatusCodes.indexOf(statusCode) === -1) {
    return null;
  }
  for (let i = 0; i < headers2.length; i += 2) {
    if (headers2[i].length === 8 && util$h.headerNameToString(headers2[i]) === "location") {
      return headers2[i + 1];
    }
  }
}
function shouldRemoveHeader(header, removeContent, unknownOrigin) {
  if (header.length === 4) {
    return util$h.headerNameToString(header) === "host";
  }
  if (removeContent && util$h.headerNameToString(header).startsWith("content-")) {
    return true;
  }
  if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
    const name = util$h.headerNameToString(header);
    return name === "authorization" || name === "cookie" || name === "proxy-authorization";
  }
  return false;
}
function cleanRequestHeaders(headers2, removeContent, unknownOrigin) {
  const ret = [];
  if (Array.isArray(headers2)) {
    for (let i = 0; i < headers2.length; i += 2) {
      if (!shouldRemoveHeader(headers2[i], removeContent, unknownOrigin)) {
        ret.push(headers2[i], headers2[i + 1]);
      }
    }
  } else if (headers2 && typeof headers2 === "object") {
    for (const key of Object.keys(headers2)) {
      if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
        ret.push(key, headers2[key]);
      }
    }
  } else {
    assert$9(headers2 == null, "headers must be an object or an array");
  }
  return ret;
}
var redirectHandler = RedirectHandler$3;
const RedirectHandler$2 = redirectHandler;
function createRedirectInterceptor$3({ maxRedirections: defaultMaxRedirections }) {
  return (dispatch) => {
    return function Intercept(opts, handler) {
      const { maxRedirections = defaultMaxRedirections } = opts;
      if (!maxRedirections) {
        return dispatch(opts, handler);
      }
      const redirectHandler2 = new RedirectHandler$2(dispatch, maxRedirections, opts, handler);
      opts = { ...opts, maxRedirections: 0 };
      return dispatch(opts, redirectHandler2);
    };
  };
}
var redirectInterceptor = createRedirectInterceptor$3;
const assert$8 = require$$0$3;
const net = require$$0$5;
const http = require$$2$1;
const util$g = util$n;
const { channels } = diagnostics;
const Request3 = request$2;
const DispatcherBase$4 = dispatcherBase;
const {
  InvalidArgumentError: InvalidArgumentError$i,
  InformationalError: InformationalError$1,
  ClientDestroyedError: ClientDestroyedError3
} = errors$1;
const buildConnector$3 = connect$3;
const {
  kUrl: kUrl$3,
  kServerName,
  kClient: kClient$1,
  kBusy: kBusy$1,
  kConnect,
  kResuming,
  kRunning: kRunning$3,
  kPending: kPending$2,
  kSize: kSize$3,
  kQueue: kQueue$1,
  kConnected: kConnected$4,
  kConnecting,
  kNeedDrain: kNeedDrain$3,
  kKeepAliveDefaultTimeout,
  kHostHeader,
  kPendingIdx,
  kRunningIdx,
  kError,
  kPipelining,
  kKeepAliveTimeoutValue,
  kMaxHeadersSize,
  kKeepAliveMaxTimeout,
  kKeepAliveTimeoutThreshold,
  kHeadersTimeout,
  kBodyTimeout,
  kStrictContentLength,
  kConnector,
  kMaxRedirections: kMaxRedirections$1,
  kMaxRequests,
  kCounter,
  kClose: kClose$6,
  kDestroy: kDestroy$4,
  kDispatch: kDispatch$3,
  kInterceptors: kInterceptors$4,
  kLocalAddress,
  kMaxResponseSize,
  kOnError,
  kHTTPContext,
  kMaxConcurrentStreams,
  kResume: kResume$1
} = symbols$4;
const connectH1 = clientH1;
const connectH2 = clientH2;
let deprecatedInterceptorWarned = false;
const kClosedResolve$1 = Symbol("kClosedResolve");
const noop$2 = () => {
};
function getPipelining(client2) {
  var _a2;
  return client2[kPipelining] ?? ((_a2 = client2[kHTTPContext]) == null ? void 0 : _a2.defaultPipelining) ?? 1;
}
let Client$4 = class Client2 extends DispatcherBase$4 {
  /**
   *
   * @param {string|URL} url
   * @param {import('../../types/client.js').Client.Options} options
   */
  constructor(url, {
    interceptors,
    maxHeaderSize,
    headersTimeout,
    socketTimeout,
    requestTimeout,
    connectTimeout,
    bodyTimeout,
    idleTimeout,
    keepAlive,
    keepAliveTimeout,
    maxKeepAliveTimeout,
    keepAliveMaxTimeout,
    keepAliveTimeoutThreshold,
    socketPath,
    pipelining,
    tls: tls2,
    strictContentLength,
    maxCachedSessions,
    maxRedirections,
    connect: connect2,
    maxRequestsPerClient,
    localAddress,
    maxResponseSize,
    autoSelectFamily,
    autoSelectFamilyAttemptTimeout,
    // h2
    maxConcurrentStreams,
    allowH2
  } = {}) {
    super();
    if (keepAlive !== void 0) {
      throw new InvalidArgumentError$i("unsupported keepAlive, use pipelining=0 instead");
    }
    if (socketTimeout !== void 0) {
      throw new InvalidArgumentError$i("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
    }
    if (requestTimeout !== void 0) {
      throw new InvalidArgumentError$i("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
    }
    if (idleTimeout !== void 0) {
      throw new InvalidArgumentError$i("unsupported idleTimeout, use keepAliveTimeout instead");
    }
    if (maxKeepAliveTimeout !== void 0) {
      throw new InvalidArgumentError$i("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
    }
    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
      throw new InvalidArgumentError$i("invalid maxHeaderSize");
    }
    if (socketPath != null && typeof socketPath !== "string") {
      throw new InvalidArgumentError$i("invalid socketPath");
    }
    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
      throw new InvalidArgumentError$i("invalid connectTimeout");
    }
    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
      throw new InvalidArgumentError$i("invalid keepAliveTimeout");
    }
    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
      throw new InvalidArgumentError$i("invalid keepAliveMaxTimeout");
    }
    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
      throw new InvalidArgumentError$i("invalid keepAliveTimeoutThreshold");
    }
    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
      throw new InvalidArgumentError$i("headersTimeout must be a positive integer or zero");
    }
    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
      throw new InvalidArgumentError$i("bodyTimeout must be a positive integer or zero");
    }
    if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
      throw new InvalidArgumentError$i("connect must be a function or an object");
    }
    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
      throw new InvalidArgumentError$i("maxRedirections must be a positive number");
    }
    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
      throw new InvalidArgumentError$i("maxRequestsPerClient must be a positive number");
    }
    if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) {
      throw new InvalidArgumentError$i("localAddress must be valid string IP address");
    }
    if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
      throw new InvalidArgumentError$i("maxResponseSize must be a positive number");
    }
    if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
      throw new InvalidArgumentError$i("autoSelectFamilyAttemptTimeout must be a positive number");
    }
    if (allowH2 != null && typeof allowH2 !== "boolean") {
      throw new InvalidArgumentError$i("allowH2 must be a valid boolean value");
    }
    if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
      throw new InvalidArgumentError$i("maxConcurrentStreams must be a positive integer, greater than 0");
    }
    if (typeof connect2 !== "function") {
      connect2 = buildConnector$3({
        ...tls2,
        maxCachedSessions,
        allowH2,
        socketPath,
        timeout: connectTimeout,
        ...autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
        ...connect2
      });
    }
    if ((interceptors == null ? void 0 : interceptors.Client) && Array.isArray(interceptors.Client)) {
      this[kInterceptors$4] = interceptors.Client;
      if (!deprecatedInterceptorWarned) {
        deprecatedInterceptorWarned = true;
        process.emitWarning("Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.", {
          code: "UNDICI-CLIENT-INTERCEPTOR-DEPRECATED"
        });
      }
    } else {
      this[kInterceptors$4] = [createRedirectInterceptor$2({ maxRedirections })];
    }
    this[kUrl$3] = util$g.parseOrigin(url);
    this[kConnector] = connect2;
    this[kPipelining] = pipelining != null ? pipelining : 1;
    this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 2e3 : keepAliveTimeoutThreshold;
    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
    this[kServerName] = null;
    this[kLocalAddress] = localAddress != null ? localAddress : null;
    this[kResuming] = 0;
    this[kNeedDrain$3] = 0;
    this[kHostHeader] = `host: ${this[kUrl$3].hostname}${this[kUrl$3].port ? `:${this[kUrl$3].port}` : ""}\r
`;
    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
    this[kMaxRedirections$1] = maxRedirections;
    this[kMaxRequests] = maxRequestsPerClient;
    this[kClosedResolve$1] = null;
    this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
    this[kMaxConcurrentStreams] = maxConcurrentStreams != null ? maxConcurrentStreams : 100;
    this[kHTTPContext] = null;
    this[kQueue$1] = [];
    this[kRunningIdx] = 0;
    this[kPendingIdx] = 0;
    this[kResume$1] = (sync) => resume(this, sync);
    this[kOnError] = (err) => onError(this, err);
  }
  get pipelining() {
    return this[kPipelining];
  }
  set pipelining(value) {
    this[kPipelining] = value;
    this[kResume$1](true);
  }
  get [kPending$2]() {
    return this[kQueue$1].length - this[kPendingIdx];
  }
  get [kRunning$3]() {
    return this[kPendingIdx] - this[kRunningIdx];
  }
  get [kSize$3]() {
    return this[kQueue$1].length - this[kRunningIdx];
  }
  get [kConnected$4]() {
    return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed;
  }
  get [kBusy$1]() {
    var _a2;
    return Boolean(
      ((_a2 = this[kHTTPContext]) == null ? void 0 : _a2.busy(null)) || this[kSize$3] >= (getPipelining(this) || 1) || this[kPending$2] > 0
    );
  }
  /* istanbul ignore: only used for test */
  [kConnect](cb) {
    connect$2(this);
    this.once("connect", cb);
  }
  [kDispatch$3](opts, handler) {
    const origin = opts.origin || this[kUrl$3].origin;
    const request2 = new Request3(origin, opts, handler);
    this[kQueue$1].push(request2);
    if (this[kResuming]) ;
    else if (util$g.bodyLength(request2.body) == null && util$g.isIterable(request2.body)) {
      this[kResuming] = 1;
      queueMicrotask(() => resume(this));
    } else {
      this[kResume$1](true);
    }
    if (this[kResuming] && this[kNeedDrain$3] !== 2 && this[kBusy$1]) {
      this[kNeedDrain$3] = 2;
    }
    return this[kNeedDrain$3] < 2;
  }
  async [kClose$6]() {
    return new Promise((resolve2) => {
      if (this[kSize$3]) {
        this[kClosedResolve$1] = resolve2;
      } else {
        resolve2(null);
      }
    });
  }
  async [kDestroy$4](err) {
    return new Promise((resolve2) => {
      const requests = this[kQueue$1].splice(this[kPendingIdx]);
      for (let i = 0; i < requests.length; i++) {
        const request2 = requests[i];
        util$g.errorRequest(this, request2, err);
      }
      const callback = () => {
        if (this[kClosedResolve$1]) {
          this[kClosedResolve$1]();
          this[kClosedResolve$1] = null;
        }
        resolve2(null);
      };
      if (this[kHTTPContext]) {
        this[kHTTPContext].destroy(err, callback);
        this[kHTTPContext] = null;
      } else {
        queueMicrotask(callback);
      }
      this[kResume$1]();
    });
  }
};
const createRedirectInterceptor$2 = redirectInterceptor;
function onError(client2, err) {
  if (client2[kRunning$3] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
    assert$8(client2[kPendingIdx] === client2[kRunningIdx]);
    const requests = client2[kQueue$1].splice(client2[kRunningIdx]);
    for (let i = 0; i < requests.length; i++) {
      const request2 = requests[i];
      util$g.errorRequest(client2, request2, err);
    }
    assert$8(client2[kSize$3] === 0);
  }
}
async function connect$2(client2) {
  var _a2, _b2, _c2;
  assert$8(!client2[kConnecting]);
  assert$8(!client2[kHTTPContext]);
  let { host, hostname, protocol, port } = client2[kUrl$3];
  if (hostname[0] === "[") {
    const idx = hostname.indexOf("]");
    assert$8(idx !== -1);
    const ip = hostname.substring(1, idx);
    assert$8(net.isIP(ip));
    hostname = ip;
  }
  client2[kConnecting] = true;
  if (channels.beforeConnect.hasSubscribers) {
    channels.beforeConnect.publish({
      connectParams: {
        host,
        hostname,
        protocol,
        port,
        version: (_a2 = client2[kHTTPContext]) == null ? void 0 : _a2.version,
        servername: client2[kServerName],
        localAddress: client2[kLocalAddress]
      },
      connector: client2[kConnector]
    });
  }
  try {
    const socket = await new Promise((resolve2, reject) => {
      client2[kConnector]({
        host,
        hostname,
        protocol,
        port,
        servername: client2[kServerName],
        localAddress: client2[kLocalAddress]
      }, (err, socket2) => {
        if (err) {
          reject(err);
        } else {
          resolve2(socket2);
        }
      });
    });
    if (client2.destroyed) {
      util$g.destroy(socket.on("error", noop$2), new ClientDestroyedError3());
      return;
    }
    assert$8(socket);
    try {
      client2[kHTTPContext] = socket.alpnProtocol === "h2" ? await connectH2(client2, socket) : await connectH1(client2, socket);
    } catch (err) {
      socket.destroy().on("error", noop$2);
      throw err;
    }
    client2[kConnecting] = false;
    socket[kCounter] = 0;
    socket[kMaxRequests] = client2[kMaxRequests];
    socket[kClient$1] = client2;
    socket[kError] = null;
    if (channels.connected.hasSubscribers) {
      channels.connected.publish({
        connectParams: {
          host,
          hostname,
          protocol,
          port,
          version: (_b2 = client2[kHTTPContext]) == null ? void 0 : _b2.version,
          servername: client2[kServerName],
          localAddress: client2[kLocalAddress]
        },
        connector: client2[kConnector],
        socket
      });
    }
    client2.emit("connect", client2[kUrl$3], [client2]);
  } catch (err) {
    if (client2.destroyed) {
      return;
    }
    client2[kConnecting] = false;
    if (channels.connectError.hasSubscribers) {
      channels.connectError.publish({
        connectParams: {
          host,
          hostname,
          protocol,
          port,
          version: (_c2 = client2[kHTTPContext]) == null ? void 0 : _c2.version,
          servername: client2[kServerName],
          localAddress: client2[kLocalAddress]
        },
        connector: client2[kConnector],
        error: err
      });
    }
    if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
      assert$8(client2[kRunning$3] === 0);
      while (client2[kPending$2] > 0 && client2[kQueue$1][client2[kPendingIdx]].servername === client2[kServerName]) {
        const request2 = client2[kQueue$1][client2[kPendingIdx]++];
        util$g.errorRequest(client2, request2, err);
      }
    } else {
      onError(client2, err);
    }
    client2.emit("connectionError", client2[kUrl$3], [client2], err);
  }
  client2[kResume$1]();
}
function emitDrain(client2) {
  client2[kNeedDrain$3] = 0;
  client2.emit("drain", client2[kUrl$3], [client2]);
}
function resume(client2, sync) {
  if (client2[kResuming] === 2) {
    return;
  }
  client2[kResuming] = 2;
  _resume(client2, sync);
  client2[kResuming] = 0;
  if (client2[kRunningIdx] > 256) {
    client2[kQueue$1].splice(0, client2[kRunningIdx]);
    client2[kPendingIdx] -= client2[kRunningIdx];
    client2[kRunningIdx] = 0;
  }
}
function _resume(client2, sync) {
  var _a2;
  while (true) {
    if (client2.destroyed) {
      assert$8(client2[kPending$2] === 0);
      return;
    }
    if (client2[kClosedResolve$1] && !client2[kSize$3]) {
      client2[kClosedResolve$1]();
      client2[kClosedResolve$1] = null;
      return;
    }
    if (client2[kHTTPContext]) {
      client2[kHTTPContext].resume();
    }
    if (client2[kBusy$1]) {
      client2[kNeedDrain$3] = 2;
    } else if (client2[kNeedDrain$3] === 2) {
      if (sync) {
        client2[kNeedDrain$3] = 1;
        queueMicrotask(() => emitDrain(client2));
      } else {
        emitDrain(client2);
      }
      continue;
    }
    if (client2[kPending$2] === 0) {
      return;
    }
    if (client2[kRunning$3] >= (getPipelining(client2) || 1)) {
      return;
    }
    const request2 = client2[kQueue$1][client2[kPendingIdx]];
    if (client2[kUrl$3].protocol === "https:" && client2[kServerName] !== request2.servername) {
      if (client2[kRunning$3] > 0) {
        return;
      }
      client2[kServerName] = request2.servername;
      (_a2 = client2[kHTTPContext]) == null ? void 0 : _a2.destroy(new InformationalError$1("servername changed"), () => {
        client2[kHTTPContext] = null;
        resume(client2);
      });
    }
    if (client2[kConnecting]) {
      return;
    }
    if (!client2[kHTTPContext]) {
      connect$2(client2);
      return;
    }
    if (client2[kHTTPContext].destroyed) {
      return;
    }
    if (client2[kHTTPContext].busy(request2)) {
      return;
    }
    if (!request2.aborted && client2[kHTTPContext].write(request2)) {
      client2[kPendingIdx]++;
    } else {
      client2[kQueue$1].splice(client2[kPendingIdx], 1);
    }
  }
}
var client = Client$4;
const kSize$2 = 2048;
const kMask = kSize$2 - 1;
class FixedCircularBuffer2 {
  constructor() {
    this.bottom = 0;
    this.top = 0;
    this.list = new Array(kSize$2);
    this.next = null;
  }
  isEmpty() {
    return this.top === this.bottom;
  }
  isFull() {
    return (this.top + 1 & kMask) === this.bottom;
  }
  push(data) {
    this.list[this.top] = data;
    this.top = this.top + 1 & kMask;
  }
  shift() {
    const nextItem = this.list[this.bottom];
    if (nextItem === void 0)
      return null;
    this.list[this.bottom] = void 0;
    this.bottom = this.bottom + 1 & kMask;
    return nextItem;
  }
}
var fixedQueue = class FixedQueue2 {
  constructor() {
    this.head = this.tail = new FixedCircularBuffer2();
  }
  isEmpty() {
    return this.head.isEmpty();
  }
  push(data) {
    if (this.head.isFull()) {
      this.head = this.head.next = new FixedCircularBuffer2();
    }
    this.head.push(data);
  }
  shift() {
    const tail = this.tail;
    const next = tail.shift();
    if (tail.isEmpty() && tail.next !== null) {
      this.tail = tail.next;
    }
    return next;
  }
};
const { kFree: kFree$1, kConnected: kConnected$3, kPending: kPending$1, kQueued: kQueued$1, kRunning: kRunning$2, kSize: kSize$1 } = symbols$4;
const kPool = Symbol("pool");
let PoolStats$1 = class PoolStats2 {
  constructor(pool2) {
    this[kPool] = pool2;
  }
  get connected() {
    return this[kPool][kConnected$3];
  }
  get free() {
    return this[kPool][kFree$1];
  }
  get pending() {
    return this[kPool][kPending$1];
  }
  get queued() {
    return this[kPool][kQueued$1];
  }
  get running() {
    return this[kPool][kRunning$2];
  }
  get size() {
    return this[kPool][kSize$1];
  }
};
var poolStats = PoolStats$1;
const DispatcherBase$3 = dispatcherBase;
const FixedQueue3 = fixedQueue;
const { kConnected: kConnected$2, kSize, kRunning: kRunning$1, kPending, kQueued, kBusy, kFree, kUrl: kUrl$2, kClose: kClose$5, kDestroy: kDestroy$3, kDispatch: kDispatch$2 } = symbols$4;
const PoolStats3 = poolStats;
const kClients$4 = Symbol("clients");
const kNeedDrain$2 = Symbol("needDrain");
const kQueue = Symbol("queue");
const kClosedResolve = Symbol("closed resolve");
const kOnDrain$1 = Symbol("onDrain");
const kOnConnect$1 = Symbol("onConnect");
const kOnDisconnect$1 = Symbol("onDisconnect");
const kOnConnectionError$1 = Symbol("onConnectionError");
const kGetDispatcher$2 = Symbol("get dispatcher");
const kAddClient$2 = Symbol("add client");
const kRemoveClient$1 = Symbol("remove client");
const kStats = Symbol("stats");
let PoolBase$2 = class PoolBase2 extends DispatcherBase$3 {
  constructor() {
    super();
    this[kQueue] = new FixedQueue3();
    this[kClients$4] = [];
    this[kQueued] = 0;
    const pool2 = this;
    this[kOnDrain$1] = function onDrain(origin, targets) {
      const queue2 = pool2[kQueue];
      let needDrain = false;
      while (!needDrain) {
        const item = queue2.shift();
        if (!item) {
          break;
        }
        pool2[kQueued]--;
        needDrain = !this.dispatch(item.opts, item.handler);
      }
      this[kNeedDrain$2] = needDrain;
      if (!this[kNeedDrain$2] && pool2[kNeedDrain$2]) {
        pool2[kNeedDrain$2] = false;
        pool2.emit("drain", origin, [pool2, ...targets]);
      }
      if (pool2[kClosedResolve] && queue2.isEmpty()) {
        Promise.all(pool2[kClients$4].map((c) => c.close())).then(pool2[kClosedResolve]);
      }
    };
    this[kOnConnect$1] = (origin, targets) => {
      pool2.emit("connect", origin, [pool2, ...targets]);
    };
    this[kOnDisconnect$1] = (origin, targets, err) => {
      pool2.emit("disconnect", origin, [pool2, ...targets], err);
    };
    this[kOnConnectionError$1] = (origin, targets, err) => {
      pool2.emit("connectionError", origin, [pool2, ...targets], err);
    };
    this[kStats] = new PoolStats3(this);
  }
  get [kBusy]() {
    return this[kNeedDrain$2];
  }
  get [kConnected$2]() {
    return this[kClients$4].filter((client2) => client2[kConnected$2]).length;
  }
  get [kFree]() {
    return this[kClients$4].filter((client2) => client2[kConnected$2] && !client2[kNeedDrain$2]).length;
  }
  get [kPending]() {
    let ret = this[kQueued];
    for (const { [kPending]: pending } of this[kClients$4]) {
      ret += pending;
    }
    return ret;
  }
  get [kRunning$1]() {
    let ret = 0;
    for (const { [kRunning$1]: running } of this[kClients$4]) {
      ret += running;
    }
    return ret;
  }
  get [kSize]() {
    let ret = this[kQueued];
    for (const { [kSize]: size } of this[kClients$4]) {
      ret += size;
    }
    return ret;
  }
  get stats() {
    return this[kStats];
  }
  async [kClose$5]() {
    if (this[kQueue].isEmpty()) {
      await Promise.all(this[kClients$4].map((c) => c.close()));
    } else {
      await new Promise((resolve2) => {
        this[kClosedResolve] = resolve2;
      });
    }
  }
  async [kDestroy$3](err) {
    while (true) {
      const item = this[kQueue].shift();
      if (!item) {
        break;
      }
      item.handler.onError(err);
    }
    await Promise.all(this[kClients$4].map((c) => c.destroy(err)));
  }
  [kDispatch$2](opts, handler) {
    const dispatcher2 = this[kGetDispatcher$2]();
    if (!dispatcher2) {
      this[kNeedDrain$2] = true;
      this[kQueue].push({ opts, handler });
      this[kQueued]++;
    } else if (!dispatcher2.dispatch(opts, handler)) {
      dispatcher2[kNeedDrain$2] = true;
      this[kNeedDrain$2] = !this[kGetDispatcher$2]();
    }
    return !this[kNeedDrain$2];
  }
  [kAddClient$2](client2) {
    client2.on("drain", this[kOnDrain$1]).on("connect", this[kOnConnect$1]).on("disconnect", this[kOnDisconnect$1]).on("connectionError", this[kOnConnectionError$1]);
    this[kClients$4].push(client2);
    if (this[kNeedDrain$2]) {
      queueMicrotask(() => {
        if (this[kNeedDrain$2]) {
          this[kOnDrain$1](client2[kUrl$2], [this, client2]);
        }
      });
    }
    return this;
  }
  [kRemoveClient$1](client2) {
    client2.close(() => {
      const idx = this[kClients$4].indexOf(client2);
      if (idx !== -1) {
        this[kClients$4].splice(idx, 1);
      }
    });
    this[kNeedDrain$2] = this[kClients$4].some((dispatcher2) => !dispatcher2[kNeedDrain$2] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
  }
};
var poolBase = {
  PoolBase: PoolBase$2,
  kClients: kClients$4,
  kNeedDrain: kNeedDrain$2,
  kAddClient: kAddClient$2,
  kRemoveClient: kRemoveClient$1,
  kGetDispatcher: kGetDispatcher$2
};
const {
  PoolBase: PoolBase$1,
  kClients: kClients$3,
  kNeedDrain: kNeedDrain$1,
  kAddClient: kAddClient$1,
  kGetDispatcher: kGetDispatcher$1
} = poolBase;
const Client$3 = client;
const {
  InvalidArgumentError: InvalidArgumentError$h
} = errors$1;
const util$f = util$n;
const { kUrl: kUrl$1, kInterceptors: kInterceptors$3 } = symbols$4;
const buildConnector$2 = connect$3;
const kOptions$3 = Symbol("options");
const kConnections = Symbol("connections");
const kFactory$3 = Symbol("factory");
function defaultFactory$3(origin, opts) {
  return new Client$3(origin, opts);
}
let Pool$5 = class Pool2 extends PoolBase$1 {
  constructor(origin, {
    connections,
    factory = defaultFactory$3,
    connect: connect2,
    connectTimeout,
    tls: tls2,
    maxCachedSessions,
    socketPath,
    autoSelectFamily,
    autoSelectFamilyAttemptTimeout,
    allowH2,
    ...options
  } = {}) {
    var _a2;
    super();
    if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
      throw new InvalidArgumentError$h("invalid connections");
    }
    if (typeof factory !== "function") {
      throw new InvalidArgumentError$h("factory must be a function.");
    }
    if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
      throw new InvalidArgumentError$h("connect must be a function or an object");
    }
    if (typeof connect2 !== "function") {
      connect2 = buildConnector$2({
        ...tls2,
        maxCachedSessions,
        allowH2,
        socketPath,
        timeout: connectTimeout,
        ...autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
        ...connect2
      });
    }
    this[kInterceptors$3] = ((_a2 = options.interceptors) == null ? void 0 : _a2.Pool) && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
    this[kConnections] = connections || null;
    this[kUrl$1] = util$f.parseOrigin(origin);
    this[kOptions$3] = { ...util$f.deepClone(options), connect: connect2, allowH2 };
    this[kOptions$3].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
    this[kFactory$3] = factory;
    this.on("connectionError", (origin2, targets, error) => {
      for (const target of targets) {
        const idx = this[kClients$3].indexOf(target);
        if (idx !== -1) {
          this[kClients$3].splice(idx, 1);
        }
      }
    });
  }
  [kGetDispatcher$1]() {
    for (const client2 of this[kClients$3]) {
      if (!client2[kNeedDrain$1]) {
        return client2;
      }
    }
    if (!this[kConnections] || this[kClients$3].length < this[kConnections]) {
      const dispatcher2 = this[kFactory$3](this[kUrl$1], this[kOptions$3]);
      this[kAddClient$1](dispatcher2);
      return dispatcher2;
    }
  }
};
var pool = Pool$5;
const {
  BalancedPoolMissingUpstreamError: BalancedPoolMissingUpstreamError3,
  InvalidArgumentError: InvalidArgumentError$g
} = errors$1;
const {
  PoolBase: PoolBase3,
  kClients: kClients$2,
  kNeedDrain,
  kAddClient,
  kRemoveClient,
  kGetDispatcher
} = poolBase;
const Pool$4 = pool;
const { kUrl, kInterceptors: kInterceptors$2 } = symbols$4;
const { parseOrigin } = util$n;
const kFactory$2 = Symbol("factory");
const kOptions$2 = Symbol("options");
const kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
const kCurrentWeight = Symbol("kCurrentWeight");
const kIndex = Symbol("kIndex");
const kWeight = Symbol("kWeight");
const kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
const kErrorPenalty = Symbol("kErrorPenalty");
function getGreatestCommonDivisor(a, b) {
  if (a === 0) return b;
  while (b !== 0) {
    const t = b;
    b = a % b;
    a = t;
  }
  return a;
}
function defaultFactory$2(origin, opts) {
  return new Pool$4(origin, opts);
}
let BalancedPool$1 = class BalancedPool2 extends PoolBase3 {
  constructor(upstreams = [], { factory = defaultFactory$2, ...opts } = {}) {
    var _a2;
    super();
    this[kOptions$2] = opts;
    this[kIndex] = -1;
    this[kCurrentWeight] = 0;
    this[kMaxWeightPerServer] = this[kOptions$2].maxWeightPerServer || 100;
    this[kErrorPenalty] = this[kOptions$2].errorPenalty || 15;
    if (!Array.isArray(upstreams)) {
      upstreams = [upstreams];
    }
    if (typeof factory !== "function") {
      throw new InvalidArgumentError$g("factory must be a function.");
    }
    this[kInterceptors$2] = ((_a2 = opts.interceptors) == null ? void 0 : _a2.BalancedPool) && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
    this[kFactory$2] = factory;
    for (const upstream of upstreams) {
      this.addUpstream(upstream);
    }
    this._updateBalancedPoolStats();
  }
  addUpstream(upstream) {
    const upstreamOrigin = parseOrigin(upstream).origin;
    if (this[kClients$2].find((pool3) => pool3[kUrl].origin === upstreamOrigin && pool3.closed !== true && pool3.destroyed !== true)) {
      return this;
    }
    const pool2 = this[kFactory$2](upstreamOrigin, Object.assign({}, this[kOptions$2]));
    this[kAddClient](pool2);
    pool2.on("connect", () => {
      pool2[kWeight] = Math.min(this[kMaxWeightPerServer], pool2[kWeight] + this[kErrorPenalty]);
    });
    pool2.on("connectionError", () => {
      pool2[kWeight] = Math.max(1, pool2[kWeight] - this[kErrorPenalty]);
      this._updateBalancedPoolStats();
    });
    pool2.on("disconnect", (...args) => {
      const err = args[2];
      if (err && err.code === "UND_ERR_SOCKET") {
        pool2[kWeight] = Math.max(1, pool2[kWeight] - this[kErrorPenalty]);
        this._updateBalancedPoolStats();
      }
    });
    for (const client2 of this[kClients$2]) {
      client2[kWeight] = this[kMaxWeightPerServer];
    }
    this._updateBalancedPoolStats();
    return this;
  }
  _updateBalancedPoolStats() {
    let result = 0;
    for (let i = 0; i < this[kClients$2].length; i++) {
      result = getGreatestCommonDivisor(this[kClients$2][i][kWeight], result);
    }
    this[kGreatestCommonDivisor] = result;
  }
  removeUpstream(upstream) {
    const upstreamOrigin = parseOrigin(upstream).origin;
    const pool2 = this[kClients$2].find((pool3) => pool3[kUrl].origin === upstreamOrigin && pool3.closed !== true && pool3.destroyed !== true);
    if (pool2) {
      this[kRemoveClient](pool2);
    }
    return this;
  }
  get upstreams() {
    return this[kClients$2].filter((dispatcher2) => dispatcher2.closed !== true && dispatcher2.destroyed !== true).map((p) => p[kUrl].origin);
  }
  [kGetDispatcher]() {
    if (this[kClients$2].length === 0) {
      throw new BalancedPoolMissingUpstreamError3();
    }
    const dispatcher2 = this[kClients$2].find((dispatcher3) => !dispatcher3[kNeedDrain] && dispatcher3.closed !== true && dispatcher3.destroyed !== true);
    if (!dispatcher2) {
      return;
    }
    const allClientsBusy = this[kClients$2].map((pool2) => pool2[kNeedDrain]).reduce((a, b) => a && b, true);
    if (allClientsBusy) {
      return;
    }
    let counter = 0;
    let maxWeightIndex = this[kClients$2].findIndex((pool2) => !pool2[kNeedDrain]);
    while (counter++ < this[kClients$2].length) {
      this[kIndex] = (this[kIndex] + 1) % this[kClients$2].length;
      const pool2 = this[kClients$2][this[kIndex]];
      if (pool2[kWeight] > this[kClients$2][maxWeightIndex][kWeight] && !pool2[kNeedDrain]) {
        maxWeightIndex = this[kIndex];
      }
      if (this[kIndex] === 0) {
        this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
        if (this[kCurrentWeight] <= 0) {
          this[kCurrentWeight] = this[kMaxWeightPerServer];
        }
      }
      if (pool2[kWeight] >= this[kCurrentWeight] && !pool2[kNeedDrain]) {
        return pool2;
      }
    }
    this[kCurrentWeight] = this[kClients$2][maxWeightIndex][kWeight];
    this[kIndex] = maxWeightIndex;
    return this[kClients$2][maxWeightIndex];
  }
};
var balancedPool = BalancedPool$1;
const { InvalidArgumentError: InvalidArgumentError$f } = errors$1;
const { kClients: kClients$1, kRunning, kClose: kClose$4, kDestroy: kDestroy$2, kDispatch: kDispatch$1, kInterceptors: kInterceptors$1 } = symbols$4;
const DispatcherBase$2 = dispatcherBase;
const Pool$3 = pool;
const Client$2 = client;
const util$e = util$n;
const createRedirectInterceptor$1 = redirectInterceptor;
const kOnConnect = Symbol("onConnect");
const kOnDisconnect = Symbol("onDisconnect");
const kOnConnectionError = Symbol("onConnectionError");
const kMaxRedirections = Symbol("maxRedirections");
const kOnDrain = Symbol("onDrain");
const kFactory$1 = Symbol("factory");
const kOptions$1 = Symbol("options");
function defaultFactory$1(origin, opts) {
  return opts && opts.connections === 1 ? new Client$2(origin, opts) : new Pool$3(origin, opts);
}
let Agent$5 = class Agent2 extends DispatcherBase$2 {
  constructor({ factory = defaultFactory$1, maxRedirections = 0, connect: connect2, ...options } = {}) {
    var _a2;
    super();
    if (typeof factory !== "function") {
      throw new InvalidArgumentError$f("factory must be a function.");
    }
    if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
      throw new InvalidArgumentError$f("connect must be a function or an object");
    }
    if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
      throw new InvalidArgumentError$f("maxRedirections must be a positive number");
    }
    if (connect2 && typeof connect2 !== "function") {
      connect2 = { ...connect2 };
    }
    this[kInterceptors$1] = ((_a2 = options.interceptors) == null ? void 0 : _a2.Agent) && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor$1({ maxRedirections })];
    this[kOptions$1] = { ...util$e.deepClone(options), connect: connect2 };
    this[kOptions$1].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
    this[kMaxRedirections] = maxRedirections;
    this[kFactory$1] = factory;
    this[kClients$1] = /* @__PURE__ */ new Map();
    this[kOnDrain] = (origin, targets) => {
      this.emit("drain", origin, [this, ...targets]);
    };
    this[kOnConnect] = (origin, targets) => {
      this.emit("connect", origin, [this, ...targets]);
    };
    this[kOnDisconnect] = (origin, targets, err) => {
      this.emit("disconnect", origin, [this, ...targets], err);
    };
    this[kOnConnectionError] = (origin, targets, err) => {
      this.emit("connectionError", origin, [this, ...targets], err);
    };
  }
  get [kRunning]() {
    let ret = 0;
    for (const client2 of this[kClients$1].values()) {
      ret += client2[kRunning];
    }
    return ret;
  }
  [kDispatch$1](opts, handler) {
    let key;
    if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
      key = String(opts.origin);
    } else {
      throw new InvalidArgumentError$f("opts.origin must be a non-empty string or URL.");
    }
    let dispatcher2 = this[kClients$1].get(key);
    if (!dispatcher2) {
      dispatcher2 = this[kFactory$1](opts.origin, this[kOptions$1]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
      this[kClients$1].set(key, dispatcher2);
    }
    return dispatcher2.dispatch(opts, handler);
  }
  async [kClose$4]() {
    const closePromises = [];
    for (const client2 of this[kClients$1].values()) {
      closePromises.push(client2.close());
    }
    this[kClients$1].clear();
    await Promise.all(closePromises);
  }
  async [kDestroy$2](err) {
    const destroyPromises = [];
    for (const client2 of this[kClients$1].values()) {
      destroyPromises.push(client2.destroy(err));
    }
    this[kClients$1].clear();
    await Promise.all(destroyPromises);
  }
};
var agent$1 = Agent$5;
const { kProxy, kClose: kClose$3, kDestroy: kDestroy$1, kInterceptors } = symbols$4;
const { URL: URL$1 } = require$$1$3;
const Agent$4 = agent$1;
const Pool$2 = pool;
const DispatcherBase$1 = dispatcherBase;
const { InvalidArgumentError: InvalidArgumentError$e, RequestAbortedError: RequestAbortedError$5, SecureProxyConnectionError: SecureProxyConnectionError3 } = errors$1;
const buildConnector$1 = connect$3;
const kAgent$1 = Symbol("proxy agent");
const kClient = Symbol("proxy client");
const kProxyHeaders = Symbol("proxy headers");
const kRequestTls = Symbol("request tls settings");
const kProxyTls = Symbol("proxy tls settings");
const kConnectEndpoint = Symbol("connect endpoint function");
function defaultProtocolPort(protocol) {
  return protocol === "https:" ? 443 : 80;
}
function defaultFactory(origin, opts) {
  return new Pool$2(origin, opts);
}
const noop$1 = () => {
};
let ProxyAgent$3 = (_q = class extends DispatcherBase$1 {
  constructor(opts) {
    var _a2;
    super();
    __privateAdd(this, _ProxyAgent_instances2);
    if (!opts || typeof opts === "object" && !(opts instanceof URL$1) && !opts.uri) {
      throw new InvalidArgumentError$e("Proxy uri is mandatory");
    }
    const { clientFactory = defaultFactory } = opts;
    if (typeof clientFactory !== "function") {
      throw new InvalidArgumentError$e("Proxy opts.clientFactory must be a function.");
    }
    const url = __privateMethod(this, _ProxyAgent_instances2, getUrl_fn2).call(this, opts);
    const { href, origin, port, protocol, username, password, hostname: proxyHostname } = url;
    this[kProxy] = { uri: href, protocol };
    this[kInterceptors] = ((_a2 = opts.interceptors) == null ? void 0 : _a2.ProxyAgent) && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
    this[kRequestTls] = opts.requestTls;
    this[kProxyTls] = opts.proxyTls;
    this[kProxyHeaders] = opts.headers || {};
    if (opts.auth && opts.token) {
      throw new InvalidArgumentError$e("opts.auth cannot be used in combination with opts.token");
    } else if (opts.auth) {
      this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
    } else if (opts.token) {
      this[kProxyHeaders]["proxy-authorization"] = opts.token;
    } else if (username && password) {
      this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
    }
    const connect2 = buildConnector$1({ ...opts.proxyTls });
    this[kConnectEndpoint] = buildConnector$1({ ...opts.requestTls });
    this[kClient] = clientFactory(url, { connect: connect2 });
    this[kAgent$1] = new Agent$4({
      ...opts,
      connect: async (opts2, callback) => {
        var _a3;
        let requestedPath = opts2.host;
        if (!opts2.port) {
          requestedPath += `:${defaultProtocolPort(opts2.protocol)}`;
        }
        try {
          const { socket, statusCode } = await this[kClient].connect({
            origin,
            port,
            path: requestedPath,
            signal: opts2.signal,
            headers: {
              ...this[kProxyHeaders],
              host: opts2.host
            },
            servername: ((_a3 = this[kProxyTls]) == null ? void 0 : _a3.servername) || proxyHostname
          });
          if (statusCode !== 200) {
            socket.on("error", noop$1).destroy();
            callback(new RequestAbortedError$5(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
          }
          if (opts2.protocol !== "https:") {
            callback(null, socket);
            return;
          }
          let servername;
          if (this[kRequestTls]) {
            servername = this[kRequestTls].servername;
          } else {
            servername = opts2.servername;
          }
          this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
        } catch (err) {
          if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
            callback(new SecureProxyConnectionError3(err));
          } else {
            callback(err);
          }
        }
      }
    });
  }
  dispatch(opts, handler) {
    const headers2 = buildHeaders(opts.headers);
    throwIfProxyAuthIsSent(headers2);
    if (headers2 && !("host" in headers2) && !("Host" in headers2)) {
      const { host } = new URL$1(opts.origin);
      headers2.host = host;
    }
    return this[kAgent$1].dispatch(
      {
        ...opts,
        headers: headers2
      },
      handler
    );
  }
  async [kClose$3]() {
    await this[kAgent$1].close();
    await this[kClient].close();
  }
  async [kDestroy$1]() {
    await this[kAgent$1].destroy();
    await this[kClient].destroy();
  }
}, _ProxyAgent_instances2 = new WeakSet(), /**
 * @param {import('../types/proxy-agent').ProxyAgent.Options | string | URL} opts
 * @returns {URL}
 */
getUrl_fn2 = function(opts) {
  if (typeof opts === "string") {
    return new URL$1(opts);
  } else if (opts instanceof URL$1) {
    return opts;
  } else {
    return new URL$1(opts.uri);
  }
}, _q);
function buildHeaders(headers2) {
  if (Array.isArray(headers2)) {
    const headersPair = {};
    for (let i = 0; i < headers2.length; i += 2) {
      headersPair[headers2[i]] = headers2[i + 1];
    }
    return headersPair;
  }
  return headers2;
}
function throwIfProxyAuthIsSent(headers2) {
  const existProxyAuth = headers2 && Object.keys(headers2).find((key) => key.toLowerCase() === "proxy-authorization");
  if (existProxyAuth) {
    throw new InvalidArgumentError$e("Proxy-Authorization should be sent in ProxyAgent constructor");
  }
}
var proxyAgent = ProxyAgent$3;
const DispatcherBase3 = dispatcherBase;
const { kClose: kClose$2, kDestroy, kClosed, kDestroyed, kDispatch, kNoProxyAgent, kHttpProxyAgent, kHttpsProxyAgent } = symbols$4;
const ProxyAgent$2 = proxyAgent;
const Agent$3 = agent$1;
const DEFAULT_PORTS = {
  "http:": 80,
  "https:": 443
};
let experimentalWarned = false;
let EnvHttpProxyAgent$1 = (_r = class extends DispatcherBase3 {
  constructor(opts = {}) {
    super();
    __privateAdd(this, _EnvHttpProxyAgent_instances2);
    __privateAdd(this, _noProxyValue2, null);
    __privateAdd(this, _noProxyEntries2, null);
    __privateAdd(this, _opts3, null);
    __privateSet(this, _opts3, opts);
    if (!experimentalWarned) {
      experimentalWarned = true;
      process.emitWarning("EnvHttpProxyAgent is experimental, expect them to change at any time.", {
        code: "UNDICI-EHPA"
      });
    }
    const { httpProxy, httpsProxy, noProxy, ...agentOpts } = opts;
    this[kNoProxyAgent] = new Agent$3(agentOpts);
    const HTTP_PROXY = httpProxy ?? process.env.http_proxy ?? process.env.HTTP_PROXY;
    if (HTTP_PROXY) {
      this[kHttpProxyAgent] = new ProxyAgent$2({ ...agentOpts, uri: HTTP_PROXY });
    } else {
      this[kHttpProxyAgent] = this[kNoProxyAgent];
    }
    const HTTPS_PROXY = httpsProxy ?? process.env.https_proxy ?? process.env.HTTPS_PROXY;
    if (HTTPS_PROXY) {
      this[kHttpsProxyAgent] = new ProxyAgent$2({ ...agentOpts, uri: HTTPS_PROXY });
    } else {
      this[kHttpsProxyAgent] = this[kHttpProxyAgent];
    }
    __privateMethod(this, _EnvHttpProxyAgent_instances2, parseNoProxy_fn2).call(this);
  }
  [kDispatch](opts, handler) {
    const url = new URL(opts.origin);
    const agent2 = __privateMethod(this, _EnvHttpProxyAgent_instances2, getProxyAgentForUrl_fn2).call(this, url);
    return agent2.dispatch(opts, handler);
  }
  async [kClose$2]() {
    await this[kNoProxyAgent].close();
    if (!this[kHttpProxyAgent][kClosed]) {
      await this[kHttpProxyAgent].close();
    }
    if (!this[kHttpsProxyAgent][kClosed]) {
      await this[kHttpsProxyAgent].close();
    }
  }
  async [kDestroy](err) {
    await this[kNoProxyAgent].destroy(err);
    if (!this[kHttpProxyAgent][kDestroyed]) {
      await this[kHttpProxyAgent].destroy(err);
    }
    if (!this[kHttpsProxyAgent][kDestroyed]) {
      await this[kHttpsProxyAgent].destroy(err);
    }
  }
}, _noProxyValue2 = new WeakMap(), _noProxyEntries2 = new WeakMap(), _opts3 = new WeakMap(), _EnvHttpProxyAgent_instances2 = new WeakSet(), getProxyAgentForUrl_fn2 = function(url) {
  let { protocol, host: hostname, port } = url;
  hostname = hostname.replace(/:\d*$/, "").toLowerCase();
  port = Number.parseInt(port, 10) || DEFAULT_PORTS[protocol] || 0;
  if (!__privateMethod(this, _EnvHttpProxyAgent_instances2, shouldProxy_fn2).call(this, hostname, port)) {
    return this[kNoProxyAgent];
  }
  if (protocol === "https:") {
    return this[kHttpsProxyAgent];
  }
  return this[kHttpProxyAgent];
}, shouldProxy_fn2 = function(hostname, port) {
  if (__privateGet(this, _EnvHttpProxyAgent_instances2, noProxyChanged_get2)) {
    __privateMethod(this, _EnvHttpProxyAgent_instances2, parseNoProxy_fn2).call(this);
  }
  if (__privateGet(this, _noProxyEntries2).length === 0) {
    return true;
  }
  if (__privateGet(this, _noProxyValue2) === "*") {
    return false;
  }
  for (let i = 0; i < __privateGet(this, _noProxyEntries2).length; i++) {
    const entry = __privateGet(this, _noProxyEntries2)[i];
    if (entry.port && entry.port !== port) {
      continue;
    }
    if (!/^[.*]/.test(entry.hostname)) {
      if (hostname === entry.hostname) {
        return false;
      }
    } else {
      if (hostname.endsWith(entry.hostname.replace(/^\*/, ""))) {
        return false;
      }
    }
  }
  return true;
}, parseNoProxy_fn2 = function() {
  const noProxyValue = __privateGet(this, _opts3).noProxy ?? __privateGet(this, _EnvHttpProxyAgent_instances2, noProxyEnv_get2);
  const noProxySplit = noProxyValue.split(/[,\s]/);
  const noProxyEntries = [];
  for (let i = 0; i < noProxySplit.length; i++) {
    const entry = noProxySplit[i];
    if (!entry) {
      continue;
    }
    const parsed = entry.match(/^(.+):(\d+)$/);
    noProxyEntries.push({
      hostname: (parsed ? parsed[1] : entry).toLowerCase(),
      port: parsed ? Number.parseInt(parsed[2], 10) : 0
    });
  }
  __privateSet(this, _noProxyValue2, noProxyValue);
  __privateSet(this, _noProxyEntries2, noProxyEntries);
}, noProxyChanged_get2 = function() {
  if (__privateGet(this, _opts3).noProxy !== void 0) {
    return false;
  }
  return __privateGet(this, _noProxyValue2) !== __privateGet(this, _EnvHttpProxyAgent_instances2, noProxyEnv_get2);
}, noProxyEnv_get2 = function() {
  return process.env.no_proxy ?? process.env.NO_PROXY ?? "";
}, _r);
var envHttpProxyAgent = EnvHttpProxyAgent$1;
const assert$7 = require$$0$3;
const { kRetryHandlerDefaultRetry } = symbols$4;
const { RequestRetryError: RequestRetryError3 } = errors$1;
const {
  isDisturbed,
  parseHeaders,
  parseRangeHeader,
  wrapRequestBody
} = util$n;
function calculateRetryAfterHeader(retryAfter) {
  const current = Date.now();
  return new Date(retryAfter).getTime() - current;
}
let RetryHandler$3 = class RetryHandler2 {
  constructor(opts, handlers) {
    const { retryOptions, ...dispatchOpts } = opts;
    const {
      // Retry scoped
      retry: retryFn,
      maxRetries,
      maxTimeout,
      minTimeout,
      timeoutFactor,
      // Response scoped
      methods,
      errorCodes,
      retryAfter,
      statusCodes
    } = retryOptions ?? {};
    this.dispatch = handlers.dispatch;
    this.handler = handlers.handler;
    this.opts = { ...dispatchOpts, body: wrapRequestBody(opts.body) };
    this.abort = null;
    this.aborted = false;
    this.retryOpts = {
      retry: retryFn ?? RetryHandler2[kRetryHandlerDefaultRetry],
      retryAfter: retryAfter ?? true,
      maxTimeout: maxTimeout ?? 30 * 1e3,
      // 30s,
      minTimeout: minTimeout ?? 500,
      // .5s
      timeoutFactor: timeoutFactor ?? 2,
      maxRetries: maxRetries ?? 5,
      // What errors we should retry
      methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
      // Indicates which errors to retry
      statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
      // List of errors to retry
      errorCodes: errorCodes ?? [
        "ECONNRESET",
        "ECONNREFUSED",
        "ENOTFOUND",
        "ENETDOWN",
        "ENETUNREACH",
        "EHOSTDOWN",
        "EHOSTUNREACH",
        "EPIPE",
        "UND_ERR_SOCKET"
      ]
    };
    this.retryCount = 0;
    this.retryCountCheckpoint = 0;
    this.start = 0;
    this.end = null;
    this.etag = null;
    this.resume = null;
    this.handler.onConnect((reason) => {
      this.aborted = true;
      if (this.abort) {
        this.abort(reason);
      } else {
        this.reason = reason;
      }
    });
  }
  onRequestSent() {
    if (this.handler.onRequestSent) {
      this.handler.onRequestSent();
    }
  }
  onUpgrade(statusCode, headers2, socket) {
    if (this.handler.onUpgrade) {
      this.handler.onUpgrade(statusCode, headers2, socket);
    }
  }
  onConnect(abort2) {
    if (this.aborted) {
      abort2(this.reason);
    } else {
      this.abort = abort2;
    }
  }
  onBodySent(chunk) {
    if (this.handler.onBodySent) return this.handler.onBodySent(chunk);
  }
  static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
    const { statusCode, code, headers: headers2 } = err;
    const { method, retryOptions } = opts;
    const {
      maxRetries,
      minTimeout,
      maxTimeout,
      timeoutFactor,
      statusCodes,
      errorCodes,
      methods
    } = retryOptions;
    const { counter } = state;
    if (code && code !== "UND_ERR_REQ_RETRY" && !errorCodes.includes(code)) {
      cb(err);
      return;
    }
    if (Array.isArray(methods) && !methods.includes(method)) {
      cb(err);
      return;
    }
    if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
      cb(err);
      return;
    }
    if (counter > maxRetries) {
      cb(err);
      return;
    }
    let retryAfterHeader = headers2 == null ? void 0 : headers2["retry-after"];
    if (retryAfterHeader) {
      retryAfterHeader = Number(retryAfterHeader);
      retryAfterHeader = Number.isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3;
    }
    const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(minTimeout * timeoutFactor ** (counter - 1), maxTimeout);
    setTimeout(() => cb(null), retryTimeout);
  }
  onHeaders(statusCode, rawHeaders, resume2, statusMessage) {
    const headers2 = parseHeaders(rawHeaders);
    this.retryCount += 1;
    if (statusCode >= 300) {
      if (this.retryOpts.statusCodes.includes(statusCode) === false) {
        return this.handler.onHeaders(
          statusCode,
          rawHeaders,
          resume2,
          statusMessage
        );
      } else {
        this.abort(
          new RequestRetryError3("Request failed", statusCode, {
            headers: headers2,
            data: {
              count: this.retryCount
            }
          })
        );
        return false;
      }
    }
    if (this.resume != null) {
      this.resume = null;
      if (statusCode !== 206 && (this.start > 0 || statusCode !== 200)) {
        this.abort(
          new RequestRetryError3("server does not support the range header and the payload was partially consumed", statusCode, {
            headers: headers2,
            data: { count: this.retryCount }
          })
        );
        return false;
      }
      const contentRange = parseRangeHeader(headers2["content-range"]);
      if (!contentRange) {
        this.abort(
          new RequestRetryError3("Content-Range mismatch", statusCode, {
            headers: headers2,
            data: { count: this.retryCount }
          })
        );
        return false;
      }
      if (this.etag != null && this.etag !== headers2.etag) {
        this.abort(
          new RequestRetryError3("ETag mismatch", statusCode, {
            headers: headers2,
            data: { count: this.retryCount }
          })
        );
        return false;
      }
      const { start, size, end = size - 1 } = contentRange;
      assert$7(this.start === start, "content-range mismatch");
      assert$7(this.end == null || this.end === end, "content-range mismatch");
      this.resume = resume2;
      return true;
    }
    if (this.end == null) {
      if (statusCode === 206) {
        const range = parseRangeHeader(headers2["content-range"]);
        if (range == null) {
          return this.handler.onHeaders(
            statusCode,
            rawHeaders,
            resume2,
            statusMessage
          );
        }
        const { start, size, end = size - 1 } = range;
        assert$7(
          start != null && Number.isFinite(start),
          "content-range mismatch"
        );
        assert$7(end != null && Number.isFinite(end), "invalid content-length");
        this.start = start;
        this.end = end;
      }
      if (this.end == null) {
        const contentLength = headers2["content-length"];
        this.end = contentLength != null ? Number(contentLength) - 1 : null;
      }
      assert$7(Number.isFinite(this.start));
      assert$7(
        this.end == null || Number.isFinite(this.end),
        "invalid content-length"
      );
      this.resume = resume2;
      this.etag = headers2.etag != null ? headers2.etag : null;
      if (this.etag != null && this.etag.startsWith("W/")) {
        this.etag = null;
      }
      return this.handler.onHeaders(
        statusCode,
        rawHeaders,
        resume2,
        statusMessage
      );
    }
    const err = new RequestRetryError3("Request failed", statusCode, {
      headers: headers2,
      data: { count: this.retryCount }
    });
    this.abort(err);
    return false;
  }
  onData(chunk) {
    this.start += chunk.length;
    return this.handler.onData(chunk);
  }
  onComplete(rawTrailers) {
    this.retryCount = 0;
    return this.handler.onComplete(rawTrailers);
  }
  onError(err) {
    if (this.aborted || isDisturbed(this.opts.body)) {
      return this.handler.onError(err);
    }
    if (this.retryCount - this.retryCountCheckpoint > 0) {
      this.retryCount = this.retryCountCheckpoint + (this.retryCount - this.retryCountCheckpoint);
    } else {
      this.retryCount += 1;
    }
    this.retryOpts.retry(
      err,
      {
        state: { counter: this.retryCount },
        opts: { retryOptions: this.retryOpts, ...this.opts }
      },
      onRetry.bind(this)
    );
    function onRetry(err2) {
      if (err2 != null || this.aborted || isDisturbed(this.opts.body)) {
        return this.handler.onError(err2);
      }
      if (this.start !== 0) {
        const headers2 = { range: `bytes=${this.start}-${this.end ?? ""}` };
        if (this.etag != null) {
          headers2["if-match"] = this.etag;
        }
        this.opts = {
          ...this.opts,
          headers: {
            ...this.opts.headers,
            ...headers2
          }
        };
      }
      try {
        this.retryCountCheckpoint = this.retryCount;
        this.dispatch(this.opts, this);
      } catch (err3) {
        this.handler.onError(err3);
      }
    }
  }
};
var retryHandler = RetryHandler$3;
const Dispatcher$2 = dispatcher;
const RetryHandler$2 = retryHandler;
let RetryAgent$1 = (_s = class extends Dispatcher$2 {
  constructor(agent2, options = {}) {
    super(options);
    __privateAdd(this, _agent2, null);
    __privateAdd(this, _options2, null);
    __privateSet(this, _agent2, agent2);
    __privateSet(this, _options2, options);
  }
  dispatch(opts, handler) {
    const retry2 = new RetryHandler$2({
      ...opts,
      retryOptions: __privateGet(this, _options2)
    }, {
      dispatch: __privateGet(this, _agent2).dispatch.bind(__privateGet(this, _agent2)),
      handler
    });
    return __privateGet(this, _agent2).dispatch(opts, retry2);
  }
  close() {
    return __privateGet(this, _agent2).close();
  }
  destroy() {
    return __privateGet(this, _agent2).destroy();
  }
}, _agent2 = new WeakMap(), _options2 = new WeakMap(), _s);
var retryAgent = RetryAgent$1;
var api$1 = {};
var apiRequest = { exports: {} };
const assert$6 = require$$0$3;
const { Readable: Readable$2 } = require$$0$4;
const { RequestAbortedError: RequestAbortedError$4, NotSupportedError: NotSupportedError3, InvalidArgumentError: InvalidArgumentError$d, AbortError: AbortError3 } = errors$1;
const util$d = util$n;
const { ReadableStreamFrom } = util$n;
const kConsume = Symbol("kConsume");
const kReading = Symbol("kReading");
const kBody = Symbol("kBody");
const kAbort = Symbol("kAbort");
const kContentType = Symbol("kContentType");
const kContentLength$1 = Symbol("kContentLength");
const noop = () => {
};
class BodyReadable2 extends Readable$2 {
  constructor({
    resume: resume2,
    abort: abort2,
    contentType = "",
    contentLength,
    highWaterMark = 64 * 1024
    // Same as nodejs fs streams.
  }) {
    super({
      autoDestroy: true,
      read: resume2,
      highWaterMark
    });
    this._readableState.dataEmitted = false;
    this[kAbort] = abort2;
    this[kConsume] = null;
    this[kBody] = null;
    this[kContentType] = contentType;
    this[kContentLength$1] = contentLength;
    this[kReading] = false;
  }
  destroy(err) {
    if (!err && !this._readableState.endEmitted) {
      err = new RequestAbortedError$4();
    }
    if (err) {
      this[kAbort]();
    }
    return super.destroy(err);
  }
  _destroy(err, callback) {
    if (!this[kReading]) {
      setImmediate(() => {
        callback(err);
      });
    } else {
      callback(err);
    }
  }
  on(ev, ...args) {
    if (ev === "data" || ev === "readable") {
      this[kReading] = true;
    }
    return super.on(ev, ...args);
  }
  addListener(ev, ...args) {
    return this.on(ev, ...args);
  }
  off(ev, ...args) {
    const ret = super.off(ev, ...args);
    if (ev === "data" || ev === "readable") {
      this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
    }
    return ret;
  }
  removeListener(ev, ...args) {
    return this.off(ev, ...args);
  }
  push(chunk) {
    if (this[kConsume] && chunk !== null) {
      consumePush(this[kConsume], chunk);
      return this[kReading] ? super.push(chunk) : true;
    }
    return super.push(chunk);
  }
  // https://fetch.spec.whatwg.org/#dom-body-text
  async text() {
    return consume(this, "text");
  }
  // https://fetch.spec.whatwg.org/#dom-body-json
  async json() {
    return consume(this, "json");
  }
  // https://fetch.spec.whatwg.org/#dom-body-blob
  async blob() {
    return consume(this, "blob");
  }
  // https://fetch.spec.whatwg.org/#dom-body-bytes
  async bytes() {
    return consume(this, "bytes");
  }
  // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
  async arrayBuffer() {
    return consume(this, "arrayBuffer");
  }
  // https://fetch.spec.whatwg.org/#dom-body-formdata
  async formData() {
    throw new NotSupportedError3();
  }
  // https://fetch.spec.whatwg.org/#dom-body-bodyused
  get bodyUsed() {
    return util$d.isDisturbed(this);
  }
  // https://fetch.spec.whatwg.org/#dom-body-body
  get body() {
    if (!this[kBody]) {
      this[kBody] = ReadableStreamFrom(this);
      if (this[kConsume]) {
        this[kBody].getReader();
        assert$6(this[kBody].locked);
      }
    }
    return this[kBody];
  }
  async dump(opts) {
    let limit = Number.isFinite(opts == null ? void 0 : opts.limit) ? opts.limit : 128 * 1024;
    const signal = opts == null ? void 0 : opts.signal;
    if (signal != null && (typeof signal !== "object" || !("aborted" in signal))) {
      throw new InvalidArgumentError$d("signal must be an AbortSignal");
    }
    signal == null ? void 0 : signal.throwIfAborted();
    if (this._readableState.closeEmitted) {
      return null;
    }
    return await new Promise((resolve2, reject) => {
      if (this[kContentLength$1] > limit) {
        this.destroy(new AbortError3());
      }
      const onAbort = () => {
        this.destroy(signal.reason ?? new AbortError3());
      };
      signal == null ? void 0 : signal.addEventListener("abort", onAbort);
      this.on("close", function() {
        signal == null ? void 0 : signal.removeEventListener("abort", onAbort);
        if (signal == null ? void 0 : signal.aborted) {
          reject(signal.reason ?? new AbortError3());
        } else {
          resolve2(null);
        }
      }).on("error", noop).on("data", function(chunk) {
        limit -= chunk.length;
        if (limit <= 0) {
          this.destroy();
        }
      }).resume();
    });
  }
}
function isLocked(self2) {
  return self2[kBody] && self2[kBody].locked === true || self2[kConsume];
}
function isUnusable(self2) {
  return util$d.isDisturbed(self2) || isLocked(self2);
}
async function consume(stream2, type) {
  assert$6(!stream2[kConsume]);
  return new Promise((resolve2, reject) => {
    if (isUnusable(stream2)) {
      const rState = stream2._readableState;
      if (rState.destroyed && rState.closeEmitted === false) {
        stream2.on("error", (err) => {
          reject(err);
        }).on("close", () => {
          reject(new TypeError("unusable"));
        });
      } else {
        reject(rState.errored ?? new TypeError("unusable"));
      }
    } else {
      queueMicrotask(() => {
        stream2[kConsume] = {
          type,
          stream: stream2,
          resolve: resolve2,
          reject,
          length: 0,
          body: []
        };
        stream2.on("error", function(err) {
          consumeFinish(this[kConsume], err);
        }).on("close", function() {
          if (this[kConsume].body !== null) {
            consumeFinish(this[kConsume], new RequestAbortedError$4());
          }
        });
        consumeStart(stream2[kConsume]);
      });
    }
  });
}
function consumeStart(consume2) {
  if (consume2.body === null) {
    return;
  }
  const { _readableState: state } = consume2.stream;
  if (state.bufferIndex) {
    const start = state.bufferIndex;
    const end = state.buffer.length;
    for (let n = start; n < end; n++) {
      consumePush(consume2, state.buffer[n]);
    }
  } else {
    for (const chunk of state.buffer) {
      consumePush(consume2, chunk);
    }
  }
  if (state.endEmitted) {
    consumeEnd(this[kConsume]);
  } else {
    consume2.stream.on("end", function() {
      consumeEnd(this[kConsume]);
    });
  }
  consume2.stream.resume();
  while (consume2.stream.read() != null) {
  }
}
function chunksDecode$1(chunks, length) {
  if (chunks.length === 0 || length === 0) {
    return "";
  }
  const buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks, length);
  const bufferLength = buffer.length;
  const start = bufferLength > 2 && buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191 ? 3 : 0;
  return buffer.utf8Slice(start, bufferLength);
}
function chunksConcat(chunks, length) {
  if (chunks.length === 0 || length === 0) {
    return new Uint8Array(0);
  }
  if (chunks.length === 1) {
    return new Uint8Array(chunks[0]);
  }
  const buffer = new Uint8Array(Buffer.allocUnsafeSlow(length).buffer);
  let offset = 0;
  for (let i = 0; i < chunks.length; ++i) {
    const chunk = chunks[i];
    buffer.set(chunk, offset);
    offset += chunk.length;
  }
  return buffer;
}
function consumeEnd(consume2) {
  const { type, body: body2, resolve: resolve2, stream: stream2, length } = consume2;
  try {
    if (type === "text") {
      resolve2(chunksDecode$1(body2, length));
    } else if (type === "json") {
      resolve2(JSON.parse(chunksDecode$1(body2, length)));
    } else if (type === "arrayBuffer") {
      resolve2(chunksConcat(body2, length).buffer);
    } else if (type === "blob") {
      resolve2(new Blob(body2, { type: stream2[kContentType] }));
    } else if (type === "bytes") {
      resolve2(chunksConcat(body2, length));
    }
    consumeFinish(consume2);
  } catch (err) {
    stream2.destroy(err);
  }
}
function consumePush(consume2, chunk) {
  consume2.length += chunk.length;
  consume2.body.push(chunk);
}
function consumeFinish(consume2, err) {
  if (consume2.body === null) {
    return;
  }
  if (err) {
    consume2.reject(err);
  } else {
    consume2.resolve();
  }
  consume2.type = null;
  consume2.stream = null;
  consume2.resolve = null;
  consume2.reject = null;
  consume2.length = 0;
  consume2.body = null;
}
var readable = { Readable: BodyReadable2, chunksDecode: chunksDecode$1 };
const assert$5 = require$$0$3;
const {
  ResponseStatusCodeError: ResponseStatusCodeError3
} = errors$1;
const { chunksDecode } = readable;
const CHUNK_LIMIT = 128 * 1024;
async function getResolveErrorBodyCallback$2({ callback, body: body2, contentType, statusCode, statusMessage, headers: headers2 }) {
  assert$5(body2);
  let chunks = [];
  let length = 0;
  try {
    for await (const chunk of body2) {
      chunks.push(chunk);
      length += chunk.length;
      if (length > CHUNK_LIMIT) {
        chunks = [];
        length = 0;
        break;
      }
    }
  } catch {
    chunks = [];
    length = 0;
  }
  const message = `Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`;
  if (statusCode === 204 || !contentType || !length) {
    queueMicrotask(() => callback(new ResponseStatusCodeError3(message, statusCode, headers2)));
    return;
  }
  const stackTraceLimit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  let payload;
  try {
    if (isContentTypeApplicationJson(contentType)) {
      payload = JSON.parse(chunksDecode(chunks, length));
    } else if (isContentTypeText(contentType)) {
      payload = chunksDecode(chunks, length);
    }
  } catch {
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
  queueMicrotask(() => callback(new ResponseStatusCodeError3(message, statusCode, headers2, payload)));
}
const isContentTypeApplicationJson = (contentType) => {
  return contentType.length > 15 && contentType[11] === "/" && contentType[0] === "a" && contentType[1] === "p" && contentType[2] === "p" && contentType[3] === "l" && contentType[4] === "i" && contentType[5] === "c" && contentType[6] === "a" && contentType[7] === "t" && contentType[8] === "i" && contentType[9] === "o" && contentType[10] === "n" && contentType[12] === "j" && contentType[13] === "s" && contentType[14] === "o" && contentType[15] === "n";
};
const isContentTypeText = (contentType) => {
  return contentType.length > 4 && contentType[4] === "/" && contentType[0] === "t" && contentType[1] === "e" && contentType[2] === "x" && contentType[3] === "t";
};
var util$c = {
  getResolveErrorBodyCallback: getResolveErrorBodyCallback$2
};
const assert$4 = require$$0$3;
const { Readable: Readable$1 } = readable;
const { InvalidArgumentError: InvalidArgumentError$c, RequestAbortedError: RequestAbortedError$3 } = errors$1;
const util$b = util$n;
const { getResolveErrorBodyCallback: getResolveErrorBodyCallback$1 } = util$c;
const { AsyncResource: AsyncResource$4 } = require$$1$4;
class RequestHandler2 extends AsyncResource$4 {
  constructor(opts, callback) {
    if (!opts || typeof opts !== "object") {
      throw new InvalidArgumentError$c("invalid opts");
    }
    const { signal, method, opaque, body: body2, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
    try {
      if (typeof callback !== "function") {
        throw new InvalidArgumentError$c("invalid callback");
      }
      if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
        throw new InvalidArgumentError$c("invalid highWaterMark");
      }
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError$c("signal must be an EventEmitter or EventTarget");
      }
      if (method === "CONNECT") {
        throw new InvalidArgumentError$c("invalid method");
      }
      if (onInfo && typeof onInfo !== "function") {
        throw new InvalidArgumentError$c("invalid onInfo callback");
      }
      super("UNDICI_REQUEST");
    } catch (err) {
      if (util$b.isStream(body2)) {
        util$b.destroy(body2.on("error", util$b.nop), err);
      }
      throw err;
    }
    this.method = method;
    this.responseHeaders = responseHeaders || null;
    this.opaque = opaque || null;
    this.callback = callback;
    this.res = null;
    this.abort = null;
    this.body = body2;
    this.trailers = {};
    this.context = null;
    this.onInfo = onInfo || null;
    this.throwOnError = throwOnError;
    this.highWaterMark = highWaterMark;
    this.signal = signal;
    this.reason = null;
    this.removeAbortListener = null;
    if (util$b.isStream(body2)) {
      body2.on("error", (err) => {
        this.onError(err);
      });
    }
    if (this.signal) {
      if (this.signal.aborted) {
        this.reason = this.signal.reason ?? new RequestAbortedError$3();
      } else {
        this.removeAbortListener = util$b.addAbortListener(this.signal, () => {
          var _a2;
          this.reason = this.signal.reason ?? new RequestAbortedError$3();
          if (this.res) {
            util$b.destroy(this.res.on("error", util$b.nop), this.reason);
          } else if (this.abort) {
            this.abort(this.reason);
          }
          if (this.removeAbortListener) {
            (_a2 = this.res) == null ? void 0 : _a2.off("close", this.removeAbortListener);
            this.removeAbortListener();
            this.removeAbortListener = null;
          }
        });
      }
    }
  }
  onConnect(abort2, context) {
    if (this.reason) {
      abort2(this.reason);
      return;
    }
    assert$4(this.callback);
    this.abort = abort2;
    this.context = context;
  }
  onHeaders(statusCode, rawHeaders, resume2, statusMessage) {
    const { callback, opaque, abort: abort2, context, responseHeaders, highWaterMark } = this;
    const headers2 = responseHeaders === "raw" ? util$b.parseRawHeaders(rawHeaders) : util$b.parseHeaders(rawHeaders);
    if (statusCode < 200) {
      if (this.onInfo) {
        this.onInfo({ statusCode, headers: headers2 });
      }
      return;
    }
    const parsedHeaders = responseHeaders === "raw" ? util$b.parseHeaders(rawHeaders) : headers2;
    const contentType = parsedHeaders["content-type"];
    const contentLength = parsedHeaders["content-length"];
    const res = new Readable$1({
      resume: resume2,
      abort: abort2,
      contentType,
      contentLength: this.method !== "HEAD" && contentLength ? Number(contentLength) : null,
      highWaterMark
    });
    if (this.removeAbortListener) {
      res.on("close", this.removeAbortListener);
    }
    this.callback = null;
    this.res = res;
    if (callback !== null) {
      if (this.throwOnError && statusCode >= 400) {
        this.runInAsyncScope(
          getResolveErrorBodyCallback$1,
          null,
          { callback, body: res, contentType, statusCode, statusMessage, headers: headers2 }
        );
      } else {
        this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers: headers2,
          trailers: this.trailers,
          opaque,
          body: res,
          context
        });
      }
    }
  }
  onData(chunk) {
    return this.res.push(chunk);
  }
  onComplete(trailers) {
    util$b.parseHeaders(trailers, this.trailers);
    this.res.push(null);
  }
  onError(err) {
    const { res, callback, body: body2, opaque } = this;
    if (callback) {
      this.callback = null;
      queueMicrotask(() => {
        this.runInAsyncScope(callback, null, err, { opaque });
      });
    }
    if (res) {
      this.res = null;
      queueMicrotask(() => {
        util$b.destroy(res, err);
      });
    }
    if (body2) {
      this.body = null;
      util$b.destroy(body2, err);
    }
    if (this.removeAbortListener) {
      res == null ? void 0 : res.off("close", this.removeAbortListener);
      this.removeAbortListener();
      this.removeAbortListener = null;
    }
  }
}
function request$1(opts, callback) {
  if (callback === void 0) {
    return new Promise((resolve2, reject) => {
      request$1.call(this, opts, (err, data) => {
        return err ? reject(err) : resolve2(data);
      });
    });
  }
  try {
    this.dispatch(opts, new RequestHandler2(opts, callback));
  } catch (err) {
    if (typeof callback !== "function") {
      throw err;
    }
    const opaque = opts == null ? void 0 : opts.opaque;
    queueMicrotask(() => callback(err, { opaque }));
  }
}
apiRequest.exports = request$1;
apiRequest.exports.RequestHandler = RequestHandler2;
var apiRequestExports = apiRequest.exports;
const { addAbortListener } = util$n;
const { RequestAbortedError: RequestAbortedError$2 } = errors$1;
const kListener = Symbol("kListener");
const kSignal = Symbol("kSignal");
function abort(self2) {
  var _a2, _b2;
  if (self2.abort) {
    self2.abort((_a2 = self2[kSignal]) == null ? void 0 : _a2.reason);
  } else {
    self2.reason = ((_b2 = self2[kSignal]) == null ? void 0 : _b2.reason) ?? new RequestAbortedError$2();
  }
  removeSignal$4(self2);
}
function addSignal$4(self2, signal) {
  self2.reason = null;
  self2[kSignal] = null;
  self2[kListener] = null;
  if (!signal) {
    return;
  }
  if (signal.aborted) {
    abort(self2);
    return;
  }
  self2[kSignal] = signal;
  self2[kListener] = () => {
    abort(self2);
  };
  addAbortListener(self2[kSignal], self2[kListener]);
}
function removeSignal$4(self2) {
  if (!self2[kSignal]) {
    return;
  }
  if ("removeEventListener" in self2[kSignal]) {
    self2[kSignal].removeEventListener("abort", self2[kListener]);
  } else {
    self2[kSignal].removeListener("abort", self2[kListener]);
  }
  self2[kSignal] = null;
  self2[kListener] = null;
}
var abortSignal = {
  addSignal: addSignal$4,
  removeSignal: removeSignal$4
};
const assert$3 = require$$0$3;
const { finished, PassThrough: PassThrough$2 } = require$$0$4;
const { InvalidArgumentError: InvalidArgumentError$b, InvalidReturnValueError: InvalidReturnValueError$1 } = errors$1;
const util$a = util$n;
const { getResolveErrorBodyCallback } = util$c;
const { AsyncResource: AsyncResource$3 } = require$$1$4;
const { addSignal: addSignal$3, removeSignal: removeSignal$3 } = abortSignal;
class StreamHandler2 extends AsyncResource$3 {
  constructor(opts, factory, callback) {
    if (!opts || typeof opts !== "object") {
      throw new InvalidArgumentError$b("invalid opts");
    }
    const { signal, method, opaque, body: body2, onInfo, responseHeaders, throwOnError } = opts;
    try {
      if (typeof callback !== "function") {
        throw new InvalidArgumentError$b("invalid callback");
      }
      if (typeof factory !== "function") {
        throw new InvalidArgumentError$b("invalid factory");
      }
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError$b("signal must be an EventEmitter or EventTarget");
      }
      if (method === "CONNECT") {
        throw new InvalidArgumentError$b("invalid method");
      }
      if (onInfo && typeof onInfo !== "function") {
        throw new InvalidArgumentError$b("invalid onInfo callback");
      }
      super("UNDICI_STREAM");
    } catch (err) {
      if (util$a.isStream(body2)) {
        util$a.destroy(body2.on("error", util$a.nop), err);
      }
      throw err;
    }
    this.responseHeaders = responseHeaders || null;
    this.opaque = opaque || null;
    this.factory = factory;
    this.callback = callback;
    this.res = null;
    this.abort = null;
    this.context = null;
    this.trailers = null;
    this.body = body2;
    this.onInfo = onInfo || null;
    this.throwOnError = throwOnError || false;
    if (util$a.isStream(body2)) {
      body2.on("error", (err) => {
        this.onError(err);
      });
    }
    addSignal$3(this, signal);
  }
  onConnect(abort2, context) {
    if (this.reason) {
      abort2(this.reason);
      return;
    }
    assert$3(this.callback);
    this.abort = abort2;
    this.context = context;
  }
  onHeaders(statusCode, rawHeaders, resume2, statusMessage) {
    var _a2;
    const { factory, opaque, context, callback, responseHeaders } = this;
    const headers2 = responseHeaders === "raw" ? util$a.parseRawHeaders(rawHeaders) : util$a.parseHeaders(rawHeaders);
    if (statusCode < 200) {
      if (this.onInfo) {
        this.onInfo({ statusCode, headers: headers2 });
      }
      return;
    }
    this.factory = null;
    let res;
    if (this.throwOnError && statusCode >= 400) {
      const parsedHeaders = responseHeaders === "raw" ? util$a.parseHeaders(rawHeaders) : headers2;
      const contentType = parsedHeaders["content-type"];
      res = new PassThrough$2();
      this.callback = null;
      this.runInAsyncScope(
        getResolveErrorBodyCallback,
        null,
        { callback, body: res, contentType, statusCode, statusMessage, headers: headers2 }
      );
    } else {
      if (factory === null) {
        return;
      }
      res = this.runInAsyncScope(factory, null, {
        statusCode,
        headers: headers2,
        opaque,
        context
      });
      if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
        throw new InvalidReturnValueError$1("expected Writable");
      }
      finished(res, { readable: false }, (err) => {
        const { callback: callback2, res: res2, opaque: opaque2, trailers, abort: abort2 } = this;
        this.res = null;
        if (err || !res2.readable) {
          util$a.destroy(res2, err);
        }
        this.callback = null;
        this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers });
        if (err) {
          abort2();
        }
      });
    }
    res.on("drain", resume2);
    this.res = res;
    const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : (_a2 = res._writableState) == null ? void 0 : _a2.needDrain;
    return needDrain !== true;
  }
  onData(chunk) {
    const { res } = this;
    return res ? res.write(chunk) : true;
  }
  onComplete(trailers) {
    const { res } = this;
    removeSignal$3(this);
    if (!res) {
      return;
    }
    this.trailers = util$a.parseHeaders(trailers);
    res.end();
  }
  onError(err) {
    const { res, callback, opaque, body: body2 } = this;
    removeSignal$3(this);
    this.factory = null;
    if (res) {
      this.res = null;
      util$a.destroy(res, err);
    } else if (callback) {
      this.callback = null;
      queueMicrotask(() => {
        this.runInAsyncScope(callback, null, err, { opaque });
      });
    }
    if (body2) {
      this.body = null;
      util$a.destroy(body2, err);
    }
  }
}
function stream(opts, factory, callback) {
  if (callback === void 0) {
    return new Promise((resolve2, reject) => {
      stream.call(this, opts, factory, (err, data) => {
        return err ? reject(err) : resolve2(data);
      });
    });
  }
  try {
    this.dispatch(opts, new StreamHandler2(opts, factory, callback));
  } catch (err) {
    if (typeof callback !== "function") {
      throw err;
    }
    const opaque = opts == null ? void 0 : opts.opaque;
    queueMicrotask(() => callback(err, { opaque }));
  }
}
var apiStream = stream;
const {
  Readable,
  Duplex,
  PassThrough: PassThrough$1
} = require$$0$4;
const {
  InvalidArgumentError: InvalidArgumentError$a,
  InvalidReturnValueError: InvalidReturnValueError3,
  RequestAbortedError: RequestAbortedError$1
} = errors$1;
const util$9 = util$n;
const { AsyncResource: AsyncResource$2 } = require$$1$4;
const { addSignal: addSignal$2, removeSignal: removeSignal$2 } = abortSignal;
const assert$2 = require$$0$3;
const kResume = Symbol("resume");
class PipelineRequest2 extends Readable {
  constructor() {
    super({ autoDestroy: true });
    this[kResume] = null;
  }
  _read() {
    const { [kResume]: resume2 } = this;
    if (resume2) {
      this[kResume] = null;
      resume2();
    }
  }
  _destroy(err, callback) {
    this._read();
    callback(err);
  }
}
class PipelineResponse2 extends Readable {
  constructor(resume2) {
    super({ autoDestroy: true });
    this[kResume] = resume2;
  }
  _read() {
    this[kResume]();
  }
  _destroy(err, callback) {
    if (!err && !this._readableState.endEmitted) {
      err = new RequestAbortedError$1();
    }
    callback(err);
  }
}
class PipelineHandler2 extends AsyncResource$2 {
  constructor(opts, handler) {
    if (!opts || typeof opts !== "object") {
      throw new InvalidArgumentError$a("invalid opts");
    }
    if (typeof handler !== "function") {
      throw new InvalidArgumentError$a("invalid handler");
    }
    const { signal, method, opaque, onInfo, responseHeaders } = opts;
    if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
      throw new InvalidArgumentError$a("signal must be an EventEmitter or EventTarget");
    }
    if (method === "CONNECT") {
      throw new InvalidArgumentError$a("invalid method");
    }
    if (onInfo && typeof onInfo !== "function") {
      throw new InvalidArgumentError$a("invalid onInfo callback");
    }
    super("UNDICI_PIPELINE");
    this.opaque = opaque || null;
    this.responseHeaders = responseHeaders || null;
    this.handler = handler;
    this.abort = null;
    this.context = null;
    this.onInfo = onInfo || null;
    this.req = new PipelineRequest2().on("error", util$9.nop);
    this.ret = new Duplex({
      readableObjectMode: opts.objectMode,
      autoDestroy: true,
      read: () => {
        const { body: body2 } = this;
        if (body2 == null ? void 0 : body2.resume) {
          body2.resume();
        }
      },
      write: (chunk, encoding2, callback) => {
        const { req: req2 } = this;
        if (req2.push(chunk, encoding2) || req2._readableState.destroyed) {
          callback();
        } else {
          req2[kResume] = callback;
        }
      },
      destroy: (err, callback) => {
        const { body: body2, req: req2, res, ret, abort: abort2 } = this;
        if (!err && !ret._readableState.endEmitted) {
          err = new RequestAbortedError$1();
        }
        if (abort2 && err) {
          abort2();
        }
        util$9.destroy(body2, err);
        util$9.destroy(req2, err);
        util$9.destroy(res, err);
        removeSignal$2(this);
        callback(err);
      }
    }).on("prefinish", () => {
      const { req: req2 } = this;
      req2.push(null);
    });
    this.res = null;
    addSignal$2(this, signal);
  }
  onConnect(abort2, context) {
    const { ret, res } = this;
    if (this.reason) {
      abort2(this.reason);
      return;
    }
    assert$2(!res, "pipeline cannot be retried");
    assert$2(!ret.destroyed);
    this.abort = abort2;
    this.context = context;
  }
  onHeaders(statusCode, rawHeaders, resume2) {
    const { opaque, handler, context } = this;
    if (statusCode < 200) {
      if (this.onInfo) {
        const headers2 = this.responseHeaders === "raw" ? util$9.parseRawHeaders(rawHeaders) : util$9.parseHeaders(rawHeaders);
        this.onInfo({ statusCode, headers: headers2 });
      }
      return;
    }
    this.res = new PipelineResponse2(resume2);
    let body2;
    try {
      this.handler = null;
      const headers2 = this.responseHeaders === "raw" ? util$9.parseRawHeaders(rawHeaders) : util$9.parseHeaders(rawHeaders);
      body2 = this.runInAsyncScope(handler, null, {
        statusCode,
        headers: headers2,
        opaque,
        body: this.res,
        context
      });
    } catch (err) {
      this.res.on("error", util$9.nop);
      throw err;
    }
    if (!body2 || typeof body2.on !== "function") {
      throw new InvalidReturnValueError3("expected Readable");
    }
    body2.on("data", (chunk) => {
      const { ret, body: body3 } = this;
      if (!ret.push(chunk) && body3.pause) {
        body3.pause();
      }
    }).on("error", (err) => {
      const { ret } = this;
      util$9.destroy(ret, err);
    }).on("end", () => {
      const { ret } = this;
      ret.push(null);
    }).on("close", () => {
      const { ret } = this;
      if (!ret._readableState.ended) {
        util$9.destroy(ret, new RequestAbortedError$1());
      }
    });
    this.body = body2;
  }
  onData(chunk) {
    const { res } = this;
    return res.push(chunk);
  }
  onComplete(trailers) {
    const { res } = this;
    res.push(null);
  }
  onError(err) {
    const { ret } = this;
    this.handler = null;
    util$9.destroy(ret, err);
  }
}
function pipeline(opts, handler) {
  try {
    const pipelineHandler = new PipelineHandler2(opts, handler);
    this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
    return pipelineHandler.ret;
  } catch (err) {
    return new PassThrough$1().destroy(err);
  }
}
var apiPipeline = pipeline;
const { InvalidArgumentError: InvalidArgumentError$9, SocketError: SocketError$1 } = errors$1;
const { AsyncResource: AsyncResource$1 } = require$$1$4;
const util$8 = util$n;
const { addSignal: addSignal$1, removeSignal: removeSignal$1 } = abortSignal;
const assert$1 = require$$0$3;
class UpgradeHandler2 extends AsyncResource$1 {
  constructor(opts, callback) {
    if (!opts || typeof opts !== "object") {
      throw new InvalidArgumentError$9("invalid opts");
    }
    if (typeof callback !== "function") {
      throw new InvalidArgumentError$9("invalid callback");
    }
    const { signal, opaque, responseHeaders } = opts;
    if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
      throw new InvalidArgumentError$9("signal must be an EventEmitter or EventTarget");
    }
    super("UNDICI_UPGRADE");
    this.responseHeaders = responseHeaders || null;
    this.opaque = opaque || null;
    this.callback = callback;
    this.abort = null;
    this.context = null;
    addSignal$1(this, signal);
  }
  onConnect(abort2, context) {
    if (this.reason) {
      abort2(this.reason);
      return;
    }
    assert$1(this.callback);
    this.abort = abort2;
    this.context = null;
  }
  onHeaders() {
    throw new SocketError$1("bad upgrade", null);
  }
  onUpgrade(statusCode, rawHeaders, socket) {
    assert$1(statusCode === 101);
    const { callback, opaque, context } = this;
    removeSignal$1(this);
    this.callback = null;
    const headers2 = this.responseHeaders === "raw" ? util$8.parseRawHeaders(rawHeaders) : util$8.parseHeaders(rawHeaders);
    this.runInAsyncScope(callback, null, null, {
      headers: headers2,
      socket,
      opaque,
      context
    });
  }
  onError(err) {
    const { callback, opaque } = this;
    removeSignal$1(this);
    if (callback) {
      this.callback = null;
      queueMicrotask(() => {
        this.runInAsyncScope(callback, null, err, { opaque });
      });
    }
  }
}
function upgrade(opts, callback) {
  if (callback === void 0) {
    return new Promise((resolve2, reject) => {
      upgrade.call(this, opts, (err, data) => {
        return err ? reject(err) : resolve2(data);
      });
    });
  }
  try {
    const upgradeHandler = new UpgradeHandler2(opts, callback);
    this.dispatch({
      ...opts,
      method: opts.method || "GET",
      upgrade: opts.protocol || "Websocket"
    }, upgradeHandler);
  } catch (err) {
    if (typeof callback !== "function") {
      throw err;
    }
    const opaque = opts == null ? void 0 : opts.opaque;
    queueMicrotask(() => callback(err, { opaque }));
  }
}
var apiUpgrade = upgrade;
const assert = require$$0$3;
const { AsyncResource } = require$$1$4;
const { InvalidArgumentError: InvalidArgumentError$8, SocketError: SocketError3 } = errors$1;
const util$7 = util$n;
const { addSignal, removeSignal } = abortSignal;
class ConnectHandler2 extends AsyncResource {
  constructor(opts, callback) {
    if (!opts || typeof opts !== "object") {
      throw new InvalidArgumentError$8("invalid opts");
    }
    if (typeof callback !== "function") {
      throw new InvalidArgumentError$8("invalid callback");
    }
    const { signal, opaque, responseHeaders } = opts;
    if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
      throw new InvalidArgumentError$8("signal must be an EventEmitter or EventTarget");
    }
    super("UNDICI_CONNECT");
    this.opaque = opaque || null;
    this.responseHeaders = responseHeaders || null;
    this.callback = callback;
    this.abort = null;
    addSignal(this, signal);
  }
  onConnect(abort2, context) {
    if (this.reason) {
      abort2(this.reason);
      return;
    }
    assert(this.callback);
    this.abort = abort2;
    this.context = context;
  }
  onHeaders() {
    throw new SocketError3("bad connect", null);
  }
  onUpgrade(statusCode, rawHeaders, socket) {
    const { callback, opaque, context } = this;
    removeSignal(this);
    this.callback = null;
    let headers2 = rawHeaders;
    if (headers2 != null) {
      headers2 = this.responseHeaders === "raw" ? util$7.parseRawHeaders(rawHeaders) : util$7.parseHeaders(rawHeaders);
    }
    this.runInAsyncScope(callback, null, null, {
      statusCode,
      headers: headers2,
      socket,
      opaque,
      context
    });
  }
  onError(err) {
    const { callback, opaque } = this;
    removeSignal(this);
    if (callback) {
      this.callback = null;
      queueMicrotask(() => {
        this.runInAsyncScope(callback, null, err, { opaque });
      });
    }
  }
}
function connect$1(opts, callback) {
  if (callback === void 0) {
    return new Promise((resolve2, reject) => {
      connect$1.call(this, opts, (err, data) => {
        return err ? reject(err) : resolve2(data);
      });
    });
  }
  try {
    const connectHandler = new ConnectHandler2(opts, callback);
    this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
  } catch (err) {
    if (typeof callback !== "function") {
      throw err;
    }
    const opaque = opts == null ? void 0 : opts.opaque;
    queueMicrotask(() => callback(err, { opaque }));
  }
}
var apiConnect = connect$1;
api$1.request = apiRequestExports;
api$1.stream = apiStream;
api$1.pipeline = apiPipeline;
api$1.upgrade = apiUpgrade;
api$1.connect = apiConnect;
const { UndiciError: UndiciError$1 } = errors$1;
let MockNotMatchedError$1 = class MockNotMatchedError2 extends UndiciError$1 {
  constructor(message) {
    super(message);
    Error.captureStackTrace(this, MockNotMatchedError2);
    this.name = "MockNotMatchedError";
    this.message = message || "The request does not match any registered mock dispatches";
    this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
  }
};
var mockErrors$1 = {
  MockNotMatchedError: MockNotMatchedError$1
};
var mockSymbols = {
  kAgent: Symbol("agent"),
  kOptions: Symbol("options"),
  kFactory: Symbol("factory"),
  kDispatches: Symbol("dispatches"),
  kDispatchKey: Symbol("dispatch key"),
  kDefaultHeaders: Symbol("default headers"),
  kDefaultTrailers: Symbol("default trailers"),
  kContentLength: Symbol("content length"),
  kMockAgent: Symbol("mock agent"),
  kMockAgentSet: Symbol("mock agent set"),
  kMockAgentGet: Symbol("mock agent get"),
  kMockDispatch: Symbol("mock dispatch"),
  kClose: Symbol("close"),
  kOriginalClose: Symbol("original agent close"),
  kOrigin: Symbol("origin"),
  kIsMockActive: Symbol("is mock active"),
  kNetConnect: Symbol("net connect"),
  kGetNetConnect: Symbol("get net connect"),
  kConnected: Symbol("connected")
};
const { MockNotMatchedError: MockNotMatchedError3 } = mockErrors$1;
const {
  kDispatches: kDispatches$4,
  kMockAgent: kMockAgent$2,
  kOriginalDispatch: kOriginalDispatch$2,
  kOrigin: kOrigin$2,
  kGetNetConnect: kGetNetConnect$1
} = mockSymbols;
const { buildURL: buildURL$1 } = util$n;
const { STATUS_CODES } = require$$2$1;
const {
  types: {
    isPromise
  }
} = require$$0$2;
function matchValue$1(match, value) {
  if (typeof match === "string") {
    return match === value;
  }
  if (match instanceof RegExp) {
    return match.test(value);
  }
  if (typeof match === "function") {
    return match(value) === true;
  }
  return false;
}
function lowerCaseEntries(headers2) {
  return Object.fromEntries(
    Object.entries(headers2).map(([headerName, headerValue]) => {
      return [headerName.toLocaleLowerCase(), headerValue];
    })
  );
}
function getHeaderByName(headers2, key) {
  if (Array.isArray(headers2)) {
    for (let i = 0; i < headers2.length; i += 2) {
      if (headers2[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
        return headers2[i + 1];
      }
    }
    return void 0;
  } else if (typeof headers2.get === "function") {
    return headers2.get(key);
  } else {
    return lowerCaseEntries(headers2)[key.toLocaleLowerCase()];
  }
}
function buildHeadersFromArray(headers2) {
  const clone = headers2.slice();
  const entries = [];
  for (let index = 0; index < clone.length; index += 2) {
    entries.push([clone[index], clone[index + 1]]);
  }
  return Object.fromEntries(entries);
}
function matchHeaders(mockDispatch2, headers2) {
  if (typeof mockDispatch2.headers === "function") {
    if (Array.isArray(headers2)) {
      headers2 = buildHeadersFromArray(headers2);
    }
    return mockDispatch2.headers(headers2 ? lowerCaseEntries(headers2) : {});
  }
  if (typeof mockDispatch2.headers === "undefined") {
    return true;
  }
  if (typeof headers2 !== "object" || typeof mockDispatch2.headers !== "object") {
    return false;
  }
  for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
    const headerValue = getHeaderByName(headers2, matchHeaderName);
    if (!matchValue$1(matchHeaderValue, headerValue)) {
      return false;
    }
  }
  return true;
}
function safeUrl(path2) {
  if (typeof path2 !== "string") {
    return path2;
  }
  const pathSegments = path2.split("?");
  if (pathSegments.length !== 2) {
    return path2;
  }
  const qp = new URLSearchParams(pathSegments.pop());
  qp.sort();
  return [...pathSegments, qp.toString()].join("?");
}
function matchKey(mockDispatch2, { path: path2, method, body: body2, headers: headers2 }) {
  const pathMatch2 = matchValue$1(mockDispatch2.path, path2);
  const methodMatch = matchValue$1(mockDispatch2.method, method);
  const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue$1(mockDispatch2.body, body2) : true;
  const headersMatch = matchHeaders(mockDispatch2, headers2);
  return pathMatch2 && methodMatch && bodyMatch && headersMatch;
}
function getResponseData$1(data) {
  if (Buffer.isBuffer(data)) {
    return data;
  } else if (data instanceof Uint8Array) {
    return data;
  } else if (data instanceof ArrayBuffer) {
    return data;
  } else if (typeof data === "object") {
    return JSON.stringify(data);
  } else {
    return data.toString();
  }
}
function getMockDispatch(mockDispatches, key) {
  const basePath = key.query ? buildURL$1(key.path, key.query) : key.path;
  const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
  let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path: path2 }) => matchValue$1(safeUrl(path2), resolvedPath));
  if (matchedMockDispatches.length === 0) {
    throw new MockNotMatchedError3(`Mock dispatch not matched for path '${resolvedPath}'`);
  }
  matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue$1(method, key.method));
  if (matchedMockDispatches.length === 0) {
    throw new MockNotMatchedError3(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`);
  }
  matchedMockDispatches = matchedMockDispatches.filter(({ body: body2 }) => typeof body2 !== "undefined" ? matchValue$1(body2, key.body) : true);
  if (matchedMockDispatches.length === 0) {
    throw new MockNotMatchedError3(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`);
  }
  matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
  if (matchedMockDispatches.length === 0) {
    const headers2 = typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers;
    throw new MockNotMatchedError3(`Mock dispatch not matched for headers '${headers2}' on path '${resolvedPath}'`);
  }
  return matchedMockDispatches[0];
}
function addMockDispatch$1(mockDispatches, key, data) {
  const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
  const replyData = typeof data === "function" ? { callback: data } : { ...data };
  const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
  mockDispatches.push(newMockDispatch);
  return newMockDispatch;
}
function deleteMockDispatch(mockDispatches, key) {
  const index = mockDispatches.findIndex((dispatch) => {
    if (!dispatch.consumed) {
      return false;
    }
    return matchKey(dispatch, key);
  });
  if (index !== -1) {
    mockDispatches.splice(index, 1);
  }
}
function buildKey$1(opts) {
  const { path: path2, method, body: body2, headers: headers2, query } = opts;
  return {
    path: path2,
    method,
    body: body2,
    headers: headers2,
    query
  };
}
function generateKeyValues(data) {
  const keys = Object.keys(data);
  const result = [];
  for (let i = 0; i < keys.length; ++i) {
    const key = keys[i];
    const value = data[key];
    const name = Buffer.from(`${key}`);
    if (Array.isArray(value)) {
      for (let j = 0; j < value.length; ++j) {
        result.push(name, Buffer.from(`${value[j]}`));
      }
    } else {
      result.push(name, Buffer.from(`${value}`));
    }
  }
  return result;
}
function getStatusText(statusCode) {
  return STATUS_CODES[statusCode] || "unknown";
}
function mockDispatch(opts, handler) {
  const key = buildKey$1(opts);
  const mockDispatch2 = getMockDispatch(this[kDispatches$4], key);
  mockDispatch2.timesInvoked++;
  if (mockDispatch2.data.callback) {
    mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
  }
  const { data: { statusCode, data, headers: headers2, trailers, error }, delay, persist } = mockDispatch2;
  const { timesInvoked, times } = mockDispatch2;
  mockDispatch2.consumed = !persist && timesInvoked >= times;
  mockDispatch2.pending = timesInvoked < times;
  if (error !== null) {
    deleteMockDispatch(this[kDispatches$4], key);
    handler.onError(error);
    return true;
  }
  if (typeof delay === "number" && delay > 0) {
    setTimeout(() => {
      handleReply(this[kDispatches$4]);
    }, delay);
  } else {
    handleReply(this[kDispatches$4]);
  }
  function handleReply(mockDispatches, _data = data) {
    var _a2, _b2, _c2, _d2;
    const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
    const body2 = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
    if (isPromise(body2)) {
      body2.then((newData) => handleReply(mockDispatches, newData));
      return;
    }
    const responseData = getResponseData$1(body2);
    const responseHeaders = generateKeyValues(headers2);
    const responseTrailers = generateKeyValues(trailers);
    (_a2 = handler.onConnect) == null ? void 0 : _a2.call(handler, (err) => handler.onError(err), null);
    (_b2 = handler.onHeaders) == null ? void 0 : _b2.call(handler, statusCode, responseHeaders, resume2, getStatusText(statusCode));
    (_c2 = handler.onData) == null ? void 0 : _c2.call(handler, Buffer.from(responseData));
    (_d2 = handler.onComplete) == null ? void 0 : _d2.call(handler, responseTrailers);
    deleteMockDispatch(mockDispatches, key);
  }
  function resume2() {
  }
  return true;
}
function buildMockDispatch$2() {
  const agent2 = this[kMockAgent$2];
  const origin = this[kOrigin$2];
  const originalDispatch = this[kOriginalDispatch$2];
  return function dispatch(opts, handler) {
    if (agent2.isMockActive) {
      try {
        mockDispatch.call(this, opts, handler);
      } catch (error) {
        if (error instanceof MockNotMatchedError3) {
          const netConnect = agent2[kGetNetConnect$1]();
          if (netConnect === false) {
            throw new MockNotMatchedError3(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
          }
          if (checkNetConnect(netConnect, origin)) {
            originalDispatch.call(this, opts, handler);
          } else {
            throw new MockNotMatchedError3(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
          }
        } else {
          throw error;
        }
      }
    } else {
      originalDispatch.call(this, opts, handler);
    }
  };
}
function checkNetConnect(netConnect, origin) {
  const url = new URL(origin);
  if (netConnect === true) {
    return true;
  } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue$1(matcher, url.host))) {
    return true;
  }
  return false;
}
function buildMockOptions$1(opts) {
  if (opts) {
    const { agent: agent2, ...mockOptions } = opts;
    return mockOptions;
  }
}
var mockUtils = {
  getResponseData: getResponseData$1,
  addMockDispatch: addMockDispatch$1,
  buildKey: buildKey$1,
  matchValue: matchValue$1,
  buildMockDispatch: buildMockDispatch$2,
  buildMockOptions: buildMockOptions$1
};
var mockInterceptor = {};
const { getResponseData, buildKey, addMockDispatch } = mockUtils;
const {
  kDispatches: kDispatches$3,
  kDispatchKey,
  kDefaultHeaders,
  kDefaultTrailers,
  kContentLength,
  kMockDispatch
} = mockSymbols;
const { InvalidArgumentError: InvalidArgumentError$7 } = errors$1;
const { buildURL } = util$n;
class MockScope2 {
  constructor(mockDispatch2) {
    this[kMockDispatch] = mockDispatch2;
  }
  /**
   * Delay a reply by a set amount in ms.
   */
  delay(waitInMs) {
    if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
      throw new InvalidArgumentError$7("waitInMs must be a valid integer > 0");
    }
    this[kMockDispatch].delay = waitInMs;
    return this;
  }
  /**
   * For a defined reply, never mark as consumed.
   */
  persist() {
    this[kMockDispatch].persist = true;
    return this;
  }
  /**
   * Allow one to define a reply for a set amount of matching requests.
   */
  times(repeatTimes) {
    if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
      throw new InvalidArgumentError$7("repeatTimes must be a valid integer > 0");
    }
    this[kMockDispatch].times = repeatTimes;
    return this;
  }
}
let MockInterceptor$2 = class MockInterceptor2 {
  constructor(opts, mockDispatches) {
    if (typeof opts !== "object") {
      throw new InvalidArgumentError$7("opts must be an object");
    }
    if (typeof opts.path === "undefined") {
      throw new InvalidArgumentError$7("opts.path must be defined");
    }
    if (typeof opts.method === "undefined") {
      opts.method = "GET";
    }
    if (typeof opts.path === "string") {
      if (opts.query) {
        opts.path = buildURL(opts.path, opts.query);
      } else {
        const parsedURL = new URL(opts.path, "data://");
        opts.path = parsedURL.pathname + parsedURL.search;
      }
    }
    if (typeof opts.method === "string") {
      opts.method = opts.method.toUpperCase();
    }
    this[kDispatchKey] = buildKey(opts);
    this[kDispatches$3] = mockDispatches;
    this[kDefaultHeaders] = {};
    this[kDefaultTrailers] = {};
    this[kContentLength] = false;
  }
  createMockScopeDispatchData({ statusCode, data, responseOptions }) {
    const responseData = getResponseData(data);
    const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
    const headers2 = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
    const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
    return { statusCode, data, headers: headers2, trailers };
  }
  validateReplyParameters(replyParameters) {
    if (typeof replyParameters.statusCode === "undefined") {
      throw new InvalidArgumentError$7("statusCode must be defined");
    }
    if (typeof replyParameters.responseOptions !== "object" || replyParameters.responseOptions === null) {
      throw new InvalidArgumentError$7("responseOptions must be an object");
    }
  }
  /**
   * Mock an undici request with a defined reply.
   */
  reply(replyOptionsCallbackOrStatusCode) {
    if (typeof replyOptionsCallbackOrStatusCode === "function") {
      const wrappedDefaultsCallback = (opts) => {
        const resolvedData = replyOptionsCallbackOrStatusCode(opts);
        if (typeof resolvedData !== "object" || resolvedData === null) {
          throw new InvalidArgumentError$7("reply options callback must return an object");
        }
        const replyParameters2 = { data: "", responseOptions: {}, ...resolvedData };
        this.validateReplyParameters(replyParameters2);
        return {
          ...this.createMockScopeDispatchData(replyParameters2)
        };
      };
      const newMockDispatch2 = addMockDispatch(this[kDispatches$3], this[kDispatchKey], wrappedDefaultsCallback);
      return new MockScope2(newMockDispatch2);
    }
    const replyParameters = {
      statusCode: replyOptionsCallbackOrStatusCode,
      data: arguments[1] === void 0 ? "" : arguments[1],
      responseOptions: arguments[2] === void 0 ? {} : arguments[2]
    };
    this.validateReplyParameters(replyParameters);
    const dispatchData = this.createMockScopeDispatchData(replyParameters);
    const newMockDispatch = addMockDispatch(this[kDispatches$3], this[kDispatchKey], dispatchData);
    return new MockScope2(newMockDispatch);
  }
  /**
   * Mock an undici request with a defined error.
   */
  replyWithError(error) {
    if (typeof error === "undefined") {
      throw new InvalidArgumentError$7("error must be defined");
    }
    const newMockDispatch = addMockDispatch(this[kDispatches$3], this[kDispatchKey], { error });
    return new MockScope2(newMockDispatch);
  }
  /**
   * Set default reply headers on the interceptor for subsequent replies
   */
  defaultReplyHeaders(headers2) {
    if (typeof headers2 === "undefined") {
      throw new InvalidArgumentError$7("headers must be defined");
    }
    this[kDefaultHeaders] = headers2;
    return this;
  }
  /**
   * Set default reply trailers on the interceptor for subsequent replies
   */
  defaultReplyTrailers(trailers) {
    if (typeof trailers === "undefined") {
      throw new InvalidArgumentError$7("trailers must be defined");
    }
    this[kDefaultTrailers] = trailers;
    return this;
  }
  /**
   * Set reply content length header for replies on the interceptor
   */
  replyContentLength() {
    this[kContentLength] = true;
    return this;
  }
};
mockInterceptor.MockInterceptor = MockInterceptor$2;
mockInterceptor.MockScope = MockScope2;
const { promisify: promisify$1 } = require$$0$2;
const Client$1 = client;
const { buildMockDispatch: buildMockDispatch$1 } = mockUtils;
const {
  kDispatches: kDispatches$2,
  kMockAgent: kMockAgent$1,
  kClose: kClose$1,
  kOriginalClose: kOriginalClose$1,
  kOrigin: kOrigin$1,
  kOriginalDispatch: kOriginalDispatch$1,
  kConnected: kConnected$1
} = mockSymbols;
const { MockInterceptor: MockInterceptor$1 } = mockInterceptor;
const Symbols$1 = symbols$4;
const { InvalidArgumentError: InvalidArgumentError$6 } = errors$1;
let MockClient$2 = class MockClient2 extends Client$1 {
  constructor(origin, opts) {
    super(origin, opts);
    if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
      throw new InvalidArgumentError$6("Argument opts.agent must implement Agent");
    }
    this[kMockAgent$1] = opts.agent;
    this[kOrigin$1] = origin;
    this[kDispatches$2] = [];
    this[kConnected$1] = 1;
    this[kOriginalDispatch$1] = this.dispatch;
    this[kOriginalClose$1] = this.close.bind(this);
    this.dispatch = buildMockDispatch$1.call(this);
    this.close = this[kClose$1];
  }
  get [Symbols$1.kConnected]() {
    return this[kConnected$1];
  }
  /**
   * Sets up the base interceptor for mocking replies from undici.
   */
  intercept(opts) {
    return new MockInterceptor$1(opts, this[kDispatches$2]);
  }
  async [kClose$1]() {
    await promisify$1(this[kOriginalClose$1])();
    this[kConnected$1] = 0;
    this[kMockAgent$1][Symbols$1.kClients].delete(this[kOrigin$1]);
  }
};
var mockClient = MockClient$2;
const { promisify } = require$$0$2;
const Pool$1 = pool;
const { buildMockDispatch } = mockUtils;
const {
  kDispatches: kDispatches$1,
  kMockAgent,
  kClose,
  kOriginalClose,
  kOrigin,
  kOriginalDispatch,
  kConnected
} = mockSymbols;
const { MockInterceptor: MockInterceptor3 } = mockInterceptor;
const Symbols = symbols$4;
const { InvalidArgumentError: InvalidArgumentError$5 } = errors$1;
let MockPool$2 = class MockPool2 extends Pool$1 {
  constructor(origin, opts) {
    super(origin, opts);
    if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
      throw new InvalidArgumentError$5("Argument opts.agent must implement Agent");
    }
    this[kMockAgent] = opts.agent;
    this[kOrigin] = origin;
    this[kDispatches$1] = [];
    this[kConnected] = 1;
    this[kOriginalDispatch] = this.dispatch;
    this[kOriginalClose] = this.close.bind(this);
    this.dispatch = buildMockDispatch.call(this);
    this.close = this[kClose];
  }
  get [Symbols.kConnected]() {
    return this[kConnected];
  }
  /**
   * Sets up the base interceptor for mocking replies from undici.
   */
  intercept(opts) {
    return new MockInterceptor3(opts, this[kDispatches$1]);
  }
  async [kClose]() {
    await promisify(this[kOriginalClose])();
    this[kConnected] = 0;
    this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
  }
};
var mockPool = MockPool$2;
const singulars = {
  pronoun: "it",
  is: "is",
  was: "was",
  this: "this"
};
const plurals = {
  pronoun: "they",
  is: "are",
  was: "were",
  this: "these"
};
var pluralizer = class Pluralizer {
  constructor(singular, plural) {
    this.singular = singular;
    this.plural = plural;
  }
  pluralize(count) {
    const one = count === 1;
    const keys = one ? singulars : plurals;
    const noun = one ? this.singular : this.plural;
    return { ...keys, count, noun };
  }
};
const { Transform } = require$$0$4;
const { Console } = require$$1$5;
const PERSISTENT = process.versions.icu ? "✅" : "Y ";
const NOT_PERSISTENT = process.versions.icu ? "❌" : "N ";
var pendingInterceptorsFormatter = class PendingInterceptorsFormatter2 {
  constructor({ disableColors } = {}) {
    this.transform = new Transform({
      transform(chunk, _enc, cb) {
        cb(null, chunk);
      }
    });
    this.logger = new Console({
      stdout: this.transform,
      inspectOptions: {
        colors: !disableColors && !process.env.CI
      }
    });
  }
  format(pendingInterceptors) {
    const withPrettyHeaders = pendingInterceptors.map(
      ({ method, path: path2, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
        Method: method,
        Origin: origin,
        Path: path2,
        "Status code": statusCode,
        Persistent: persist ? PERSISTENT : NOT_PERSISTENT,
        Invocations: timesInvoked,
        Remaining: persist ? Infinity : times - timesInvoked
      })
    );
    this.logger.table(withPrettyHeaders);
    return this.transform.read().toString();
  }
};
const { kClients } = symbols$4;
const Agent$2 = agent$1;
const {
  kAgent,
  kMockAgentSet,
  kMockAgentGet,
  kDispatches,
  kIsMockActive,
  kNetConnect,
  kGetNetConnect,
  kOptions,
  kFactory
} = mockSymbols;
const MockClient$1 = mockClient;
const MockPool$1 = mockPool;
const { matchValue, buildMockOptions } = mockUtils;
const { InvalidArgumentError: InvalidArgumentError$4, UndiciError: UndiciError3 } = errors$1;
const Dispatcher$1 = dispatcher;
const Pluralizer2 = pluralizer;
const PendingInterceptorsFormatter3 = pendingInterceptorsFormatter;
let MockAgent$1 = class MockAgent2 extends Dispatcher$1 {
  constructor(opts) {
    super(opts);
    this[kNetConnect] = true;
    this[kIsMockActive] = true;
    if ((opts == null ? void 0 : opts.agent) && typeof opts.agent.dispatch !== "function") {
      throw new InvalidArgumentError$4("Argument opts.agent must implement Agent");
    }
    const agent2 = (opts == null ? void 0 : opts.agent) ? opts.agent : new Agent$2(opts);
    this[kAgent] = agent2;
    this[kClients] = agent2[kClients];
    this[kOptions] = buildMockOptions(opts);
  }
  get(origin) {
    let dispatcher2 = this[kMockAgentGet](origin);
    if (!dispatcher2) {
      dispatcher2 = this[kFactory](origin);
      this[kMockAgentSet](origin, dispatcher2);
    }
    return dispatcher2;
  }
  dispatch(opts, handler) {
    this.get(opts.origin);
    return this[kAgent].dispatch(opts, handler);
  }
  async close() {
    await this[kAgent].close();
    this[kClients].clear();
  }
  deactivate() {
    this[kIsMockActive] = false;
  }
  activate() {
    this[kIsMockActive] = true;
  }
  enableNetConnect(matcher) {
    if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
      if (Array.isArray(this[kNetConnect])) {
        this[kNetConnect].push(matcher);
      } else {
        this[kNetConnect] = [matcher];
      }
    } else if (typeof matcher === "undefined") {
      this[kNetConnect] = true;
    } else {
      throw new InvalidArgumentError$4("Unsupported matcher. Must be one of String|Function|RegExp.");
    }
  }
  disableNetConnect() {
    this[kNetConnect] = false;
  }
  // This is required to bypass issues caused by using global symbols - see:
  // https://github.com/nodejs/undici/issues/1447
  get isMockActive() {
    return this[kIsMockActive];
  }
  [kMockAgentSet](origin, dispatcher2) {
    this[kClients].set(origin, dispatcher2);
  }
  [kFactory](origin) {
    const mockOptions = Object.assign({ agent: this }, this[kOptions]);
    return this[kOptions] && this[kOptions].connections === 1 ? new MockClient$1(origin, mockOptions) : new MockPool$1(origin, mockOptions);
  }
  [kMockAgentGet](origin) {
    const client2 = this[kClients].get(origin);
    if (client2) {
      return client2;
    }
    if (typeof origin !== "string") {
      const dispatcher2 = this[kFactory]("http://localhost:9999");
      this[kMockAgentSet](origin, dispatcher2);
      return dispatcher2;
    }
    for (const [keyMatcher, nonExplicitDispatcher] of Array.from(this[kClients])) {
      if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
        const dispatcher2 = this[kFactory](origin);
        this[kMockAgentSet](origin, dispatcher2);
        dispatcher2[kDispatches] = nonExplicitDispatcher[kDispatches];
        return dispatcher2;
      }
    }
  }
  [kGetNetConnect]() {
    return this[kNetConnect];
  }
  pendingInterceptors() {
    const mockAgentClients = this[kClients];
    return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
  }
  assertNoPendingInterceptors({ pendingInterceptorsFormatter: pendingInterceptorsFormatter2 = new PendingInterceptorsFormatter3() } = {}) {
    const pending = this.pendingInterceptors();
    if (pending.length === 0) {
      return;
    }
    const pluralizer2 = new Pluralizer2("interceptor", "interceptors").pluralize(pending.length);
    throw new UndiciError3(`
${pluralizer2.count} ${pluralizer2.noun} ${pluralizer2.is} pending:

${pendingInterceptorsFormatter2.format(pending)}
`.trim());
  }
};
var mockAgent = MockAgent$1;
const globalDispatcher = Symbol.for("undici.globalDispatcher.1");
const { InvalidArgumentError: InvalidArgumentError$3 } = errors$1;
const Agent$1 = agent$1;
if (getGlobalDispatcher$1() === void 0) {
  setGlobalDispatcher$1(new Agent$1());
}
function setGlobalDispatcher$1(agent2) {
  if (!agent2 || typeof agent2.dispatch !== "function") {
    throw new InvalidArgumentError$3("Argument agent must implement Agent");
  }
  Object.defineProperty(globalThis, globalDispatcher, {
    value: agent2,
    writable: true,
    enumerable: false,
    configurable: false
  });
}
function getGlobalDispatcher$1() {
  return globalThis[globalDispatcher];
}
var global$1 = {
  setGlobalDispatcher: setGlobalDispatcher$1,
  getGlobalDispatcher: getGlobalDispatcher$1
};
var decoratorHandler = (_t = class {
  constructor(handler) {
    __privateAdd(this, _handler6);
    if (typeof handler !== "object" || handler === null) {
      throw new TypeError("handler must be an object");
    }
    __privateSet(this, _handler6, handler);
  }
  onConnect(...args) {
    var _a2, _b2;
    return (_b2 = (_a2 = __privateGet(this, _handler6)).onConnect) == null ? void 0 : _b2.call(_a2, ...args);
  }
  onError(...args) {
    var _a2, _b2;
    return (_b2 = (_a2 = __privateGet(this, _handler6)).onError) == null ? void 0 : _b2.call(_a2, ...args);
  }
  onUpgrade(...args) {
    var _a2, _b2;
    return (_b2 = (_a2 = __privateGet(this, _handler6)).onUpgrade) == null ? void 0 : _b2.call(_a2, ...args);
  }
  onResponseStarted(...args) {
    var _a2, _b2;
    return (_b2 = (_a2 = __privateGet(this, _handler6)).onResponseStarted) == null ? void 0 : _b2.call(_a2, ...args);
  }
  onHeaders(...args) {
    var _a2, _b2;
    return (_b2 = (_a2 = __privateGet(this, _handler6)).onHeaders) == null ? void 0 : _b2.call(_a2, ...args);
  }
  onData(...args) {
    var _a2, _b2;
    return (_b2 = (_a2 = __privateGet(this, _handler6)).onData) == null ? void 0 : _b2.call(_a2, ...args);
  }
  onComplete(...args) {
    var _a2, _b2;
    return (_b2 = (_a2 = __privateGet(this, _handler6)).onComplete) == null ? void 0 : _b2.call(_a2, ...args);
  }
  onBodySent(...args) {
    var _a2, _b2;
    return (_b2 = (_a2 = __privateGet(this, _handler6)).onBodySent) == null ? void 0 : _b2.call(_a2, ...args);
  }
}, _handler6 = new WeakMap(), _t);
const RedirectHandler$1 = redirectHandler;
var redirect = (opts) => {
  const globalMaxRedirections = opts == null ? void 0 : opts.maxRedirections;
  return (dispatch) => {
    return function redirectInterceptor2(opts2, handler) {
      const { maxRedirections = globalMaxRedirections, ...baseOpts } = opts2;
      if (!maxRedirections) {
        return dispatch(opts2, handler);
      }
      const redirectHandler2 = new RedirectHandler$1(
        dispatch,
        maxRedirections,
        opts2,
        handler
      );
      return dispatch(baseOpts, redirectHandler2);
    };
  };
};
const RetryHandler$1 = retryHandler;
var retry = (globalOpts) => {
  return (dispatch) => {
    return function retryInterceptor(opts, handler) {
      return dispatch(
        opts,
        new RetryHandler$1(
          { ...opts, retryOptions: { ...globalOpts, ...opts.retryOptions } },
          {
            handler,
            dispatch
          }
        )
      );
    };
  };
};
const util$6 = util$n;
const { InvalidArgumentError: InvalidArgumentError$2, RequestAbortedError: RequestAbortedError3 } = errors$1;
const DecoratorHandler$2 = decoratorHandler;
class DumpHandler extends DecoratorHandler$2 {
  constructor({ maxSize }, handler) {
    super(handler);
    __privateAdd(this, _DumpHandler_instances2);
    __privateAdd(this, _maxSize3, 1024 * 1024);
    __privateAdd(this, _abort2, null);
    __privateAdd(this, _dumped2, false);
    __privateAdd(this, _aborted2, false);
    __privateAdd(this, _size3, 0);
    __privateAdd(this, _reason2, null);
    __privateAdd(this, _handler7, null);
    if (maxSize != null && (!Number.isFinite(maxSize) || maxSize < 1)) {
      throw new InvalidArgumentError$2("maxSize must be a number greater than 0");
    }
    __privateSet(this, _maxSize3, maxSize ?? __privateGet(this, _maxSize3));
    __privateSet(this, _handler7, handler);
  }
  onConnect(abort2) {
    __privateSet(this, _abort2, abort2);
    __privateGet(this, _handler7).onConnect(__privateMethod(this, _DumpHandler_instances2, customAbort_fn).bind(this));
  }
  // TODO: will require adjustment after new hooks are out
  onHeaders(statusCode, rawHeaders, resume2, statusMessage) {
    const headers2 = util$6.parseHeaders(rawHeaders);
    const contentLength = headers2["content-length"];
    if (contentLength != null && contentLength > __privateGet(this, _maxSize3)) {
      throw new RequestAbortedError3(
        `Response size (${contentLength}) larger than maxSize (${__privateGet(this, _maxSize3)})`
      );
    }
    if (__privateGet(this, _aborted2)) {
      return true;
    }
    return __privateGet(this, _handler7).onHeaders(
      statusCode,
      rawHeaders,
      resume2,
      statusMessage
    );
  }
  onError(err) {
    if (__privateGet(this, _dumped2)) {
      return;
    }
    err = __privateGet(this, _reason2) ?? err;
    __privateGet(this, _handler7).onError(err);
  }
  onData(chunk) {
    __privateSet(this, _size3, __privateGet(this, _size3) + chunk.length);
    if (__privateGet(this, _size3) >= __privateGet(this, _maxSize3)) {
      __privateSet(this, _dumped2, true);
      if (__privateGet(this, _aborted2)) {
        __privateGet(this, _handler7).onError(__privateGet(this, _reason2));
      } else {
        __privateGet(this, _handler7).onComplete([]);
      }
    }
    return true;
  }
  onComplete(trailers) {
    if (__privateGet(this, _dumped2)) {
      return;
    }
    if (__privateGet(this, _aborted2)) {
      __privateGet(this, _handler7).onError(this.reason);
      return;
    }
    __privateGet(this, _handler7).onComplete(trailers);
  }
}
_maxSize3 = new WeakMap();
_abort2 = new WeakMap();
_dumped2 = new WeakMap();
_aborted2 = new WeakMap();
_size3 = new WeakMap();
_reason2 = new WeakMap();
_handler7 = new WeakMap();
_DumpHandler_instances2 = new WeakSet();
customAbort_fn = function(reason) {
  __privateSet(this, _aborted2, true);
  __privateSet(this, _reason2, reason);
};
function createDumpInterceptor({ maxSize: defaultMaxSize } = {
  maxSize: 1024 * 1024
}) {
  return (dispatch) => {
    return function Intercept(opts, handler) {
      const { dumpMaxSize = defaultMaxSize } = opts;
      const dumpHandler = new DumpHandler(
        { maxSize: dumpMaxSize },
        handler
      );
      return dispatch(opts, dumpHandler);
    };
  };
}
var dump = createDumpInterceptor;
const { isIP } = require$$0$5;
const { lookup } = require$$1$6;
const DecoratorHandler$1 = decoratorHandler;
const { InvalidArgumentError: InvalidArgumentError$1, InformationalError: InformationalError3 } = errors$1;
const maxInt = Math.pow(2, 31) - 1;
class DNSInstance {
  constructor(opts) {
    __privateAdd(this, _DNSInstance_instances2);
    __privateAdd(this, _maxTTL2, 0);
    __privateAdd(this, _maxItems2, 0);
    __privateAdd(this, _records2, /* @__PURE__ */ new Map());
    __publicField(this, "dualStack", true);
    __publicField(this, "affinity", null);
    __publicField(this, "lookup", null);
    __publicField(this, "pick", null);
    __privateSet(this, _maxTTL2, opts.maxTTL);
    __privateSet(this, _maxItems2, opts.maxItems);
    this.dualStack = opts.dualStack;
    this.affinity = opts.affinity;
    this.lookup = opts.lookup ?? __privateMethod(this, _DNSInstance_instances2, defaultLookup_fn2);
    this.pick = opts.pick ?? __privateMethod(this, _DNSInstance_instances2, defaultPick_fn2);
  }
  get full() {
    return __privateGet(this, _records2).size === __privateGet(this, _maxItems2);
  }
  runLookup(origin, opts, cb) {
    const ips = __privateGet(this, _records2).get(origin.hostname);
    if (ips == null && this.full) {
      cb(null, origin.origin);
      return;
    }
    const newOpts = {
      affinity: this.affinity,
      dualStack: this.dualStack,
      lookup: this.lookup,
      pick: this.pick,
      ...opts.dns,
      maxTTL: __privateGet(this, _maxTTL2),
      maxItems: __privateGet(this, _maxItems2)
    };
    if (ips == null) {
      this.lookup(origin, newOpts, (err, addresses) => {
        if (err || addresses == null || addresses.length === 0) {
          cb(err ?? new InformationalError3("No DNS entries found"));
          return;
        }
        this.setRecords(origin, addresses);
        const records = __privateGet(this, _records2).get(origin.hostname);
        const ip = this.pick(
          origin,
          records,
          newOpts.affinity
        );
        let port;
        if (typeof ip.port === "number") {
          port = `:${ip.port}`;
        } else if (origin.port !== "") {
          port = `:${origin.port}`;
        } else {
          port = "";
        }
        cb(
          null,
          `${origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`
        );
      });
    } else {
      const ip = this.pick(
        origin,
        ips,
        newOpts.affinity
      );
      if (ip == null) {
        __privateGet(this, _records2).delete(origin.hostname);
        this.runLookup(origin, opts, cb);
        return;
      }
      let port;
      if (typeof ip.port === "number") {
        port = `:${ip.port}`;
      } else if (origin.port !== "") {
        port = `:${origin.port}`;
      } else {
        port = "";
      }
      cb(
        null,
        `${origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`
      );
    }
  }
  setRecords(origin, addresses) {
    const timestamp = Date.now();
    const records = { records: { 4: null, 6: null } };
    for (const record of addresses) {
      record.timestamp = timestamp;
      if (typeof record.ttl === "number") {
        record.ttl = Math.min(record.ttl, __privateGet(this, _maxTTL2));
      } else {
        record.ttl = __privateGet(this, _maxTTL2);
      }
      const familyRecords = records.records[record.family] ?? { ips: [] };
      familyRecords.ips.push(record);
      records.records[record.family] = familyRecords;
    }
    __privateGet(this, _records2).set(origin.hostname, records);
  }
  getHandler(meta, opts) {
    return new DNSDispatchHandler(this, meta, opts);
  }
}
_maxTTL2 = new WeakMap();
_maxItems2 = new WeakMap();
_records2 = new WeakMap();
_DNSInstance_instances2 = new WeakSet();
defaultLookup_fn2 = function(origin, opts, cb) {
  lookup(
    origin.hostname,
    {
      all: true,
      family: this.dualStack === false ? this.affinity : 0,
      order: "ipv4first"
    },
    (err, addresses) => {
      if (err) {
        return cb(err);
      }
      const results = /* @__PURE__ */ new Map();
      for (const addr of addresses) {
        results.set(`${addr.address}:${addr.family}`, addr);
      }
      cb(null, results.values());
    }
  );
};
defaultPick_fn2 = function(origin, hostnameRecords, affinity) {
  let ip = null;
  const { records, offset } = hostnameRecords;
  let family;
  if (this.dualStack) {
    if (affinity == null) {
      if (offset == null || offset === maxInt) {
        hostnameRecords.offset = 0;
        affinity = 4;
      } else {
        hostnameRecords.offset++;
        affinity = (hostnameRecords.offset & 1) === 1 ? 6 : 4;
      }
    }
    if (records[affinity] != null && records[affinity].ips.length > 0) {
      family = records[affinity];
    } else {
      family = records[affinity === 4 ? 6 : 4];
    }
  } else {
    family = records[affinity];
  }
  if (family == null || family.ips.length === 0) {
    return ip;
  }
  if (family.offset == null || family.offset === maxInt) {
    family.offset = 0;
  } else {
    family.offset++;
  }
  const position = family.offset % family.ips.length;
  ip = family.ips[position] ?? null;
  if (ip == null) {
    return ip;
  }
  if (Date.now() - ip.timestamp > ip.ttl) {
    family.ips.splice(position, 1);
    return this.pick(origin, hostnameRecords, affinity);
  }
  return ip;
};
class DNSDispatchHandler extends DecoratorHandler$1 {
  constructor(state, { origin, handler, dispatch }, opts) {
    super(handler);
    __privateAdd(this, _state2, null);
    __privateAdd(this, _opts4, null);
    __privateAdd(this, _dispatch3, null);
    __privateAdd(this, _handler8, null);
    __privateAdd(this, _origin2, null);
    __privateSet(this, _origin2, origin);
    __privateSet(this, _handler8, handler);
    __privateSet(this, _opts4, { ...opts });
    __privateSet(this, _state2, state);
    __privateSet(this, _dispatch3, dispatch);
  }
  onError(err) {
    switch (err.code) {
      case "ETIMEDOUT":
      case "ECONNREFUSED": {
        if (__privateGet(this, _state2).dualStack) {
          __privateGet(this, _state2).runLookup(__privateGet(this, _origin2), __privateGet(this, _opts4), (err2, newOrigin) => {
            if (err2) {
              return __privateGet(this, _handler8).onError(err2);
            }
            const dispatchOpts = {
              ...__privateGet(this, _opts4),
              origin: newOrigin
            };
            __privateGet(this, _dispatch3).call(this, dispatchOpts, this);
          });
          return;
        }
        __privateGet(this, _handler8).onError(err);
        return;
      }
      case "ENOTFOUND":
        __privateGet(this, _state2).deleteRecord(__privateGet(this, _origin2));
      default:
        __privateGet(this, _handler8).onError(err);
        break;
    }
  }
}
_state2 = new WeakMap();
_opts4 = new WeakMap();
_dispatch3 = new WeakMap();
_handler8 = new WeakMap();
_origin2 = new WeakMap();
var dns = (interceptorOpts) => {
  if ((interceptorOpts == null ? void 0 : interceptorOpts.maxTTL) != null && (typeof (interceptorOpts == null ? void 0 : interceptorOpts.maxTTL) !== "number" || (interceptorOpts == null ? void 0 : interceptorOpts.maxTTL) < 0)) {
    throw new InvalidArgumentError$1("Invalid maxTTL. Must be a positive number");
  }
  if ((interceptorOpts == null ? void 0 : interceptorOpts.maxItems) != null && (typeof (interceptorOpts == null ? void 0 : interceptorOpts.maxItems) !== "number" || (interceptorOpts == null ? void 0 : interceptorOpts.maxItems) < 1)) {
    throw new InvalidArgumentError$1(
      "Invalid maxItems. Must be a positive number and greater than zero"
    );
  }
  if ((interceptorOpts == null ? void 0 : interceptorOpts.affinity) != null && (interceptorOpts == null ? void 0 : interceptorOpts.affinity) !== 4 && (interceptorOpts == null ? void 0 : interceptorOpts.affinity) !== 6) {
    throw new InvalidArgumentError$1("Invalid affinity. Must be either 4 or 6");
  }
  if ((interceptorOpts == null ? void 0 : interceptorOpts.dualStack) != null && typeof (interceptorOpts == null ? void 0 : interceptorOpts.dualStack) !== "boolean") {
    throw new InvalidArgumentError$1("Invalid dualStack. Must be a boolean");
  }
  if ((interceptorOpts == null ? void 0 : interceptorOpts.lookup) != null && typeof (interceptorOpts == null ? void 0 : interceptorOpts.lookup) !== "function") {
    throw new InvalidArgumentError$1("Invalid lookup. Must be a function");
  }
  if ((interceptorOpts == null ? void 0 : interceptorOpts.pick) != null && typeof (interceptorOpts == null ? void 0 : interceptorOpts.pick) !== "function") {
    throw new InvalidArgumentError$1("Invalid pick. Must be a function");
  }
  const dualStack = (interceptorOpts == null ? void 0 : interceptorOpts.dualStack) ?? true;
  let affinity;
  if (dualStack) {
    affinity = (interceptorOpts == null ? void 0 : interceptorOpts.affinity) ?? null;
  } else {
    affinity = (interceptorOpts == null ? void 0 : interceptorOpts.affinity) ?? 4;
  }
  const opts = {
    maxTTL: (interceptorOpts == null ? void 0 : interceptorOpts.maxTTL) ?? 1e4,
    // Expressed in ms
    lookup: (interceptorOpts == null ? void 0 : interceptorOpts.lookup) ?? null,
    pick: (interceptorOpts == null ? void 0 : interceptorOpts.pick) ?? null,
    dualStack,
    affinity,
    maxItems: (interceptorOpts == null ? void 0 : interceptorOpts.maxItems) ?? Infinity
  };
  const instance = new DNSInstance(opts);
  return (dispatch) => {
    return function dnsInterceptor(origDispatchOpts, handler) {
      const origin = origDispatchOpts.origin.constructor === URL ? origDispatchOpts.origin : new URL(origDispatchOpts.origin);
      if (isIP(origin.hostname) !== 0) {
        return dispatch(origDispatchOpts, handler);
      }
      instance.runLookup(origin, origDispatchOpts, (err, newOrigin) => {
        if (err) {
          return handler.onError(err);
        }
        let dispatchOpts = null;
        dispatchOpts = {
          ...origDispatchOpts,
          servername: origin.hostname,
          // For SNI on TLS
          origin: newOrigin,
          headers: {
            host: origin.hostname,
            ...origDispatchOpts.headers
          }
        };
        dispatch(
          dispatchOpts,
          instance.getHandler({ origin, dispatch, handler }, origDispatchOpts)
        );
      });
      return true;
    };
  };
};
var headers;
var hasRequiredHeaders;
function requireHeaders() {
  var _guard, _headersList;
  if (hasRequiredHeaders) return headers;
  hasRequiredHeaders = 1;
  const { kConstruct: kConstruct2 } = symbols$4;
  const { kEnumerableProperty: kEnumerableProperty2 } = util$n;
  const {
    iteratorMixin,
    isValidHeaderName,
    isValidHeaderValue: isValidHeaderValue2
  } = requireUtil$5();
  const { webidl } = requireWebidl();
  const assert2 = require$$0$3;
  const util2 = require$$0$2;
  const kHeadersMap = Symbol("headers map");
  const kHeadersSortedMap = Symbol("headers map sorted");
  function isHTTPWhiteSpaceCharCode(code) {
    return code === 10 || code === 13 || code === 9 || code === 32;
  }
  function headerValueNormalize(potentialValue) {
    let i = 0;
    let j = potentialValue.length;
    while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j;
    while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i;
    return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
  }
  function fill(headers2, object) {
    if (Array.isArray(object)) {
      for (let i = 0; i < object.length; ++i) {
        const header = object[i];
        if (header.length !== 2) {
          throw webidl.errors.exception({
            header: "Headers constructor",
            message: `expected name/value pair to be length 2, found ${header.length}.`
          });
        }
        appendHeader(headers2, header[0], header[1]);
      }
    } else if (typeof object === "object" && object !== null) {
      const keys = Object.keys(object);
      for (let i = 0; i < keys.length; ++i) {
        appendHeader(headers2, keys[i], object[keys[i]]);
      }
    } else {
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    }
  }
  function appendHeader(headers2, name, value) {
    value = headerValueNormalize(value);
    if (!isValidHeaderName(name)) {
      throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value: name,
        type: "header name"
      });
    } else if (!isValidHeaderValue2(value)) {
      throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value,
        type: "header value"
      });
    }
    if (getHeadersGuard(headers2) === "immutable") {
      throw new TypeError("immutable");
    }
    return getHeadersList(headers2).append(name, value, false);
  }
  function compareHeaderName(a, b) {
    return a[0] < b[0] ? -1 : 1;
  }
  class HeadersList {
    constructor(init) {
      /** @type {[string, string][]|null} */
      __publicField(this, "cookies", null);
      if (init instanceof HeadersList) {
        this[kHeadersMap] = new Map(init[kHeadersMap]);
        this[kHeadersSortedMap] = init[kHeadersSortedMap];
        this.cookies = init.cookies === null ? null : [...init.cookies];
      } else {
        this[kHeadersMap] = new Map(init);
        this[kHeadersSortedMap] = null;
      }
    }
    /**
     * @see https://fetch.spec.whatwg.org/#header-list-contains
     * @param {string} name
     * @param {boolean} isLowerCase
     */
    contains(name, isLowerCase) {
      return this[kHeadersMap].has(isLowerCase ? name : name.toLowerCase());
    }
    clear() {
      this[kHeadersMap].clear();
      this[kHeadersSortedMap] = null;
      this.cookies = null;
    }
    /**
     * @see https://fetch.spec.whatwg.org/#concept-header-list-append
     * @param {string} name
     * @param {string} value
     * @param {boolean} isLowerCase
     */
    append(name, value, isLowerCase) {
      this[kHeadersSortedMap] = null;
      const lowercaseName = isLowerCase ? name : name.toLowerCase();
      const exists = this[kHeadersMap].get(lowercaseName);
      if (exists) {
        const delimiter = lowercaseName === "cookie" ? "; " : ", ";
        this[kHeadersMap].set(lowercaseName, {
          name: exists.name,
          value: `${exists.value}${delimiter}${value}`
        });
      } else {
        this[kHeadersMap].set(lowercaseName, { name, value });
      }
      if (lowercaseName === "set-cookie") {
        (this.cookies ?? (this.cookies = [])).push(value);
      }
    }
    /**
     * @see https://fetch.spec.whatwg.org/#concept-header-list-set
     * @param {string} name
     * @param {string} value
     * @param {boolean} isLowerCase
     */
    set(name, value, isLowerCase) {
      this[kHeadersSortedMap] = null;
      const lowercaseName = isLowerCase ? name : name.toLowerCase();
      if (lowercaseName === "set-cookie") {
        this.cookies = [value];
      }
      this[kHeadersMap].set(lowercaseName, { name, value });
    }
    /**
     * @see https://fetch.spec.whatwg.org/#concept-header-list-delete
     * @param {string} name
     * @param {boolean} isLowerCase
     */
    delete(name, isLowerCase) {
      this[kHeadersSortedMap] = null;
      if (!isLowerCase) name = name.toLowerCase();
      if (name === "set-cookie") {
        this.cookies = null;
      }
      this[kHeadersMap].delete(name);
    }
    /**
     * @see https://fetch.spec.whatwg.org/#concept-header-list-get
     * @param {string} name
     * @param {boolean} isLowerCase
     * @returns {string | null}
     */
    get(name, isLowerCase) {
      var _a2;
      return ((_a2 = this[kHeadersMap].get(isLowerCase ? name : name.toLowerCase())) == null ? void 0 : _a2.value) ?? null;
    }
    *[Symbol.iterator]() {
      for (const { 0: name, 1: { value } } of this[kHeadersMap]) {
        yield [name, value];
      }
    }
    get entries() {
      const headers2 = {};
      if (this[kHeadersMap].size !== 0) {
        for (const { name, value } of this[kHeadersMap].values()) {
          headers2[name] = value;
        }
      }
      return headers2;
    }
    rawValues() {
      return this[kHeadersMap].values();
    }
    get entriesList() {
      const headers2 = [];
      if (this[kHeadersMap].size !== 0) {
        for (const { 0: lowerName, 1: { name, value } } of this[kHeadersMap]) {
          if (lowerName === "set-cookie") {
            for (const cookie2 of this.cookies) {
              headers2.push([name, cookie2]);
            }
          } else {
            headers2.push([name, value]);
          }
        }
      }
      return headers2;
    }
    // https://fetch.spec.whatwg.org/#convert-header-names-to-a-sorted-lowercase-set
    toSortedArray() {
      const size = this[kHeadersMap].size;
      const array = new Array(size);
      if (size <= 32) {
        if (size === 0) {
          return array;
        }
        const iterator = this[kHeadersMap][Symbol.iterator]();
        const firstValue = iterator.next().value;
        array[0] = [firstValue[0], firstValue[1].value];
        assert2(firstValue[1].value !== null);
        for (let i = 1, j = 0, right = 0, left = 0, pivot = 0, x, value; i < size; ++i) {
          value = iterator.next().value;
          x = array[i] = [value[0], value[1].value];
          assert2(x[1] !== null);
          left = 0;
          right = i;
          while (left < right) {
            pivot = left + (right - left >> 1);
            if (array[pivot][0] <= x[0]) {
              left = pivot + 1;
            } else {
              right = pivot;
            }
          }
          if (i !== pivot) {
            j = i;
            while (j > left) {
              array[j] = array[--j];
            }
            array[left] = x;
          }
        }
        if (!iterator.next().done) {
          throw new TypeError("Unreachable");
        }
        return array;
      } else {
        let i = 0;
        for (const { 0: name, 1: { value } } of this[kHeadersMap]) {
          array[i++] = [name, value];
          assert2(value !== null);
        }
        return array.sort(compareHeaderName);
      }
    }
  }
  const _Headers = class _Headers {
    constructor(init = void 0) {
      __privateAdd(this, _guard);
      __privateAdd(this, _headersList);
      webidl.util.markAsUncloneable(this);
      if (init === kConstruct2) {
        return;
      }
      __privateSet(this, _headersList, new HeadersList());
      __privateSet(this, _guard, "none");
      if (init !== void 0) {
        init = webidl.converters.HeadersInit(init, "Headers contructor", "init");
        fill(this, init);
      }
    }
    // https://fetch.spec.whatwg.org/#dom-headers-append
    append(name, value) {
      webidl.brandCheck(this, _Headers);
      webidl.argumentLengthCheck(arguments, 2, "Headers.append");
      const prefix = "Headers.append";
      name = webidl.converters.ByteString(name, prefix, "name");
      value = webidl.converters.ByteString(value, prefix, "value");
      return appendHeader(this, name, value);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-delete
    delete(name) {
      webidl.brandCheck(this, _Headers);
      webidl.argumentLengthCheck(arguments, 1, "Headers.delete");
      const prefix = "Headers.delete";
      name = webidl.converters.ByteString(name, prefix, "name");
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.delete",
          value: name,
          type: "header name"
        });
      }
      if (__privateGet(this, _guard) === "immutable") {
        throw new TypeError("immutable");
      }
      if (!__privateGet(this, _headersList).contains(name, false)) {
        return;
      }
      __privateGet(this, _headersList).delete(name, false);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-get
    get(name) {
      webidl.brandCheck(this, _Headers);
      webidl.argumentLengthCheck(arguments, 1, "Headers.get");
      const prefix = "Headers.get";
      name = webidl.converters.ByteString(name, prefix, "name");
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value: name,
          type: "header name"
        });
      }
      return __privateGet(this, _headersList).get(name, false);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-has
    has(name) {
      webidl.brandCheck(this, _Headers);
      webidl.argumentLengthCheck(arguments, 1, "Headers.has");
      const prefix = "Headers.has";
      name = webidl.converters.ByteString(name, prefix, "name");
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value: name,
          type: "header name"
        });
      }
      return __privateGet(this, _headersList).contains(name, false);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-set
    set(name, value) {
      webidl.brandCheck(this, _Headers);
      webidl.argumentLengthCheck(arguments, 2, "Headers.set");
      const prefix = "Headers.set";
      name = webidl.converters.ByteString(name, prefix, "name");
      value = webidl.converters.ByteString(value, prefix, "value");
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue2(value)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value,
          type: "header value"
        });
      }
      if (__privateGet(this, _guard) === "immutable") {
        throw new TypeError("immutable");
      }
      __privateGet(this, _headersList).set(name, value, false);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
    getSetCookie() {
      webidl.brandCheck(this, _Headers);
      const list = __privateGet(this, _headersList).cookies;
      if (list) {
        return [...list];
      }
      return [];
    }
    // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
    get [kHeadersSortedMap]() {
      if (__privateGet(this, _headersList)[kHeadersSortedMap]) {
        return __privateGet(this, _headersList)[kHeadersSortedMap];
      }
      const headers2 = [];
      const names = __privateGet(this, _headersList).toSortedArray();
      const cookies2 = __privateGet(this, _headersList).cookies;
      if (cookies2 === null || cookies2.length === 1) {
        return __privateGet(this, _headersList)[kHeadersSortedMap] = names;
      }
      for (let i = 0; i < names.length; ++i) {
        const { 0: name, 1: value } = names[i];
        if (name === "set-cookie") {
          for (let j = 0; j < cookies2.length; ++j) {
            headers2.push([name, cookies2[j]]);
          }
        } else {
          headers2.push([name, value]);
        }
      }
      return __privateGet(this, _headersList)[kHeadersSortedMap] = headers2;
    }
    [util2.inspect.custom](depth, options) {
      options.depth ?? (options.depth = depth);
      return `Headers ${util2.formatWithOptions(options, __privateGet(this, _headersList).entries)}`;
    }
    static getHeadersGuard(o) {
      return __privateGet(o, _guard);
    }
    static setHeadersGuard(o, guard) {
      __privateSet(o, _guard, guard);
    }
    static getHeadersList(o) {
      return __privateGet(o, _headersList);
    }
    static setHeadersList(o, list) {
      __privateSet(o, _headersList, list);
    }
  };
  _guard = new WeakMap();
  _headersList = new WeakMap();
  let Headers = _Headers;
  const { getHeadersGuard, setHeadersGuard, getHeadersList, setHeadersList } = Headers;
  Reflect.deleteProperty(Headers, "getHeadersGuard");
  Reflect.deleteProperty(Headers, "setHeadersGuard");
  Reflect.deleteProperty(Headers, "getHeadersList");
  Reflect.deleteProperty(Headers, "setHeadersList");
  iteratorMixin("Headers", Headers, kHeadersSortedMap, 0, 1);
  Object.defineProperties(Headers.prototype, {
    append: kEnumerableProperty2,
    delete: kEnumerableProperty2,
    get: kEnumerableProperty2,
    has: kEnumerableProperty2,
    set: kEnumerableProperty2,
    getSetCookie: kEnumerableProperty2,
    [Symbol.toStringTag]: {
      value: "Headers",
      configurable: true
    },
    [util2.inspect.custom]: {
      enumerable: false
    }
  });
  webidl.converters.HeadersInit = function(V, prefix, argument) {
    if (webidl.util.Type(V) === "Object") {
      const iterator = Reflect.get(V, Symbol.iterator);
      if (!util2.types.isProxy(V) && iterator === Headers.prototype.entries) {
        try {
          return getHeadersList(V).entriesList;
        } catch {
        }
      }
      if (typeof iterator === "function") {
        return webidl.converters["sequence<sequence<ByteString>>"](V, prefix, argument, iterator.bind(V));
      }
      return webidl.converters["record<ByteString, ByteString>"](V, prefix, argument);
    }
    throw webidl.errors.conversionFailed({
      prefix: "Headers constructor",
      argument: "Argument 1",
      types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
    });
  };
  headers = {
    fill,
    // for test.
    compareHeaderName,
    Headers,
    HeadersList,
    getHeadersGuard,
    setHeadersGuard,
    setHeadersList,
    getHeadersList
  };
  return headers;
}
var response;
var hasRequiredResponse;
function requireResponse() {
  if (hasRequiredResponse) return response;
  hasRequiredResponse = 1;
  const { Headers, HeadersList, fill, getHeadersGuard, setHeadersGuard, setHeadersList } = requireHeaders();
  const { extractBody: extractBody2, cloneBody, mixinBody, hasFinalizationRegistry, streamRegistry, bodyUnusable } = requireBody();
  const util2 = util$n;
  const nodeUtil2 = require$$0$2;
  const { kEnumerableProperty: kEnumerableProperty2 } = util2;
  const {
    isValidReasonPhrase,
    isCancelled,
    isAborted,
    isBlobLike: isBlobLike2,
    serializeJavascriptValueToJSONString,
    isErrorLike,
    isomorphicEncode,
    environmentSettingsObject: relevantRealm
  } = requireUtil$5();
  const {
    redirectStatusSet,
    nullBodyStatus
  } = requireConstants$2();
  const { kState, kHeaders } = requireSymbols$3();
  const { webidl } = requireWebidl();
  const { FormData } = requireFormdata();
  const { URLSerializer } = requireDataUrl();
  const { kConstruct: kConstruct2 } = symbols$4;
  const assert2 = require$$0$3;
  const { types } = require$$0$2;
  const textEncoder = new TextEncoder("utf-8");
  class Response {
    // Creates network error Response.
    static error() {
      const responseObject = fromInnerResponse(makeNetworkError(), "immutable");
      return responseObject;
    }
    // https://fetch.spec.whatwg.org/#dom-response-json
    static json(data, init = {}) {
      webidl.argumentLengthCheck(arguments, 1, "Response.json");
      if (init !== null) {
        init = webidl.converters.ResponseInit(init);
      }
      const bytes = textEncoder.encode(
        serializeJavascriptValueToJSONString(data)
      );
      const body2 = extractBody2(bytes);
      const responseObject = fromInnerResponse(makeResponse({}), "response");
      initializeResponse(responseObject, init, { body: body2[0], type: "application/json" });
      return responseObject;
    }
    // Creates a redirect Response that redirects to url with status status.
    static redirect(url, status = 302) {
      webidl.argumentLengthCheck(arguments, 1, "Response.redirect");
      url = webidl.converters.USVString(url);
      status = webidl.converters["unsigned short"](status);
      let parsedURL;
      try {
        parsedURL = new URL(url, relevantRealm.settingsObject.baseUrl);
      } catch (err) {
        throw new TypeError(`Failed to parse URL from ${url}`, { cause: err });
      }
      if (!redirectStatusSet.has(status)) {
        throw new RangeError(`Invalid status code ${status}`);
      }
      const responseObject = fromInnerResponse(makeResponse({}), "immutable");
      responseObject[kState].status = status;
      const value = isomorphicEncode(URLSerializer(parsedURL));
      responseObject[kState].headersList.append("location", value, true);
      return responseObject;
    }
    // https://fetch.spec.whatwg.org/#dom-response
    constructor(body2 = null, init = {}) {
      webidl.util.markAsUncloneable(this);
      if (body2 === kConstruct2) {
        return;
      }
      if (body2 !== null) {
        body2 = webidl.converters.BodyInit(body2);
      }
      init = webidl.converters.ResponseInit(init);
      this[kState] = makeResponse({});
      this[kHeaders] = new Headers(kConstruct2);
      setHeadersGuard(this[kHeaders], "response");
      setHeadersList(this[kHeaders], this[kState].headersList);
      let bodyWithType = null;
      if (body2 != null) {
        const [extractedBody, type] = extractBody2(body2);
        bodyWithType = { body: extractedBody, type };
      }
      initializeResponse(this, init, bodyWithType);
    }
    // Returns response’s type, e.g., "cors".
    get type() {
      webidl.brandCheck(this, Response);
      return this[kState].type;
    }
    // Returns response’s URL, if it has one; otherwise the empty string.
    get url() {
      webidl.brandCheck(this, Response);
      const urlList = this[kState].urlList;
      const url = urlList[urlList.length - 1] ?? null;
      if (url === null) {
        return "";
      }
      return URLSerializer(url, true);
    }
    // Returns whether response was obtained through a redirect.
    get redirected() {
      webidl.brandCheck(this, Response);
      return this[kState].urlList.length > 1;
    }
    // Returns response’s status.
    get status() {
      webidl.brandCheck(this, Response);
      return this[kState].status;
    }
    // Returns whether response’s status is an ok status.
    get ok() {
      webidl.brandCheck(this, Response);
      return this[kState].status >= 200 && this[kState].status <= 299;
    }
    // Returns response’s status message.
    get statusText() {
      webidl.brandCheck(this, Response);
      return this[kState].statusText;
    }
    // Returns response’s headers as Headers.
    get headers() {
      webidl.brandCheck(this, Response);
      return this[kHeaders];
    }
    get body() {
      webidl.brandCheck(this, Response);
      return this[kState].body ? this[kState].body.stream : null;
    }
    get bodyUsed() {
      webidl.brandCheck(this, Response);
      return !!this[kState].body && util2.isDisturbed(this[kState].body.stream);
    }
    // Returns a clone of response.
    clone() {
      webidl.brandCheck(this, Response);
      if (bodyUnusable(this)) {
        throw webidl.errors.exception({
          header: "Response.clone",
          message: "Body has already been consumed."
        });
      }
      const clonedResponse = cloneResponse(this[kState]);
      return fromInnerResponse(clonedResponse, getHeadersGuard(this[kHeaders]));
    }
    [nodeUtil2.inspect.custom](depth, options) {
      if (options.depth === null) {
        options.depth = 2;
      }
      options.colors ?? (options.colors = true);
      const properties = {
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        body: this.body,
        bodyUsed: this.bodyUsed,
        ok: this.ok,
        redirected: this.redirected,
        type: this.type,
        url: this.url
      };
      return `Response ${nodeUtil2.formatWithOptions(options, properties)}`;
    }
  }
  mixinBody(Response);
  Object.defineProperties(Response.prototype, {
    type: kEnumerableProperty2,
    url: kEnumerableProperty2,
    status: kEnumerableProperty2,
    ok: kEnumerableProperty2,
    redirected: kEnumerableProperty2,
    statusText: kEnumerableProperty2,
    headers: kEnumerableProperty2,
    clone: kEnumerableProperty2,
    body: kEnumerableProperty2,
    bodyUsed: kEnumerableProperty2,
    [Symbol.toStringTag]: {
      value: "Response",
      configurable: true
    }
  });
  Object.defineProperties(Response, {
    json: kEnumerableProperty2,
    redirect: kEnumerableProperty2,
    error: kEnumerableProperty2
  });
  function cloneResponse(response2) {
    if (response2.internalResponse) {
      return filterResponse(
        cloneResponse(response2.internalResponse),
        response2.type
      );
    }
    const newResponse = makeResponse({ ...response2, body: null });
    if (response2.body != null) {
      newResponse.body = cloneBody(newResponse, response2.body);
    }
    return newResponse;
  }
  function makeResponse(init) {
    return {
      aborted: false,
      rangeRequested: false,
      timingAllowPassed: false,
      requestIncludesCredentials: false,
      type: "default",
      status: 200,
      timingInfo: null,
      cacheState: "",
      statusText: "",
      ...init,
      headersList: (init == null ? void 0 : init.headersList) ? new HeadersList(init == null ? void 0 : init.headersList) : new HeadersList(),
      urlList: (init == null ? void 0 : init.urlList) ? [...init.urlList] : []
    };
  }
  function makeNetworkError(reason) {
    const isError = isErrorLike(reason);
    return makeResponse({
      type: "error",
      status: 0,
      error: isError ? reason : new Error(reason ? String(reason) : reason),
      aborted: reason && reason.name === "AbortError"
    });
  }
  function isNetworkError(response2) {
    return (
      // A network error is a response whose type is "error",
      response2.type === "error" && // status is 0
      response2.status === 0
    );
  }
  function makeFilteredResponse(response2, state) {
    state = {
      internalResponse: response2,
      ...state
    };
    return new Proxy(response2, {
      get(target, p) {
        return p in state ? state[p] : target[p];
      },
      set(target, p, value) {
        assert2(!(p in state));
        target[p] = value;
        return true;
      }
    });
  }
  function filterResponse(response2, type) {
    if (type === "basic") {
      return makeFilteredResponse(response2, {
        type: "basic",
        headersList: response2.headersList
      });
    } else if (type === "cors") {
      return makeFilteredResponse(response2, {
        type: "cors",
        headersList: response2.headersList
      });
    } else if (type === "opaque") {
      return makeFilteredResponse(response2, {
        type: "opaque",
        urlList: Object.freeze([]),
        status: 0,
        statusText: "",
        body: null
      });
    } else if (type === "opaqueredirect") {
      return makeFilteredResponse(response2, {
        type: "opaqueredirect",
        status: 0,
        statusText: "",
        headersList: [],
        body: null
      });
    } else {
      assert2(false);
    }
  }
  function makeAppropriateNetworkError(fetchParams, err = null) {
    assert2(isCancelled(fetchParams));
    return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException("Request was cancelled."), { cause: err }));
  }
  function initializeResponse(response2, init, body2) {
    if (init.status !== null && (init.status < 200 || init.status > 599)) {
      throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
    }
    if ("statusText" in init && init.statusText != null) {
      if (!isValidReasonPhrase(String(init.statusText))) {
        throw new TypeError("Invalid statusText");
      }
    }
    if ("status" in init && init.status != null) {
      response2[kState].status = init.status;
    }
    if ("statusText" in init && init.statusText != null) {
      response2[kState].statusText = init.statusText;
    }
    if ("headers" in init && init.headers != null) {
      fill(response2[kHeaders], init.headers);
    }
    if (body2) {
      if (nullBodyStatus.includes(response2.status)) {
        throw webidl.errors.exception({
          header: "Response constructor",
          message: `Invalid response status code ${response2.status}`
        });
      }
      response2[kState].body = body2.body;
      if (body2.type != null && !response2[kState].headersList.contains("content-type", true)) {
        response2[kState].headersList.append("content-type", body2.type, true);
      }
    }
  }
  function fromInnerResponse(innerResponse, guard) {
    var _a2;
    const response2 = new Response(kConstruct2);
    response2[kState] = innerResponse;
    response2[kHeaders] = new Headers(kConstruct2);
    setHeadersList(response2[kHeaders], innerResponse.headersList);
    setHeadersGuard(response2[kHeaders], guard);
    if (hasFinalizationRegistry && ((_a2 = innerResponse.body) == null ? void 0 : _a2.stream)) {
      streamRegistry.register(response2, new WeakRef(innerResponse.body.stream));
    }
    return response2;
  }
  webidl.converters.ReadableStream = webidl.interfaceConverter(
    ReadableStream
  );
  webidl.converters.FormData = webidl.interfaceConverter(
    FormData
  );
  webidl.converters.URLSearchParams = webidl.interfaceConverter(
    URLSearchParams
  );
  webidl.converters.XMLHttpRequestBodyInit = function(V, prefix, name) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V, prefix, name);
    }
    if (isBlobLike2(V)) {
      return webidl.converters.Blob(V, prefix, name, { strict: false });
    }
    if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {
      return webidl.converters.BufferSource(V, prefix, name);
    }
    if (util2.isFormDataLike(V)) {
      return webidl.converters.FormData(V, prefix, name, { strict: false });
    }
    if (V instanceof URLSearchParams) {
      return webidl.converters.URLSearchParams(V, prefix, name);
    }
    return webidl.converters.DOMString(V, prefix, name);
  };
  webidl.converters.BodyInit = function(V, prefix, argument) {
    if (V instanceof ReadableStream) {
      return webidl.converters.ReadableStream(V, prefix, argument);
    }
    if (V == null ? void 0 : V[Symbol.asyncIterator]) {
      return V;
    }
    return webidl.converters.XMLHttpRequestBodyInit(V, prefix, argument);
  };
  webidl.converters.ResponseInit = webidl.dictionaryConverter([
    {
      key: "status",
      converter: webidl.converters["unsigned short"],
      defaultValue: () => 200
    },
    {
      key: "statusText",
      converter: webidl.converters.ByteString,
      defaultValue: () => ""
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    }
  ]);
  response = {
    isNetworkError,
    makeNetworkError,
    makeResponse,
    makeAppropriateNetworkError,
    filterResponse,
    Response,
    cloneResponse,
    fromInnerResponse
  };
  return response;
}
var dispatcherWeakref;
var hasRequiredDispatcherWeakref;
function requireDispatcherWeakref() {
  if (hasRequiredDispatcherWeakref) return dispatcherWeakref;
  hasRequiredDispatcherWeakref = 1;
  const { kConnected: kConnected2, kSize: kSize2 } = symbols$4;
  class CompatWeakRef {
    constructor(value) {
      this.value = value;
    }
    deref() {
      return this.value[kConnected2] === 0 && this.value[kSize2] === 0 ? void 0 : this.value;
    }
  }
  class CompatFinalizer {
    constructor(finalizer) {
      this.finalizer = finalizer;
    }
    register(dispatcher2, key) {
      if (dispatcher2.on) {
        dispatcher2.on("disconnect", () => {
          if (dispatcher2[kConnected2] === 0 && dispatcher2[kSize2] === 0) {
            this.finalizer(key);
          }
        });
      }
    }
    unregister(key) {
    }
  }
  dispatcherWeakref = function() {
    if (process.env.NODE_V8_COVERAGE && process.version.startsWith("v18")) {
      process._rawDebug("Using compatibility WeakRef and FinalizationRegistry");
      return {
        WeakRef: CompatWeakRef,
        FinalizationRegistry: CompatFinalizer
      };
    }
    return { WeakRef, FinalizationRegistry };
  };
  return dispatcherWeakref;
}
var request;
var hasRequiredRequest;
function requireRequest() {
  if (hasRequiredRequest) return request;
  hasRequiredRequest = 1;
  const { extractBody: extractBody2, mixinBody, cloneBody, bodyUnusable } = requireBody();
  const { Headers, fill: fillHeaders, HeadersList, setHeadersGuard, getHeadersGuard, setHeadersList, getHeadersList } = requireHeaders();
  const { FinalizationRegistry: FinalizationRegistry2 } = requireDispatcherWeakref()();
  const util2 = util$n;
  const nodeUtil2 = require$$0$2;
  const {
    isValidHTTPToken: isValidHTTPToken2,
    sameOrigin,
    environmentSettingsObject
  } = requireUtil$5();
  const {
    forbiddenMethodsSet,
    corsSafeListedMethodsSet,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    requestDuplex
  } = requireConstants$2();
  const { kEnumerableProperty: kEnumerableProperty2, normalizedMethodRecordsBase: normalizedMethodRecordsBase2, normalizedMethodRecords: normalizedMethodRecords2 } = util2;
  const { kHeaders, kSignal: kSignal2, kState, kDispatcher } = requireSymbols$3();
  const { webidl } = requireWebidl();
  const { URLSerializer } = requireDataUrl();
  const { kConstruct: kConstruct2 } = symbols$4;
  const assert2 = require$$0$3;
  const { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = require$$8$1;
  const kAbortController = Symbol("abortController");
  const requestFinalizer = new FinalizationRegistry2(({ signal, abort: abort2 }) => {
    signal.removeEventListener("abort", abort2);
  });
  const dependentControllerMap = /* @__PURE__ */ new WeakMap();
  function buildAbort(acRef) {
    return abort2;
    function abort2() {
      const ac = acRef.deref();
      if (ac !== void 0) {
        requestFinalizer.unregister(abort2);
        this.removeEventListener("abort", abort2);
        ac.abort(this.reason);
        const controllerList = dependentControllerMap.get(ac.signal);
        if (controllerList !== void 0) {
          if (controllerList.size !== 0) {
            for (const ref of controllerList) {
              const ctrl = ref.deref();
              if (ctrl !== void 0) {
                ctrl.abort(this.reason);
              }
            }
            controllerList.clear();
          }
          dependentControllerMap.delete(ac.signal);
        }
      }
    }
  }
  let patchMethodWarning = false;
  class Request4 {
    // https://fetch.spec.whatwg.org/#dom-request
    constructor(input, init = {}) {
      var _a2, _b2;
      webidl.util.markAsUncloneable(this);
      if (input === kConstruct2) {
        return;
      }
      const prefix = "Request constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      input = webidl.converters.RequestInfo(input, prefix, "input");
      init = webidl.converters.RequestInit(init, prefix, "init");
      let request2 = null;
      let fallbackMode = null;
      const baseUrl = environmentSettingsObject.settingsObject.baseUrl;
      let signal = null;
      if (typeof input === "string") {
        this[kDispatcher] = init.dispatcher;
        let parsedURL;
        try {
          parsedURL = new URL(input, baseUrl);
        } catch (err) {
          throw new TypeError("Failed to parse URL from " + input, { cause: err });
        }
        if (parsedURL.username || parsedURL.password) {
          throw new TypeError(
            "Request cannot be constructed from a URL that includes credentials: " + input
          );
        }
        request2 = makeRequest({ urlList: [parsedURL] });
        fallbackMode = "cors";
      } else {
        this[kDispatcher] = init.dispatcher || input[kDispatcher];
        assert2(input instanceof Request4);
        request2 = input[kState];
        signal = input[kSignal2];
      }
      const origin = environmentSettingsObject.settingsObject.origin;
      let window2 = "client";
      if (((_b2 = (_a2 = request2.window) == null ? void 0 : _a2.constructor) == null ? void 0 : _b2.name) === "EnvironmentSettingsObject" && sameOrigin(request2.window, origin)) {
        window2 = request2.window;
      }
      if (init.window != null) {
        throw new TypeError(`'window' option '${window2}' must be null`);
      }
      if ("window" in init) {
        window2 = "no-window";
      }
      request2 = makeRequest({
        // URL request’s URL.
        // undici implementation note: this is set as the first item in request's urlList in makeRequest
        // method request’s method.
        method: request2.method,
        // header list A copy of request’s header list.
        // undici implementation note: headersList is cloned in makeRequest
        headersList: request2.headersList,
        // unsafe-request flag Set.
        unsafeRequest: request2.unsafeRequest,
        // client This’s relevant settings object.
        client: environmentSettingsObject.settingsObject,
        // window window.
        window: window2,
        // priority request’s priority.
        priority: request2.priority,
        // origin request’s origin. The propagation of the origin is only significant for navigation requests
        // being handled by a service worker. In this scenario a request can have an origin that is different
        // from the current client.
        origin: request2.origin,
        // referrer request’s referrer.
        referrer: request2.referrer,
        // referrer policy request’s referrer policy.
        referrerPolicy: request2.referrerPolicy,
        // mode request’s mode.
        mode: request2.mode,
        // credentials mode request’s credentials mode.
        credentials: request2.credentials,
        // cache mode request’s cache mode.
        cache: request2.cache,
        // redirect mode request’s redirect mode.
        redirect: request2.redirect,
        // integrity metadata request’s integrity metadata.
        integrity: request2.integrity,
        // keepalive request’s keepalive.
        keepalive: request2.keepalive,
        // reload-navigation flag request’s reload-navigation flag.
        reloadNavigation: request2.reloadNavigation,
        // history-navigation flag request’s history-navigation flag.
        historyNavigation: request2.historyNavigation,
        // URL list A clone of request’s URL list.
        urlList: [...request2.urlList]
      });
      const initHasKey = Object.keys(init).length !== 0;
      if (initHasKey) {
        if (request2.mode === "navigate") {
          request2.mode = "same-origin";
        }
        request2.reloadNavigation = false;
        request2.historyNavigation = false;
        request2.origin = "client";
        request2.referrer = "client";
        request2.referrerPolicy = "";
        request2.url = request2.urlList[request2.urlList.length - 1];
        request2.urlList = [request2.url];
      }
      if (init.referrer !== void 0) {
        const referrer = init.referrer;
        if (referrer === "") {
          request2.referrer = "no-referrer";
        } else {
          let parsedReferrer;
          try {
            parsedReferrer = new URL(referrer, baseUrl);
          } catch (err) {
            throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
          }
          if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, environmentSettingsObject.settingsObject.baseUrl)) {
            request2.referrer = "client";
          } else {
            request2.referrer = parsedReferrer;
          }
        }
      }
      if (init.referrerPolicy !== void 0) {
        request2.referrerPolicy = init.referrerPolicy;
      }
      let mode;
      if (init.mode !== void 0) {
        mode = init.mode;
      } else {
        mode = fallbackMode;
      }
      if (mode === "navigate") {
        throw webidl.errors.exception({
          header: "Request constructor",
          message: "invalid request mode navigate."
        });
      }
      if (mode != null) {
        request2.mode = mode;
      }
      if (init.credentials !== void 0) {
        request2.credentials = init.credentials;
      }
      if (init.cache !== void 0) {
        request2.cache = init.cache;
      }
      if (request2.cache === "only-if-cached" && request2.mode !== "same-origin") {
        throw new TypeError(
          "'only-if-cached' can be set only with 'same-origin' mode"
        );
      }
      if (init.redirect !== void 0) {
        request2.redirect = init.redirect;
      }
      if (init.integrity != null) {
        request2.integrity = String(init.integrity);
      }
      if (init.keepalive !== void 0) {
        request2.keepalive = Boolean(init.keepalive);
      }
      if (init.method !== void 0) {
        let method = init.method;
        const mayBeNormalized = normalizedMethodRecords2[method];
        if (mayBeNormalized !== void 0) {
          request2.method = mayBeNormalized;
        } else {
          if (!isValidHTTPToken2(method)) {
            throw new TypeError(`'${method}' is not a valid HTTP method.`);
          }
          const upperCase = method.toUpperCase();
          if (forbiddenMethodsSet.has(upperCase)) {
            throw new TypeError(`'${method}' HTTP method is unsupported.`);
          }
          method = normalizedMethodRecordsBase2[upperCase] ?? method;
          request2.method = method;
        }
        if (!patchMethodWarning && request2.method === "patch") {
          process.emitWarning("Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.", {
            code: "UNDICI-FETCH-patch"
          });
          patchMethodWarning = true;
        }
      }
      if (init.signal !== void 0) {
        signal = init.signal;
      }
      this[kState] = request2;
      const ac = new AbortController();
      this[kSignal2] = ac.signal;
      if (signal != null) {
        if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") {
          throw new TypeError(
            "Failed to construct 'Request': member signal is not of type AbortSignal."
          );
        }
        if (signal.aborted) {
          ac.abort(signal.reason);
        } else {
          this[kAbortController] = ac;
          const acRef = new WeakRef(ac);
          const abort2 = buildAbort(acRef);
          try {
            if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) {
              setMaxListeners(1500, signal);
            } else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) {
              setMaxListeners(1500, signal);
            }
          } catch {
          }
          util2.addAbortListener(signal, abort2);
          requestFinalizer.register(ac, { signal, abort: abort2 }, abort2);
        }
      }
      this[kHeaders] = new Headers(kConstruct2);
      setHeadersList(this[kHeaders], request2.headersList);
      setHeadersGuard(this[kHeaders], "request");
      if (mode === "no-cors") {
        if (!corsSafeListedMethodsSet.has(request2.method)) {
          throw new TypeError(
            `'${request2.method} is unsupported in no-cors mode.`
          );
        }
        setHeadersGuard(this[kHeaders], "request-no-cors");
      }
      if (initHasKey) {
        const headersList = getHeadersList(this[kHeaders]);
        const headers2 = init.headers !== void 0 ? init.headers : new HeadersList(headersList);
        headersList.clear();
        if (headers2 instanceof HeadersList) {
          for (const { name, value } of headers2.rawValues()) {
            headersList.append(name, value, false);
          }
          headersList.cookies = headers2.cookies;
        } else {
          fillHeaders(this[kHeaders], headers2);
        }
      }
      const inputBody = input instanceof Request4 ? input[kState].body : null;
      if ((init.body != null || inputBody != null) && (request2.method === "GET" || request2.method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body.");
      }
      let initBody = null;
      if (init.body != null) {
        const [extractedBody, contentType] = extractBody2(
          init.body,
          request2.keepalive
        );
        initBody = extractedBody;
        if (contentType && !getHeadersList(this[kHeaders]).contains("content-type", true)) {
          this[kHeaders].append("content-type", contentType);
        }
      }
      const inputOrInitBody = initBody ?? inputBody;
      if (inputOrInitBody != null && inputOrInitBody.source == null) {
        if (initBody != null && init.duplex == null) {
          throw new TypeError("RequestInit: duplex option is required when sending a body.");
        }
        if (request2.mode !== "same-origin" && request2.mode !== "cors") {
          throw new TypeError(
            'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
          );
        }
        request2.useCORSPreflightFlag = true;
      }
      let finalBody = inputOrInitBody;
      if (initBody == null && inputBody != null) {
        if (bodyUnusable(input)) {
          throw new TypeError(
            "Cannot construct a Request with a Request object that has already been used."
          );
        }
        const identityTransform = new TransformStream();
        inputBody.stream.pipeThrough(identityTransform);
        finalBody = {
          source: inputBody.source,
          length: inputBody.length,
          stream: identityTransform.readable
        };
      }
      this[kState].body = finalBody;
    }
    // Returns request’s HTTP method, which is "GET" by default.
    get method() {
      webidl.brandCheck(this, Request4);
      return this[kState].method;
    }
    // Returns the URL of request as a string.
    get url() {
      webidl.brandCheck(this, Request4);
      return URLSerializer(this[kState].url);
    }
    // Returns a Headers object consisting of the headers associated with request.
    // Note that headers added in the network layer by the user agent will not
    // be accounted for in this object, e.g., the "Host" header.
    get headers() {
      webidl.brandCheck(this, Request4);
      return this[kHeaders];
    }
    // Returns the kind of resource requested by request, e.g., "document"
    // or "script".
    get destination() {
      webidl.brandCheck(this, Request4);
      return this[kState].destination;
    }
    // Returns the referrer of request. Its value can be a same-origin URL if
    // explicitly set in init, the empty string to indicate no referrer, and
    // "about:client" when defaulting to the global’s default. This is used
    // during fetching to determine the value of the `Referer` header of the
    // request being made.
    get referrer() {
      webidl.brandCheck(this, Request4);
      if (this[kState].referrer === "no-referrer") {
        return "";
      }
      if (this[kState].referrer === "client") {
        return "about:client";
      }
      return this[kState].referrer.toString();
    }
    // Returns the referrer policy associated with request.
    // This is used during fetching to compute the value of the request’s
    // referrer.
    get referrerPolicy() {
      webidl.brandCheck(this, Request4);
      return this[kState].referrerPolicy;
    }
    // Returns the mode associated with request, which is a string indicating
    // whether the request will use CORS, or will be restricted to same-origin
    // URLs.
    get mode() {
      webidl.brandCheck(this, Request4);
      return this[kState].mode;
    }
    // Returns the credentials mode associated with request,
    // which is a string indicating whether credentials will be sent with the
    // request always, never, or only when sent to a same-origin URL.
    get credentials() {
      return this[kState].credentials;
    }
    // Returns the cache mode associated with request,
    // which is a string indicating how the request will
    // interact with the browser’s cache when fetching.
    get cache() {
      webidl.brandCheck(this, Request4);
      return this[kState].cache;
    }
    // Returns the redirect mode associated with request,
    // which is a string indicating how redirects for the
    // request will be handled during fetching. A request
    // will follow redirects by default.
    get redirect() {
      webidl.brandCheck(this, Request4);
      return this[kState].redirect;
    }
    // Returns request’s subresource integrity metadata, which is a
    // cryptographic hash of the resource being fetched. Its value
    // consists of multiple hashes separated by whitespace. [SRI]
    get integrity() {
      webidl.brandCheck(this, Request4);
      return this[kState].integrity;
    }
    // Returns a boolean indicating whether or not request can outlive the
    // global in which it was created.
    get keepalive() {
      webidl.brandCheck(this, Request4);
      return this[kState].keepalive;
    }
    // Returns a boolean indicating whether or not request is for a reload
    // navigation.
    get isReloadNavigation() {
      webidl.brandCheck(this, Request4);
      return this[kState].reloadNavigation;
    }
    // Returns a boolean indicating whether or not request is for a history
    // navigation (a.k.a. back-forward navigation).
    get isHistoryNavigation() {
      webidl.brandCheck(this, Request4);
      return this[kState].historyNavigation;
    }
    // Returns the signal associated with request, which is an AbortSignal
    // object indicating whether or not request has been aborted, and its
    // abort event handler.
    get signal() {
      webidl.brandCheck(this, Request4);
      return this[kSignal2];
    }
    get body() {
      webidl.brandCheck(this, Request4);
      return this[kState].body ? this[kState].body.stream : null;
    }
    get bodyUsed() {
      webidl.brandCheck(this, Request4);
      return !!this[kState].body && util2.isDisturbed(this[kState].body.stream);
    }
    get duplex() {
      webidl.brandCheck(this, Request4);
      return "half";
    }
    // Returns a clone of request.
    clone() {
      webidl.brandCheck(this, Request4);
      if (bodyUnusable(this)) {
        throw new TypeError("unusable");
      }
      const clonedRequest = cloneRequest(this[kState]);
      const ac = new AbortController();
      if (this.signal.aborted) {
        ac.abort(this.signal.reason);
      } else {
        let list = dependentControllerMap.get(this.signal);
        if (list === void 0) {
          list = /* @__PURE__ */ new Set();
          dependentControllerMap.set(this.signal, list);
        }
        const acRef = new WeakRef(ac);
        list.add(acRef);
        util2.addAbortListener(
          ac.signal,
          buildAbort(acRef)
        );
      }
      return fromInnerRequest(clonedRequest, ac.signal, getHeadersGuard(this[kHeaders]));
    }
    [nodeUtil2.inspect.custom](depth, options) {
      if (options.depth === null) {
        options.depth = 2;
      }
      options.colors ?? (options.colors = true);
      const properties = {
        method: this.method,
        url: this.url,
        headers: this.headers,
        destination: this.destination,
        referrer: this.referrer,
        referrerPolicy: this.referrerPolicy,
        mode: this.mode,
        credentials: this.credentials,
        cache: this.cache,
        redirect: this.redirect,
        integrity: this.integrity,
        keepalive: this.keepalive,
        isReloadNavigation: this.isReloadNavigation,
        isHistoryNavigation: this.isHistoryNavigation,
        signal: this.signal
      };
      return `Request ${nodeUtil2.formatWithOptions(options, properties)}`;
    }
  }
  mixinBody(Request4);
  function makeRequest(init) {
    return {
      method: init.method ?? "GET",
      localURLsOnly: init.localURLsOnly ?? false,
      unsafeRequest: init.unsafeRequest ?? false,
      body: init.body ?? null,
      client: init.client ?? null,
      reservedClient: init.reservedClient ?? null,
      replacesClientId: init.replacesClientId ?? "",
      window: init.window ?? "client",
      keepalive: init.keepalive ?? false,
      serviceWorkers: init.serviceWorkers ?? "all",
      initiator: init.initiator ?? "",
      destination: init.destination ?? "",
      priority: init.priority ?? null,
      origin: init.origin ?? "client",
      policyContainer: init.policyContainer ?? "client",
      referrer: init.referrer ?? "client",
      referrerPolicy: init.referrerPolicy ?? "",
      mode: init.mode ?? "no-cors",
      useCORSPreflightFlag: init.useCORSPreflightFlag ?? false,
      credentials: init.credentials ?? "same-origin",
      useCredentials: init.useCredentials ?? false,
      cache: init.cache ?? "default",
      redirect: init.redirect ?? "follow",
      integrity: init.integrity ?? "",
      cryptoGraphicsNonceMetadata: init.cryptoGraphicsNonceMetadata ?? "",
      parserMetadata: init.parserMetadata ?? "",
      reloadNavigation: init.reloadNavigation ?? false,
      historyNavigation: init.historyNavigation ?? false,
      userActivation: init.userActivation ?? false,
      taintedOrigin: init.taintedOrigin ?? false,
      redirectCount: init.redirectCount ?? 0,
      responseTainting: init.responseTainting ?? "basic",
      preventNoCacheCacheControlHeaderModification: init.preventNoCacheCacheControlHeaderModification ?? false,
      done: init.done ?? false,
      timingAllowFailed: init.timingAllowFailed ?? false,
      urlList: init.urlList,
      url: init.urlList[0],
      headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
    };
  }
  function cloneRequest(request2) {
    const newRequest = makeRequest({ ...request2, body: null });
    if (request2.body != null) {
      newRequest.body = cloneBody(newRequest, request2.body);
    }
    return newRequest;
  }
  function fromInnerRequest(innerRequest, signal, guard) {
    const request2 = new Request4(kConstruct2);
    request2[kState] = innerRequest;
    request2[kSignal2] = signal;
    request2[kHeaders] = new Headers(kConstruct2);
    setHeadersList(request2[kHeaders], innerRequest.headersList);
    setHeadersGuard(request2[kHeaders], guard);
    return request2;
  }
  Object.defineProperties(Request4.prototype, {
    method: kEnumerableProperty2,
    url: kEnumerableProperty2,
    headers: kEnumerableProperty2,
    redirect: kEnumerableProperty2,
    clone: kEnumerableProperty2,
    signal: kEnumerableProperty2,
    duplex: kEnumerableProperty2,
    destination: kEnumerableProperty2,
    body: kEnumerableProperty2,
    bodyUsed: kEnumerableProperty2,
    isHistoryNavigation: kEnumerableProperty2,
    isReloadNavigation: kEnumerableProperty2,
    keepalive: kEnumerableProperty2,
    integrity: kEnumerableProperty2,
    cache: kEnumerableProperty2,
    credentials: kEnumerableProperty2,
    attribute: kEnumerableProperty2,
    referrerPolicy: kEnumerableProperty2,
    referrer: kEnumerableProperty2,
    mode: kEnumerableProperty2,
    [Symbol.toStringTag]: {
      value: "Request",
      configurable: true
    }
  });
  webidl.converters.Request = webidl.interfaceConverter(
    Request4
  );
  webidl.converters.RequestInfo = function(V, prefix, argument) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V, prefix, argument);
    }
    if (V instanceof Request4) {
      return webidl.converters.Request(V, prefix, argument);
    }
    return webidl.converters.USVString(V, prefix, argument);
  };
  webidl.converters.AbortSignal = webidl.interfaceConverter(
    AbortSignal
  );
  webidl.converters.RequestInit = webidl.dictionaryConverter([
    {
      key: "method",
      converter: webidl.converters.ByteString
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    },
    {
      key: "body",
      converter: webidl.nullableConverter(
        webidl.converters.BodyInit
      )
    },
    {
      key: "referrer",
      converter: webidl.converters.USVString
    },
    {
      key: "referrerPolicy",
      converter: webidl.converters.DOMString,
      // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
      allowedValues: referrerPolicy
    },
    {
      key: "mode",
      converter: webidl.converters.DOMString,
      // https://fetch.spec.whatwg.org/#concept-request-mode
      allowedValues: requestMode
    },
    {
      key: "credentials",
      converter: webidl.converters.DOMString,
      // https://fetch.spec.whatwg.org/#requestcredentials
      allowedValues: requestCredentials
    },
    {
      key: "cache",
      converter: webidl.converters.DOMString,
      // https://fetch.spec.whatwg.org/#requestcache
      allowedValues: requestCache
    },
    {
      key: "redirect",
      converter: webidl.converters.DOMString,
      // https://fetch.spec.whatwg.org/#requestredirect
      allowedValues: requestRedirect
    },
    {
      key: "integrity",
      converter: webidl.converters.DOMString
    },
    {
      key: "keepalive",
      converter: webidl.converters.boolean
    },
    {
      key: "signal",
      converter: webidl.nullableConverter(
        (signal) => webidl.converters.AbortSignal(
          signal,
          "RequestInit",
          "signal",
          { strict: false }
        )
      )
    },
    {
      key: "window",
      converter: webidl.converters.any
    },
    {
      key: "duplex",
      converter: webidl.converters.DOMString,
      allowedValues: requestDuplex
    },
    {
      key: "dispatcher",
      // undici specific option
      converter: webidl.converters.any
    }
  ]);
  request = { Request: Request4, makeRequest, fromInnerRequest, cloneRequest };
  return request;
}
var fetch_1;
var hasRequiredFetch;
function requireFetch() {
  if (hasRequiredFetch) return fetch_1;
  hasRequiredFetch = 1;
  const {
    makeNetworkError,
    makeAppropriateNetworkError,
    filterResponse,
    makeResponse,
    fromInnerResponse
  } = requireResponse();
  const { HeadersList } = requireHeaders();
  const { Request: Request4, cloneRequest } = requireRequest();
  const zlib = require$$1$2;
  const {
    bytesMatch,
    makePolicyContainer,
    clonePolicyContainer,
    requestBadPort,
    TAOCheck,
    appendRequestOriginHeader,
    responseLocationURL,
    requestCurrentURL,
    setRequestReferrerPolicyOnRedirect,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    createOpaqueTimingInfo,
    appendFetchMetadata,
    corsCheck,
    crossOriginResourcePolicyCheck,
    determineRequestsReferrer,
    coarsenedSharedCurrentTime,
    createDeferredPromise,
    isBlobLike: isBlobLike2,
    sameOrigin,
    isCancelled,
    isAborted,
    isErrorLike,
    fullyReadBody,
    readableStreamClose,
    isomorphicEncode,
    urlIsLocal,
    urlIsHttpHttpsScheme,
    urlHasHttpsScheme,
    clampAndCoarsenConnectionTimingInfo,
    simpleRangeHeaderValue,
    buildContentRange,
    createInflate,
    extractMimeType
  } = requireUtil$5();
  const { kState, kDispatcher } = requireSymbols$3();
  const assert2 = require$$0$3;
  const { safelyExtractBody, extractBody: extractBody2 } = requireBody();
  const {
    redirectStatusSet,
    nullBodyStatus,
    safeMethodsSet,
    requestBodyHeader,
    subresourceSet
  } = requireConstants$2();
  const EE2 = require$$8$1;
  const { Readable: Readable2, pipeline: pipeline2, finished: finished2 } = require$$0$4;
  const { addAbortListener: addAbortListener2, isErrored: isErrored2, isReadable: isReadable2, bufferToLowerCasedHeaderName: bufferToLowerCasedHeaderName2 } = util$n;
  const { dataURLProcessor, serializeAMimeType: serializeAMimeType2, minimizeSupportedMimeType } = requireDataUrl();
  const { getGlobalDispatcher: getGlobalDispatcher2 } = global$1;
  const { webidl } = requireWebidl();
  const { STATUS_CODES: STATUS_CODES2 } = require$$2$1;
  const GET_OR_HEAD = ["GET", "HEAD"];
  const defaultUserAgent = typeof __UNDICI_IS_NODE__ !== "undefined" || typeof esbuildDetection !== "undefined" ? "node" : "undici";
  let resolveObjectURL;
  class Fetch extends EE2 {
    constructor(dispatcher2) {
      super();
      this.dispatcher = dispatcher2;
      this.connection = null;
      this.dump = false;
      this.state = "ongoing";
    }
    terminate(reason) {
      var _a2;
      if (this.state !== "ongoing") {
        return;
      }
      this.state = "terminated";
      (_a2 = this.connection) == null ? void 0 : _a2.destroy(reason);
      this.emit("terminated", reason);
    }
    // https://fetch.spec.whatwg.org/#fetch-controller-abort
    abort(error) {
      var _a2;
      if (this.state !== "ongoing") {
        return;
      }
      this.state = "aborted";
      if (!error) {
        error = new DOMException("The operation was aborted.", "AbortError");
      }
      this.serializedAbortReason = error;
      (_a2 = this.connection) == null ? void 0 : _a2.destroy(error);
      this.emit("terminated", error);
    }
  }
  function handleFetchDone(response2) {
    finalizeAndReportTiming(response2, "fetch");
  }
  function fetch2(input, init = void 0) {
    var _a2;
    webidl.argumentLengthCheck(arguments, 1, "globalThis.fetch");
    let p = createDeferredPromise();
    let requestObject;
    try {
      requestObject = new Request4(input, init);
    } catch (e) {
      p.reject(e);
      return p.promise;
    }
    const request2 = requestObject[kState];
    if (requestObject.signal.aborted) {
      abortFetch(p, request2, null, requestObject.signal.reason);
      return p.promise;
    }
    const globalObject = request2.client.globalObject;
    if (((_a2 = globalObject == null ? void 0 : globalObject.constructor) == null ? void 0 : _a2.name) === "ServiceWorkerGlobalScope") {
      request2.serviceWorkers = "none";
    }
    let responseObject = null;
    let locallyAborted = false;
    let controller = null;
    addAbortListener2(
      requestObject.signal,
      () => {
        locallyAborted = true;
        assert2(controller != null);
        controller.abort(requestObject.signal.reason);
        const realResponse = responseObject == null ? void 0 : responseObject.deref();
        abortFetch(p, request2, realResponse, requestObject.signal.reason);
      }
    );
    const processResponse = (response2) => {
      if (locallyAborted) {
        return;
      }
      if (response2.aborted) {
        abortFetch(p, request2, responseObject, controller.serializedAbortReason);
        return;
      }
      if (response2.type === "error") {
        p.reject(new TypeError("fetch failed", { cause: response2.error }));
        return;
      }
      responseObject = new WeakRef(fromInnerResponse(response2, "immutable"));
      p.resolve(responseObject.deref());
      p = null;
    };
    controller = fetching({
      request: request2,
      processResponseEndOfBody: handleFetchDone,
      processResponse,
      dispatcher: requestObject[kDispatcher]
      // undici
    });
    return p.promise;
  }
  function finalizeAndReportTiming(response2, initiatorType = "other") {
    var _a2;
    if (response2.type === "error" && response2.aborted) {
      return;
    }
    if (!((_a2 = response2.urlList) == null ? void 0 : _a2.length)) {
      return;
    }
    const originalURL = response2.urlList[0];
    let timingInfo = response2.timingInfo;
    let cacheState = response2.cacheState;
    if (!urlIsHttpHttpsScheme(originalURL)) {
      return;
    }
    if (timingInfo === null) {
      return;
    }
    if (!response2.timingAllowPassed) {
      timingInfo = createOpaqueTimingInfo({
        startTime: timingInfo.startTime
      });
      cacheState = "";
    }
    timingInfo.endTime = coarsenedSharedCurrentTime();
    response2.timingInfo = timingInfo;
    markResourceTiming(
      timingInfo,
      originalURL.href,
      initiatorType,
      globalThis,
      cacheState
    );
  }
  const markResourceTiming = performance.markResourceTiming;
  function abortFetch(p, request2, responseObject, error) {
    var _a2, _b2;
    if (p) {
      p.reject(error);
    }
    if (request2.body != null && isReadable2((_a2 = request2.body) == null ? void 0 : _a2.stream)) {
      request2.body.stream.cancel(error).catch((err) => {
        if (err.code === "ERR_INVALID_STATE") {
          return;
        }
        throw err;
      });
    }
    if (responseObject == null) {
      return;
    }
    const response2 = responseObject[kState];
    if (response2.body != null && isReadable2((_b2 = response2.body) == null ? void 0 : _b2.stream)) {
      response2.body.stream.cancel(error).catch((err) => {
        if (err.code === "ERR_INVALID_STATE") {
          return;
        }
        throw err;
      });
    }
  }
  function fetching({
    request: request2,
    processRequestBodyChunkLength,
    processRequestEndOfBody,
    processResponse,
    processResponseEndOfBody,
    processResponseConsumeBody,
    useParallelQueue = false,
    dispatcher: dispatcher2 = getGlobalDispatcher2()
    // undici
  }) {
    var _a2, _b2, _c2;
    assert2(dispatcher2);
    let taskDestination = null;
    let crossOriginIsolatedCapability = false;
    if (request2.client != null) {
      taskDestination = request2.client.globalObject;
      crossOriginIsolatedCapability = request2.client.crossOriginIsolatedCapability;
    }
    const currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
    const timingInfo = createOpaqueTimingInfo({
      startTime: currentTime
    });
    const fetchParams = {
      controller: new Fetch(dispatcher2),
      request: request2,
      timingInfo,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseConsumeBody,
      processResponseEndOfBody,
      taskDestination,
      crossOriginIsolatedCapability
    };
    assert2(!request2.body || request2.body.stream);
    if (request2.window === "client") {
      request2.window = ((_c2 = (_b2 = (_a2 = request2.client) == null ? void 0 : _a2.globalObject) == null ? void 0 : _b2.constructor) == null ? void 0 : _c2.name) === "Window" ? request2.client : "no-window";
    }
    if (request2.origin === "client") {
      request2.origin = request2.client.origin;
    }
    if (request2.policyContainer === "client") {
      if (request2.client != null) {
        request2.policyContainer = clonePolicyContainer(
          request2.client.policyContainer
        );
      } else {
        request2.policyContainer = makePolicyContainer();
      }
    }
    if (!request2.headersList.contains("accept", true)) {
      const value = "*/*";
      request2.headersList.append("accept", value, true);
    }
    if (!request2.headersList.contains("accept-language", true)) {
      request2.headersList.append("accept-language", "*", true);
    }
    if (request2.priority === null) ;
    if (subresourceSet.has(request2.destination)) ;
    mainFetch(fetchParams).catch((err) => {
      fetchParams.controller.terminate(err);
    });
    return fetchParams.controller;
  }
  async function mainFetch(fetchParams, recursive = false) {
    const request2 = fetchParams.request;
    let response2 = null;
    if (request2.localURLsOnly && !urlIsLocal(requestCurrentURL(request2))) {
      response2 = makeNetworkError("local URLs only");
    }
    tryUpgradeRequestToAPotentiallyTrustworthyURL(request2);
    if (requestBadPort(request2) === "blocked") {
      response2 = makeNetworkError("bad port");
    }
    if (request2.referrerPolicy === "") {
      request2.referrerPolicy = request2.policyContainer.referrerPolicy;
    }
    if (request2.referrer !== "no-referrer") {
      request2.referrer = determineRequestsReferrer(request2);
    }
    if (response2 === null) {
      response2 = await (async () => {
        const currentURL = requestCurrentURL(request2);
        if (
          // - request’s current URL’s origin is same origin with request’s origin,
          //   and request’s response tainting is "basic"
          sameOrigin(currentURL, request2.url) && request2.responseTainting === "basic" || // request’s current URL’s scheme is "data"
          currentURL.protocol === "data:" || // - request’s mode is "navigate" or "websocket"
          (request2.mode === "navigate" || request2.mode === "websocket")
        ) {
          request2.responseTainting = "basic";
          return await schemeFetch(fetchParams);
        }
        if (request2.mode === "same-origin") {
          return makeNetworkError('request mode cannot be "same-origin"');
        }
        if (request2.mode === "no-cors") {
          if (request2.redirect !== "follow") {
            return makeNetworkError(
              'redirect mode cannot be "follow" for "no-cors" request'
            );
          }
          request2.responseTainting = "opaque";
          return await schemeFetch(fetchParams);
        }
        if (!urlIsHttpHttpsScheme(requestCurrentURL(request2))) {
          return makeNetworkError("URL scheme must be a HTTP(S) scheme");
        }
        request2.responseTainting = "cors";
        return await httpFetch(fetchParams);
      })();
    }
    if (recursive) {
      return response2;
    }
    if (response2.status !== 0 && !response2.internalResponse) {
      if (request2.responseTainting === "cors") ;
      if (request2.responseTainting === "basic") {
        response2 = filterResponse(response2, "basic");
      } else if (request2.responseTainting === "cors") {
        response2 = filterResponse(response2, "cors");
      } else if (request2.responseTainting === "opaque") {
        response2 = filterResponse(response2, "opaque");
      } else {
        assert2(false);
      }
    }
    let internalResponse = response2.status === 0 ? response2 : response2.internalResponse;
    if (internalResponse.urlList.length === 0) {
      internalResponse.urlList.push(...request2.urlList);
    }
    if (!request2.timingAllowFailed) {
      response2.timingAllowPassed = true;
    }
    if (response2.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request2.headers.contains("range", true)) {
      response2 = internalResponse = makeNetworkError();
    }
    if (response2.status !== 0 && (request2.method === "HEAD" || request2.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
      internalResponse.body = null;
      fetchParams.controller.dump = true;
    }
    if (request2.integrity) {
      const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
      if (request2.responseTainting === "opaque" || response2.body == null) {
        processBodyError(response2.error);
        return;
      }
      const processBody = (bytes) => {
        if (!bytesMatch(bytes, request2.integrity)) {
          processBodyError("integrity mismatch");
          return;
        }
        response2.body = safelyExtractBody(bytes)[0];
        fetchFinale(fetchParams, response2);
      };
      await fullyReadBody(response2.body, processBody, processBodyError);
    } else {
      fetchFinale(fetchParams, response2);
    }
  }
  function schemeFetch(fetchParams) {
    if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
      return Promise.resolve(makeAppropriateNetworkError(fetchParams));
    }
    const { request: request2 } = fetchParams;
    const { protocol: scheme } = requestCurrentURL(request2);
    switch (scheme) {
      case "about:": {
        return Promise.resolve(makeNetworkError("about scheme is not supported"));
      }
      case "blob:": {
        if (!resolveObjectURL) {
          resolveObjectURL = require$$0$1.resolveObjectURL;
        }
        const blobURLEntry = requestCurrentURL(request2);
        if (blobURLEntry.search.length !== 0) {
          return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
        }
        const blob = resolveObjectURL(blobURLEntry.toString());
        if (request2.method !== "GET" || !isBlobLike2(blob)) {
          return Promise.resolve(makeNetworkError("invalid method"));
        }
        const response2 = makeResponse();
        const fullLength = blob.size;
        const serializedFullLength = isomorphicEncode(`${fullLength}`);
        const type = blob.type;
        if (!request2.headersList.contains("range", true)) {
          const bodyWithType = extractBody2(blob);
          response2.statusText = "OK";
          response2.body = bodyWithType[0];
          response2.headersList.set("content-length", serializedFullLength, true);
          response2.headersList.set("content-type", type, true);
        } else {
          response2.rangeRequested = true;
          const rangeHeader = request2.headersList.get("range", true);
          const rangeValue = simpleRangeHeaderValue(rangeHeader, true);
          if (rangeValue === "failure") {
            return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
          }
          let { rangeStartValue: rangeStart, rangeEndValue: rangeEnd } = rangeValue;
          if (rangeStart === null) {
            rangeStart = fullLength - rangeEnd;
            rangeEnd = rangeStart + rangeEnd - 1;
          } else {
            if (rangeStart >= fullLength) {
              return Promise.resolve(makeNetworkError("Range start is greater than the blob's size."));
            }
            if (rangeEnd === null || rangeEnd >= fullLength) {
              rangeEnd = fullLength - 1;
            }
          }
          const slicedBlob = blob.slice(rangeStart, rangeEnd, type);
          const slicedBodyWithType = extractBody2(slicedBlob);
          response2.body = slicedBodyWithType[0];
          const serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`);
          const contentRange = buildContentRange(rangeStart, rangeEnd, fullLength);
          response2.status = 206;
          response2.statusText = "Partial Content";
          response2.headersList.set("content-length", serializedSlicedLength, true);
          response2.headersList.set("content-type", type, true);
          response2.headersList.set("content-range", contentRange, true);
        }
        return Promise.resolve(response2);
      }
      case "data:": {
        const currentURL = requestCurrentURL(request2);
        const dataURLStruct = dataURLProcessor(currentURL);
        if (dataURLStruct === "failure") {
          return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
        }
        const mimeType = serializeAMimeType2(dataURLStruct.mimeType);
        return Promise.resolve(makeResponse({
          statusText: "OK",
          headersList: [
            ["content-type", { name: "Content-Type", value: mimeType }]
          ],
          body: safelyExtractBody(dataURLStruct.body)[0]
        }));
      }
      case "file:": {
        return Promise.resolve(makeNetworkError("not implemented... yet..."));
      }
      case "http:":
      case "https:": {
        return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
      }
      default: {
        return Promise.resolve(makeNetworkError("unknown scheme"));
      }
    }
  }
  function finalizeResponse(fetchParams, response2) {
    fetchParams.request.done = true;
    if (fetchParams.processResponseDone != null) {
      queueMicrotask(() => fetchParams.processResponseDone(response2));
    }
  }
  function fetchFinale(fetchParams, response2) {
    let timingInfo = fetchParams.timingInfo;
    const processResponseEndOfBody = () => {
      const unsafeEndTime = Date.now();
      if (fetchParams.request.destination === "document") {
        fetchParams.controller.fullTimingInfo = timingInfo;
      }
      fetchParams.controller.reportTimingSteps = () => {
        if (fetchParams.request.url.protocol !== "https:") {
          return;
        }
        timingInfo.endTime = unsafeEndTime;
        let cacheState = response2.cacheState;
        const bodyInfo = response2.bodyInfo;
        if (!response2.timingAllowPassed) {
          timingInfo = createOpaqueTimingInfo(timingInfo);
          cacheState = "";
        }
        let responseStatus = 0;
        if (fetchParams.request.mode !== "navigator" || !response2.hasCrossOriginRedirects) {
          responseStatus = response2.status;
          const mimeType = extractMimeType(response2.headersList);
          if (mimeType !== "failure") {
            bodyInfo.contentType = minimizeSupportedMimeType(mimeType);
          }
        }
        if (fetchParams.request.initiatorType != null) {
          markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus);
        }
      };
      const processResponseEndOfBodyTask = () => {
        fetchParams.request.done = true;
        if (fetchParams.processResponseEndOfBody != null) {
          queueMicrotask(() => fetchParams.processResponseEndOfBody(response2));
        }
        if (fetchParams.request.initiatorType != null) {
          fetchParams.controller.reportTimingSteps();
        }
      };
      queueMicrotask(() => processResponseEndOfBodyTask());
    };
    if (fetchParams.processResponse != null) {
      queueMicrotask(() => {
        fetchParams.processResponse(response2);
        fetchParams.processResponse = null;
      });
    }
    const internalResponse = response2.type === "error" ? response2 : response2.internalResponse ?? response2;
    if (internalResponse.body == null) {
      processResponseEndOfBody();
    } else {
      finished2(internalResponse.body.stream, () => {
        processResponseEndOfBody();
      });
    }
  }
  async function httpFetch(fetchParams) {
    const request2 = fetchParams.request;
    let response2 = null;
    let actualResponse = null;
    const timingInfo = fetchParams.timingInfo;
    if (request2.serviceWorkers === "all") ;
    if (response2 === null) {
      if (request2.redirect === "follow") {
        request2.serviceWorkers = "none";
      }
      actualResponse = response2 = await httpNetworkOrCacheFetch(fetchParams);
      if (request2.responseTainting === "cors" && corsCheck(request2, response2) === "failure") {
        return makeNetworkError("cors failure");
      }
      if (TAOCheck(request2, response2) === "failure") {
        request2.timingAllowFailed = true;
      }
    }
    if ((request2.responseTainting === "opaque" || response2.type === "opaque") && crossOriginResourcePolicyCheck(
      request2.origin,
      request2.client,
      request2.destination,
      actualResponse
    ) === "blocked") {
      return makeNetworkError("blocked");
    }
    if (redirectStatusSet.has(actualResponse.status)) {
      if (request2.redirect !== "manual") {
        fetchParams.controller.connection.destroy(void 0, false);
      }
      if (request2.redirect === "error") {
        response2 = makeNetworkError("unexpected redirect");
      } else if (request2.redirect === "manual") {
        response2 = actualResponse;
      } else if (request2.redirect === "follow") {
        response2 = await httpRedirectFetch(fetchParams, response2);
      } else {
        assert2(false);
      }
    }
    response2.timingInfo = timingInfo;
    return response2;
  }
  function httpRedirectFetch(fetchParams, response2) {
    const request2 = fetchParams.request;
    const actualResponse = response2.internalResponse ? response2.internalResponse : response2;
    let locationURL;
    try {
      locationURL = responseLocationURL(
        actualResponse,
        requestCurrentURL(request2).hash
      );
      if (locationURL == null) {
        return response2;
      }
    } catch (err) {
      return Promise.resolve(makeNetworkError(err));
    }
    if (!urlIsHttpHttpsScheme(locationURL)) {
      return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
    }
    if (request2.redirectCount === 20) {
      return Promise.resolve(makeNetworkError("redirect count exceeded"));
    }
    request2.redirectCount += 1;
    if (request2.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request2, locationURL)) {
      return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
    }
    if (request2.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
      return Promise.resolve(makeNetworkError(
        'URL cannot contain credentials for request mode "cors"'
      ));
    }
    if (actualResponse.status !== 303 && request2.body != null && request2.body.source == null) {
      return Promise.resolve(makeNetworkError());
    }
    if ([301, 302].includes(actualResponse.status) && request2.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request2.method)) {
      request2.method = "GET";
      request2.body = null;
      for (const headerName of requestBodyHeader) {
        request2.headersList.delete(headerName);
      }
    }
    if (!sameOrigin(requestCurrentURL(request2), locationURL)) {
      request2.headersList.delete("authorization", true);
      request2.headersList.delete("proxy-authorization", true);
      request2.headersList.delete("cookie", true);
      request2.headersList.delete("host", true);
    }
    if (request2.body != null) {
      assert2(request2.body.source != null);
      request2.body = safelyExtractBody(request2.body.source)[0];
    }
    const timingInfo = fetchParams.timingInfo;
    timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
    if (timingInfo.redirectStartTime === 0) {
      timingInfo.redirectStartTime = timingInfo.startTime;
    }
    request2.urlList.push(locationURL);
    setRequestReferrerPolicyOnRedirect(request2, actualResponse);
    return mainFetch(fetchParams, true);
  }
  async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
    const request2 = fetchParams.request;
    let httpFetchParams = null;
    let httpRequest = null;
    let response2 = null;
    if (request2.window === "no-window" && request2.redirect === "error") {
      httpFetchParams = fetchParams;
      httpRequest = request2;
    } else {
      httpRequest = cloneRequest(request2);
      httpFetchParams = { ...fetchParams };
      httpFetchParams.request = httpRequest;
    }
    const includeCredentials = request2.credentials === "include" || request2.credentials === "same-origin" && request2.responseTainting === "basic";
    const contentLength = httpRequest.body ? httpRequest.body.length : null;
    let contentLengthHeaderValue = null;
    if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
      contentLengthHeaderValue = "0";
    }
    if (contentLength != null) {
      contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
    }
    if (contentLengthHeaderValue != null) {
      httpRequest.headersList.append("content-length", contentLengthHeaderValue, true);
    }
    if (contentLength != null && httpRequest.keepalive) ;
    if (httpRequest.referrer instanceof URL) {
      httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href), true);
    }
    appendRequestOriginHeader(httpRequest);
    appendFetchMetadata(httpRequest);
    if (!httpRequest.headersList.contains("user-agent", true)) {
      httpRequest.headersList.append("user-agent", defaultUserAgent);
    }
    if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since", true) || httpRequest.headersList.contains("if-none-match", true) || httpRequest.headersList.contains("if-unmodified-since", true) || httpRequest.headersList.contains("if-match", true) || httpRequest.headersList.contains("if-range", true))) {
      httpRequest.cache = "no-store";
    }
    if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control", true)) {
      httpRequest.headersList.append("cache-control", "max-age=0", true);
    }
    if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
      if (!httpRequest.headersList.contains("pragma", true)) {
        httpRequest.headersList.append("pragma", "no-cache", true);
      }
      if (!httpRequest.headersList.contains("cache-control", true)) {
        httpRequest.headersList.append("cache-control", "no-cache", true);
      }
    }
    if (httpRequest.headersList.contains("range", true)) {
      httpRequest.headersList.append("accept-encoding", "identity", true);
    }
    if (!httpRequest.headersList.contains("accept-encoding", true)) {
      if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
        httpRequest.headersList.append("accept-encoding", "br, gzip, deflate", true);
      } else {
        httpRequest.headersList.append("accept-encoding", "gzip, deflate", true);
      }
    }
    httpRequest.headersList.delete("host", true);
    {
      httpRequest.cache = "no-store";
    }
    if (httpRequest.cache !== "no-store" && httpRequest.cache !== "reload") ;
    if (response2 == null) {
      if (httpRequest.cache === "only-if-cached") {
        return makeNetworkError("only if cached");
      }
      const forwardResponse = await httpNetworkFetch(
        httpFetchParams,
        includeCredentials,
        isNewConnectionFetch
      );
      if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) ;
      if (response2 == null) {
        response2 = forwardResponse;
      }
    }
    response2.urlList = [...httpRequest.urlList];
    if (httpRequest.headersList.contains("range", true)) {
      response2.rangeRequested = true;
    }
    response2.requestIncludesCredentials = includeCredentials;
    if (response2.status === 407) {
      if (request2.window === "no-window") {
        return makeNetworkError();
      }
      if (isCancelled(fetchParams)) {
        return makeAppropriateNetworkError(fetchParams);
      }
      return makeNetworkError("proxy authentication required");
    }
    if (
      // response’s status is 421
      response2.status === 421 && // isNewConnectionFetch is false
      !isNewConnectionFetch && // request’s body is null, or request’s body is non-null and request’s body’s source is non-null
      (request2.body == null || request2.body.source != null)
    ) {
      if (isCancelled(fetchParams)) {
        return makeAppropriateNetworkError(fetchParams);
      }
      fetchParams.controller.connection.destroy();
      response2 = await httpNetworkOrCacheFetch(
        fetchParams,
        isAuthenticationFetch,
        true
      );
    }
    return response2;
  }
  async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
    assert2(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
    fetchParams.controller.connection = {
      abort: null,
      destroyed: false,
      destroy(err, abort2 = true) {
        var _a2;
        if (!this.destroyed) {
          this.destroyed = true;
          if (abort2) {
            (_a2 = this.abort) == null ? void 0 : _a2.call(this, err ?? new DOMException("The operation was aborted.", "AbortError"));
          }
        }
      }
    };
    const request2 = fetchParams.request;
    let response2 = null;
    const timingInfo = fetchParams.timingInfo;
    {
      request2.cache = "no-store";
    }
    if (request2.mode === "websocket") ;
    let requestBody = null;
    if (request2.body == null && fetchParams.processRequestEndOfBody) {
      queueMicrotask(() => fetchParams.processRequestEndOfBody());
    } else if (request2.body != null) {
      const processBodyChunk = async function* (bytes) {
        var _a2;
        if (isCancelled(fetchParams)) {
          return;
        }
        yield bytes;
        (_a2 = fetchParams.processRequestBodyChunkLength) == null ? void 0 : _a2.call(fetchParams, bytes.byteLength);
      };
      const processEndOfBody = () => {
        if (isCancelled(fetchParams)) {
          return;
        }
        if (fetchParams.processRequestEndOfBody) {
          fetchParams.processRequestEndOfBody();
        }
      };
      const processBodyError = (e) => {
        if (isCancelled(fetchParams)) {
          return;
        }
        if (e.name === "AbortError") {
          fetchParams.controller.abort();
        } else {
          fetchParams.controller.terminate(e);
        }
      };
      requestBody = async function* () {
        try {
          for await (const bytes of request2.body.stream) {
            yield* processBodyChunk(bytes);
          }
          processEndOfBody();
        } catch (err) {
          processBodyError(err);
        }
      }();
    }
    try {
      const { body: body2, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
      if (socket) {
        response2 = makeResponse({ status, statusText, headersList, socket });
      } else {
        const iterator = body2[Symbol.asyncIterator]();
        fetchParams.controller.next = () => iterator.next();
        response2 = makeResponse({ status, statusText, headersList });
      }
    } catch (err) {
      if (err.name === "AbortError") {
        fetchParams.controller.connection.destroy();
        return makeAppropriateNetworkError(fetchParams, err);
      }
      return makeNetworkError(err);
    }
    const pullAlgorithm = async () => {
      await fetchParams.controller.resume();
    };
    const cancelAlgorithm = (reason) => {
      if (!isCancelled(fetchParams)) {
        fetchParams.controller.abort(reason);
      }
    };
    const stream2 = new ReadableStream(
      {
        async start(controller) {
          fetchParams.controller.controller = controller;
        },
        async pull(controller) {
          await pullAlgorithm();
        },
        async cancel(reason) {
          await cancelAlgorithm(reason);
        },
        type: "bytes"
      }
    );
    response2.body = { stream: stream2, source: null, length: null };
    fetchParams.controller.onAborted = onAborted;
    fetchParams.controller.on("terminated", onAborted);
    fetchParams.controller.resume = async () => {
      while (true) {
        let bytes;
        let isFailure;
        try {
          const { done, value } = await fetchParams.controller.next();
          if (isAborted(fetchParams)) {
            break;
          }
          bytes = done ? void 0 : value;
        } catch (err) {
          if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
            bytes = void 0;
          } else {
            bytes = err;
            isFailure = true;
          }
        }
        if (bytes === void 0) {
          readableStreamClose(fetchParams.controller.controller);
          finalizeResponse(fetchParams, response2);
          return;
        }
        timingInfo.decodedBodySize += (bytes == null ? void 0 : bytes.byteLength) ?? 0;
        if (isFailure) {
          fetchParams.controller.terminate(bytes);
          return;
        }
        const buffer = new Uint8Array(bytes);
        if (buffer.byteLength) {
          fetchParams.controller.controller.enqueue(buffer);
        }
        if (isErrored2(stream2)) {
          fetchParams.controller.terminate();
          return;
        }
        if (fetchParams.controller.controller.desiredSize <= 0) {
          return;
        }
      }
    };
    function onAborted(reason) {
      if (isAborted(fetchParams)) {
        response2.aborted = true;
        if (isReadable2(stream2)) {
          fetchParams.controller.controller.error(
            fetchParams.controller.serializedAbortReason
          );
        }
      } else {
        if (isReadable2(stream2)) {
          fetchParams.controller.controller.error(new TypeError("terminated", {
            cause: isErrorLike(reason) ? reason : void 0
          }));
        }
      }
      fetchParams.controller.connection.destroy();
    }
    return response2;
    function dispatch({ body: body2 }) {
      const url = requestCurrentURL(request2);
      const agent2 = fetchParams.controller.dispatcher;
      return new Promise((resolve2, reject) => agent2.dispatch(
        {
          path: url.pathname + url.search,
          origin: url.origin,
          method: request2.method,
          body: agent2.isMockActive ? request2.body && (request2.body.source || request2.body.stream) : body2,
          headers: request2.headersList.entries,
          maxRedirections: 0,
          upgrade: request2.mode === "websocket" ? "websocket" : void 0
        },
        {
          body: null,
          abort: null,
          onConnect(abort2) {
            const { connection: connection2 } = fetchParams.controller;
            timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(void 0, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability);
            if (connection2.destroyed) {
              abort2(new DOMException("The operation was aborted.", "AbortError"));
            } else {
              fetchParams.controller.on("terminated", abort2);
              this.abort = connection2.abort = abort2;
            }
            timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
          },
          onResponseStarted() {
            timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
          },
          onHeaders(status, rawHeaders, resume2, statusText) {
            if (status < 200) {
              return;
            }
            let codings = [];
            let location = "";
            const headersList = new HeadersList();
            for (let i = 0; i < rawHeaders.length; i += 2) {
              headersList.append(bufferToLowerCasedHeaderName2(rawHeaders[i]), rawHeaders[i + 1].toString("latin1"), true);
            }
            const contentEncoding = headersList.get("content-encoding", true);
            if (contentEncoding) {
              codings = contentEncoding.toLowerCase().split(",").map((x) => x.trim());
            }
            location = headersList.get("location", true);
            this.body = new Readable2({ read: resume2 });
            const decoders = [];
            const willFollow = location && request2.redirect === "follow" && redirectStatusSet.has(status);
            if (codings.length !== 0 && request2.method !== "HEAD" && request2.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
              for (let i = codings.length - 1; i >= 0; --i) {
                const coding = codings[i];
                if (coding === "x-gzip" || coding === "gzip") {
                  decoders.push(zlib.createGunzip({
                    // Be less strict when decoding compressed responses, since sometimes
                    // servers send slightly invalid responses that are still accepted
                    // by common browsers.
                    // Always using Z_SYNC_FLUSH is what cURL does.
                    flush: zlib.constants.Z_SYNC_FLUSH,
                    finishFlush: zlib.constants.Z_SYNC_FLUSH
                  }));
                } else if (coding === "deflate") {
                  decoders.push(createInflate({
                    flush: zlib.constants.Z_SYNC_FLUSH,
                    finishFlush: zlib.constants.Z_SYNC_FLUSH
                  }));
                } else if (coding === "br") {
                  decoders.push(zlib.createBrotliDecompress({
                    flush: zlib.constants.BROTLI_OPERATION_FLUSH,
                    finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
                  }));
                } else {
                  decoders.length = 0;
                  break;
                }
              }
            }
            const onError2 = this.onError.bind(this);
            resolve2({
              status,
              statusText,
              headersList,
              body: decoders.length ? pipeline2(this.body, ...decoders, (err) => {
                if (err) {
                  this.onError(err);
                }
              }).on("error", onError2) : this.body.on("error", onError2)
            });
            return true;
          },
          onData(chunk) {
            if (fetchParams.controller.dump) {
              return;
            }
            const bytes = chunk;
            timingInfo.encodedBodySize += bytes.byteLength;
            return this.body.push(bytes);
          },
          onComplete() {
            if (this.abort) {
              fetchParams.controller.off("terminated", this.abort);
            }
            if (fetchParams.controller.onAborted) {
              fetchParams.controller.off("terminated", fetchParams.controller.onAborted);
            }
            fetchParams.controller.ended = true;
            this.body.push(null);
          },
          onError(error) {
            var _a2;
            if (this.abort) {
              fetchParams.controller.off("terminated", this.abort);
            }
            (_a2 = this.body) == null ? void 0 : _a2.destroy(error);
            fetchParams.controller.terminate(error);
            reject(error);
          },
          onUpgrade(status, rawHeaders, socket) {
            if (status !== 101) {
              return;
            }
            const headersList = new HeadersList();
            for (let i = 0; i < rawHeaders.length; i += 2) {
              headersList.append(bufferToLowerCasedHeaderName2(rawHeaders[i]), rawHeaders[i + 1].toString("latin1"), true);
            }
            resolve2({
              status,
              statusText: STATUS_CODES2[status],
              headersList,
              socket
            });
            return true;
          }
        }
      ));
    }
  }
  fetch_1 = {
    fetch: fetch2,
    Fetch,
    fetching,
    finalizeAndReportTiming
  };
  return fetch_1;
}
var symbols$2;
var hasRequiredSymbols$2;
function requireSymbols$2() {
  if (hasRequiredSymbols$2) return symbols$2;
  hasRequiredSymbols$2 = 1;
  symbols$2 = {
    kState: Symbol("FileReader state"),
    kResult: Symbol("FileReader result"),
    kError: Symbol("FileReader error"),
    kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
    kEvents: Symbol("FileReader events"),
    kAborted: Symbol("FileReader aborted")
  };
  return symbols$2;
}
var progressevent;
var hasRequiredProgressevent;
function requireProgressevent() {
  if (hasRequiredProgressevent) return progressevent;
  hasRequiredProgressevent = 1;
  const { webidl } = requireWebidl();
  const kState = Symbol("ProgressEvent state");
  class ProgressEvent extends Event {
    constructor(type, eventInitDict = {}) {
      type = webidl.converters.DOMString(type, "ProgressEvent constructor", "type");
      eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
      super(type, eventInitDict);
      this[kState] = {
        lengthComputable: eventInitDict.lengthComputable,
        loaded: eventInitDict.loaded,
        total: eventInitDict.total
      };
    }
    get lengthComputable() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].lengthComputable;
    }
    get loaded() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].loaded;
    }
    get total() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].total;
    }
  }
  webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
    {
      key: "lengthComputable",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "loaded",
      converter: webidl.converters["unsigned long long"],
      defaultValue: () => 0
    },
    {
      key: "total",
      converter: webidl.converters["unsigned long long"],
      defaultValue: () => 0
    },
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    }
  ]);
  progressevent = {
    ProgressEvent
  };
  return progressevent;
}
var encoding;
var hasRequiredEncoding;
function requireEncoding() {
  if (hasRequiredEncoding) return encoding;
  hasRequiredEncoding = 1;
  function getEncoding(label) {
    if (!label) {
      return "failure";
    }
    switch (label.trim().toLowerCase()) {
      case "unicode-1-1-utf-8":
      case "unicode11utf8":
      case "unicode20utf8":
      case "utf-8":
      case "utf8":
      case "x-unicode20utf8":
        return "UTF-8";
      case "866":
      case "cp866":
      case "csibm866":
      case "ibm866":
        return "IBM866";
      case "csisolatin2":
      case "iso-8859-2":
      case "iso-ir-101":
      case "iso8859-2":
      case "iso88592":
      case "iso_8859-2":
      case "iso_8859-2:1987":
      case "l2":
      case "latin2":
        return "ISO-8859-2";
      case "csisolatin3":
      case "iso-8859-3":
      case "iso-ir-109":
      case "iso8859-3":
      case "iso88593":
      case "iso_8859-3":
      case "iso_8859-3:1988":
      case "l3":
      case "latin3":
        return "ISO-8859-3";
      case "csisolatin4":
      case "iso-8859-4":
      case "iso-ir-110":
      case "iso8859-4":
      case "iso88594":
      case "iso_8859-4":
      case "iso_8859-4:1988":
      case "l4":
      case "latin4":
        return "ISO-8859-4";
      case "csisolatincyrillic":
      case "cyrillic":
      case "iso-8859-5":
      case "iso-ir-144":
      case "iso8859-5":
      case "iso88595":
      case "iso_8859-5":
      case "iso_8859-5:1988":
        return "ISO-8859-5";
      case "arabic":
      case "asmo-708":
      case "csiso88596e":
      case "csiso88596i":
      case "csisolatinarabic":
      case "ecma-114":
      case "iso-8859-6":
      case "iso-8859-6-e":
      case "iso-8859-6-i":
      case "iso-ir-127":
      case "iso8859-6":
      case "iso88596":
      case "iso_8859-6":
      case "iso_8859-6:1987":
        return "ISO-8859-6";
      case "csisolatingreek":
      case "ecma-118":
      case "elot_928":
      case "greek":
      case "greek8":
      case "iso-8859-7":
      case "iso-ir-126":
      case "iso8859-7":
      case "iso88597":
      case "iso_8859-7":
      case "iso_8859-7:1987":
      case "sun_eu_greek":
        return "ISO-8859-7";
      case "csiso88598e":
      case "csisolatinhebrew":
      case "hebrew":
      case "iso-8859-8":
      case "iso-8859-8-e":
      case "iso-ir-138":
      case "iso8859-8":
      case "iso88598":
      case "iso_8859-8":
      case "iso_8859-8:1988":
      case "visual":
        return "ISO-8859-8";
      case "csiso88598i":
      case "iso-8859-8-i":
      case "logical":
        return "ISO-8859-8-I";
      case "csisolatin6":
      case "iso-8859-10":
      case "iso-ir-157":
      case "iso8859-10":
      case "iso885910":
      case "l6":
      case "latin6":
        return "ISO-8859-10";
      case "iso-8859-13":
      case "iso8859-13":
      case "iso885913":
        return "ISO-8859-13";
      case "iso-8859-14":
      case "iso8859-14":
      case "iso885914":
        return "ISO-8859-14";
      case "csisolatin9":
      case "iso-8859-15":
      case "iso8859-15":
      case "iso885915":
      case "iso_8859-15":
      case "l9":
        return "ISO-8859-15";
      case "iso-8859-16":
        return "ISO-8859-16";
      case "cskoi8r":
      case "koi":
      case "koi8":
      case "koi8-r":
      case "koi8_r":
        return "KOI8-R";
      case "koi8-ru":
      case "koi8-u":
        return "KOI8-U";
      case "csmacintosh":
      case "mac":
      case "macintosh":
      case "x-mac-roman":
        return "macintosh";
      case "iso-8859-11":
      case "iso8859-11":
      case "iso885911":
      case "tis-620":
      case "windows-874":
        return "windows-874";
      case "cp1250":
      case "windows-1250":
      case "x-cp1250":
        return "windows-1250";
      case "cp1251":
      case "windows-1251":
      case "x-cp1251":
        return "windows-1251";
      case "ansi_x3.4-1968":
      case "ascii":
      case "cp1252":
      case "cp819":
      case "csisolatin1":
      case "ibm819":
      case "iso-8859-1":
      case "iso-ir-100":
      case "iso8859-1":
      case "iso88591":
      case "iso_8859-1":
      case "iso_8859-1:1987":
      case "l1":
      case "latin1":
      case "us-ascii":
      case "windows-1252":
      case "x-cp1252":
        return "windows-1252";
      case "cp1253":
      case "windows-1253":
      case "x-cp1253":
        return "windows-1253";
      case "cp1254":
      case "csisolatin5":
      case "iso-8859-9":
      case "iso-ir-148":
      case "iso8859-9":
      case "iso88599":
      case "iso_8859-9":
      case "iso_8859-9:1989":
      case "l5":
      case "latin5":
      case "windows-1254":
      case "x-cp1254":
        return "windows-1254";
      case "cp1255":
      case "windows-1255":
      case "x-cp1255":
        return "windows-1255";
      case "cp1256":
      case "windows-1256":
      case "x-cp1256":
        return "windows-1256";
      case "cp1257":
      case "windows-1257":
      case "x-cp1257":
        return "windows-1257";
      case "cp1258":
      case "windows-1258":
      case "x-cp1258":
        return "windows-1258";
      case "x-mac-cyrillic":
      case "x-mac-ukrainian":
        return "x-mac-cyrillic";
      case "chinese":
      case "csgb2312":
      case "csiso58gb231280":
      case "gb2312":
      case "gb_2312":
      case "gb_2312-80":
      case "gbk":
      case "iso-ir-58":
      case "x-gbk":
        return "GBK";
      case "gb18030":
        return "gb18030";
      case "big5":
      case "big5-hkscs":
      case "cn-big5":
      case "csbig5":
      case "x-x-big5":
        return "Big5";
      case "cseucpkdfmtjapanese":
      case "euc-jp":
      case "x-euc-jp":
        return "EUC-JP";
      case "csiso2022jp":
      case "iso-2022-jp":
        return "ISO-2022-JP";
      case "csshiftjis":
      case "ms932":
      case "ms_kanji":
      case "shift-jis":
      case "shift_jis":
      case "sjis":
      case "windows-31j":
      case "x-sjis":
        return "Shift_JIS";
      case "cseuckr":
      case "csksc56011987":
      case "euc-kr":
      case "iso-ir-149":
      case "korean":
      case "ks_c_5601-1987":
      case "ks_c_5601-1989":
      case "ksc5601":
      case "ksc_5601":
      case "windows-949":
        return "EUC-KR";
      case "csiso2022kr":
      case "hz-gb-2312":
      case "iso-2022-cn":
      case "iso-2022-cn-ext":
      case "iso-2022-kr":
      case "replacement":
        return "replacement";
      case "unicodefffe":
      case "utf-16be":
        return "UTF-16BE";
      case "csunicode":
      case "iso-10646-ucs-2":
      case "ucs-2":
      case "unicode":
      case "unicodefeff":
      case "utf-16":
      case "utf-16le":
        return "UTF-16LE";
      case "x-user-defined":
        return "x-user-defined";
      default:
        return "failure";
    }
  }
  encoding = {
    getEncoding
  };
  return encoding;
}
var util$5;
var hasRequiredUtil$4;
function requireUtil$4() {
  if (hasRequiredUtil$4) return util$5;
  hasRequiredUtil$4 = 1;
  const {
    kState,
    kError: kError2,
    kResult,
    kAborted,
    kLastProgressEventFired
  } = requireSymbols$2();
  const { ProgressEvent } = requireProgressevent();
  const { getEncoding } = requireEncoding();
  const { serializeAMimeType: serializeAMimeType2, parseMIMEType: parseMIMEType2 } = requireDataUrl();
  const { types } = require$$0$2;
  const { StringDecoder } = require$$1;
  const { btoa } = require$$0$1;
  const staticPropertyDescriptors = {
    enumerable: true,
    writable: false,
    configurable: false
  };
  function readOperation(fr, blob, type, encodingName) {
    if (fr[kState] === "loading") {
      throw new DOMException("Invalid state", "InvalidStateError");
    }
    fr[kState] = "loading";
    fr[kResult] = null;
    fr[kError2] = null;
    const stream2 = blob.stream();
    const reader = stream2.getReader();
    const bytes = [];
    let chunkPromise = reader.read();
    let isFirstChunk = true;
    (async () => {
      while (!fr[kAborted]) {
        try {
          const { done, value } = await chunkPromise;
          if (isFirstChunk && !fr[kAborted]) {
            queueMicrotask(() => {
              fireAProgressEvent("loadstart", fr);
            });
          }
          isFirstChunk = false;
          if (!done && types.isUint8Array(value)) {
            bytes.push(value);
            if ((fr[kLastProgressEventFired] === void 0 || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {
              fr[kLastProgressEventFired] = Date.now();
              queueMicrotask(() => {
                fireAProgressEvent("progress", fr);
              });
            }
            chunkPromise = reader.read();
          } else if (done) {
            queueMicrotask(() => {
              fr[kState] = "done";
              try {
                const result = packageData(bytes, type, blob.type, encodingName);
                if (fr[kAborted]) {
                  return;
                }
                fr[kResult] = result;
                fireAProgressEvent("load", fr);
              } catch (error) {
                fr[kError2] = error;
                fireAProgressEvent("error", fr);
              }
              if (fr[kState] !== "loading") {
                fireAProgressEvent("loadend", fr);
              }
            });
            break;
          }
        } catch (error) {
          if (fr[kAborted]) {
            return;
          }
          queueMicrotask(() => {
            fr[kState] = "done";
            fr[kError2] = error;
            fireAProgressEvent("error", fr);
            if (fr[kState] !== "loading") {
              fireAProgressEvent("loadend", fr);
            }
          });
          break;
        }
      }
    })();
  }
  function fireAProgressEvent(e, reader) {
    const event = new ProgressEvent(e, {
      bubbles: false,
      cancelable: false
    });
    reader.dispatchEvent(event);
  }
  function packageData(bytes, type, mimeType, encodingName) {
    switch (type) {
      case "DataURL": {
        let dataURL = "data:";
        const parsed = parseMIMEType2(mimeType || "application/octet-stream");
        if (parsed !== "failure") {
          dataURL += serializeAMimeType2(parsed);
        }
        dataURL += ";base64,";
        const decoder = new StringDecoder("latin1");
        for (const chunk of bytes) {
          dataURL += btoa(decoder.write(chunk));
        }
        dataURL += btoa(decoder.end());
        return dataURL;
      }
      case "Text": {
        let encoding2 = "failure";
        if (encodingName) {
          encoding2 = getEncoding(encodingName);
        }
        if (encoding2 === "failure" && mimeType) {
          const type2 = parseMIMEType2(mimeType);
          if (type2 !== "failure") {
            encoding2 = getEncoding(type2.parameters.get("charset"));
          }
        }
        if (encoding2 === "failure") {
          encoding2 = "UTF-8";
        }
        return decode(bytes, encoding2);
      }
      case "ArrayBuffer": {
        const sequence = combineByteSequences(bytes);
        return sequence.buffer;
      }
      case "BinaryString": {
        let binaryString = "";
        const decoder = new StringDecoder("latin1");
        for (const chunk of bytes) {
          binaryString += decoder.write(chunk);
        }
        binaryString += decoder.end();
        return binaryString;
      }
    }
  }
  function decode(ioQueue, encoding2) {
    const bytes = combineByteSequences(ioQueue);
    const BOMEncoding = BOMSniffing(bytes);
    let slice = 0;
    if (BOMEncoding !== null) {
      encoding2 = BOMEncoding;
      slice = BOMEncoding === "UTF-8" ? 3 : 2;
    }
    const sliced = bytes.slice(slice);
    return new TextDecoder(encoding2).decode(sliced);
  }
  function BOMSniffing(ioQueue) {
    const [a, b, c] = ioQueue;
    if (a === 239 && b === 187 && c === 191) {
      return "UTF-8";
    } else if (a === 254 && b === 255) {
      return "UTF-16BE";
    } else if (a === 255 && b === 254) {
      return "UTF-16LE";
    }
    return null;
  }
  function combineByteSequences(sequences) {
    const size = sequences.reduce((a, b) => {
      return a + b.byteLength;
    }, 0);
    let offset = 0;
    return sequences.reduce((a, b) => {
      a.set(b, offset);
      offset += b.byteLength;
      return a;
    }, new Uint8Array(size));
  }
  util$5 = {
    staticPropertyDescriptors,
    readOperation,
    fireAProgressEvent
  };
  return util$5;
}
var filereader;
var hasRequiredFilereader;
function requireFilereader() {
  if (hasRequiredFilereader) return filereader;
  hasRequiredFilereader = 1;
  const {
    staticPropertyDescriptors,
    readOperation,
    fireAProgressEvent
  } = requireUtil$4();
  const {
    kState,
    kError: kError2,
    kResult,
    kEvents,
    kAborted
  } = requireSymbols$2();
  const { webidl } = requireWebidl();
  const { kEnumerableProperty: kEnumerableProperty2 } = util$n;
  class FileReader extends EventTarget {
    constructor() {
      super();
      this[kState] = "empty";
      this[kResult] = null;
      this[kError2] = null;
      this[kEvents] = {
        loadend: null,
        error: null,
        abort: null,
        load: null,
        progress: null,
        loadstart: null
      };
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
     * @param {import('buffer').Blob} blob
     */
    readAsArrayBuffer(blob) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, "FileReader.readAsArrayBuffer");
      blob = webidl.converters.Blob(blob, { strict: false });
      readOperation(this, blob, "ArrayBuffer");
    }
    /**
     * @see https://w3c.github.io/FileAPI/#readAsBinaryString
     * @param {import('buffer').Blob} blob
     */
    readAsBinaryString(blob) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, "FileReader.readAsBinaryString");
      blob = webidl.converters.Blob(blob, { strict: false });
      readOperation(this, blob, "BinaryString");
    }
    /**
     * @see https://w3c.github.io/FileAPI/#readAsDataText
     * @param {import('buffer').Blob} blob
     * @param {string?} encoding
     */
    readAsText(blob, encoding2 = void 0) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, "FileReader.readAsText");
      blob = webidl.converters.Blob(blob, { strict: false });
      if (encoding2 !== void 0) {
        encoding2 = webidl.converters.DOMString(encoding2, "FileReader.readAsText", "encoding");
      }
      readOperation(this, blob, "Text", encoding2);
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
     * @param {import('buffer').Blob} blob
     */
    readAsDataURL(blob) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, "FileReader.readAsDataURL");
      blob = webidl.converters.Blob(blob, { strict: false });
      readOperation(this, blob, "DataURL");
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dfn-abort
     */
    abort() {
      if (this[kState] === "empty" || this[kState] === "done") {
        this[kResult] = null;
        return;
      }
      if (this[kState] === "loading") {
        this[kState] = "done";
        this[kResult] = null;
      }
      this[kAborted] = true;
      fireAProgressEvent("abort", this);
      if (this[kState] !== "loading") {
        fireAProgressEvent("loadend", this);
      }
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
     */
    get readyState() {
      webidl.brandCheck(this, FileReader);
      switch (this[kState]) {
        case "empty":
          return this.EMPTY;
        case "loading":
          return this.LOADING;
        case "done":
          return this.DONE;
      }
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dom-filereader-result
     */
    get result() {
      webidl.brandCheck(this, FileReader);
      return this[kResult];
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dom-filereader-error
     */
    get error() {
      webidl.brandCheck(this, FileReader);
      return this[kError2];
    }
    get onloadend() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].loadend;
    }
    set onloadend(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].loadend) {
        this.removeEventListener("loadend", this[kEvents].loadend);
      }
      if (typeof fn === "function") {
        this[kEvents].loadend = fn;
        this.addEventListener("loadend", fn);
      } else {
        this[kEvents].loadend = null;
      }
    }
    get onerror() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].error;
    }
    set onerror(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].error) {
        this.removeEventListener("error", this[kEvents].error);
      }
      if (typeof fn === "function") {
        this[kEvents].error = fn;
        this.addEventListener("error", fn);
      } else {
        this[kEvents].error = null;
      }
    }
    get onloadstart() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].loadstart;
    }
    set onloadstart(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].loadstart) {
        this.removeEventListener("loadstart", this[kEvents].loadstart);
      }
      if (typeof fn === "function") {
        this[kEvents].loadstart = fn;
        this.addEventListener("loadstart", fn);
      } else {
        this[kEvents].loadstart = null;
      }
    }
    get onprogress() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].progress;
    }
    set onprogress(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].progress) {
        this.removeEventListener("progress", this[kEvents].progress);
      }
      if (typeof fn === "function") {
        this[kEvents].progress = fn;
        this.addEventListener("progress", fn);
      } else {
        this[kEvents].progress = null;
      }
    }
    get onload() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].load;
    }
    set onload(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].load) {
        this.removeEventListener("load", this[kEvents].load);
      }
      if (typeof fn === "function") {
        this[kEvents].load = fn;
        this.addEventListener("load", fn);
      } else {
        this[kEvents].load = null;
      }
    }
    get onabort() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].abort;
    }
    set onabort(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].abort) {
        this.removeEventListener("abort", this[kEvents].abort);
      }
      if (typeof fn === "function") {
        this[kEvents].abort = fn;
        this.addEventListener("abort", fn);
      } else {
        this[kEvents].abort = null;
      }
    }
  }
  FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
  FileReader.LOADING = FileReader.prototype.LOADING = 1;
  FileReader.DONE = FileReader.prototype.DONE = 2;
  Object.defineProperties(FileReader.prototype, {
    EMPTY: staticPropertyDescriptors,
    LOADING: staticPropertyDescriptors,
    DONE: staticPropertyDescriptors,
    readAsArrayBuffer: kEnumerableProperty2,
    readAsBinaryString: kEnumerableProperty2,
    readAsText: kEnumerableProperty2,
    readAsDataURL: kEnumerableProperty2,
    abort: kEnumerableProperty2,
    readyState: kEnumerableProperty2,
    result: kEnumerableProperty2,
    error: kEnumerableProperty2,
    onloadstart: kEnumerableProperty2,
    onprogress: kEnumerableProperty2,
    onload: kEnumerableProperty2,
    onabort: kEnumerableProperty2,
    onerror: kEnumerableProperty2,
    onloadend: kEnumerableProperty2,
    [Symbol.toStringTag]: {
      value: "FileReader",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  Object.defineProperties(FileReader, {
    EMPTY: staticPropertyDescriptors,
    LOADING: staticPropertyDescriptors,
    DONE: staticPropertyDescriptors
  });
  filereader = {
    FileReader
  };
  return filereader;
}
var symbols$1;
var hasRequiredSymbols$1;
function requireSymbols$1() {
  if (hasRequiredSymbols$1) return symbols$1;
  hasRequiredSymbols$1 = 1;
  symbols$1 = {
    kConstruct: symbols$4.kConstruct
  };
  return symbols$1;
}
var util$4;
var hasRequiredUtil$3;
function requireUtil$3() {
  if (hasRequiredUtil$3) return util$4;
  hasRequiredUtil$3 = 1;
  const assert2 = require$$0$3;
  const { URLSerializer } = requireDataUrl();
  const { isValidHeaderName } = requireUtil$5();
  function urlEquals(A, B, excludeFragment = false) {
    const serializedA = URLSerializer(A, excludeFragment);
    const serializedB = URLSerializer(B, excludeFragment);
    return serializedA === serializedB;
  }
  function getFieldValues(header) {
    assert2(header !== null);
    const values = [];
    for (let value of header.split(",")) {
      value = value.trim();
      if (isValidHeaderName(value)) {
        values.push(value);
      }
    }
    return values;
  }
  util$4 = {
    urlEquals,
    getFieldValues
  };
  return util$4;
}
var cache$1;
var hasRequiredCache;
function requireCache() {
  var _relevantRequestResponseList, _Cache_instances, batchCacheOperations_fn, queryCache_fn, requestMatchesCachedItem_fn, internalMatchAll_fn;
  if (hasRequiredCache) return cache$1;
  hasRequiredCache = 1;
  const { kConstruct: kConstruct2 } = requireSymbols$1();
  const { urlEquals, getFieldValues } = requireUtil$3();
  const { kEnumerableProperty: kEnumerableProperty2, isDisturbed: isDisturbed2 } = util$n;
  const { webidl } = requireWebidl();
  const { Response, cloneResponse, fromInnerResponse } = requireResponse();
  const { Request: Request4, fromInnerRequest } = requireRequest();
  const { kState } = requireSymbols$3();
  const { fetching } = requireFetch();
  const { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = requireUtil$5();
  const assert2 = require$$0$3;
  const _Cache = class _Cache {
    constructor() {
      __privateAdd(this, _Cache_instances);
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
       * @type {requestResponseList}
       */
      __privateAdd(this, _relevantRequestResponseList);
      if (arguments[0] !== kConstruct2) {
        webidl.illegalConstructor();
      }
      webidl.util.markAsUncloneable(this);
      __privateSet(this, _relevantRequestResponseList, arguments[1]);
    }
    async match(request2, options = {}) {
      webidl.brandCheck(this, _Cache);
      const prefix = "Cache.match";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      request2 = webidl.converters.RequestInfo(request2, prefix, "request");
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      const p = __privateMethod(this, _Cache_instances, internalMatchAll_fn).call(this, request2, options, 1);
      if (p.length === 0) {
        return;
      }
      return p[0];
    }
    async matchAll(request2 = void 0, options = {}) {
      webidl.brandCheck(this, _Cache);
      const prefix = "Cache.matchAll";
      if (request2 !== void 0) request2 = webidl.converters.RequestInfo(request2, prefix, "request");
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      return __privateMethod(this, _Cache_instances, internalMatchAll_fn).call(this, request2, options);
    }
    async add(request2) {
      webidl.brandCheck(this, _Cache);
      const prefix = "Cache.add";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      request2 = webidl.converters.RequestInfo(request2, prefix, "request");
      const requests = [request2];
      const responseArrayPromise = this.addAll(requests);
      return await responseArrayPromise;
    }
    async addAll(requests) {
      webidl.brandCheck(this, _Cache);
      const prefix = "Cache.addAll";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      const responsePromises = [];
      const requestList = [];
      for (let request2 of requests) {
        if (request2 === void 0) {
          throw webidl.errors.conversionFailed({
            prefix,
            argument: "Argument 1",
            types: ["undefined is not allowed"]
          });
        }
        request2 = webidl.converters.RequestInfo(request2);
        if (typeof request2 === "string") {
          continue;
        }
        const r = request2[kState];
        if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
          throw webidl.errors.exception({
            header: prefix,
            message: "Expected http/s scheme when method is not GET."
          });
        }
      }
      const fetchControllers = [];
      for (const request2 of requests) {
        const r = new Request4(request2)[kState];
        if (!urlIsHttpHttpsScheme(r.url)) {
          throw webidl.errors.exception({
            header: prefix,
            message: "Expected http/s scheme."
          });
        }
        r.initiator = "fetch";
        r.destination = "subresource";
        requestList.push(r);
        const responsePromise = createDeferredPromise();
        fetchControllers.push(fetching({
          request: r,
          processResponse(response2) {
            if (response2.type === "error" || response2.status === 206 || response2.status < 200 || response2.status > 299) {
              responsePromise.reject(webidl.errors.exception({
                header: "Cache.addAll",
                message: "Received an invalid status code or the request failed."
              }));
            } else if (response2.headersList.contains("vary")) {
              const fieldValues = getFieldValues(response2.headersList.get("vary"));
              for (const fieldValue of fieldValues) {
                if (fieldValue === "*") {
                  responsePromise.reject(webidl.errors.exception({
                    header: "Cache.addAll",
                    message: "invalid vary field value"
                  }));
                  for (const controller of fetchControllers) {
                    controller.abort();
                  }
                  return;
                }
              }
            }
          },
          processResponseEndOfBody(response2) {
            if (response2.aborted) {
              responsePromise.reject(new DOMException("aborted", "AbortError"));
              return;
            }
            responsePromise.resolve(response2);
          }
        }));
        responsePromises.push(responsePromise.promise);
      }
      const p = Promise.all(responsePromises);
      const responses = await p;
      const operations = [];
      let index = 0;
      for (const response2 of responses) {
        const operation = {
          type: "put",
          // 7.3.2
          request: requestList[index],
          // 7.3.3
          response: response2
          // 7.3.4
        };
        operations.push(operation);
        index++;
      }
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      try {
        __privateMethod(this, _Cache_instances, batchCacheOperations_fn).call(this, operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve(void 0);
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async put(request2, response2) {
      webidl.brandCheck(this, _Cache);
      const prefix = "Cache.put";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      request2 = webidl.converters.RequestInfo(request2, prefix, "request");
      response2 = webidl.converters.Response(response2, prefix, "response");
      let innerRequest = null;
      if (request2 instanceof Request4) {
        innerRequest = request2[kState];
      } else {
        innerRequest = new Request4(request2)[kState];
      }
      if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
        throw webidl.errors.exception({
          header: prefix,
          message: "Expected an http/s scheme when method is not GET"
        });
      }
      const innerResponse = response2[kState];
      if (innerResponse.status === 206) {
        throw webidl.errors.exception({
          header: prefix,
          message: "Got 206 status"
        });
      }
      if (innerResponse.headersList.contains("vary")) {
        const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
        for (const fieldValue of fieldValues) {
          if (fieldValue === "*") {
            throw webidl.errors.exception({
              header: prefix,
              message: "Got * vary field value"
            });
          }
        }
      }
      if (innerResponse.body && (isDisturbed2(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
        throw webidl.errors.exception({
          header: prefix,
          message: "Response body is locked or disturbed"
        });
      }
      const clonedResponse = cloneResponse(innerResponse);
      const bodyReadPromise = createDeferredPromise();
      if (innerResponse.body != null) {
        const stream2 = innerResponse.body.stream;
        const reader = stream2.getReader();
        readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
      } else {
        bodyReadPromise.resolve(void 0);
      }
      const operations = [];
      const operation = {
        type: "put",
        // 14.
        request: innerRequest,
        // 15.
        response: clonedResponse
        // 16.
      };
      operations.push(operation);
      const bytes = await bodyReadPromise.promise;
      if (clonedResponse.body != null) {
        clonedResponse.body.source = bytes;
      }
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      try {
        __privateMethod(this, _Cache_instances, batchCacheOperations_fn).call(this, operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve();
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async delete(request2, options = {}) {
      webidl.brandCheck(this, _Cache);
      const prefix = "Cache.delete";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      request2 = webidl.converters.RequestInfo(request2, prefix, "request");
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      let r = null;
      if (request2 instanceof Request4) {
        r = request2[kState];
        if (r.method !== "GET" && !options.ignoreMethod) {
          return false;
        }
      } else {
        assert2(typeof request2 === "string");
        r = new Request4(request2)[kState];
      }
      const operations = [];
      const operation = {
        type: "delete",
        request: r,
        options
      };
      operations.push(operation);
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      let requestResponses;
      try {
        requestResponses = __privateMethod(this, _Cache_instances, batchCacheOperations_fn).call(this, operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve(!!(requestResponses == null ? void 0 : requestResponses.length));
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
     * @param {any} request
     * @param {import('../../types/cache').CacheQueryOptions} options
     * @returns {Promise<readonly Request[]>}
     */
    async keys(request2 = void 0, options = {}) {
      webidl.brandCheck(this, _Cache);
      const prefix = "Cache.keys";
      if (request2 !== void 0) request2 = webidl.converters.RequestInfo(request2, prefix, "request");
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      let r = null;
      if (request2 !== void 0) {
        if (request2 instanceof Request4) {
          r = request2[kState];
          if (r.method !== "GET" && !options.ignoreMethod) {
            return [];
          }
        } else if (typeof request2 === "string") {
          r = new Request4(request2)[kState];
        }
      }
      const promise = createDeferredPromise();
      const requests = [];
      if (request2 === void 0) {
        for (const requestResponse of __privateGet(this, _relevantRequestResponseList)) {
          requests.push(requestResponse[0]);
        }
      } else {
        const requestResponses = __privateMethod(this, _Cache_instances, queryCache_fn).call(this, r, options);
        for (const requestResponse of requestResponses) {
          requests.push(requestResponse[0]);
        }
      }
      queueMicrotask(() => {
        const requestList = [];
        for (const request3 of requests) {
          const requestObject = fromInnerRequest(
            request3,
            new AbortController().signal,
            "immutable"
          );
          requestList.push(requestObject);
        }
        promise.resolve(Object.freeze(requestList));
      });
      return promise.promise;
    }
  };
  _relevantRequestResponseList = new WeakMap();
  _Cache_instances = new WeakSet();
  /**
   * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
   * @param {CacheBatchOperation[]} operations
   * @returns {requestResponseList}
   */
  batchCacheOperations_fn = function(operations) {
    const cache2 = __privateGet(this, _relevantRequestResponseList);
    const backupCache = [...cache2];
    const addedItems = [];
    const resultList = [];
    try {
      for (const operation of operations) {
        if (operation.type !== "delete" && operation.type !== "put") {
          throw webidl.errors.exception({
            header: "Cache.#batchCacheOperations",
            message: 'operation type does not match "delete" or "put"'
          });
        }
        if (operation.type === "delete" && operation.response != null) {
          throw webidl.errors.exception({
            header: "Cache.#batchCacheOperations",
            message: "delete operation should not have an associated response"
          });
        }
        if (__privateMethod(this, _Cache_instances, queryCache_fn).call(this, operation.request, operation.options, addedItems).length) {
          throw new DOMException("???", "InvalidStateError");
        }
        let requestResponses;
        if (operation.type === "delete") {
          requestResponses = __privateMethod(this, _Cache_instances, queryCache_fn).call(this, operation.request, operation.options);
          if (requestResponses.length === 0) {
            return [];
          }
          for (const requestResponse of requestResponses) {
            const idx = cache2.indexOf(requestResponse);
            assert2(idx !== -1);
            cache2.splice(idx, 1);
          }
        } else if (operation.type === "put") {
          if (operation.response == null) {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "put operation should have an associated response"
            });
          }
          const r = operation.request;
          if (!urlIsHttpHttpsScheme(r.url)) {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "expected http or https scheme"
            });
          }
          if (r.method !== "GET") {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "not get method"
            });
          }
          if (operation.options != null) {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "options must not be defined"
            });
          }
          requestResponses = __privateMethod(this, _Cache_instances, queryCache_fn).call(this, operation.request);
          for (const requestResponse of requestResponses) {
            const idx = cache2.indexOf(requestResponse);
            assert2(idx !== -1);
            cache2.splice(idx, 1);
          }
          cache2.push([operation.request, operation.response]);
          addedItems.push([operation.request, operation.response]);
        }
        resultList.push([operation.request, operation.response]);
      }
      return resultList;
    } catch (e) {
      __privateGet(this, _relevantRequestResponseList).length = 0;
      __privateSet(this, _relevantRequestResponseList, backupCache);
      throw e;
    }
  };
  /**
   * @see https://w3c.github.io/ServiceWorker/#query-cache
   * @param {any} requestQuery
   * @param {import('../../types/cache').CacheQueryOptions} options
   * @param {requestResponseList} targetStorage
   * @returns {requestResponseList}
   */
  queryCache_fn = function(requestQuery, options, targetStorage) {
    const resultList = [];
    const storage = targetStorage ?? __privateGet(this, _relevantRequestResponseList);
    for (const requestResponse of storage) {
      const [cachedRequest, cachedResponse] = requestResponse;
      if (__privateMethod(this, _Cache_instances, requestMatchesCachedItem_fn).call(this, requestQuery, cachedRequest, cachedResponse, options)) {
        resultList.push(requestResponse);
      }
    }
    return resultList;
  };
  /**
   * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
   * @param {any} requestQuery
   * @param {any} request
   * @param {any | null} response
   * @param {import('../../types/cache').CacheQueryOptions | undefined} options
   * @returns {boolean}
   */
  requestMatchesCachedItem_fn = function(requestQuery, request2, response2 = null, options) {
    const queryURL = new URL(requestQuery.url);
    const cachedURL = new URL(request2.url);
    if (options == null ? void 0 : options.ignoreSearch) {
      cachedURL.search = "";
      queryURL.search = "";
    }
    if (!urlEquals(queryURL, cachedURL, true)) {
      return false;
    }
    if (response2 == null || (options == null ? void 0 : options.ignoreVary) || !response2.headersList.contains("vary")) {
      return true;
    }
    const fieldValues = getFieldValues(response2.headersList.get("vary"));
    for (const fieldValue of fieldValues) {
      if (fieldValue === "*") {
        return false;
      }
      const requestValue = request2.headersList.get(fieldValue);
      const queryValue = requestQuery.headersList.get(fieldValue);
      if (requestValue !== queryValue) {
        return false;
      }
    }
    return true;
  };
  internalMatchAll_fn = function(request2, options, maxResponses = Infinity) {
    let r = null;
    if (request2 !== void 0) {
      if (request2 instanceof Request4) {
        r = request2[kState];
        if (r.method !== "GET" && !options.ignoreMethod) {
          return [];
        }
      } else if (typeof request2 === "string") {
        r = new Request4(request2)[kState];
      }
    }
    const responses = [];
    if (request2 === void 0) {
      for (const requestResponse of __privateGet(this, _relevantRequestResponseList)) {
        responses.push(requestResponse[1]);
      }
    } else {
      const requestResponses = __privateMethod(this, _Cache_instances, queryCache_fn).call(this, r, options);
      for (const requestResponse of requestResponses) {
        responses.push(requestResponse[1]);
      }
    }
    const responseList = [];
    for (const response2 of responses) {
      const responseObject = fromInnerResponse(response2, "immutable");
      responseList.push(responseObject.clone());
      if (responseList.length >= maxResponses) {
        break;
      }
    }
    return Object.freeze(responseList);
  };
  let Cache2 = _Cache;
  Object.defineProperties(Cache2.prototype, {
    [Symbol.toStringTag]: {
      value: "Cache",
      configurable: true
    },
    match: kEnumerableProperty2,
    matchAll: kEnumerableProperty2,
    add: kEnumerableProperty2,
    addAll: kEnumerableProperty2,
    put: kEnumerableProperty2,
    delete: kEnumerableProperty2,
    keys: kEnumerableProperty2
  });
  const cacheQueryOptionConverters = [
    {
      key: "ignoreSearch",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "ignoreMethod",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "ignoreVary",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    }
  ];
  webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
  webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
    ...cacheQueryOptionConverters,
    {
      key: "cacheName",
      converter: webidl.converters.DOMString
    }
  ]);
  webidl.converters.Response = webidl.interfaceConverter(Response);
  webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(
    webidl.converters.RequestInfo
  );
  cache$1 = {
    Cache: Cache2
  };
  return cache$1;
}
var cachestorage;
var hasRequiredCachestorage;
function requireCachestorage() {
  var _caches;
  if (hasRequiredCachestorage) return cachestorage;
  hasRequiredCachestorage = 1;
  const { kConstruct: kConstruct2 } = requireSymbols$1();
  const { Cache: Cache2 } = requireCache();
  const { webidl } = requireWebidl();
  const { kEnumerableProperty: kEnumerableProperty2 } = util$n;
  const _CacheStorage = class _CacheStorage {
    constructor() {
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
       * @type {Map<string, import('./cache').requestResponseList}
       */
      __privateAdd(this, _caches, /* @__PURE__ */ new Map());
      if (arguments[0] !== kConstruct2) {
        webidl.illegalConstructor();
      }
      webidl.util.markAsUncloneable(this);
    }
    async match(request2, options = {}) {
      webidl.brandCheck(this, _CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, "CacheStorage.match");
      request2 = webidl.converters.RequestInfo(request2);
      options = webidl.converters.MultiCacheQueryOptions(options);
      if (options.cacheName != null) {
        if (__privateGet(this, _caches).has(options.cacheName)) {
          const cacheList = __privateGet(this, _caches).get(options.cacheName);
          const cache2 = new Cache2(kConstruct2, cacheList);
          return await cache2.match(request2, options);
        }
      } else {
        for (const cacheList of __privateGet(this, _caches).values()) {
          const cache2 = new Cache2(kConstruct2, cacheList);
          const response2 = await cache2.match(request2, options);
          if (response2 !== void 0) {
            return response2;
          }
        }
      }
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
     * @param {string} cacheName
     * @returns {Promise<boolean>}
     */
    async has(cacheName) {
      webidl.brandCheck(this, _CacheStorage);
      const prefix = "CacheStorage.has";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
      return __privateGet(this, _caches).has(cacheName);
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
     * @param {string} cacheName
     * @returns {Promise<Cache>}
     */
    async open(cacheName) {
      webidl.brandCheck(this, _CacheStorage);
      const prefix = "CacheStorage.open";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
      if (__privateGet(this, _caches).has(cacheName)) {
        const cache3 = __privateGet(this, _caches).get(cacheName);
        return new Cache2(kConstruct2, cache3);
      }
      const cache2 = [];
      __privateGet(this, _caches).set(cacheName, cache2);
      return new Cache2(kConstruct2, cache2);
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
     * @param {string} cacheName
     * @returns {Promise<boolean>}
     */
    async delete(cacheName) {
      webidl.brandCheck(this, _CacheStorage);
      const prefix = "CacheStorage.delete";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
      return __privateGet(this, _caches).delete(cacheName);
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
     * @returns {Promise<string[]>}
     */
    async keys() {
      webidl.brandCheck(this, _CacheStorage);
      const keys = __privateGet(this, _caches).keys();
      return [...keys];
    }
  };
  _caches = new WeakMap();
  let CacheStorage2 = _CacheStorage;
  Object.defineProperties(CacheStorage2.prototype, {
    [Symbol.toStringTag]: {
      value: "CacheStorage",
      configurable: true
    },
    match: kEnumerableProperty2,
    has: kEnumerableProperty2,
    open: kEnumerableProperty2,
    delete: kEnumerableProperty2,
    keys: kEnumerableProperty2
  });
  cachestorage = {
    CacheStorage: CacheStorage2
  };
  return cachestorage;
}
var constants$1;
var hasRequiredConstants$1;
function requireConstants$1() {
  if (hasRequiredConstants$1) return constants$1;
  hasRequiredConstants$1 = 1;
  const maxAttributeValueSize = 1024;
  const maxNameValuePairSize = 4096;
  constants$1 = {
    maxAttributeValueSize,
    maxNameValuePairSize
  };
  return constants$1;
}
var util$3;
var hasRequiredUtil$2;
function requireUtil$2() {
  if (hasRequiredUtil$2) return util$3;
  hasRequiredUtil$2 = 1;
  function isCTLExcludingHtab(value) {
    for (let i = 0; i < value.length; ++i) {
      const code = value.charCodeAt(i);
      if (code >= 0 && code <= 8 || code >= 10 && code <= 31 || code === 127) {
        return true;
      }
    }
    return false;
  }
  function validateCookieName(name) {
    for (let i = 0; i < name.length; ++i) {
      const code = name.charCodeAt(i);
      if (code < 33 || // exclude CTLs (0-31), SP and HT
      code > 126 || // exclude non-ascii and DEL
      code === 34 || // "
      code === 40 || // (
      code === 41 || // )
      code === 60 || // <
      code === 62 || // >
      code === 64 || // @
      code === 44 || // ,
      code === 59 || // ;
      code === 58 || // :
      code === 92 || // \
      code === 47 || // /
      code === 91 || // [
      code === 93 || // ]
      code === 63 || // ?
      code === 61 || // =
      code === 123 || // {
      code === 125) {
        throw new Error("Invalid cookie name");
      }
    }
  }
  function validateCookieValue(value) {
    let len = value.length;
    let i = 0;
    if (value[0] === '"') {
      if (len === 1 || value[len - 1] !== '"') {
        throw new Error("Invalid cookie value");
      }
      --len;
      ++i;
    }
    while (i < len) {
      const code = value.charCodeAt(i++);
      if (code < 33 || // exclude CTLs (0-31)
      code > 126 || // non-ascii and DEL (127)
      code === 34 || // "
      code === 44 || // ,
      code === 59 || // ;
      code === 92) {
        throw new Error("Invalid cookie value");
      }
    }
  }
  function validateCookiePath(path2) {
    for (let i = 0; i < path2.length; ++i) {
      const code = path2.charCodeAt(i);
      if (code < 32 || // exclude CTLs (0-31)
      code === 127 || // DEL
      code === 59) {
        throw new Error("Invalid cookie path");
      }
    }
  }
  function validateCookieDomain(domain) {
    if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
      throw new Error("Invalid cookie domain");
    }
  }
  const IMFDays = [
    "Sun",
    "Mon",
    "Tue",
    "Wed",
    "Thu",
    "Fri",
    "Sat"
  ];
  const IMFMonths = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  const IMFPaddedNumbers = Array(61).fill(0).map((_, i) => i.toString().padStart(2, "0"));
  function toIMFDate(date2) {
    if (typeof date2 === "number") {
      date2 = new Date(date2);
    }
    return `${IMFDays[date2.getUTCDay()]}, ${IMFPaddedNumbers[date2.getUTCDate()]} ${IMFMonths[date2.getUTCMonth()]} ${date2.getUTCFullYear()} ${IMFPaddedNumbers[date2.getUTCHours()]}:${IMFPaddedNumbers[date2.getUTCMinutes()]}:${IMFPaddedNumbers[date2.getUTCSeconds()]} GMT`;
  }
  function validateCookieMaxAge(maxAge) {
    if (maxAge < 0) {
      throw new Error("Invalid cookie max-age");
    }
  }
  function stringify2(cookie2) {
    if (cookie2.name.length === 0) {
      return null;
    }
    validateCookieName(cookie2.name);
    validateCookieValue(cookie2.value);
    const out = [`${cookie2.name}=${cookie2.value}`];
    if (cookie2.name.startsWith("__Secure-")) {
      cookie2.secure = true;
    }
    if (cookie2.name.startsWith("__Host-")) {
      cookie2.secure = true;
      cookie2.domain = null;
      cookie2.path = "/";
    }
    if (cookie2.secure) {
      out.push("Secure");
    }
    if (cookie2.httpOnly) {
      out.push("HttpOnly");
    }
    if (typeof cookie2.maxAge === "number") {
      validateCookieMaxAge(cookie2.maxAge);
      out.push(`Max-Age=${cookie2.maxAge}`);
    }
    if (cookie2.domain) {
      validateCookieDomain(cookie2.domain);
      out.push(`Domain=${cookie2.domain}`);
    }
    if (cookie2.path) {
      validateCookiePath(cookie2.path);
      out.push(`Path=${cookie2.path}`);
    }
    if (cookie2.expires && cookie2.expires.toString() !== "Invalid Date") {
      out.push(`Expires=${toIMFDate(cookie2.expires)}`);
    }
    if (cookie2.sameSite) {
      out.push(`SameSite=${cookie2.sameSite}`);
    }
    for (const part of cookie2.unparsed) {
      if (!part.includes("=")) {
        throw new Error("Invalid unparsed");
      }
      const [key, ...value] = part.split("=");
      out.push(`${key.trim()}=${value.join("=")}`);
    }
    return out.join("; ");
  }
  util$3 = {
    isCTLExcludingHtab,
    validateCookieName,
    validateCookiePath,
    validateCookieValue,
    toIMFDate,
    stringify: stringify2
  };
  return util$3;
}
var parse;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse;
  hasRequiredParse = 1;
  const { maxNameValuePairSize, maxAttributeValueSize } = requireConstants$1();
  const { isCTLExcludingHtab } = requireUtil$2();
  const { collectASequenceOfCodePointsFast } = requireDataUrl();
  const assert2 = require$$0$3;
  function parseSetCookie(header) {
    if (isCTLExcludingHtab(header)) {
      return null;
    }
    let nameValuePair = "";
    let unparsedAttributes = "";
    let name = "";
    let value = "";
    if (header.includes(";")) {
      const position = { position: 0 };
      nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
      unparsedAttributes = header.slice(position.position);
    } else {
      nameValuePair = header;
    }
    if (!nameValuePair.includes("=")) {
      value = nameValuePair;
    } else {
      const position = { position: 0 };
      name = collectASequenceOfCodePointsFast(
        "=",
        nameValuePair,
        position
      );
      value = nameValuePair.slice(position.position + 1);
    }
    name = name.trim();
    value = value.trim();
    if (name.length + value.length > maxNameValuePairSize) {
      return null;
    }
    return {
      name,
      value,
      ...parseUnparsedAttributes(unparsedAttributes)
    };
  }
  function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
    if (unparsedAttributes.length === 0) {
      return cookieAttributeList;
    }
    assert2(unparsedAttributes[0] === ";");
    unparsedAttributes = unparsedAttributes.slice(1);
    let cookieAv = "";
    if (unparsedAttributes.includes(";")) {
      cookieAv = collectASequenceOfCodePointsFast(
        ";",
        unparsedAttributes,
        { position: 0 }
      );
      unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
    } else {
      cookieAv = unparsedAttributes;
      unparsedAttributes = "";
    }
    let attributeName = "";
    let attributeValue = "";
    if (cookieAv.includes("=")) {
      const position = { position: 0 };
      attributeName = collectASequenceOfCodePointsFast(
        "=",
        cookieAv,
        position
      );
      attributeValue = cookieAv.slice(position.position + 1);
    } else {
      attributeName = cookieAv;
    }
    attributeName = attributeName.trim();
    attributeValue = attributeValue.trim();
    if (attributeValue.length > maxAttributeValueSize) {
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    const attributeNameLowercase = attributeName.toLowerCase();
    if (attributeNameLowercase === "expires") {
      const expiryTime = new Date(attributeValue);
      cookieAttributeList.expires = expiryTime;
    } else if (attributeNameLowercase === "max-age") {
      const charCode = attributeValue.charCodeAt(0);
      if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      if (!/^\d+$/.test(attributeValue)) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const deltaSeconds = Number(attributeValue);
      cookieAttributeList.maxAge = deltaSeconds;
    } else if (attributeNameLowercase === "domain") {
      let cookieDomain = attributeValue;
      if (cookieDomain[0] === ".") {
        cookieDomain = cookieDomain.slice(1);
      }
      cookieDomain = cookieDomain.toLowerCase();
      cookieAttributeList.domain = cookieDomain;
    } else if (attributeNameLowercase === "path") {
      let cookiePath = "";
      if (attributeValue.length === 0 || attributeValue[0] !== "/") {
        cookiePath = "/";
      } else {
        cookiePath = attributeValue;
      }
      cookieAttributeList.path = cookiePath;
    } else if (attributeNameLowercase === "secure") {
      cookieAttributeList.secure = true;
    } else if (attributeNameLowercase === "httponly") {
      cookieAttributeList.httpOnly = true;
    } else if (attributeNameLowercase === "samesite") {
      let enforcement = "Default";
      const attributeValueLowercase = attributeValue.toLowerCase();
      if (attributeValueLowercase.includes("none")) {
        enforcement = "None";
      }
      if (attributeValueLowercase.includes("strict")) {
        enforcement = "Strict";
      }
      if (attributeValueLowercase.includes("lax")) {
        enforcement = "Lax";
      }
      cookieAttributeList.sameSite = enforcement;
    } else {
      cookieAttributeList.unparsed ?? (cookieAttributeList.unparsed = []);
      cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
    }
    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
  }
  parse = {
    parseSetCookie,
    parseUnparsedAttributes
  };
  return parse;
}
var cookies;
var hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies) return cookies;
  hasRequiredCookies = 1;
  const { parseSetCookie } = requireParse();
  const { stringify: stringify2 } = requireUtil$2();
  const { webidl } = requireWebidl();
  const { Headers } = requireHeaders();
  function getCookies2(headers2) {
    webidl.argumentLengthCheck(arguments, 1, "getCookies");
    webidl.brandCheck(headers2, Headers, { strict: false });
    const cookie2 = headers2.get("cookie");
    const out = {};
    if (!cookie2) {
      return out;
    }
    for (const piece of cookie2.split(";")) {
      const [name, ...value] = piece.split("=");
      out[name.trim()] = value.join("=");
    }
    return out;
  }
  function deleteCookie2(headers2, name, attributes) {
    webidl.brandCheck(headers2, Headers, { strict: false });
    const prefix = "deleteCookie";
    webidl.argumentLengthCheck(arguments, 2, prefix);
    name = webidl.converters.DOMString(name, prefix, "name");
    attributes = webidl.converters.DeleteCookieAttributes(attributes);
    setCookie2(headers2, {
      name,
      value: "",
      expires: /* @__PURE__ */ new Date(0),
      ...attributes
    });
  }
  function getSetCookies2(headers2) {
    webidl.argumentLengthCheck(arguments, 1, "getSetCookies");
    webidl.brandCheck(headers2, Headers, { strict: false });
    const cookies2 = headers2.getSetCookie();
    if (!cookies2) {
      return [];
    }
    return cookies2.map((pair) => parseSetCookie(pair));
  }
  function setCookie2(headers2, cookie2) {
    webidl.argumentLengthCheck(arguments, 2, "setCookie");
    webidl.brandCheck(headers2, Headers, { strict: false });
    cookie2 = webidl.converters.Cookie(cookie2);
    const str = stringify2(cookie2);
    if (str) {
      headers2.append("Set-Cookie", str);
    }
  }
  webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: () => null
    }
  ]);
  webidl.converters.Cookie = webidl.dictionaryConverter([
    {
      converter: webidl.converters.DOMString,
      key: "name"
    },
    {
      converter: webidl.converters.DOMString,
      key: "value"
    },
    {
      converter: webidl.nullableConverter((value) => {
        if (typeof value === "number") {
          return webidl.converters["unsigned long long"](value);
        }
        return new Date(value);
      }),
      key: "expires",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters["long long"]),
      key: "maxAge",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "secure",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "httpOnly",
      defaultValue: () => null
    },
    {
      converter: webidl.converters.USVString,
      key: "sameSite",
      allowedValues: ["Strict", "Lax", "None"]
    },
    {
      converter: webidl.sequenceConverter(webidl.converters.DOMString),
      key: "unparsed",
      defaultValue: () => new Array(0)
    }
  ]);
  cookies = {
    getCookies: getCookies2,
    deleteCookie: deleteCookie2,
    getSetCookies: getSetCookies2,
    setCookie: setCookie2
  };
  return cookies;
}
var events;
var hasRequiredEvents;
function requireEvents() {
  var _eventInit, _eventInit2, _eventInit3;
  if (hasRequiredEvents) return events;
  hasRequiredEvents = 1;
  const { webidl } = requireWebidl();
  const { kEnumerableProperty: kEnumerableProperty2 } = util$n;
  const { kConstruct: kConstruct2 } = symbols$4;
  const { MessagePort: MessagePort2 } = require$$1$1;
  const _MessageEvent = class _MessageEvent extends Event {
    constructor(type, eventInitDict = {}) {
      var __super = (...args) => {
        super(...args);
        __privateAdd(this, _eventInit);
        return this;
      };
      if (type === kConstruct2) {
        __super(arguments[1], arguments[2]);
        webidl.util.markAsUncloneable(this);
        return;
      }
      const prefix = "MessageEvent constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      type = webidl.converters.DOMString(type, prefix, "type");
      eventInitDict = webidl.converters.MessageEventInit(eventInitDict, prefix, "eventInitDict");
      __super(type, eventInitDict);
      __privateSet(this, _eventInit, eventInitDict);
      webidl.util.markAsUncloneable(this);
    }
    get data() {
      webidl.brandCheck(this, _MessageEvent);
      return __privateGet(this, _eventInit).data;
    }
    get origin() {
      webidl.brandCheck(this, _MessageEvent);
      return __privateGet(this, _eventInit).origin;
    }
    get lastEventId() {
      webidl.brandCheck(this, _MessageEvent);
      return __privateGet(this, _eventInit).lastEventId;
    }
    get source() {
      webidl.brandCheck(this, _MessageEvent);
      return __privateGet(this, _eventInit).source;
    }
    get ports() {
      webidl.brandCheck(this, _MessageEvent);
      if (!Object.isFrozen(__privateGet(this, _eventInit).ports)) {
        Object.freeze(__privateGet(this, _eventInit).ports);
      }
      return __privateGet(this, _eventInit).ports;
    }
    initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
      webidl.brandCheck(this, _MessageEvent);
      webidl.argumentLengthCheck(arguments, 1, "MessageEvent.initMessageEvent");
      return new _MessageEvent(type, {
        bubbles,
        cancelable,
        data,
        origin,
        lastEventId,
        source,
        ports
      });
    }
    static createFastMessageEvent(type, init) {
      var _a2, _b2, _c2, _d2, _e2;
      const messageEvent = new _MessageEvent(kConstruct2, type, init);
      __privateSet(messageEvent, _eventInit, init);
      (_a2 = __privateGet(messageEvent, _eventInit)).data ?? (_a2.data = null);
      (_b2 = __privateGet(messageEvent, _eventInit)).origin ?? (_b2.origin = "");
      (_c2 = __privateGet(messageEvent, _eventInit)).lastEventId ?? (_c2.lastEventId = "");
      (_d2 = __privateGet(messageEvent, _eventInit)).source ?? (_d2.source = null);
      (_e2 = __privateGet(messageEvent, _eventInit)).ports ?? (_e2.ports = []);
      return messageEvent;
    }
  };
  _eventInit = new WeakMap();
  let MessageEvent2 = _MessageEvent;
  const { createFastMessageEvent } = MessageEvent2;
  delete MessageEvent2.createFastMessageEvent;
  const _CloseEvent = class _CloseEvent extends Event {
    constructor(type, eventInitDict = {}) {
      const prefix = "CloseEvent constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      type = webidl.converters.DOMString(type, prefix, "type");
      eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
      super(type, eventInitDict);
      __privateAdd(this, _eventInit2);
      __privateSet(this, _eventInit2, eventInitDict);
      webidl.util.markAsUncloneable(this);
    }
    get wasClean() {
      webidl.brandCheck(this, _CloseEvent);
      return __privateGet(this, _eventInit2).wasClean;
    }
    get code() {
      webidl.brandCheck(this, _CloseEvent);
      return __privateGet(this, _eventInit2).code;
    }
    get reason() {
      webidl.brandCheck(this, _CloseEvent);
      return __privateGet(this, _eventInit2).reason;
    }
  };
  _eventInit2 = new WeakMap();
  let CloseEvent2 = _CloseEvent;
  const _ErrorEvent = class _ErrorEvent extends Event {
    constructor(type, eventInitDict) {
      const prefix = "ErrorEvent constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      super(type, eventInitDict);
      __privateAdd(this, _eventInit3);
      webidl.util.markAsUncloneable(this);
      type = webidl.converters.DOMString(type, prefix, "type");
      eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
      __privateSet(this, _eventInit3, eventInitDict);
    }
    get message() {
      webidl.brandCheck(this, _ErrorEvent);
      return __privateGet(this, _eventInit3).message;
    }
    get filename() {
      webidl.brandCheck(this, _ErrorEvent);
      return __privateGet(this, _eventInit3).filename;
    }
    get lineno() {
      webidl.brandCheck(this, _ErrorEvent);
      return __privateGet(this, _eventInit3).lineno;
    }
    get colno() {
      webidl.brandCheck(this, _ErrorEvent);
      return __privateGet(this, _eventInit3).colno;
    }
    get error() {
      webidl.brandCheck(this, _ErrorEvent);
      return __privateGet(this, _eventInit3).error;
    }
  };
  _eventInit3 = new WeakMap();
  let ErrorEvent2 = _ErrorEvent;
  Object.defineProperties(MessageEvent2.prototype, {
    [Symbol.toStringTag]: {
      value: "MessageEvent",
      configurable: true
    },
    data: kEnumerableProperty2,
    origin: kEnumerableProperty2,
    lastEventId: kEnumerableProperty2,
    source: kEnumerableProperty2,
    ports: kEnumerableProperty2,
    initMessageEvent: kEnumerableProperty2
  });
  Object.defineProperties(CloseEvent2.prototype, {
    [Symbol.toStringTag]: {
      value: "CloseEvent",
      configurable: true
    },
    reason: kEnumerableProperty2,
    code: kEnumerableProperty2,
    wasClean: kEnumerableProperty2
  });
  Object.defineProperties(ErrorEvent2.prototype, {
    [Symbol.toStringTag]: {
      value: "ErrorEvent",
      configurable: true
    },
    message: kEnumerableProperty2,
    filename: kEnumerableProperty2,
    lineno: kEnumerableProperty2,
    colno: kEnumerableProperty2,
    error: kEnumerableProperty2
  });
  webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort2);
  webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(
    webidl.converters.MessagePort
  );
  const eventInit = [
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    }
  ];
  webidl.converters.MessageEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "data",
      converter: webidl.converters.any,
      defaultValue: () => null
    },
    {
      key: "origin",
      converter: webidl.converters.USVString,
      defaultValue: () => ""
    },
    {
      key: "lastEventId",
      converter: webidl.converters.DOMString,
      defaultValue: () => ""
    },
    {
      key: "source",
      // Node doesn't implement WindowProxy or ServiceWorker, so the only
      // valid value for source is a MessagePort.
      converter: webidl.nullableConverter(webidl.converters.MessagePort),
      defaultValue: () => null
    },
    {
      key: "ports",
      converter: webidl.converters["sequence<MessagePort>"],
      defaultValue: () => new Array(0)
    }
  ]);
  webidl.converters.CloseEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "wasClean",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "code",
      converter: webidl.converters["unsigned short"],
      defaultValue: () => 0
    },
    {
      key: "reason",
      converter: webidl.converters.USVString,
      defaultValue: () => ""
    }
  ]);
  webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "message",
      converter: webidl.converters.DOMString,
      defaultValue: () => ""
    },
    {
      key: "filename",
      converter: webidl.converters.USVString,
      defaultValue: () => ""
    },
    {
      key: "lineno",
      converter: webidl.converters["unsigned long"],
      defaultValue: () => 0
    },
    {
      key: "colno",
      converter: webidl.converters["unsigned long"],
      defaultValue: () => 0
    },
    {
      key: "error",
      converter: webidl.converters.any
    }
  ]);
  events = {
    MessageEvent: MessageEvent2,
    CloseEvent: CloseEvent2,
    ErrorEvent: ErrorEvent2,
    createFastMessageEvent
  };
  return events;
}
var constants;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  const uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
  const staticPropertyDescriptors = {
    enumerable: true,
    writable: false,
    configurable: false
  };
  const states = {
    CONNECTING: 0,
    OPEN: 1,
    CLOSING: 2,
    CLOSED: 3
  };
  const sentCloseFrameState = {
    NOT_SENT: 0,
    PROCESSING: 1,
    SENT: 2
  };
  const opcodes = {
    CONTINUATION: 0,
    TEXT: 1,
    BINARY: 2,
    CLOSE: 8,
    PING: 9,
    PONG: 10
  };
  const maxUnsigned16Bit = 2 ** 16 - 1;
  const parserStates = {
    INFO: 0,
    PAYLOADLENGTH_16: 2,
    PAYLOADLENGTH_64: 3,
    READ_DATA: 4
  };
  const emptyBuffer = Buffer.allocUnsafe(0);
  const sendHints = {
    string: 1,
    typedArray: 2,
    arrayBuffer: 3,
    blob: 4
  };
  constants = {
    uid,
    sentCloseFrameState,
    staticPropertyDescriptors,
    states,
    opcodes,
    maxUnsigned16Bit,
    parserStates,
    emptyBuffer,
    sendHints
  };
  return constants;
}
var symbols;
var hasRequiredSymbols;
function requireSymbols() {
  if (hasRequiredSymbols) return symbols;
  hasRequiredSymbols = 1;
  symbols = {
    kWebSocketURL: Symbol("url"),
    kReadyState: Symbol("ready state"),
    kController: Symbol("controller"),
    kResponse: Symbol("response"),
    kBinaryType: Symbol("binary type"),
    kSentClose: Symbol("sent close"),
    kReceivedClose: Symbol("received close"),
    kByteParser: Symbol("byte parser")
  };
  return symbols;
}
var util$2;
var hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1) return util$2;
  hasRequiredUtil$1 = 1;
  const { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = requireSymbols();
  const { states, opcodes } = requireConstants();
  const { ErrorEvent: ErrorEvent2, createFastMessageEvent } = requireEvents();
  const { isUtf8 } = require$$0$1;
  const { collectASequenceOfCodePointsFast, removeHTTPWhitespace } = requireDataUrl();
  function isConnecting(ws) {
    return ws[kReadyState] === states.CONNECTING;
  }
  function isEstablished(ws) {
    return ws[kReadyState] === states.OPEN;
  }
  function isClosing(ws) {
    return ws[kReadyState] === states.CLOSING;
  }
  function isClosed(ws) {
    return ws[kReadyState] === states.CLOSED;
  }
  function fireEvent(e, target, eventFactory = (type, init) => new Event(type, init), eventInitDict = {}) {
    const event = eventFactory(e, eventInitDict);
    target.dispatchEvent(event);
  }
  function websocketMessageReceived(ws, type, data) {
    if (ws[kReadyState] !== states.OPEN) {
      return;
    }
    let dataForEvent;
    if (type === opcodes.TEXT) {
      try {
        dataForEvent = utf8Decode(data);
      } catch {
        failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
        return;
      }
    } else if (type === opcodes.BINARY) {
      if (ws[kBinaryType] === "blob") {
        dataForEvent = new Blob([data]);
      } else {
        dataForEvent = toArrayBuffer(data);
      }
    }
    fireEvent("message", ws, createFastMessageEvent, {
      origin: ws[kWebSocketURL].origin,
      data: dataForEvent
    });
  }
  function toArrayBuffer(buffer) {
    if (buffer.byteLength === buffer.buffer.byteLength) {
      return buffer.buffer;
    }
    return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
  }
  function isValidSubprotocol(protocol) {
    if (protocol.length === 0) {
      return false;
    }
    for (let i = 0; i < protocol.length; ++i) {
      const code = protocol.charCodeAt(i);
      if (code < 33 || // CTL, contains SP (0x20) and HT (0x09)
      code > 126 || code === 34 || // "
      code === 40 || // (
      code === 41 || // )
      code === 44 || // ,
      code === 47 || // /
      code === 58 || // :
      code === 59 || // ;
      code === 60 || // <
      code === 61 || // =
      code === 62 || // >
      code === 63 || // ?
      code === 64 || // @
      code === 91 || // [
      code === 92 || // \
      code === 93 || // ]
      code === 123 || // {
      code === 125) {
        return false;
      }
    }
    return true;
  }
  function isValidStatusCode(code) {
    if (code >= 1e3 && code < 1015) {
      return code !== 1004 && // reserved
      code !== 1005 && // "MUST NOT be set as a status code"
      code !== 1006;
    }
    return code >= 3e3 && code <= 4999;
  }
  function failWebsocketConnection(ws, reason) {
    const { [kController]: controller, [kResponse]: response2 } = ws;
    controller.abort();
    if ((response2 == null ? void 0 : response2.socket) && !response2.socket.destroyed) {
      response2.socket.destroy();
    }
    if (reason) {
      fireEvent("error", ws, (type, init) => new ErrorEvent2(type, init), {
        error: new Error(reason),
        message: reason
      });
    }
  }
  function isControlFrame(opcode) {
    return opcode === opcodes.CLOSE || opcode === opcodes.PING || opcode === opcodes.PONG;
  }
  function isContinuationFrame(opcode) {
    return opcode === opcodes.CONTINUATION;
  }
  function isTextBinaryFrame(opcode) {
    return opcode === opcodes.TEXT || opcode === opcodes.BINARY;
  }
  function isValidOpcode(opcode) {
    return isTextBinaryFrame(opcode) || isContinuationFrame(opcode) || isControlFrame(opcode);
  }
  function parseExtensions(extensions) {
    const position = { position: 0 };
    const extensionList = /* @__PURE__ */ new Map();
    while (position.position < extensions.length) {
      const pair = collectASequenceOfCodePointsFast(";", extensions, position);
      const [name, value = ""] = pair.split("=");
      extensionList.set(
        removeHTTPWhitespace(name, true, false),
        removeHTTPWhitespace(value, false, true)
      );
      position.position++;
    }
    return extensionList;
  }
  function isValidClientWindowBits(value) {
    for (let i = 0; i < value.length; i++) {
      const byte = value.charCodeAt(i);
      if (byte < 48 || byte > 57) {
        return false;
      }
    }
    return true;
  }
  const hasIntl = typeof process.versions.icu === "string";
  const fatalDecoder = hasIntl ? new TextDecoder("utf-8", { fatal: true }) : void 0;
  const utf8Decode = hasIntl ? fatalDecoder.decode.bind(fatalDecoder) : function(buffer) {
    if (isUtf8(buffer)) {
      return buffer.toString("utf-8");
    }
    throw new TypeError("Invalid utf-8 received.");
  };
  util$2 = {
    isConnecting,
    isEstablished,
    isClosing,
    isClosed,
    fireEvent,
    isValidSubprotocol,
    isValidStatusCode,
    failWebsocketConnection,
    websocketMessageReceived,
    utf8Decode,
    isControlFrame,
    isContinuationFrame,
    isTextBinaryFrame,
    isValidOpcode,
    parseExtensions,
    isValidClientWindowBits
  };
  return util$2;
}
var frame;
var hasRequiredFrame;
function requireFrame() {
  if (hasRequiredFrame) return frame;
  hasRequiredFrame = 1;
  const { maxUnsigned16Bit } = requireConstants();
  const BUFFER_SIZE = 16386;
  let crypto2;
  let buffer = null;
  let bufIdx = BUFFER_SIZE;
  try {
    crypto2 = require("node:crypto");
  } catch {
    crypto2 = {
      // not full compatibility, but minimum.
      randomFillSync: function randomFillSync(buffer2, _offset, _size4) {
        for (let i = 0; i < buffer2.length; ++i) {
          buffer2[i] = Math.random() * 255 | 0;
        }
        return buffer2;
      }
    };
  }
  function generateMask() {
    if (bufIdx === BUFFER_SIZE) {
      bufIdx = 0;
      crypto2.randomFillSync(buffer ?? (buffer = Buffer.allocUnsafe(BUFFER_SIZE)), 0, BUFFER_SIZE);
    }
    return [buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++]];
  }
  class WebsocketFrameSend {
    /**
     * @param {Buffer|undefined} data
     */
    constructor(data) {
      this.frameData = data;
    }
    createFrame(opcode) {
      const frameData = this.frameData;
      const maskKey = generateMask();
      const bodyLength2 = (frameData == null ? void 0 : frameData.byteLength) ?? 0;
      let payloadLength = bodyLength2;
      let offset = 6;
      if (bodyLength2 > maxUnsigned16Bit) {
        offset += 8;
        payloadLength = 127;
      } else if (bodyLength2 > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const buffer2 = Buffer.allocUnsafe(bodyLength2 + offset);
      buffer2[0] = buffer2[1] = 0;
      buffer2[0] |= 128;
      buffer2[0] = (buffer2[0] & 240) + opcode;
      /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
      buffer2[offset - 4] = maskKey[0];
      buffer2[offset - 3] = maskKey[1];
      buffer2[offset - 2] = maskKey[2];
      buffer2[offset - 1] = maskKey[3];
      buffer2[1] = payloadLength;
      if (payloadLength === 126) {
        buffer2.writeUInt16BE(bodyLength2, 2);
      } else if (payloadLength === 127) {
        buffer2[2] = buffer2[3] = 0;
        buffer2.writeUIntBE(bodyLength2, 4, 6);
      }
      buffer2[1] |= 128;
      for (let i = 0; i < bodyLength2; ++i) {
        buffer2[offset + i] = frameData[i] ^ maskKey[i & 3];
      }
      return buffer2;
    }
  }
  frame = {
    WebsocketFrameSend
  };
  return frame;
}
var connection;
var hasRequiredConnection;
function requireConnection() {
  if (hasRequiredConnection) return connection;
  hasRequiredConnection = 1;
  const { uid, states, sentCloseFrameState, emptyBuffer, opcodes } = requireConstants();
  const {
    kReadyState,
    kSentClose,
    kByteParser,
    kReceivedClose,
    kResponse
  } = requireSymbols();
  const { fireEvent, failWebsocketConnection, isClosing, isClosed, isEstablished, parseExtensions } = requireUtil$1();
  const { channels: channels2 } = diagnostics;
  const { CloseEvent: CloseEvent2 } = requireEvents();
  const { makeRequest } = requireRequest();
  const { fetching } = requireFetch();
  const { Headers, getHeadersList } = requireHeaders();
  const { getDecodeSplit } = requireUtil$5();
  const { WebsocketFrameSend } = requireFrame();
  let crypto2;
  try {
    crypto2 = require("node:crypto");
  } catch {
  }
  function establishWebSocketConnection(url, protocols, client2, ws, onEstablish, options) {
    const requestURL = url;
    requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
    const request2 = makeRequest({
      urlList: [requestURL],
      client: client2,
      serviceWorkers: "none",
      referrer: "no-referrer",
      mode: "websocket",
      credentials: "include",
      cache: "no-store",
      redirect: "error"
    });
    if (options.headers) {
      const headersList = getHeadersList(new Headers(options.headers));
      request2.headersList = headersList;
    }
    const keyValue = crypto2.randomBytes(16).toString("base64");
    request2.headersList.append("sec-websocket-key", keyValue);
    request2.headersList.append("sec-websocket-version", "13");
    for (const protocol of protocols) {
      request2.headersList.append("sec-websocket-protocol", protocol);
    }
    const permessageDeflate2 = "permessage-deflate; client_max_window_bits";
    request2.headersList.append("sec-websocket-extensions", permessageDeflate2);
    const controller = fetching({
      request: request2,
      useParallelQueue: true,
      dispatcher: options.dispatcher,
      processResponse(response2) {
        var _a2, _b2;
        if (response2.type === "error" || response2.status !== 101) {
          failWebsocketConnection(ws, "Received network error or non-101 status code.");
          return;
        }
        if (protocols.length !== 0 && !response2.headersList.get("Sec-WebSocket-Protocol")) {
          failWebsocketConnection(ws, "Server did not respond with sent protocols.");
          return;
        }
        if (((_a2 = response2.headersList.get("Upgrade")) == null ? void 0 : _a2.toLowerCase()) !== "websocket") {
          failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
          return;
        }
        if (((_b2 = response2.headersList.get("Connection")) == null ? void 0 : _b2.toLowerCase()) !== "upgrade") {
          failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
          return;
        }
        const secWSAccept = response2.headersList.get("Sec-WebSocket-Accept");
        const digest = crypto2.createHash("sha1").update(keyValue + uid).digest("base64");
        if (secWSAccept !== digest) {
          failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
          return;
        }
        const secExtension = response2.headersList.get("Sec-WebSocket-Extensions");
        let extensions;
        if (secExtension !== null) {
          extensions = parseExtensions(secExtension);
          if (!extensions.has("permessage-deflate")) {
            failWebsocketConnection(ws, "Sec-WebSocket-Extensions header does not match.");
            return;
          }
        }
        const secProtocol = response2.headersList.get("Sec-WebSocket-Protocol");
        if (secProtocol !== null) {
          const requestProtocols = getDecodeSplit("sec-websocket-protocol", request2.headersList);
          if (!requestProtocols.includes(secProtocol)) {
            failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
            return;
          }
        }
        response2.socket.on("data", onSocketData);
        response2.socket.on("close", onSocketClose2);
        response2.socket.on("error", onSocketError);
        if (channels2.open.hasSubscribers) {
          channels2.open.publish({
            address: response2.socket.address(),
            protocol: secProtocol,
            extensions: secExtension
          });
        }
        onEstablish(response2, extensions);
      }
    });
    return controller;
  }
  function closeWebSocketConnection(ws, code, reason, reasonByteLength) {
    if (isClosing(ws) || isClosed(ws)) ;
    else if (!isEstablished(ws)) {
      failWebsocketConnection(ws, "Connection was closed before it was established.");
      ws[kReadyState] = states.CLOSING;
    } else if (ws[kSentClose] === sentCloseFrameState.NOT_SENT) {
      ws[kSentClose] = sentCloseFrameState.PROCESSING;
      const frame2 = new WebsocketFrameSend();
      if (code !== void 0 && reason === void 0) {
        frame2.frameData = Buffer.allocUnsafe(2);
        frame2.frameData.writeUInt16BE(code, 0);
      } else if (code !== void 0 && reason !== void 0) {
        frame2.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
        frame2.frameData.writeUInt16BE(code, 0);
        frame2.frameData.write(reason, 2, "utf-8");
      } else {
        frame2.frameData = emptyBuffer;
      }
      const socket = ws[kResponse].socket;
      socket.write(frame2.createFrame(opcodes.CLOSE));
      ws[kSentClose] = sentCloseFrameState.SENT;
      ws[kReadyState] = states.CLOSING;
    } else {
      ws[kReadyState] = states.CLOSING;
    }
  }
  function onSocketData(chunk) {
    if (!this.ws[kByteParser].write(chunk)) {
      this.pause();
    }
  }
  function onSocketClose2() {
    const { ws } = this;
    const { [kResponse]: response2 } = ws;
    response2.socket.off("data", onSocketData);
    response2.socket.off("close", onSocketClose2);
    response2.socket.off("error", onSocketError);
    const wasClean = ws[kSentClose] === sentCloseFrameState.SENT && ws[kReceivedClose];
    let code = 1005;
    let reason = "";
    const result = ws[kByteParser].closingInfo;
    if (result && !result.error) {
      code = result.code ?? 1005;
      reason = result.reason;
    } else if (!ws[kReceivedClose]) {
      code = 1006;
    }
    ws[kReadyState] = states.CLOSED;
    fireEvent("close", ws, (type, init) => new CloseEvent2(type, init), {
      wasClean,
      code,
      reason
    });
    if (channels2.close.hasSubscribers) {
      channels2.close.publish({
        websocket: ws,
        code,
        reason
      });
    }
  }
  function onSocketError(error) {
    const { ws } = this;
    ws[kReadyState] = states.CLOSING;
    if (channels2.socketError.hasSubscribers) {
      channels2.socketError.publish(error);
    }
    this.destroy();
  }
  connection = {
    establishWebSocketConnection,
    closeWebSocketConnection
  };
  return connection;
}
var permessageDeflate;
var hasRequiredPermessageDeflate;
function requirePermessageDeflate() {
  var _inflate, _options3;
  if (hasRequiredPermessageDeflate) return permessageDeflate;
  hasRequiredPermessageDeflate = 1;
  const { createInflateRaw, Z_DEFAULT_WINDOWBITS } = require$$1$2;
  const { isValidClientWindowBits } = requireUtil$1();
  const tail = Buffer.from([0, 0, 255, 255]);
  const kBuffer = Symbol("kBuffer");
  const kLength = Symbol("kLength");
  class PerMessageDeflate {
    constructor(extensions) {
      /** @type {import('node:zlib').InflateRaw} */
      __privateAdd(this, _inflate);
      __privateAdd(this, _options3, {});
      __privateGet(this, _options3).serverNoContextTakeover = extensions.has("server_no_context_takeover");
      __privateGet(this, _options3).serverMaxWindowBits = extensions.get("server_max_window_bits");
    }
    decompress(chunk, fin, callback) {
      if (!__privateGet(this, _inflate)) {
        let windowBits = Z_DEFAULT_WINDOWBITS;
        if (__privateGet(this, _options3).serverMaxWindowBits) {
          if (!isValidClientWindowBits(__privateGet(this, _options3).serverMaxWindowBits)) {
            callback(new Error("Invalid server_max_window_bits"));
            return;
          }
          windowBits = Number.parseInt(__privateGet(this, _options3).serverMaxWindowBits);
        }
        __privateSet(this, _inflate, createInflateRaw({ windowBits }));
        __privateGet(this, _inflate)[kBuffer] = [];
        __privateGet(this, _inflate)[kLength] = 0;
        __privateGet(this, _inflate).on("data", (data) => {
          __privateGet(this, _inflate)[kBuffer].push(data);
          __privateGet(this, _inflate)[kLength] += data.length;
        });
        __privateGet(this, _inflate).on("error", (err) => {
          __privateSet(this, _inflate, null);
          callback(err);
        });
      }
      __privateGet(this, _inflate).write(chunk);
      if (fin) {
        __privateGet(this, _inflate).write(tail);
      }
      __privateGet(this, _inflate).flush(() => {
        const full = Buffer.concat(__privateGet(this, _inflate)[kBuffer], __privateGet(this, _inflate)[kLength]);
        __privateGet(this, _inflate)[kBuffer].length = 0;
        __privateGet(this, _inflate)[kLength] = 0;
        callback(null, full);
      });
    }
  }
  _inflate = new WeakMap();
  _options3 = new WeakMap();
  permessageDeflate = { PerMessageDeflate };
  return permessageDeflate;
}
var receiver;
var hasRequiredReceiver;
function requireReceiver() {
  var _buffers, _byteOffset, _loop, _state3, _info, _fragments, _extensions;
  if (hasRequiredReceiver) return receiver;
  hasRequiredReceiver = 1;
  const { Writable: Writable2 } = require$$0$4;
  const assert2 = require$$0$3;
  const { parserStates, opcodes, states, emptyBuffer, sentCloseFrameState } = requireConstants();
  const { kReadyState, kSentClose, kResponse, kReceivedClose } = requireSymbols();
  const { channels: channels2 } = diagnostics;
  const {
    isValidStatusCode,
    isValidOpcode,
    failWebsocketConnection,
    websocketMessageReceived,
    utf8Decode,
    isControlFrame,
    isTextBinaryFrame,
    isContinuationFrame
  } = requireUtil$1();
  const { WebsocketFrameSend } = requireFrame();
  const { closeWebSocketConnection } = requireConnection();
  const { PerMessageDeflate } = requirePermessageDeflate();
  class ByteParser extends Writable2 {
    constructor(ws, extensions) {
      super();
      __privateAdd(this, _buffers, []);
      __privateAdd(this, _byteOffset, 0);
      __privateAdd(this, _loop, false);
      __privateAdd(this, _state3, parserStates.INFO);
      __privateAdd(this, _info, {});
      __privateAdd(this, _fragments, []);
      /** @type {Map<string, PerMessageDeflate>} */
      __privateAdd(this, _extensions);
      this.ws = ws;
      __privateSet(this, _extensions, extensions == null ? /* @__PURE__ */ new Map() : extensions);
      if (__privateGet(this, _extensions).has("permessage-deflate")) {
        __privateGet(this, _extensions).set("permessage-deflate", new PerMessageDeflate(extensions));
      }
    }
    /**
     * @param {Buffer} chunk
     * @param {() => void} callback
     */
    _write(chunk, _, callback) {
      __privateGet(this, _buffers).push(chunk);
      __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) + chunk.length);
      __privateSet(this, _loop, true);
      this.run(callback);
    }
    /**
     * Runs whenever a new chunk is received.
     * Callback is called whenever there are no more chunks buffering,
     * or not enough bytes are buffered to parse.
     */
    run(callback) {
      while (__privateGet(this, _loop)) {
        if (__privateGet(this, _state3) === parserStates.INFO) {
          if (__privateGet(this, _byteOffset) < 2) {
            return callback();
          }
          const buffer = this.consume(2);
          const fin = (buffer[0] & 128) !== 0;
          const opcode = buffer[0] & 15;
          const masked = (buffer[1] & 128) === 128;
          const fragmented = !fin && opcode !== opcodes.CONTINUATION;
          const payloadLength = buffer[1] & 127;
          const rsv1 = buffer[0] & 64;
          const rsv2 = buffer[0] & 32;
          const rsv3 = buffer[0] & 16;
          if (!isValidOpcode(opcode)) {
            failWebsocketConnection(this.ws, "Invalid opcode received");
            return callback();
          }
          if (masked) {
            failWebsocketConnection(this.ws, "Frame cannot be masked");
            return callback();
          }
          if (rsv1 !== 0 && !__privateGet(this, _extensions).has("permessage-deflate")) {
            failWebsocketConnection(this.ws, "Expected RSV1 to be clear.");
            return;
          }
          if (rsv2 !== 0 || rsv3 !== 0) {
            failWebsocketConnection(this.ws, "RSV1, RSV2, RSV3 must be clear");
            return;
          }
          if (fragmented && !isTextBinaryFrame(opcode)) {
            failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
            return;
          }
          if (isTextBinaryFrame(opcode) && __privateGet(this, _fragments).length > 0) {
            failWebsocketConnection(this.ws, "Expected continuation frame");
            return;
          }
          if (__privateGet(this, _info).fragmented && fragmented) {
            failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
            return;
          }
          if ((payloadLength > 125 || fragmented) && isControlFrame(opcode)) {
            failWebsocketConnection(this.ws, "Control frame either too large or fragmented");
            return;
          }
          if (isContinuationFrame(opcode) && __privateGet(this, _fragments).length === 0 && !__privateGet(this, _info).compressed) {
            failWebsocketConnection(this.ws, "Unexpected continuation frame");
            return;
          }
          if (payloadLength <= 125) {
            __privateGet(this, _info).payloadLength = payloadLength;
            __privateSet(this, _state3, parserStates.READ_DATA);
          } else if (payloadLength === 126) {
            __privateSet(this, _state3, parserStates.PAYLOADLENGTH_16);
          } else if (payloadLength === 127) {
            __privateSet(this, _state3, parserStates.PAYLOADLENGTH_64);
          }
          if (isTextBinaryFrame(opcode)) {
            __privateGet(this, _info).binaryType = opcode;
            __privateGet(this, _info).compressed = rsv1 !== 0;
          }
          __privateGet(this, _info).opcode = opcode;
          __privateGet(this, _info).masked = masked;
          __privateGet(this, _info).fin = fin;
          __privateGet(this, _info).fragmented = fragmented;
        } else if (__privateGet(this, _state3) === parserStates.PAYLOADLENGTH_16) {
          if (__privateGet(this, _byteOffset) < 2) {
            return callback();
          }
          const buffer = this.consume(2);
          __privateGet(this, _info).payloadLength = buffer.readUInt16BE(0);
          __privateSet(this, _state3, parserStates.READ_DATA);
        } else if (__privateGet(this, _state3) === parserStates.PAYLOADLENGTH_64) {
          if (__privateGet(this, _byteOffset) < 8) {
            return callback();
          }
          const buffer = this.consume(8);
          const upper = buffer.readUInt32BE(0);
          if (upper > 2 ** 31 - 1) {
            failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
            return;
          }
          const lower = buffer.readUInt32BE(4);
          __privateGet(this, _info).payloadLength = (upper << 8) + lower;
          __privateSet(this, _state3, parserStates.READ_DATA);
        } else if (__privateGet(this, _state3) === parserStates.READ_DATA) {
          if (__privateGet(this, _byteOffset) < __privateGet(this, _info).payloadLength) {
            return callback();
          }
          const body2 = this.consume(__privateGet(this, _info).payloadLength);
          if (isControlFrame(__privateGet(this, _info).opcode)) {
            __privateSet(this, _loop, this.parseControlFrame(body2));
            __privateSet(this, _state3, parserStates.INFO);
          } else {
            if (!__privateGet(this, _info).compressed) {
              __privateGet(this, _fragments).push(body2);
              if (!__privateGet(this, _info).fragmented && __privateGet(this, _info).fin) {
                const fullMessage = Buffer.concat(__privateGet(this, _fragments));
                websocketMessageReceived(this.ws, __privateGet(this, _info).binaryType, fullMessage);
                __privateGet(this, _fragments).length = 0;
              }
              __privateSet(this, _state3, parserStates.INFO);
            } else {
              __privateGet(this, _extensions).get("permessage-deflate").decompress(body2, __privateGet(this, _info).fin, (error, data) => {
                if (error) {
                  closeWebSocketConnection(this.ws, 1007, error.message, error.message.length);
                  return;
                }
                __privateGet(this, _fragments).push(data);
                if (!__privateGet(this, _info).fin) {
                  __privateSet(this, _state3, parserStates.INFO);
                  __privateSet(this, _loop, true);
                  this.run(callback);
                  return;
                }
                websocketMessageReceived(this.ws, __privateGet(this, _info).binaryType, Buffer.concat(__privateGet(this, _fragments)));
                __privateSet(this, _loop, true);
                __privateSet(this, _state3, parserStates.INFO);
                __privateGet(this, _fragments).length = 0;
                this.run(callback);
              });
              __privateSet(this, _loop, false);
              break;
            }
          }
        }
      }
    }
    /**
     * Take n bytes from the buffered Buffers
     * @param {number} n
     * @returns {Buffer}
     */
    consume(n) {
      if (n > __privateGet(this, _byteOffset)) {
        throw new Error("Called consume() before buffers satiated.");
      } else if (n === 0) {
        return emptyBuffer;
      }
      if (__privateGet(this, _buffers)[0].length === n) {
        __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) - __privateGet(this, _buffers)[0].length);
        return __privateGet(this, _buffers).shift();
      }
      const buffer = Buffer.allocUnsafe(n);
      let offset = 0;
      while (offset !== n) {
        const next = __privateGet(this, _buffers)[0];
        const { length } = next;
        if (length + offset === n) {
          buffer.set(__privateGet(this, _buffers).shift(), offset);
          break;
        } else if (length + offset > n) {
          buffer.set(next.subarray(0, n - offset), offset);
          __privateGet(this, _buffers)[0] = next.subarray(n - offset);
          break;
        } else {
          buffer.set(__privateGet(this, _buffers).shift(), offset);
          offset += next.length;
        }
      }
      __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) - n);
      return buffer;
    }
    parseCloseBody(data) {
      assert2(data.length !== 1);
      let code;
      if (data.length >= 2) {
        code = data.readUInt16BE(0);
      }
      if (code !== void 0 && !isValidStatusCode(code)) {
        return { code: 1002, reason: "Invalid status code", error: true };
      }
      let reason = data.subarray(2);
      if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
        reason = reason.subarray(3);
      }
      try {
        reason = utf8Decode(reason);
      } catch {
        return { code: 1007, reason: "Invalid UTF-8", error: true };
      }
      return { code, reason, error: false };
    }
    /**
     * Parses control frames.
     * @param {Buffer} body
     */
    parseControlFrame(body2) {
      const { opcode, payloadLength } = __privateGet(this, _info);
      if (opcode === opcodes.CLOSE) {
        if (payloadLength === 1) {
          failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
          return false;
        }
        __privateGet(this, _info).closeInfo = this.parseCloseBody(body2);
        if (__privateGet(this, _info).closeInfo.error) {
          const { code, reason } = __privateGet(this, _info).closeInfo;
          closeWebSocketConnection(this.ws, code, reason, reason.length);
          failWebsocketConnection(this.ws, reason);
          return false;
        }
        if (this.ws[kSentClose] !== sentCloseFrameState.SENT) {
          let body3 = emptyBuffer;
          if (__privateGet(this, _info).closeInfo.code) {
            body3 = Buffer.allocUnsafe(2);
            body3.writeUInt16BE(__privateGet(this, _info).closeInfo.code, 0);
          }
          const closeFrame = new WebsocketFrameSend(body3);
          this.ws[kResponse].socket.write(
            closeFrame.createFrame(opcodes.CLOSE),
            (err) => {
              if (!err) {
                this.ws[kSentClose] = sentCloseFrameState.SENT;
              }
            }
          );
        }
        this.ws[kReadyState] = states.CLOSING;
        this.ws[kReceivedClose] = true;
        return false;
      } else if (opcode === opcodes.PING) {
        if (!this.ws[kReceivedClose]) {
          const frame2 = new WebsocketFrameSend(body2);
          this.ws[kResponse].socket.write(frame2.createFrame(opcodes.PONG));
          if (channels2.ping.hasSubscribers) {
            channels2.ping.publish({
              payload: body2
            });
          }
        }
      } else if (opcode === opcodes.PONG) {
        if (channels2.pong.hasSubscribers) {
          channels2.pong.publish({
            payload: body2
          });
        }
      }
      return true;
    }
    get closingInfo() {
      return __privateGet(this, _info).closeInfo;
    }
  }
  _buffers = new WeakMap();
  _byteOffset = new WeakMap();
  _loop = new WeakMap();
  _state3 = new WeakMap();
  _info = new WeakMap();
  _fragments = new WeakMap();
  _extensions = new WeakMap();
  receiver = {
    ByteParser
  };
  return receiver;
}
var sender;
var hasRequiredSender;
function requireSender() {
  var _queue, _running, _socket, _SendQueue_instances, run_fn;
  if (hasRequiredSender) return sender;
  hasRequiredSender = 1;
  const { WebsocketFrameSend } = requireFrame();
  const { opcodes, sendHints } = requireConstants();
  const FixedQueue4 = fixedQueue;
  const FastBuffer2 = Buffer[Symbol.species];
  class SendQueue {
    constructor(socket) {
      __privateAdd(this, _SendQueue_instances);
      /**
       * @type {FixedQueue}
       */
      __privateAdd(this, _queue, new FixedQueue4());
      /**
       * @type {boolean}
       */
      __privateAdd(this, _running, false);
      /** @type {import('node:net').Socket} */
      __privateAdd(this, _socket);
      __privateSet(this, _socket, socket);
    }
    add(item, cb, hint) {
      if (hint !== sendHints.blob) {
        const frame2 = createFrame(item, hint);
        if (!__privateGet(this, _running)) {
          __privateGet(this, _socket).write(frame2, cb);
        } else {
          const node3 = {
            promise: null,
            callback: cb,
            frame: frame2
          };
          __privateGet(this, _queue).push(node3);
        }
        return;
      }
      const node2 = {
        promise: item.arrayBuffer().then((ab) => {
          node2.promise = null;
          node2.frame = createFrame(ab, hint);
        }),
        callback: cb,
        frame: null
      };
      __privateGet(this, _queue).push(node2);
      if (!__privateGet(this, _running)) {
        __privateMethod(this, _SendQueue_instances, run_fn).call(this);
      }
    }
  }
  _queue = new WeakMap();
  _running = new WeakMap();
  _socket = new WeakMap();
  _SendQueue_instances = new WeakSet();
  run_fn = async function() {
    __privateSet(this, _running, true);
    const queue2 = __privateGet(this, _queue);
    while (!queue2.isEmpty()) {
      const node2 = queue2.shift();
      if (node2.promise !== null) {
        await node2.promise;
      }
      __privateGet(this, _socket).write(node2.frame, node2.callback);
      node2.callback = node2.frame = null;
    }
    __privateSet(this, _running, false);
  };
  function createFrame(data, hint) {
    return new WebsocketFrameSend(toBuffer2(data, hint)).createFrame(hint === sendHints.string ? opcodes.TEXT : opcodes.BINARY);
  }
  function toBuffer2(data, hint) {
    switch (hint) {
      case sendHints.string:
        return Buffer.from(data);
      case sendHints.arrayBuffer:
      case sendHints.blob:
        return new FastBuffer2(data);
      case sendHints.typedArray:
        return new FastBuffer2(data.buffer, data.byteOffset, data.byteLength);
    }
  }
  sender = { SendQueue };
  return sender;
}
var websocket;
var hasRequiredWebsocket;
function requireWebsocket() {
  var _events, _bufferedAmount, _protocol, _extensions, _sendQueue, _WebSocket_instances, onConnectionEstablished_fn;
  if (hasRequiredWebsocket) return websocket;
  hasRequiredWebsocket = 1;
  const { webidl } = requireWebidl();
  const { URLSerializer } = requireDataUrl();
  const { environmentSettingsObject } = requireUtil$5();
  const { staticPropertyDescriptors, states, sentCloseFrameState, sendHints } = requireConstants();
  const {
    kWebSocketURL,
    kReadyState,
    kController,
    kBinaryType,
    kResponse,
    kSentClose,
    kByteParser
  } = requireSymbols();
  const {
    isConnecting,
    isEstablished,
    isClosing,
    isValidSubprotocol,
    fireEvent
  } = requireUtil$1();
  const { establishWebSocketConnection, closeWebSocketConnection } = requireConnection();
  const { ByteParser } = requireReceiver();
  const { kEnumerableProperty: kEnumerableProperty2, isBlobLike: isBlobLike2 } = util$n;
  const { getGlobalDispatcher: getGlobalDispatcher2 } = global$1;
  const { types } = require$$0$2;
  const { ErrorEvent: ErrorEvent2, CloseEvent: CloseEvent2 } = requireEvents();
  const { SendQueue } = requireSender();
  const _WebSocket = class _WebSocket extends EventTarget {
    /**
     * @param {string} url
     * @param {string|string[]} protocols
     */
    constructor(url, protocols = []) {
      super();
      __privateAdd(this, _WebSocket_instances);
      __privateAdd(this, _events, {
        open: null,
        error: null,
        close: null,
        message: null
      });
      __privateAdd(this, _bufferedAmount, 0);
      __privateAdd(this, _protocol, "");
      __privateAdd(this, _extensions, "");
      /** @type {SendQueue} */
      __privateAdd(this, _sendQueue);
      webidl.util.markAsUncloneable(this);
      const prefix = "WebSocket constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols, prefix, "options");
      url = webidl.converters.USVString(url, prefix, "url");
      protocols = options.protocols;
      const baseURL = environmentSettingsObject.settingsObject.baseUrl;
      let urlRecord;
      try {
        urlRecord = new URL(url, baseURL);
      } catch (e) {
        throw new DOMException(e, "SyntaxError");
      }
      if (urlRecord.protocol === "http:") {
        urlRecord.protocol = "ws:";
      } else if (urlRecord.protocol === "https:") {
        urlRecord.protocol = "wss:";
      }
      if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
        throw new DOMException(
          `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,
          "SyntaxError"
        );
      }
      if (urlRecord.hash || urlRecord.href.endsWith("#")) {
        throw new DOMException("Got fragment", "SyntaxError");
      }
      if (typeof protocols === "string") {
        protocols = [protocols];
      }
      if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
        throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
        throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      this[kWebSocketURL] = new URL(urlRecord.href);
      const client2 = environmentSettingsObject.settingsObject;
      this[kController] = establishWebSocketConnection(
        urlRecord,
        protocols,
        client2,
        this,
        (response2, extensions) => __privateMethod(this, _WebSocket_instances, onConnectionEstablished_fn).call(this, response2, extensions),
        options
      );
      this[kReadyState] = _WebSocket.CONNECTING;
      this[kSentClose] = sentCloseFrameState.NOT_SENT;
      this[kBinaryType] = "blob";
    }
    /**
     * @see https://websockets.spec.whatwg.org/#dom-websocket-close
     * @param {number|undefined} code
     * @param {string|undefined} reason
     */
    close(code = void 0, reason = void 0) {
      webidl.brandCheck(this, _WebSocket);
      const prefix = "WebSocket.close";
      if (code !== void 0) {
        code = webidl.converters["unsigned short"](code, prefix, "code", { clamp: true });
      }
      if (reason !== void 0) {
        reason = webidl.converters.USVString(reason, prefix, "reason");
      }
      if (code !== void 0) {
        if (code !== 1e3 && (code < 3e3 || code > 4999)) {
          throw new DOMException("invalid code", "InvalidAccessError");
        }
      }
      let reasonByteLength = 0;
      if (reason !== void 0) {
        reasonByteLength = Buffer.byteLength(reason);
        if (reasonByteLength > 123) {
          throw new DOMException(
            `Reason must be less than 123 bytes; received ${reasonByteLength}`,
            "SyntaxError"
          );
        }
      }
      closeWebSocketConnection(this, code, reason, reasonByteLength);
    }
    /**
     * @see https://websockets.spec.whatwg.org/#dom-websocket-send
     * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
     */
    send(data) {
      webidl.brandCheck(this, _WebSocket);
      const prefix = "WebSocket.send";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      data = webidl.converters.WebSocketSendData(data, prefix, "data");
      if (isConnecting(this)) {
        throw new DOMException("Sent before connected.", "InvalidStateError");
      }
      if (!isEstablished(this) || isClosing(this)) {
        return;
      }
      if (typeof data === "string") {
        const length = Buffer.byteLength(data);
        __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + length);
        __privateGet(this, _sendQueue).add(data, () => {
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - length);
        }, sendHints.string);
      } else if (types.isArrayBuffer(data)) {
        __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + data.byteLength);
        __privateGet(this, _sendQueue).add(data, () => {
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - data.byteLength);
        }, sendHints.arrayBuffer);
      } else if (ArrayBuffer.isView(data)) {
        __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + data.byteLength);
        __privateGet(this, _sendQueue).add(data, () => {
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - data.byteLength);
        }, sendHints.typedArray);
      } else if (isBlobLike2(data)) {
        __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + data.size);
        __privateGet(this, _sendQueue).add(data, () => {
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - data.size);
        }, sendHints.blob);
      }
    }
    get readyState() {
      webidl.brandCheck(this, _WebSocket);
      return this[kReadyState];
    }
    get bufferedAmount() {
      webidl.brandCheck(this, _WebSocket);
      return __privateGet(this, _bufferedAmount);
    }
    get url() {
      webidl.brandCheck(this, _WebSocket);
      return URLSerializer(this[kWebSocketURL]);
    }
    get extensions() {
      webidl.brandCheck(this, _WebSocket);
      return __privateGet(this, _extensions);
    }
    get protocol() {
      webidl.brandCheck(this, _WebSocket);
      return __privateGet(this, _protocol);
    }
    get onopen() {
      webidl.brandCheck(this, _WebSocket);
      return __privateGet(this, _events).open;
    }
    set onopen(fn) {
      webidl.brandCheck(this, _WebSocket);
      if (__privateGet(this, _events).open) {
        this.removeEventListener("open", __privateGet(this, _events).open);
      }
      if (typeof fn === "function") {
        __privateGet(this, _events).open = fn;
        this.addEventListener("open", fn);
      } else {
        __privateGet(this, _events).open = null;
      }
    }
    get onerror() {
      webidl.brandCheck(this, _WebSocket);
      return __privateGet(this, _events).error;
    }
    set onerror(fn) {
      webidl.brandCheck(this, _WebSocket);
      if (__privateGet(this, _events).error) {
        this.removeEventListener("error", __privateGet(this, _events).error);
      }
      if (typeof fn === "function") {
        __privateGet(this, _events).error = fn;
        this.addEventListener("error", fn);
      } else {
        __privateGet(this, _events).error = null;
      }
    }
    get onclose() {
      webidl.brandCheck(this, _WebSocket);
      return __privateGet(this, _events).close;
    }
    set onclose(fn) {
      webidl.brandCheck(this, _WebSocket);
      if (__privateGet(this, _events).close) {
        this.removeEventListener("close", __privateGet(this, _events).close);
      }
      if (typeof fn === "function") {
        __privateGet(this, _events).close = fn;
        this.addEventListener("close", fn);
      } else {
        __privateGet(this, _events).close = null;
      }
    }
    get onmessage() {
      webidl.brandCheck(this, _WebSocket);
      return __privateGet(this, _events).message;
    }
    set onmessage(fn) {
      webidl.brandCheck(this, _WebSocket);
      if (__privateGet(this, _events).message) {
        this.removeEventListener("message", __privateGet(this, _events).message);
      }
      if (typeof fn === "function") {
        __privateGet(this, _events).message = fn;
        this.addEventListener("message", fn);
      } else {
        __privateGet(this, _events).message = null;
      }
    }
    get binaryType() {
      webidl.brandCheck(this, _WebSocket);
      return this[kBinaryType];
    }
    set binaryType(type) {
      webidl.brandCheck(this, _WebSocket);
      if (type !== "blob" && type !== "arraybuffer") {
        this[kBinaryType] = "blob";
      } else {
        this[kBinaryType] = type;
      }
    }
  };
  _events = new WeakMap();
  _bufferedAmount = new WeakMap();
  _protocol = new WeakMap();
  _extensions = new WeakMap();
  _sendQueue = new WeakMap();
  _WebSocket_instances = new WeakSet();
  /**
   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
   */
  onConnectionEstablished_fn = function(response2, parsedExtensions) {
    this[kResponse] = response2;
    const parser = new ByteParser(this, parsedExtensions);
    parser.on("drain", onParserDrain);
    parser.on("error", onParserError.bind(this));
    response2.socket.ws = this;
    this[kByteParser] = parser;
    __privateSet(this, _sendQueue, new SendQueue(response2.socket));
    this[kReadyState] = states.OPEN;
    const extensions = response2.headersList.get("sec-websocket-extensions");
    if (extensions !== null) {
      __privateSet(this, _extensions, extensions);
    }
    const protocol = response2.headersList.get("sec-websocket-protocol");
    if (protocol !== null) {
      __privateSet(this, _protocol, protocol);
    }
    fireEvent("open", this);
  };
  let WebSocket = _WebSocket;
  WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
  WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
  WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
  WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
  Object.defineProperties(WebSocket.prototype, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors,
    url: kEnumerableProperty2,
    readyState: kEnumerableProperty2,
    bufferedAmount: kEnumerableProperty2,
    onopen: kEnumerableProperty2,
    onerror: kEnumerableProperty2,
    onclose: kEnumerableProperty2,
    close: kEnumerableProperty2,
    onmessage: kEnumerableProperty2,
    binaryType: kEnumerableProperty2,
    send: kEnumerableProperty2,
    extensions: kEnumerableProperty2,
    protocol: kEnumerableProperty2,
    [Symbol.toStringTag]: {
      value: "WebSocket",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  Object.defineProperties(WebSocket, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors
  });
  webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(
    webidl.converters.DOMString
  );
  webidl.converters["DOMString or sequence<DOMString>"] = function(V, prefix, argument) {
    if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) {
      return webidl.converters["sequence<DOMString>"](V);
    }
    return webidl.converters.DOMString(V, prefix, argument);
  };
  webidl.converters.WebSocketInit = webidl.dictionaryConverter([
    {
      key: "protocols",
      converter: webidl.converters["DOMString or sequence<DOMString>"],
      defaultValue: () => new Array(0)
    },
    {
      key: "dispatcher",
      converter: webidl.converters.any,
      defaultValue: () => getGlobalDispatcher2()
    },
    {
      key: "headers",
      converter: webidl.nullableConverter(webidl.converters.HeadersInit)
    }
  ]);
  webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
    if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) {
      return webidl.converters.WebSocketInit(V);
    }
    return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
  };
  webidl.converters.WebSocketSendData = function(V) {
    if (webidl.util.Type(V) === "Object") {
      if (isBlobLike2(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {
        return webidl.converters.BufferSource(V);
      }
    }
    return webidl.converters.USVString(V);
  };
  function onParserDrain() {
    this.ws[kResponse].socket.resume();
  }
  function onParserError(err) {
    let message;
    let code;
    if (err instanceof CloseEvent2) {
      message = err.reason;
      code = err.code;
    } else {
      message = err.message;
    }
    fireEvent("error", this, () => new ErrorEvent2("error", { error: err, message }));
    closeWebSocketConnection(this, code);
  }
  websocket = {
    WebSocket
  };
  return websocket;
}
var util$1;
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util$1;
  hasRequiredUtil = 1;
  function isValidLastEventId(value) {
    return value.indexOf("\0") === -1;
  }
  function isASCIINumber(value) {
    if (value.length === 0) return false;
    for (let i = 0; i < value.length; i++) {
      if (value.charCodeAt(i) < 48 || value.charCodeAt(i) > 57) return false;
    }
    return true;
  }
  function delay(ms2) {
    return new Promise((resolve2) => {
      setTimeout(resolve2, ms2).unref();
    });
  }
  util$1 = {
    isValidLastEventId,
    isASCIINumber,
    delay
  };
  return util$1;
}
var eventsourceStream;
var hasRequiredEventsourceStream;
function requireEventsourceStream() {
  if (hasRequiredEventsourceStream) return eventsourceStream;
  hasRequiredEventsourceStream = 1;
  const { Transform: Transform2 } = require$$0$4;
  const { isASCIINumber, isValidLastEventId } = requireUtil();
  const BOM = [239, 187, 191];
  const LF = 10;
  const CR = 13;
  const COLON = 58;
  const SPACE = 32;
  class EventSourceStream extends Transform2 {
    /**
     * @param {object} options
     * @param {eventSourceSettings} options.eventSourceSettings
     * @param {Function} [options.push]
     */
    constructor(options = {}) {
      options.readableObjectMode = true;
      super(options);
      /**
       * @type {eventSourceSettings}
       */
      __publicField(this, "state", null);
      /**
       * Leading byte-order-mark check.
       * @type {boolean}
       */
      __publicField(this, "checkBOM", true);
      /**
       * @type {boolean}
       */
      __publicField(this, "crlfCheck", false);
      /**
       * @type {boolean}
       */
      __publicField(this, "eventEndCheck", false);
      /**
       * @type {Buffer}
       */
      __publicField(this, "buffer", null);
      __publicField(this, "pos", 0);
      __publicField(this, "event", {
        data: void 0,
        event: void 0,
        id: void 0,
        retry: void 0
      });
      this.state = options.eventSourceSettings || {};
      if (options.push) {
        this.push = options.push;
      }
    }
    /**
     * @param {Buffer} chunk
     * @param {string} _encoding
     * @param {Function} callback
     * @returns {void}
     */
    _transform(chunk, _encoding, callback) {
      if (chunk.length === 0) {
        callback();
        return;
      }
      if (this.buffer) {
        this.buffer = Buffer.concat([this.buffer, chunk]);
      } else {
        this.buffer = chunk;
      }
      if (this.checkBOM) {
        switch (this.buffer.length) {
          case 1:
            if (this.buffer[0] === BOM[0]) {
              callback();
              return;
            }
            this.checkBOM = false;
            callback();
            return;
          case 2:
            if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1]) {
              callback();
              return;
            }
            this.checkBOM = false;
            break;
          case 3:
            if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
              this.buffer = Buffer.alloc(0);
              this.checkBOM = false;
              callback();
              return;
            }
            this.checkBOM = false;
            break;
          default:
            if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
              this.buffer = this.buffer.subarray(3);
            }
            this.checkBOM = false;
            break;
        }
      }
      while (this.pos < this.buffer.length) {
        if (this.eventEndCheck) {
          if (this.crlfCheck) {
            if (this.buffer[this.pos] === LF) {
              this.buffer = this.buffer.subarray(this.pos + 1);
              this.pos = 0;
              this.crlfCheck = false;
              continue;
            }
            this.crlfCheck = false;
          }
          if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
            if (this.buffer[this.pos] === CR) {
              this.crlfCheck = true;
            }
            this.buffer = this.buffer.subarray(this.pos + 1);
            this.pos = 0;
            if (this.event.data !== void 0 || this.event.event || this.event.id || this.event.retry) {
              this.processEvent(this.event);
            }
            this.clearEvent();
            continue;
          }
          this.eventEndCheck = false;
          continue;
        }
        if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
          if (this.buffer[this.pos] === CR) {
            this.crlfCheck = true;
          }
          this.parseLine(this.buffer.subarray(0, this.pos), this.event);
          this.buffer = this.buffer.subarray(this.pos + 1);
          this.pos = 0;
          this.eventEndCheck = true;
          continue;
        }
        this.pos++;
      }
      callback();
    }
    /**
     * @param {Buffer} line
     * @param {EventStreamEvent} event
     */
    parseLine(line, event) {
      if (line.length === 0) {
        return;
      }
      const colonPosition = line.indexOf(COLON);
      if (colonPosition === 0) {
        return;
      }
      let field = "";
      let value = "";
      if (colonPosition !== -1) {
        field = line.subarray(0, colonPosition).toString("utf8");
        let valueStart = colonPosition + 1;
        if (line[valueStart] === SPACE) {
          ++valueStart;
        }
        value = line.subarray(valueStart).toString("utf8");
      } else {
        field = line.toString("utf8");
        value = "";
      }
      switch (field) {
        case "data":
          if (event[field] === void 0) {
            event[field] = value;
          } else {
            event[field] += `
${value}`;
          }
          break;
        case "retry":
          if (isASCIINumber(value)) {
            event[field] = value;
          }
          break;
        case "id":
          if (isValidLastEventId(value)) {
            event[field] = value;
          }
          break;
        case "event":
          if (value.length > 0) {
            event[field] = value;
          }
          break;
      }
    }
    /**
     * @param {EventSourceStreamEvent} event
     */
    processEvent(event) {
      if (event.retry && isASCIINumber(event.retry)) {
        this.state.reconnectionTime = parseInt(event.retry, 10);
      }
      if (event.id && isValidLastEventId(event.id)) {
        this.state.lastEventId = event.id;
      }
      if (event.data !== void 0) {
        this.push({
          type: event.event || "message",
          options: {
            data: event.data,
            lastEventId: this.state.lastEventId,
            origin: this.state.origin
          }
        });
      }
    }
    clearEvent() {
      this.event = {
        data: void 0,
        event: void 0,
        id: void 0,
        retry: void 0
      };
    }
  }
  eventsourceStream = {
    EventSourceStream
  };
  return eventsourceStream;
}
var eventsource;
var hasRequiredEventsource;
function requireEventsource() {
  var _events, _url, _withCredentials, _readyState, _request, _controller4, _dispatcher2, _state3, _EventSource_instances, connect_fn, reconnect_fn;
  if (hasRequiredEventsource) return eventsource;
  hasRequiredEventsource = 1;
  const { pipeline: pipeline2 } = require$$0$4;
  const { fetching } = requireFetch();
  const { makeRequest } = requireRequest();
  const { webidl } = requireWebidl();
  const { EventSourceStream } = requireEventsourceStream();
  const { parseMIMEType: parseMIMEType2 } = requireDataUrl();
  const { createFastMessageEvent } = requireEvents();
  const { isNetworkError } = requireResponse();
  const { delay } = requireUtil();
  const { kEnumerableProperty: kEnumerableProperty2 } = util$n;
  const { environmentSettingsObject } = requireUtil$5();
  let experimentalWarned2 = false;
  const defaultReconnectionTime = 3e3;
  const CONNECTING = 0;
  const OPEN = 1;
  const CLOSED = 2;
  const ANONYMOUS = "anonymous";
  const USE_CREDENTIALS = "use-credentials";
  const _EventSource = class _EventSource extends EventTarget {
    /**
     * Creates a new EventSource object.
     * @param {string} url
     * @param {EventSourceInit} [eventSourceInitDict]
     * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface
     */
    constructor(url, eventSourceInitDict = {}) {
      super();
      __privateAdd(this, _EventSource_instances);
      __privateAdd(this, _events, {
        open: null,
        error: null,
        message: null
      });
      __privateAdd(this, _url, null);
      __privateAdd(this, _withCredentials, false);
      __privateAdd(this, _readyState, CONNECTING);
      __privateAdd(this, _request, null);
      __privateAdd(this, _controller4, null);
      __privateAdd(this, _dispatcher2);
      /**
       * @type {import('./eventsource-stream').eventSourceSettings}
       */
      __privateAdd(this, _state3);
      webidl.util.markAsUncloneable(this);
      const prefix = "EventSource constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      if (!experimentalWarned2) {
        experimentalWarned2 = true;
        process.emitWarning("EventSource is experimental, expect them to change at any time.", {
          code: "UNDICI-ES"
        });
      }
      url = webidl.converters.USVString(url, prefix, "url");
      eventSourceInitDict = webidl.converters.EventSourceInitDict(eventSourceInitDict, prefix, "eventSourceInitDict");
      __privateSet(this, _dispatcher2, eventSourceInitDict.dispatcher);
      __privateSet(this, _state3, {
        lastEventId: "",
        reconnectionTime: defaultReconnectionTime
      });
      const settings = environmentSettingsObject;
      let urlRecord;
      try {
        urlRecord = new URL(url, settings.settingsObject.baseUrl);
        __privateGet(this, _state3).origin = urlRecord.origin;
      } catch (e) {
        throw new DOMException(e, "SyntaxError");
      }
      __privateSet(this, _url, urlRecord.href);
      let corsAttributeState = ANONYMOUS;
      if (eventSourceInitDict.withCredentials) {
        corsAttributeState = USE_CREDENTIALS;
        __privateSet(this, _withCredentials, true);
      }
      const initRequest = {
        redirect: "follow",
        keepalive: true,
        // @see https://html.spec.whatwg.org/multipage/urls-and-fetching.html#cors-settings-attributes
        mode: "cors",
        credentials: corsAttributeState === "anonymous" ? "same-origin" : "omit",
        referrer: "no-referrer"
      };
      initRequest.client = environmentSettingsObject.settingsObject;
      initRequest.headersList = [["accept", { name: "accept", value: "text/event-stream" }]];
      initRequest.cache = "no-store";
      initRequest.initiator = "other";
      initRequest.urlList = [new URL(__privateGet(this, _url))];
      __privateSet(this, _request, makeRequest(initRequest));
      __privateMethod(this, _EventSource_instances, connect_fn).call(this);
    }
    /**
     * Returns the state of this EventSource object's connection. It can have the
     * values described below.
     * @returns {0|1|2}
     * @readonly
     */
    get readyState() {
      return __privateGet(this, _readyState);
    }
    /**
     * Returns the URL providing the event stream.
     * @readonly
     * @returns {string}
     */
    get url() {
      return __privateGet(this, _url);
    }
    /**
     * Returns a boolean indicating whether the EventSource object was
     * instantiated with CORS credentials set (true), or not (false, the default).
     */
    get withCredentials() {
      return __privateGet(this, _withCredentials);
    }
    /**
     * Closes the connection, if any, and sets the readyState attribute to
     * CLOSED.
     */
    close() {
      webidl.brandCheck(this, _EventSource);
      if (__privateGet(this, _readyState) === CLOSED) return;
      __privateSet(this, _readyState, CLOSED);
      __privateGet(this, _controller4).abort();
      __privateSet(this, _request, null);
    }
    get onopen() {
      return __privateGet(this, _events).open;
    }
    set onopen(fn) {
      if (__privateGet(this, _events).open) {
        this.removeEventListener("open", __privateGet(this, _events).open);
      }
      if (typeof fn === "function") {
        __privateGet(this, _events).open = fn;
        this.addEventListener("open", fn);
      } else {
        __privateGet(this, _events).open = null;
      }
    }
    get onmessage() {
      return __privateGet(this, _events).message;
    }
    set onmessage(fn) {
      if (__privateGet(this, _events).message) {
        this.removeEventListener("message", __privateGet(this, _events).message);
      }
      if (typeof fn === "function") {
        __privateGet(this, _events).message = fn;
        this.addEventListener("message", fn);
      } else {
        __privateGet(this, _events).message = null;
      }
    }
    get onerror() {
      return __privateGet(this, _events).error;
    }
    set onerror(fn) {
      if (__privateGet(this, _events).error) {
        this.removeEventListener("error", __privateGet(this, _events).error);
      }
      if (typeof fn === "function") {
        __privateGet(this, _events).error = fn;
        this.addEventListener("error", fn);
      } else {
        __privateGet(this, _events).error = null;
      }
    }
  };
  _events = new WeakMap();
  _url = new WeakMap();
  _withCredentials = new WeakMap();
  _readyState = new WeakMap();
  _request = new WeakMap();
  _controller4 = new WeakMap();
  _dispatcher2 = new WeakMap();
  _state3 = new WeakMap();
  _EventSource_instances = new WeakSet();
  connect_fn = function() {
    if (__privateGet(this, _readyState) === CLOSED) return;
    __privateSet(this, _readyState, CONNECTING);
    const fetchParams = {
      request: __privateGet(this, _request),
      dispatcher: __privateGet(this, _dispatcher2)
    };
    const processEventSourceEndOfBody = (response2) => {
      if (isNetworkError(response2)) {
        this.dispatchEvent(new Event("error"));
        this.close();
      }
      __privateMethod(this, _EventSource_instances, reconnect_fn).call(this);
    };
    fetchParams.processResponseEndOfBody = processEventSourceEndOfBody;
    fetchParams.processResponse = (response2) => {
      if (isNetworkError(response2)) {
        if (response2.aborted) {
          this.close();
          this.dispatchEvent(new Event("error"));
          return;
        } else {
          __privateMethod(this, _EventSource_instances, reconnect_fn).call(this);
          return;
        }
      }
      const contentType = response2.headersList.get("content-type", true);
      const mimeType = contentType !== null ? parseMIMEType2(contentType) : "failure";
      const contentTypeValid = mimeType !== "failure" && mimeType.essence === "text/event-stream";
      if (response2.status !== 200 || contentTypeValid === false) {
        this.close();
        this.dispatchEvent(new Event("error"));
        return;
      }
      __privateSet(this, _readyState, OPEN);
      this.dispatchEvent(new Event("open"));
      __privateGet(this, _state3).origin = response2.urlList[response2.urlList.length - 1].origin;
      const eventSourceStream = new EventSourceStream({
        eventSourceSettings: __privateGet(this, _state3),
        push: (event) => {
          this.dispatchEvent(createFastMessageEvent(
            event.type,
            event.options
          ));
        }
      });
      pipeline2(
        response2.body.stream,
        eventSourceStream,
        (error) => {
          if ((error == null ? void 0 : error.aborted) === false) {
            this.close();
            this.dispatchEvent(new Event("error"));
          }
        }
      );
    };
    __privateSet(this, _controller4, fetching(fetchParams));
  };
  reconnect_fn = async function() {
    if (__privateGet(this, _readyState) === CLOSED) return;
    __privateSet(this, _readyState, CONNECTING);
    this.dispatchEvent(new Event("error"));
    await delay(__privateGet(this, _state3).reconnectionTime);
    if (__privateGet(this, _readyState) !== CONNECTING) return;
    if (__privateGet(this, _state3).lastEventId.length) {
      __privateGet(this, _request).headersList.set("last-event-id", __privateGet(this, _state3).lastEventId, true);
    }
    __privateMethod(this, _EventSource_instances, connect_fn).call(this);
  };
  let EventSource2 = _EventSource;
  const constantsPropertyDescriptors = {
    CONNECTING: {
      __proto__: null,
      configurable: false,
      enumerable: true,
      value: CONNECTING,
      writable: false
    },
    OPEN: {
      __proto__: null,
      configurable: false,
      enumerable: true,
      value: OPEN,
      writable: false
    },
    CLOSED: {
      __proto__: null,
      configurable: false,
      enumerable: true,
      value: CLOSED,
      writable: false
    }
  };
  Object.defineProperties(EventSource2, constantsPropertyDescriptors);
  Object.defineProperties(EventSource2.prototype, constantsPropertyDescriptors);
  Object.defineProperties(EventSource2.prototype, {
    close: kEnumerableProperty2,
    onerror: kEnumerableProperty2,
    onmessage: kEnumerableProperty2,
    onopen: kEnumerableProperty2,
    readyState: kEnumerableProperty2,
    url: kEnumerableProperty2,
    withCredentials: kEnumerableProperty2
  });
  webidl.converters.EventSourceInitDict = webidl.dictionaryConverter([
    {
      key: "withCredentials",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "dispatcher",
      // undici only
      converter: webidl.converters.any
    }
  ]);
  eventsource = {
    EventSource: EventSource2,
    defaultReconnectionTime
  };
  return eventsource;
}
const Client3 = client;
const Dispatcher3 = dispatcher;
const Pool3 = pool;
const BalancedPool3 = balancedPool;
const Agent3 = agent$1;
const ProxyAgent$1 = proxyAgent;
const EnvHttpProxyAgent = envHttpProxyAgent;
const RetryAgent = retryAgent;
const errors = errors$1;
const util = util$n;
const { InvalidArgumentError: InvalidArgumentError3 } = errors;
const api = api$1;
const buildConnector = connect$3;
const MockClient3 = mockClient;
const MockAgent3 = mockAgent;
const MockPool3 = mockPool;
const mockErrors = mockErrors$1;
const RetryHandler3 = retryHandler;
const { getGlobalDispatcher, setGlobalDispatcher } = global$1;
const DecoratorHandler = decoratorHandler;
const RedirectHandler3 = redirectHandler;
const createRedirectInterceptor = redirectInterceptor;
Object.assign(Dispatcher3.prototype, api);
undici$1.Dispatcher = Dispatcher3;
undici$1.Client = Client3;
undici$1.Pool = Pool3;
undici$1.BalancedPool = BalancedPool3;
undici$1.Agent = Agent3;
undici$1.ProxyAgent = ProxyAgent$1;
undici$1.EnvHttpProxyAgent = EnvHttpProxyAgent;
undici$1.RetryAgent = RetryAgent;
undici$1.RetryHandler = RetryHandler3;
undici$1.DecoratorHandler = DecoratorHandler;
undici$1.RedirectHandler = RedirectHandler3;
undici$1.createRedirectInterceptor = createRedirectInterceptor;
undici$1.interceptors = {
  redirect,
  retry,
  dump,
  dns
};
undici$1.buildConnector = buildConnector;
undici$1.errors = errors;
undici$1.util = {
  parseHeaders: util.parseHeaders,
  headerNameToString: util.headerNameToString
};
function makeDispatcher(fn) {
  return (url, opts, handler) => {
    if (typeof opts === "function") {
      handler = opts;
      opts = null;
    }
    if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
      throw new InvalidArgumentError3("invalid url");
    }
    if (opts != null && typeof opts !== "object") {
      throw new InvalidArgumentError3("invalid opts");
    }
    if (opts && opts.path != null) {
      if (typeof opts.path !== "string") {
        throw new InvalidArgumentError3("invalid opts.path");
      }
      let path2 = opts.path;
      if (!opts.path.startsWith("/")) {
        path2 = `/${path2}`;
      }
      url = new URL(util.parseOrigin(url).origin + path2);
    } else {
      if (!opts) {
        opts = typeof url === "object" ? url : {};
      }
      url = util.parseURL(url);
    }
    const { agent: agent2, dispatcher: dispatcher2 = getGlobalDispatcher() } = opts;
    if (agent2) {
      throw new InvalidArgumentError3("unsupported opts.agent. Did you mean opts.client?");
    }
    return fn.call(dispatcher2, {
      ...opts,
      origin: url.origin,
      path: url.search ? `${url.pathname}${url.search}` : url.pathname,
      method: opts.method || (opts.body ? "PUT" : "GET")
    }, handler);
  };
}
undici$1.setGlobalDispatcher = setGlobalDispatcher;
undici$1.getGlobalDispatcher = getGlobalDispatcher;
const fetchImpl = requireFetch().fetch;
undici$1.fetch = async function fetch(init, options = void 0) {
  try {
    return await fetchImpl(init, options);
  } catch (err) {
    if (err && typeof err === "object") {
      Error.captureStackTrace(err);
    }
    throw err;
  }
};
undici$1.Headers = requireHeaders().Headers;
undici$1.Response = requireResponse().Response;
undici$1.Request = requireRequest().Request;
undici$1.FormData = requireFormdata().FormData;
undici$1.File = globalThis.File ?? require$$0$1.File;
undici$1.FileReader = requireFilereader().FileReader;
const { setGlobalOrigin, getGlobalOrigin } = requireGlobal();
undici$1.setGlobalOrigin = setGlobalOrigin;
undici$1.getGlobalOrigin = getGlobalOrigin;
const { CacheStorage } = requireCachestorage();
const { kConstruct } = requireSymbols$1();
undici$1.caches = new CacheStorage(kConstruct);
const { deleteCookie, getCookies, getSetCookies, setCookie } = requireCookies();
undici$1.deleteCookie = deleteCookie;
undici$1.getCookies = getCookies;
undici$1.getSetCookies = getSetCookies;
undici$1.setCookie = setCookie;
const { parseMIMEType, serializeAMimeType } = requireDataUrl();
undici$1.parseMIMEType = parseMIMEType;
undici$1.serializeAMimeType = serializeAMimeType;
const { CloseEvent, ErrorEvent, MessageEvent } = requireEvents();
undici$1.WebSocket = requireWebsocket().WebSocket;
undici$1.CloseEvent = CloseEvent;
undici$1.ErrorEvent = ErrorEvent;
undici$1.MessageEvent = MessageEvent;
undici$1.request = makeDispatcher(api.request);
undici$1.stream = makeDispatcher(api.stream);
undici$1.pipeline = makeDispatcher(api.pipeline);
undici$1.connect = makeDispatcher(api.connect);
undici$1.upgrade = makeDispatcher(api.upgrade);
undici$1.MockClient = MockClient3;
undici$1.MockPool = MockPool3;
undici$1.MockAgent = MockAgent3;
undici$1.mockErrors = mockErrors;
const { EventSource } = requireEventsource();
undici$1.EventSource = EventSource;
var validate_cookie_options = {};
Object.defineProperty(validate_cookie_options, "__esModule", {
  value: true
});
validate_cookie_options.validateCookieOptions = validateCookieOptions;
function validateCookieOptions(opts) {
  if (!("jar" in opts)) {
    throw new TypeError("invalid cookies.jar");
  }
  if (!opts.jar.store.synchronous) {
    throw new TypeError("an asynchronous cookie store is not supported.");
  }
}
var cookie_client = {};
var create_cookie_header_value = {};
Object.defineProperty(create_cookie_header_value, "__esModule", {
  value: true
});
create_cookie_header_value.createCookieHeaderValue = createCookieHeaderValue;
var _toughCookie = cookie$1;
function createCookieHeaderValue({
  cookieOptions,
  passedValues,
  requestUrl
}) {
  const {
    jar
  } = cookieOptions;
  const cookies2 = jar.getCookiesSync(requestUrl);
  const cookiesMap = new Map(cookies2.map((cookie2) => [cookie2.key, cookie2]));
  for (const passedValue of passedValues) {
    if (typeof passedValue !== "string") {
      continue;
    }
    for (const str of passedValue.split(";")) {
      const cookie2 = _toughCookie.Cookie.parse(str.trim());
      if (cookie2 != null) {
        cookiesMap.set(cookie2.key, cookie2);
      }
    }
  }
  const cookieHeaderValue = Array.from(cookiesMap.values()).map((cookie2) => cookie2.cookieString()).join("; ");
  return cookieHeaderValue;
}
var cookie_handler = {};
var save_cookies_from_header = {};
Object.defineProperty(save_cookies_from_header, "__esModule", {
  value: true
});
save_cookies_from_header.saveCookiesFromHeader = saveCookiesFromHeader;
function saveCookiesFromHeader({
  cookieOptions,
  cookies: cookies2,
  requestUrl
}) {
  const {
    jar
  } = cookieOptions;
  for (const cookie2 of [cookies2].flat()) {
    if (cookie2 == null) {
      continue;
    }
    jar.setCookieSync(cookie2, requestUrl, {
      ignoreError: true
    });
  }
}
var convert_to_headers_object = {};
Object.defineProperty(convert_to_headers_object, "__esModule", {
  value: true
});
convert_to_headers_object.convertToHeadersObject = convertToHeadersObject;
var _undici$3 = undici$1;
function isIterable(value) {
  return typeof value === "object" && value != null && Symbol.iterator in value;
}
function convertToHeadersObject(_headers2) {
  const headers2 = {};
  if (Array.isArray(_headers2)) {
    if (_headers2.length % 2 !== 0) {
      throw new _undici$3.errors.InvalidArgumentError("headers array must be even");
    }
    for (let idx = 0; idx < _headers2.length; idx += 2) {
      const key = _headers2[idx];
      const value = _headers2[idx + 1];
      if (key != null && value != null) {
        const keyStr = (Buffer.isBuffer(key) ? key.toString("utf-8") : key).toLowerCase();
        const valueStr = Buffer.isBuffer(value) ? value.toString("utf-8") : value;
        if (keyStr === "set-cookie") {
          headers2[keyStr] = [...headers2[keyStr] ?? [], valueStr];
        } else {
          headers2[keyStr] = valueStr;
        }
      }
    }
  } else if (isIterable(_headers2)) {
    for (const [key, value] of _headers2) {
      headers2[key.toLowerCase()] = value;
    }
  } else if (_headers2 != null) {
    for (const [key, value] of Object.entries(_headers2)) {
      headers2[key.toLowerCase()] = value;
    }
  }
  return headers2;
}
Object.defineProperty(cookie_handler, "__esModule", {
  value: true
});
cookie_handler.CookieHandler = void 0;
var _undici$2 = undici$1;
var _save_cookies_from_header = save_cookies_from_header;
var _convert_to_headers_object$1 = convert_to_headers_object;
const kRequestUrl = Symbol("requestUrl");
const kCookieOptions$1 = Symbol("cookieOptions");
const kHandlers = Symbol("handlers");
class CookieHandler {
  constructor(requestUrl, cookieOptions, handlers) {
    __publicField(this, "onResponseStarted", () => {
      var _a2, _b2;
      (_b2 = (_a2 = this[kHandlers]).onResponseStarted) == null ? void 0 : _b2.call(_a2);
    });
    __publicField(this, "onConnect", (abort2) => {
      var _a2, _b2;
      (_b2 = (_a2 = this[kHandlers]).onConnect) == null ? void 0 : _b2.call(_a2, abort2);
    });
    __publicField(this, "onError", (err) => {
      var _a2, _b2;
      (_b2 = (_a2 = this[kHandlers]).onError) == null ? void 0 : _b2.call(_a2, err);
    });
    __publicField(this, "onUpgrade", (statusCode, headers2, socket) => {
      var _a2, _b2;
      (_b2 = (_a2 = this[kHandlers]).onUpgrade) == null ? void 0 : _b2.call(_a2, statusCode, headers2, socket);
    });
    __publicField(this, "onHeaders", (statusCode, _headers2, resume2, statusText) => {
      if (this[kHandlers].onHeaders == null) {
        throw new _undici$2.errors.InvalidArgumentError("invalid onHeaders method");
      }
      const headers2 = (0, _convert_to_headers_object$1.convertToHeadersObject)(_headers2);
      (0, _save_cookies_from_header.saveCookiesFromHeader)({
        cookieOptions: this[kCookieOptions$1],
        cookies: headers2["set-cookie"],
        requestUrl: this[kRequestUrl]
      });
      return this[kHandlers].onHeaders(statusCode, _headers2, resume2, statusText);
    });
    __publicField(this, "onData", (chunk) => {
      if (this[kHandlers].onData == null) {
        throw new _undici$2.errors.InvalidArgumentError("invalid onData method");
      }
      return this[kHandlers].onData(chunk);
    });
    __publicField(this, "onComplete", (trailers) => {
      var _a2, _b2;
      (_b2 = (_a2 = this[kHandlers]).onComplete) == null ? void 0 : _b2.call(_a2, trailers);
    });
    __publicField(this, "onBodySent", (chunkSize, totalBytesSent) => {
      var _a2, _b2;
      (_b2 = (_a2 = this[kHandlers]).onBodySent) == null ? void 0 : _b2.call(_a2, chunkSize, totalBytesSent);
    });
    this[kRequestUrl] = requestUrl;
    this[kCookieOptions$1] = cookieOptions;
    this[kHandlers] = handlers;
  }
}
cookie_handler.CookieHandler = CookieHandler;
Object.defineProperty(cookie_client, "__esModule", {
  value: true
});
cookie_client.CookieClient = void 0;
cookie_client.createCookieClient = createCookieClient;
var _undici$1 = undici$1;
var _symbols = _interopRequireDefault(symbols$4);
var _create_cookie_header_value = create_cookie_header_value;
var _validate_cookie_options$1 = validate_cookie_options;
var _cookie_handler = cookie_handler;
var _convert_to_headers_object = convert_to_headers_object;
function _interopRequireDefault(e) {
  return e && e.__esModule ? e : { default: e };
}
const kCookieOptions = Symbol("cookieOptions");
function createCookieClient(BaseClientClass) {
  class CookieClient2 extends BaseClientClass {
    constructor(url, {
      cookies: cookieOpts,
      ...options
    } = {}) {
      super(url, options);
      if (cookieOpts) {
        (0, _validate_cookie_options$1.validateCookieOptions)(cookieOpts);
        this[kCookieOptions] = cookieOpts;
      }
    }
    [_symbols.default.kDispatch](opts, handler) {
      const {
        maxRedirections = this[_symbols.default.kMaxRedirections]
      } = opts;
      if (maxRedirections) {
        opts = {
          ...opts,
          maxRedirections: 0
        };
        handler = new _undici$1.RedirectHandler(this, maxRedirections, opts, handler, false);
      }
      const cookieOptions = this[kCookieOptions];
      if (cookieOptions) {
        const origin = opts.origin || this[_symbols.default.kUrl].origin;
        const requestUrl = new URL(opts.path, origin).toString();
        const headers2 = (0, _convert_to_headers_object.convertToHeadersObject)(opts.headers);
        const cookieHeader = (0, _create_cookie_header_value.createCookieHeaderValue)({
          cookieOptions,
          passedValues: [headers2["cookie"]].flat(),
          requestUrl
        });
        if (cookieHeader) {
          headers2["cookie"] = cookieHeader;
        }
        opts = {
          ...opts,
          headers: headers2
        };
        handler = new _cookie_handler.CookieHandler(requestUrl, cookieOptions, handler);
      }
      return super[_symbols.default.kDispatch](opts, handler);
    }
  }
  return CookieClient2;
}
cookie_client.CookieClient = createCookieClient(_undici$1.Client);
Object.defineProperty(cookie_agent, "__esModule", {
  value: true
});
cookie_agent.CookieAgent = void 0;
var _undici = undici$1;
var _validate_cookie_options = validate_cookie_options;
var _cookie_client = cookie_client;
let CookieAgent$1 = class CookieAgent extends _undici.Agent {
  constructor({
    cookies: cookieOpts,
    ...agentOpts
  } = {}) {
    if (agentOpts.factory) {
      throw new _undici.errors.InvalidArgumentError("factory function cannot set via CookieAgent");
    }
    if (cookieOpts) {
      (0, _validate_cookie_options.validateCookieOptions)(cookieOpts);
    }
    function factory(origin, opts) {
      if (opts && opts.connections === 1) {
        return new _cookie_client.CookieClient(origin, {
          ...opts,
          cookies: cookieOpts
        });
      } else {
        return new _undici.Pool(origin, {
          ...opts,
          factory: (origin2, opts2) => {
            return new _cookie_client.CookieClient(origin2, {
              ...opts2,
              cookies: cookieOpts
            });
          }
        });
      }
    }
    super({
      ...agentOpts,
      factory
    });
  }
};
cookie_agent.CookieAgent = CookieAgent$1;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "CookieAgent", {
    enumerable: true,
    get: function() {
      return _cookie_agent.CookieAgent;
    }
  });
  Object.defineProperty(exports, "CookieClient", {
    enumerable: true,
    get: function() {
      return _cookie_client2.CookieClient;
    }
  });
  Object.defineProperty(exports, "createCookieClient", {
    enumerable: true,
    get: function() {
      return _cookie_client2.createCookieClient;
    }
  });
  var _cookie_agent = cookie_agent;
  var _cookie_client2 = cookie_client;
})(undici$2);
var undici = undici$2;
const { ProxyAgent } = undiciExports;
const { HttpsProxyAgent: HttpsProxyAgent2 } = dist$3;
const { Cookie: Cookie2, CookieJar: CookieJar2, canonicalDomain } = cookie$1;
const { CookieAgent: CookieAgent2, CookieClient } = undici;
const convertSameSite = (sameSite) => {
  switch (sameSite) {
    case "strict":
      return "strict";
    case "lax":
      return "lax";
    case "no_restriction":
    case "unspecified":
    default:
      return "none";
  }
};
const convertCookie = (cookie2) => cookie2 instanceof Cookie2 ? cookie2 : new Cookie2({
  key: cookie2.name,
  value: cookie2.value,
  expires: typeof cookie2.expirationDate === "number" ? new Date(cookie2.expirationDate * 1e3) : "Infinity",
  domain: canonicalDomain(cookie2.domain),
  path: cookie2.path,
  secure: cookie2.secure,
  httpOnly: cookie2.httpOnly,
  sameSite: convertSameSite(cookie2.sameSite),
  hostOnly: cookie2.hostOnly
});
const addCookies = agent$2.addCookies = (jar, cookies2) => {
  if (!cookies2 || !Array.isArray(cookies2)) {
    throw new Error("cookies must be an array");
  }
  if (!cookies2.some((c) => c.name === "SOCS")) {
    cookies2.push({
      domain: ".youtube.com",
      hostOnly: false,
      httpOnly: false,
      name: "SOCS",
      path: "/",
      sameSite: "lax",
      secure: true,
      session: false,
      value: "CAI"
    });
  }
  for (const cookie2 of cookies2) {
    jar.setCookieSync(convertCookie(cookie2), "https://www.youtube.com");
  }
};
agent$2.addCookiesFromString = (jar, cookies2) => {
  if (!cookies2 || typeof cookies2 !== "string") {
    throw new Error("cookies must be a string");
  }
  return addCookies(
    jar,
    cookies2.split(";").map((c) => Cookie2.parse(c)).filter(Boolean)
  );
};
const createAgent = agent$2.createAgent = (cookies2 = [], opts = {}) => {
  const options = Object.assign({}, opts);
  if (!options.cookies) {
    const jar = new CookieJar2();
    addCookies(jar, cookies2);
    options.cookies = { jar };
  }
  return {
    dispatcher: new CookieAgent2(options),
    localAddress: options.localAddress,
    jar: options.cookies.jar
  };
};
agent$2.createProxyAgent = (options, cookies2 = []) => {
  if (!cookies2) cookies2 = [];
  if (typeof options === "string") options = { uri: options };
  if (options.factory) throw new Error("Cannot use factory with createProxyAgent");
  const jar = new CookieJar2();
  addCookies(jar, cookies2);
  const proxyOptions = Object.assign(
    {
      factory: (origin, opts) => {
        const o = Object.assign({ cookies: { jar } }, opts);
        return new CookieClient(origin, o);
      }
    },
    options
  );
  const agent2 = new HttpsProxyAgent2(options.uri);
  const dispatcher2 = new ProxyAgent(proxyOptions);
  return { dispatcher: dispatcher2, agent: agent2, jar, localAddress: options.localAddress };
};
agent$2.defaultAgent = createAgent();
const version = "4.16.5";
const require$$8 = {
  version
};
(function(exports) {
  const { request: request2 } = undiciExports;
  const { writeFileSync } = fs;
  const AGENT = agent$2;
  const between = exports.between = (haystack, left, right) => {
    let pos;
    if (left instanceof RegExp) {
      const match = haystack.match(left);
      if (!match) {
        return "";
      }
      pos = match.index + match[0].length;
    } else {
      pos = haystack.indexOf(left);
      if (pos === -1) {
        return "";
      }
      pos += left.length;
    }
    haystack = haystack.slice(pos);
    pos = haystack.indexOf(right);
    if (pos === -1) {
      return "";
    }
    haystack = haystack.slice(0, pos);
    return haystack;
  };
  exports.tryParseBetween = (body2, left, right, prepend = "", append = "") => {
    try {
      let data = between(body2, left, right);
      if (!data) return null;
      return JSON.parse(`${prepend}${data}${append}`);
    } catch (e) {
      return null;
    }
  };
  exports.parseAbbreviatedNumber = (string) => {
    const match = string.replace(",", ".").replace(" ", "").match(/([\d,.]+)([MK]?)/);
    if (match) {
      let [, num, multi] = match;
      num = parseFloat(num);
      return Math.round(multi === "M" ? num * 1e6 : multi === "K" ? num * 1e3 : num);
    }
    return null;
  };
  const ESCAPING_SEQUENZES = [
    // Strings
    { start: '"', end: '"' },
    { start: "'", end: "'" },
    { start: "`", end: "`" },
    // RegeEx
    { start: "/", end: "/", startPrefix: /(^|[[{:;,/])\s?$/ }
  ];
  exports.cutAfterJS = (mixedJson) => {
    let open, close;
    if (mixedJson[0] === "[") {
      open = "[";
      close = "]";
    } else if (mixedJson[0] === "{") {
      open = "{";
      close = "}";
    }
    if (!open) {
      throw new Error(`Can't cut unsupported JSON (need to begin with [ or { ) but got: ${mixedJson[0]}`);
    }
    let isEscapedObject = null;
    let isEscaped = false;
    let counter = 0;
    let i;
    for (i = 0; i < mixedJson.length; i++) {
      if (!isEscaped && isEscapedObject !== null && mixedJson[i] === isEscapedObject.end) {
        isEscapedObject = null;
        continue;
      } else if (!isEscaped && isEscapedObject === null) {
        for (const escaped of ESCAPING_SEQUENZES) {
          if (mixedJson[i] !== escaped.start) continue;
          if (!escaped.startPrefix || mixedJson.substring(i - 10, i).match(escaped.startPrefix)) {
            isEscapedObject = escaped;
            break;
          }
        }
        if (isEscapedObject !== null) {
          continue;
        }
      }
      isEscaped = mixedJson[i] === "\\" && !isEscaped;
      if (isEscapedObject !== null) continue;
      if (mixedJson[i] === open) {
        counter++;
      } else if (mixedJson[i] === close) {
        counter--;
      }
      if (counter === 0) {
        return mixedJson.substring(0, i + 1);
      }
    }
    throw Error("Can't cut unsupported JSON (no matching closing bracket found)");
  };
  class UnrecoverableError extends Error {
  }
  exports.playError = (player_response) => {
    var _a2;
    const playability = player_response == null ? void 0 : player_response.playabilityStatus;
    if (!playability) return null;
    if (["ERROR", "LOGIN_REQUIRED"].includes(playability.status)) {
      return new UnrecoverableError(playability.reason || ((_a2 = playability.messages) == null ? void 0 : _a2[0]));
    }
    if (playability.status === "LIVE_STREAM_OFFLINE") {
      return new UnrecoverableError(playability.reason || "The live stream is offline.");
    }
    if (playability.status === "UNPLAYABLE") {
      return new UnrecoverableError(playability.reason || "This video is unavailable.");
    }
    return null;
  };
  const useFetch = async (fetch2, url, requestOptions) => {
    const query = requestOptions.query;
    if (query) {
      const urlObject = new URL(url);
      for (const key in query) {
        urlObject.searchParams.append(key, query[key]);
      }
      url = urlObject.toString();
    }
    const response2 = await fetch2(url, requestOptions);
    const statusCode = response2.status;
    const body2 = Object.assign(response2, response2.body || {});
    const headers2 = Object.fromEntries(response2.headers.entries());
    return { body: body2, statusCode, headers: headers2 };
  };
  exports.request = async (url, options = {}) => {
    let { requestOptions, rewriteRequest, fetch: fetch2 } = options;
    if (typeof rewriteRequest === "function") {
      const rewritten = rewriteRequest(url, requestOptions);
      requestOptions = rewritten.requestOptions || requestOptions;
      url = rewritten.url || url;
    }
    const req2 = typeof fetch2 === "function" ? await useFetch(fetch2, url, requestOptions) : await request2(url, requestOptions);
    const code = req2.statusCode.toString();
    if (code.startsWith("2")) {
      if (req2.headers["content-type"].includes("application/json")) return req2.body.json();
      return req2.body.text();
    }
    if (code.startsWith("3")) return exports.request(req2.headers.location, options);
    const e = new Error(`Status code: ${code}`);
    e.statusCode = req2.statusCode;
    throw e;
  };
  exports.deprecate = (obj, prop, value, oldPath, newPath) => {
    Object.defineProperty(obj, prop, {
      get: () => {
        console.warn(`\`${oldPath}\` will be removed in a near future release, use \`${newPath}\` instead.`);
        return value;
      }
    });
  };
  const pkg = require$$8;
  const UPDATE_INTERVAL = 1e3 * 60 * 60 * 12;
  let updateWarnTimes = 0;
  exports.lastUpdateCheck = 0;
  exports.checkForUpdates = () => {
    if (!process.env.YTDL_NO_UPDATE && !pkg.version.startsWith("0.0.0-") && Date.now() - exports.lastUpdateCheck >= UPDATE_INTERVAL) {
      exports.lastUpdateCheck = Date.now();
      return exports.request("https://api.github.com/repos/distubejs/ytdl-core/contents/package.json", {
        requestOptions: {
          headers: {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.3"
          }
        }
      }).then(
        (response2) => {
          const buf = Buffer.from(response2.content, response2.encoding);
          const pkgFile = JSON.parse(buf.toString("ascii"));
          if (pkgFile.version !== pkg.version && updateWarnTimes++ < 5) {
            console.warn(
              '\x1B[33mWARNING:\x1B[0m @distube/ytdl-core is out of date! Update with "npm install @distube/ytdl-core@latest".'
            );
          }
        },
        (err) => {
          console.warn("Error checking for updates:", err.message);
          console.warn("You can disable this check by setting the `YTDL_NO_UPDATE` env variable.");
        }
      );
    }
    return null;
  };
  const getRandomIPv6 = (ip) => {
    if (!isIPv6(ip)) {
      throw new Error("Invalid IPv6 format");
    }
    const [rawAddr, rawMask] = ip.split("/");
    const mask = parseInt(rawMask, 10);
    if (isNaN(mask) || mask > 128 || mask < 1) {
      throw new Error("Invalid IPv6 subnet mask (must be between 1 and 128)");
    }
    const base10addr = normalizeIP(rawAddr);
    const fullMaskGroups = Math.floor(mask / 16);
    const remainingBits = mask % 16;
    const result = new Array(8).fill(0);
    for (let i = 0; i < 8; i++) {
      if (i < fullMaskGroups) {
        result[i] = base10addr[i];
      } else if (i === fullMaskGroups && remainingBits > 0) {
        const groupMask = 65535 << 16 - remainingBits;
        const randomPart = Math.floor(Math.random() * (1 << 16 - remainingBits));
        result[i] = base10addr[i] & groupMask | randomPart;
      } else {
        result[i] = Math.floor(Math.random() * 65536);
      }
    }
    return result.map((x) => x.toString(16).padStart(4, "0")).join(":");
  };
  const isIPv6 = (ip) => {
    const IPV6_REGEX = /^(?:(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|(?:[0-9a-fA-F]{1,4}:){1,7}:|(?:[0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|(?:[0-9a-fA-F]{1,4}:){1,5}(?::[0-9a-fA-F]{1,4}){1,2}|(?:[0-9a-fA-F]{1,4}:){1,4}(?::[0-9a-fA-F]{1,4}){1,3}|(?:[0-9a-fA-F]{1,4}:){1,3}(?::[0-9a-fA-F]{1,4}){1,4}|(?:[0-9a-fA-F]{1,4}:){1,2}(?::[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:(?:(?::[0-9a-fA-F]{1,4}){1,6})|:(?:(?::[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(?::[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(?:ffff(?::0{1,4}){0,1}:){0,1}(?:(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])|(?:[0-9a-fA-F]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9]))(?:\/(?:1[0-1][0-9]|12[0-8]|[1-9][0-9]|[1-9]))?$/;
    return IPV6_REGEX.test(ip);
  };
  const normalizeIP = (ip) => {
    const parts = ip.split("::");
    let start = parts[0] ? parts[0].split(":") : [];
    let end = parts[1] ? parts[1].split(":") : [];
    const missing = 8 - (start.length + end.length);
    const zeros = new Array(missing).fill("0");
    const full = [...start, ...zeros, ...end];
    return full.map((part) => parseInt(part || "0", 16));
  };
  exports.saveDebugFile = (name, body2) => {
    const filename = `${+/* @__PURE__ */ new Date()}-${name}`;
    writeFileSync(filename, body2);
    return filename;
  };
  const findPropKeyInsensitive = (obj, prop) => Object.keys(obj).find((p) => p.toLowerCase() === prop.toLowerCase()) || null;
  exports.getPropInsensitive = (obj, prop) => {
    const key = findPropKeyInsensitive(obj, prop);
    return key && obj[key];
  };
  exports.setPropInsensitive = (obj, prop, value) => {
    const key = findPropKeyInsensitive(obj, prop);
    obj[key || prop] = value;
    return key;
  };
  let oldCookieWarning = true;
  let oldDispatcherWarning = true;
  exports.applyDefaultAgent = (options) => {
    if (!options.agent) {
      const { jar } = AGENT.defaultAgent;
      const c = exports.getPropInsensitive(options.requestOptions.headers, "cookie");
      if (c) {
        jar.removeAllCookiesSync();
        AGENT.addCookiesFromString(jar, c);
        if (oldCookieWarning) {
          oldCookieWarning = false;
          console.warn(
            "\x1B[33mWARNING:\x1B[0m Using old cookie format, please use the new one instead. (https://github.com/distubejs/ytdl-core#cookies-support)"
          );
        }
      }
      if (options.requestOptions.dispatcher && oldDispatcherWarning) {
        oldDispatcherWarning = false;
        console.warn(
          "\x1B[33mWARNING:\x1B[0m Your dispatcher is overridden by `ytdl.Agent`. To implement your own, check out the documentation. (https://github.com/distubejs/ytdl-core#how-to-implement-ytdlagent-with-your-own-dispatcher)"
        );
      }
      options.agent = AGENT.defaultAgent;
    }
  };
  let oldLocalAddressWarning = true;
  exports.applyOldLocalAddress = (options) => {
    var _a2;
    if (!((_a2 = options == null ? void 0 : options.requestOptions) == null ? void 0 : _a2.localAddress) || options.requestOptions.localAddress === options.agent.localAddress)
      return;
    options.agent = AGENT.createAgent(void 0, { localAddress: options.requestOptions.localAddress });
    if (oldLocalAddressWarning) {
      oldLocalAddressWarning = false;
      console.warn(
        "\x1B[33mWARNING:\x1B[0m Using old localAddress option, please add it to the agent options instead. (https://github.com/distubejs/ytdl-core#ip-rotation)"
      );
    }
  };
  let oldIpRotationsWarning = true;
  exports.applyIPv6Rotations = (options) => {
    if (options.IPv6Block) {
      options.requestOptions = Object.assign({}, options.requestOptions, {
        localAddress: getRandomIPv6(options.IPv6Block)
      });
      if (oldIpRotationsWarning) {
        oldIpRotationsWarning = false;
        oldLocalAddressWarning = false;
        console.warn(
          "\x1B[33mWARNING:\x1B[0m IPv6Block option is deprecated, please create your own ip rotation instead. (https://github.com/distubejs/ytdl-core#ip-rotation)"
        );
      }
    }
  };
  exports.applyDefaultHeaders = (options) => {
    options.requestOptions = Object.assign({}, options.requestOptions);
    options.requestOptions.headers = Object.assign(
      {},
      {
        // eslint-disable-next-line max-len
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.101 Safari/537.36"
      },
      options.requestOptions.headers
    );
  };
  exports.generateClientPlaybackNonce = (length) => {
    const CPN_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
    return Array.from({ length }, () => CPN_CHARS[Math.floor(Math.random() * CPN_CHARS.length)]).join("");
  };
  exports.applyPlayerClients = (options) => {
    if (!options.playerClients || options.playerClients.length === 0) {
      options.playerClients = ["WEB_EMBEDDED", "IOS", "ANDROID", "TV"];
    }
  };
})(utils$5);
var formatUtils$1 = {};
var formats = {
  5: {
    mimeType: 'video/flv; codecs="Sorenson H.283, mp3"',
    qualityLabel: "240p",
    bitrate: 25e4,
    audioBitrate: 64
  },
  6: {
    mimeType: 'video/flv; codecs="Sorenson H.263, mp3"',
    qualityLabel: "270p",
    bitrate: 8e5,
    audioBitrate: 64
  },
  13: {
    mimeType: 'video/3gp; codecs="MPEG-4 Visual, aac"',
    qualityLabel: null,
    bitrate: 5e5,
    audioBitrate: null
  },
  17: {
    mimeType: 'video/3gp; codecs="MPEG-4 Visual, aac"',
    qualityLabel: "144p",
    bitrate: 5e4,
    audioBitrate: 24
  },
  18: {
    mimeType: 'video/mp4; codecs="H.264, aac"',
    qualityLabel: "360p",
    bitrate: 5e5,
    audioBitrate: 96
  },
  22: {
    mimeType: 'video/mp4; codecs="H.264, aac"',
    qualityLabel: "720p",
    bitrate: 2e6,
    audioBitrate: 192
  },
  34: {
    mimeType: 'video/flv; codecs="H.264, aac"',
    qualityLabel: "360p",
    bitrate: 5e5,
    audioBitrate: 128
  },
  35: {
    mimeType: 'video/flv; codecs="H.264, aac"',
    qualityLabel: "480p",
    bitrate: 8e5,
    audioBitrate: 128
  },
  36: {
    mimeType: 'video/3gp; codecs="MPEG-4 Visual, aac"',
    qualityLabel: "240p",
    bitrate: 175e3,
    audioBitrate: 32
  },
  37: {
    mimeType: 'video/mp4; codecs="H.264, aac"',
    qualityLabel: "1080p",
    bitrate: 3e6,
    audioBitrate: 192
  },
  38: {
    mimeType: 'video/mp4; codecs="H.264, aac"',
    qualityLabel: "3072p",
    bitrate: 35e5,
    audioBitrate: 192
  },
  43: {
    mimeType: 'video/webm; codecs="VP8, vorbis"',
    qualityLabel: "360p",
    bitrate: 5e5,
    audioBitrate: 128
  },
  44: {
    mimeType: 'video/webm; codecs="VP8, vorbis"',
    qualityLabel: "480p",
    bitrate: 1e6,
    audioBitrate: 128
  },
  45: {
    mimeType: 'video/webm; codecs="VP8, vorbis"',
    qualityLabel: "720p",
    bitrate: 2e6,
    audioBitrate: 192
  },
  46: {
    mimeType: 'audio/webm; codecs="vp8, vorbis"',
    qualityLabel: "1080p",
    bitrate: null,
    audioBitrate: 192
  },
  82: {
    mimeType: 'video/mp4; codecs="H.264, aac"',
    qualityLabel: "360p",
    bitrate: 5e5,
    audioBitrate: 96
  },
  83: {
    mimeType: 'video/mp4; codecs="H.264, aac"',
    qualityLabel: "240p",
    bitrate: 5e5,
    audioBitrate: 96
  },
  84: {
    mimeType: 'video/mp4; codecs="H.264, aac"',
    qualityLabel: "720p",
    bitrate: 2e6,
    audioBitrate: 192
  },
  85: {
    mimeType: 'video/mp4; codecs="H.264, aac"',
    qualityLabel: "1080p",
    bitrate: 3e6,
    audioBitrate: 192
  },
  91: {
    mimeType: 'video/ts; codecs="H.264, aac"',
    qualityLabel: "144p",
    bitrate: 1e5,
    audioBitrate: 48
  },
  92: {
    mimeType: 'video/ts; codecs="H.264, aac"',
    qualityLabel: "240p",
    bitrate: 15e4,
    audioBitrate: 48
  },
  93: {
    mimeType: 'video/ts; codecs="H.264, aac"',
    qualityLabel: "360p",
    bitrate: 5e5,
    audioBitrate: 128
  },
  94: {
    mimeType: 'video/ts; codecs="H.264, aac"',
    qualityLabel: "480p",
    bitrate: 8e5,
    audioBitrate: 128
  },
  95: {
    mimeType: 'video/ts; codecs="H.264, aac"',
    qualityLabel: "720p",
    bitrate: 15e5,
    audioBitrate: 256
  },
  96: {
    mimeType: 'video/ts; codecs="H.264, aac"',
    qualityLabel: "1080p",
    bitrate: 25e5,
    audioBitrate: 256
  },
  100: {
    mimeType: 'audio/webm; codecs="VP8, vorbis"',
    qualityLabel: "360p",
    bitrate: null,
    audioBitrate: 128
  },
  101: {
    mimeType: 'audio/webm; codecs="VP8, vorbis"',
    qualityLabel: "360p",
    bitrate: null,
    audioBitrate: 192
  },
  102: {
    mimeType: 'audio/webm; codecs="VP8, vorbis"',
    qualityLabel: "720p",
    bitrate: null,
    audioBitrate: 192
  },
  120: {
    mimeType: 'video/flv; codecs="H.264, aac"',
    qualityLabel: "720p",
    bitrate: 2e6,
    audioBitrate: 128
  },
  127: {
    mimeType: 'audio/ts; codecs="aac"',
    qualityLabel: null,
    bitrate: null,
    audioBitrate: 96
  },
  128: {
    mimeType: 'audio/ts; codecs="aac"',
    qualityLabel: null,
    bitrate: null,
    audioBitrate: 96
  },
  132: {
    mimeType: 'video/ts; codecs="H.264, aac"',
    qualityLabel: "240p",
    bitrate: 15e4,
    audioBitrate: 48
  },
  133: {
    mimeType: 'video/mp4; codecs="H.264"',
    qualityLabel: "240p",
    bitrate: 2e5,
    audioBitrate: null
  },
  134: {
    mimeType: 'video/mp4; codecs="H.264"',
    qualityLabel: "360p",
    bitrate: 3e5,
    audioBitrate: null
  },
  135: {
    mimeType: 'video/mp4; codecs="H.264"',
    qualityLabel: "480p",
    bitrate: 5e5,
    audioBitrate: null
  },
  136: {
    mimeType: 'video/mp4; codecs="H.264"',
    qualityLabel: "720p",
    bitrate: 1e6,
    audioBitrate: null
  },
  137: {
    mimeType: 'video/mp4; codecs="H.264"',
    qualityLabel: "1080p",
    bitrate: 25e5,
    audioBitrate: null
  },
  138: {
    mimeType: 'video/mp4; codecs="H.264"',
    qualityLabel: "4320p",
    bitrate: 135e5,
    audioBitrate: null
  },
  139: {
    mimeType: 'audio/mp4; codecs="aac"',
    qualityLabel: null,
    bitrate: null,
    audioBitrate: 48
  },
  140: {
    mimeType: 'audio/m4a; codecs="aac"',
    qualityLabel: null,
    bitrate: null,
    audioBitrate: 128
  },
  141: {
    mimeType: 'audio/mp4; codecs="aac"',
    qualityLabel: null,
    bitrate: null,
    audioBitrate: 256
  },
  151: {
    mimeType: 'video/ts; codecs="H.264, aac"',
    qualityLabel: "720p",
    bitrate: 5e4,
    audioBitrate: 24
  },
  160: {
    mimeType: 'video/mp4; codecs="H.264"',
    qualityLabel: "144p",
    bitrate: 1e5,
    audioBitrate: null
  },
  171: {
    mimeType: 'audio/webm; codecs="vorbis"',
    qualityLabel: null,
    bitrate: null,
    audioBitrate: 128
  },
  172: {
    mimeType: 'audio/webm; codecs="vorbis"',
    qualityLabel: null,
    bitrate: null,
    audioBitrate: 192
  },
  231: {
    mimeType: 'video/ts; codecs="H.264, aac"',
    qualityLabel: "480p",
    bitrate: 5e5,
    audioBitrate: null
  },
  232: {
    mimeType: 'video/ts; codecs="H.264, aac"',
    qualityLabel: "720p",
    bitrate: 8e5,
    audioBitrate: null
  },
  242: {
    mimeType: 'video/webm; codecs="VP9"',
    qualityLabel: "240p",
    bitrate: 1e5,
    audioBitrate: null
  },
  243: {
    mimeType: 'video/webm; codecs="VP9"',
    qualityLabel: "360p",
    bitrate: 25e4,
    audioBitrate: null
  },
  244: {
    mimeType: 'video/webm; codecs="VP9"',
    qualityLabel: "480p",
    bitrate: 5e5,
    audioBitrate: null
  },
  247: {
    mimeType: 'video/webm; codecs="VP9"',
    qualityLabel: "720p",
    bitrate: 7e5,
    audioBitrate: null
  },
  248: {
    mimeType: 'video/webm; codecs="VP9"',
    qualityLabel: "1080p",
    bitrate: 15e5,
    audioBitrate: null
  },
  249: {
    mimeType: 'audio/webm; codecs="opus"',
    qualityLabel: null,
    bitrate: null,
    audioBitrate: 48
  },
  250: {
    mimeType: 'audio/webm; codecs="opus"',
    qualityLabel: null,
    bitrate: null,
    audioBitrate: 64
  },
  251: {
    mimeType: 'audio/webm; codecs="opus"',
    qualityLabel: null,
    bitrate: null,
    audioBitrate: 160
  },
  264: {
    mimeType: 'video/mp4; codecs="H.264"',
    qualityLabel: "1440p",
    bitrate: 4e6,
    audioBitrate: null
  },
  266: {
    mimeType: 'video/mp4; codecs="H.264"',
    qualityLabel: "2160p",
    bitrate: 125e5,
    audioBitrate: null
  },
  270: {
    mimeType: 'video/mp4; codecs="H.264"',
    qualityLabel: "1080p",
    bitrate: 25e5,
    audioBitrate: null
  },
  271: {
    mimeType: 'video/webm; codecs="VP9"',
    qualityLabel: "1440p",
    bitrate: 9e6,
    audioBitrate: null
  },
  272: {
    mimeType: 'video/webm; codecs="VP9"',
    qualityLabel: "4320p",
    bitrate: 2e7,
    audioBitrate: null
  },
  278: {
    mimeType: 'video/webm; codecs="VP9"',
    qualityLabel: "144p 30fps",
    bitrate: 8e4,
    audioBitrate: null
  },
  298: {
    mimeType: 'video/mp4; codecs="H.264"',
    qualityLabel: "720p",
    bitrate: 3e6,
    audioBitrate: null
  },
  299: {
    mimeType: 'video/mp4; codecs="H.264"',
    qualityLabel: "1080p",
    bitrate: 55e5,
    audioBitrate: null
  },
  300: {
    mimeType: 'video/ts; codecs="H.264, aac"',
    qualityLabel: "720p",
    bitrate: 1318e3,
    audioBitrate: 48
  },
  301: {
    mimeType: 'video/ts; codecs="H.264, aac"',
    qualityLabel: "1080p",
    bitrate: 3e6,
    audioBitrate: 128
  },
  302: {
    mimeType: 'video/webm; codecs="VP9"',
    qualityLabel: "720p HFR",
    bitrate: 25e5,
    audioBitrate: null
  },
  303: {
    mimeType: 'video/webm; codecs="VP9"',
    qualityLabel: "1080p HFR",
    bitrate: 5e6,
    audioBitrate: null
  },
  308: {
    mimeType: 'video/webm; codecs="VP9"',
    qualityLabel: "1440p HFR",
    bitrate: 1e7,
    audioBitrate: null
  },
  311: {
    mimeType: 'video/webm; codecs="VP9"',
    qualityLabel: "720p",
    bitrate: 125e4,
    audioBitrate: null
  },
  312: {
    mimeType: 'video/mp4; codecs="H.264"',
    qualityLabel: "1080p",
    bitrate: 25e5,
    audioBitrate: null
  },
  313: {
    mimeType: 'video/webm; codecs="VP9"',
    qualityLabel: "2160p",
    bitrate: 13e6,
    audioBitrate: null
  },
  315: {
    mimeType: 'video/webm; codecs="VP9"',
    qualityLabel: "2160p HFR",
    bitrate: 2e7,
    audioBitrate: null
  },
  330: {
    mimeType: 'video/webm; codecs="VP9"',
    qualityLabel: "144p HDR, HFR",
    bitrate: 8e4,
    audioBitrate: null
  },
  331: {
    mimeType: 'video/webm; codecs="VP9"',
    qualityLabel: "240p HDR, HFR",
    bitrate: 1e5,
    audioBitrate: null
  },
  332: {
    mimeType: 'video/webm; codecs="VP9"',
    qualityLabel: "360p HDR, HFR",
    bitrate: 25e4,
    audioBitrate: null
  },
  333: {
    mimeType: 'video/webm; codecs="VP9"',
    qualityLabel: "240p HDR, HFR",
    bitrate: 5e5,
    audioBitrate: null
  },
  334: {
    mimeType: 'video/webm; codecs="VP9"',
    qualityLabel: "720p HDR, HFR",
    bitrate: 1e6,
    audioBitrate: null
  },
  335: {
    mimeType: 'video/webm; codecs="VP9"',
    qualityLabel: "1080p HDR, HFR",
    bitrate: 15e5,
    audioBitrate: null
  },
  336: {
    mimeType: 'video/webm; codecs="VP9"',
    qualityLabel: "1440p HDR, HFR",
    bitrate: 5e6,
    audioBitrate: null
  },
  337: {
    mimeType: 'video/webm; codecs="VP9"',
    qualityLabel: "2160p HDR, HFR",
    bitrate: 12e6,
    audioBitrate: null
  }
};
(function(exports) {
  const utils2 = utils$5;
  const FORMATS = formats;
  const audioEncodingRanks = ["mp4a", "mp3", "vorbis", "aac", "opus", "flac"];
  const videoEncodingRanks = ["mp4v", "avc1", "Sorenson H.283", "MPEG-4 Visual", "VP8", "VP9", "H.264"];
  const getVideoBitrate = (format) => format.bitrate || 0;
  const getVideoEncodingRank = (format) => videoEncodingRanks.findIndex((enc) => {
    var _a2;
    return (_a2 = format.codecs) == null ? void 0 : _a2.includes(enc);
  });
  const getAudioBitrate = (format) => format.audioBitrate || 0;
  const getAudioEncodingRank = (format) => audioEncodingRanks.findIndex((enc) => {
    var _a2;
    return (_a2 = format.codecs) == null ? void 0 : _a2.includes(enc);
  });
  const sortFormatsBy = (a, b, sortBy) => {
    let res = 0;
    for (let fn of sortBy) {
      res = fn(b) - fn(a);
      if (res !== 0) {
        break;
      }
    }
    return res;
  };
  const sortFormatsByVideo = (a, b) => sortFormatsBy(a, b, [(format) => parseInt(format.qualityLabel), getVideoBitrate, getVideoEncodingRank]);
  const sortFormatsByAudio = (a, b) => sortFormatsBy(a, b, [getAudioBitrate, getAudioEncodingRank]);
  exports.sortFormats = (a, b) => sortFormatsBy(a, b, [
    // Formats with both video and audio are ranked highest.
    (format) => +!!format.isHLS,
    (format) => +!!format.isDashMPD,
    (format) => +(format.contentLength > 0),
    (format) => +(format.hasVideo && format.hasAudio),
    (format) => +format.hasVideo,
    (format) => parseInt(format.qualityLabel) || 0,
    getVideoBitrate,
    getAudioBitrate,
    getVideoEncodingRank,
    getAudioEncodingRank
  ]);
  exports.chooseFormat = (formats2, options) => {
    if (typeof options.format === "object") {
      if (!options.format.url) {
        throw Error("Invalid format given, did you use `ytdl.getInfo()`?");
      }
      return options.format;
    }
    if (options.filter) {
      formats2 = exports.filterFormats(formats2, options.filter);
    }
    if (formats2.some((fmt) => fmt.isHLS)) {
      formats2 = formats2.filter((fmt) => fmt.isHLS || !fmt.isLive);
    }
    let format;
    const quality = options.quality || "highest";
    switch (quality) {
      case "highest":
        format = formats2[0];
        break;
      case "lowest":
        format = formats2[formats2.length - 1];
        break;
      case "highestaudio": {
        formats2 = exports.filterFormats(formats2, "audio");
        formats2.sort(sortFormatsByAudio);
        const bestAudioFormat = formats2[0];
        formats2 = formats2.filter((f) => sortFormatsByAudio(bestAudioFormat, f) === 0);
        const worstVideoQuality = formats2.map((f) => parseInt(f.qualityLabel) || 0).sort((a, b) => a - b)[0];
        format = formats2.find((f) => (parseInt(f.qualityLabel) || 0) === worstVideoQuality);
        break;
      }
      case "lowestaudio":
        formats2 = exports.filterFormats(formats2, "audio");
        formats2.sort(sortFormatsByAudio);
        format = formats2[formats2.length - 1];
        break;
      case "highestvideo": {
        formats2 = exports.filterFormats(formats2, "video");
        formats2.sort(sortFormatsByVideo);
        const bestVideoFormat = formats2[0];
        formats2 = formats2.filter((f) => sortFormatsByVideo(bestVideoFormat, f) === 0);
        const worstAudioQuality = formats2.map((f) => f.audioBitrate || 0).sort((a, b) => a - b)[0];
        format = formats2.find((f) => (f.audioBitrate || 0) === worstAudioQuality);
        break;
      }
      case "lowestvideo":
        formats2 = exports.filterFormats(formats2, "video");
        formats2.sort(sortFormatsByVideo);
        format = formats2[formats2.length - 1];
        break;
      default:
        format = getFormatByQuality(quality, formats2);
        break;
    }
    if (!format) {
      throw Error(`No such format found: ${quality}`);
    }
    return format;
  };
  const getFormatByQuality = (quality, formats2) => {
    let getFormat = (itag) => formats2.find((format) => `${format.itag}` === `${itag}`);
    if (Array.isArray(quality)) {
      return getFormat(quality.find((q) => getFormat(q)));
    } else {
      return getFormat(quality);
    }
  };
  exports.filterFormats = (formats2, filter) => {
    let fn;
    switch (filter) {
      case "videoandaudio":
      case "audioandvideo":
        fn = (format) => format.hasVideo && format.hasAudio;
        break;
      case "video":
        fn = (format) => format.hasVideo;
        break;
      case "videoonly":
        fn = (format) => format.hasVideo && !format.hasAudio;
        break;
      case "audio":
        fn = (format) => format.hasAudio;
        break;
      case "audioonly":
        fn = (format) => !format.hasVideo && format.hasAudio;
        break;
      default:
        if (typeof filter === "function") {
          fn = filter;
        } else {
          throw TypeError(`Given filter (${filter}) is not supported`);
        }
    }
    return formats2.filter((format) => !!format.url && fn(format));
  };
  exports.addFormatMeta = (format) => {
    format = Object.assign({}, FORMATS[format.itag], format);
    format.hasVideo = !!format.qualityLabel;
    format.hasAudio = !!format.audioBitrate;
    format.container = format.mimeType ? format.mimeType.split(";")[0].split("/")[1] : null;
    format.codecs = format.mimeType ? utils2.between(format.mimeType, 'codecs="', '"') : null;
    format.videoCodec = format.hasVideo && format.codecs ? format.codecs.split(", ")[0] : null;
    format.audioCodec = format.hasAudio && format.codecs ? format.codecs.split(", ").slice(-1)[0] : null;
    format.isLive = /\bsource[/=]yt_live_broadcast\b/.test(format.url);
    format.isHLS = /\/manifest\/hls_(variant|playlist)\//.test(format.url);
    format.isDashMPD = /\/manifest\/dash\//.test(format.url);
    return format;
  };
})(formatUtils$1);
var urlUtils$1 = {};
(function(exports) {
  const validQueryDomains = /* @__PURE__ */ new Set([
    "youtube.com",
    "www.youtube.com",
    "m.youtube.com",
    "music.youtube.com",
    "gaming.youtube.com"
  ]);
  const validPathDomains = /^https?:\/\/(youtu\.be\/|(www\.)?youtube\.com\/(embed|v|shorts|live)\/)/;
  exports.getURLVideoID = (link) => {
    const parsed = new URL(link.trim());
    let id = parsed.searchParams.get("v");
    if (validPathDomains.test(link.trim()) && !id) {
      const paths = parsed.pathname.split("/");
      id = parsed.host === "youtu.be" ? paths[1] : paths[2];
    } else if (parsed.hostname && !validQueryDomains.has(parsed.hostname)) {
      throw Error("Not a YouTube domain");
    }
    if (!id) {
      throw Error(`No video id found: "${link}"`);
    }
    id = id.substring(0, 11);
    if (!exports.validateID(id)) {
      throw TypeError(`Video id (${id}) does not match expected format (${idRegex.toString()})`);
    }
    return id;
  };
  const urlRegex = /^https?:\/\//;
  exports.getVideoID = (str) => {
    if (exports.validateID(str)) {
      return str;
    } else if (urlRegex.test(str.trim())) {
      return exports.getURLVideoID(str);
    } else {
      throw Error(`No video id found: ${str}`);
    }
  };
  const idRegex = /^[a-zA-Z0-9-_]{11}$/;
  exports.validateID = (id) => idRegex.test(id.trim());
  exports.validateURL = (string) => {
    try {
      exports.getURLVideoID(string);
      return true;
    } catch (e) {
      return false;
    }
  };
})(urlUtils$1);
var infoExtras = {};
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
const http_1 = __importDefault$2(require$$0$9);
const https_1 = __importDefault$2(require$$1$9);
const stream_1$3 = require$$0$7;
const httpLibs = { "http:": http_1.default, "https:": https_1.default };
const redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
const retryStatusCodes = /* @__PURE__ */ new Set([429, 503]);
const requestEvents = ["connect", "continue", "information", "socket", "timeout", "upgrade"];
const responseEvents = ["aborted"];
Miniget.MinigetError = class MinigetError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
  }
};
Miniget.defaultOptions = {
  maxRedirects: 10,
  maxRetries: 2,
  maxReconnects: 0,
  backoff: { inc: 100, max: 1e4 }
};
function Miniget(url, options = {}) {
  var _a2;
  const opts = Object.assign({}, Miniget.defaultOptions, options);
  const stream2 = new stream_1$3.PassThrough({ highWaterMark: opts.highWaterMark });
  stream2.destroyed = stream2.aborted = false;
  let activeRequest;
  let activeResponse;
  let activeDecodedStream;
  let redirects = 0;
  let retries = 0;
  let retryTimeout;
  let reconnects = 0;
  let contentLength;
  let acceptRanges = false;
  let rangeStart = 0, rangeEnd;
  let downloaded = 0;
  if ((_a2 = opts.headers) === null || _a2 === void 0 ? void 0 : _a2.Range) {
    let r = /bytes=(\d+)-(\d+)?/.exec(`${opts.headers.Range}`);
    if (r) {
      rangeStart = parseInt(r[1], 10);
      rangeEnd = parseInt(r[2], 10);
    }
  }
  if (opts.acceptEncoding) {
    opts.headers = Object.assign({
      "Accept-Encoding": Object.keys(opts.acceptEncoding).join(", ")
    }, opts.headers);
  }
  const downloadHasStarted = () => activeDecodedStream && downloaded > 0;
  const downloadComplete = () => !acceptRanges || downloaded === contentLength;
  const reconnect = (err) => {
    activeDecodedStream = null;
    retries = 0;
    let inc = opts.backoff.inc;
    let ms2 = Math.min(inc, opts.backoff.max);
    retryTimeout = setTimeout(doDownload, ms2);
    stream2.emit("reconnect", reconnects, err);
  };
  const reconnectIfEndedEarly = (err) => {
    if (options.method !== "HEAD" && !downloadComplete() && reconnects++ < opts.maxReconnects) {
      reconnect(err);
      return true;
    }
    return false;
  };
  const retryRequest = (retryOptions) => {
    if (stream2.destroyed) {
      return false;
    }
    if (downloadHasStarted()) {
      return reconnectIfEndedEarly(retryOptions.err);
    } else if ((!retryOptions.err || retryOptions.err.message === "ENOTFOUND") && retries++ < opts.maxRetries) {
      let ms2 = retryOptions.retryAfter || Math.min(retries * opts.backoff.inc, opts.backoff.max);
      retryTimeout = setTimeout(doDownload, ms2);
      stream2.emit("retry", retries, retryOptions.err);
      return true;
    }
    return false;
  };
  const forwardEvents = (ee, events2) => {
    for (let event of events2) {
      ee.on(event, stream2.emit.bind(stream2, event));
    }
  };
  const doDownload = () => {
    let parsed = {}, httpLib;
    try {
      let urlObj = typeof url === "string" ? new URL(url) : url;
      parsed = Object.assign({}, {
        host: urlObj.host,
        hostname: urlObj.hostname,
        path: urlObj.pathname + urlObj.search + urlObj.hash,
        port: urlObj.port,
        protocol: urlObj.protocol
      });
      if (urlObj.username) {
        parsed.auth = `${urlObj.username}:${urlObj.password}`;
      }
      httpLib = httpLibs[String(parsed.protocol)];
    } catch (err) {
    }
    if (!httpLib) {
      stream2.emit("error", new Miniget.MinigetError(`Invalid URL: ${url}`));
      return;
    }
    Object.assign(parsed, opts);
    if (acceptRanges && downloaded > 0) {
      let start = downloaded + rangeStart;
      let end = rangeEnd || "";
      parsed.headers = Object.assign({}, parsed.headers, {
        Range: `bytes=${start}-${end}`
      });
    }
    if (opts.transform) {
      try {
        parsed = opts.transform(parsed);
      } catch (err) {
        stream2.emit("error", err);
        return;
      }
      if (!parsed || parsed.protocol) {
        httpLib = httpLibs[String(parsed === null || parsed === void 0 ? void 0 : parsed.protocol)];
        if (!httpLib) {
          stream2.emit("error", new Miniget.MinigetError("Invalid URL object from `transform` function"));
          return;
        }
      }
    }
    const onError2 = (err) => {
      if (stream2.destroyed || stream2.readableEnded) {
        return;
      }
      cleanup();
      if (!retryRequest({ err })) {
        stream2.emit("error", err);
      } else {
        activeRequest.removeListener("close", onRequestClose);
      }
    };
    const onRequestClose = () => {
      cleanup();
      retryRequest({});
    };
    const cleanup = () => {
      activeRequest.removeListener("close", onRequestClose);
      activeResponse === null || activeResponse === void 0 ? void 0 : activeResponse.removeListener("data", onData);
      activeDecodedStream === null || activeDecodedStream === void 0 ? void 0 : activeDecodedStream.removeListener("end", onEnd);
    };
    const onData = (chunk) => {
      downloaded += chunk.length;
    };
    const onEnd = () => {
      cleanup();
      if (!reconnectIfEndedEarly()) {
        stream2.end();
      }
    };
    activeRequest = httpLib.request(parsed, (res) => {
      if (stream2.destroyed) {
        return;
      }
      if (redirectStatusCodes.has(res.statusCode)) {
        if (redirects++ >= opts.maxRedirects) {
          stream2.emit("error", new Miniget.MinigetError("Too many redirects"));
        } else {
          if (res.headers.location) {
            url = res.headers.location;
          } else {
            let err = new Miniget.MinigetError("Redirect status code given with no location", res.statusCode);
            stream2.emit("error", err);
            cleanup();
            return;
          }
          setTimeout(doDownload, parseInt(res.headers["retry-after"] || "0", 10) * 1e3);
          stream2.emit("redirect", url);
        }
        cleanup();
        return;
      } else if (retryStatusCodes.has(res.statusCode)) {
        if (!retryRequest({ retryAfter: parseInt(res.headers["retry-after"] || "0", 10) })) {
          let err = new Miniget.MinigetError(`Status code: ${res.statusCode}`, res.statusCode);
          stream2.emit("error", err);
        }
        cleanup();
        return;
      } else if (res.statusCode && (res.statusCode < 200 || res.statusCode >= 400)) {
        let err = new Miniget.MinigetError(`Status code: ${res.statusCode}`, res.statusCode);
        if (res.statusCode >= 500) {
          onError2(err);
        } else {
          stream2.emit("error", err);
        }
        cleanup();
        return;
      }
      activeDecodedStream = res;
      if (opts.acceptEncoding && res.headers["content-encoding"]) {
        for (let enc of res.headers["content-encoding"].split(", ").reverse()) {
          let fn = opts.acceptEncoding[enc];
          if (fn) {
            activeDecodedStream = activeDecodedStream.pipe(fn());
            activeDecodedStream.on("error", onError2);
          }
        }
      }
      if (!contentLength) {
        contentLength = parseInt(`${res.headers["content-length"]}`, 10);
        acceptRanges = res.headers["accept-ranges"] === "bytes" && contentLength > 0 && opts.maxReconnects > 0;
      }
      res.on("data", onData);
      activeDecodedStream.on("end", onEnd);
      activeDecodedStream.pipe(stream2, { end: !acceptRanges });
      activeResponse = res;
      stream2.emit("response", res);
      res.on("error", onError2);
      forwardEvents(res, responseEvents);
    });
    activeRequest.on("error", onError2);
    activeRequest.on("close", onRequestClose);
    forwardEvents(activeRequest, requestEvents);
    if (stream2.destroyed) {
      streamDestroy(...destroyArgs);
    }
    stream2.emit("request", activeRequest);
    activeRequest.end();
  };
  stream2.abort = (err) => {
    console.warn("`MinigetStream#abort()` has been deprecated in favor of `MinigetStream#destroy()`");
    stream2.aborted = true;
    stream2.emit("abort");
    stream2.destroy(err);
  };
  let destroyArgs = [];
  const streamDestroy = (err) => {
    activeRequest.destroy(err);
    activeDecodedStream === null || activeDecodedStream === void 0 ? void 0 : activeDecodedStream.unpipe(stream2);
    activeDecodedStream === null || activeDecodedStream === void 0 ? void 0 : activeDecodedStream.destroy();
    clearTimeout(retryTimeout);
  };
  stream2._destroy = (...args) => {
    stream2.destroyed = true;
    if (activeRequest) {
      streamDestroy(...args);
    } else {
      destroyArgs = args;
    }
  };
  stream2.text = () => new Promise((resolve2, reject) => {
    let body2 = "";
    stream2.setEncoding("utf8");
    stream2.on("data", (chunk) => body2 += chunk);
    stream2.on("end", () => resolve2(body2));
    stream2.on("error", reject);
  });
  process.nextTick(doDownload);
  return stream2;
}
var dist$1 = Miniget;
var m3u8Parser$1 = {};
Object.defineProperty(m3u8Parser$1, "__esModule", { value: true });
const stream_1$2 = require$$0$7;
class m3u8Parser extends stream_1$2.Writable {
  constructor() {
    super();
    this._lastLine = "";
    this._seq = 0;
    this._nextItemDuration = null;
    this._nextItemRange = null;
    this._lastItemRangeEnd = 0;
    this.on("finish", () => {
      this._parseLine(this._lastLine);
      this.emit("end");
    });
  }
  _parseAttrList(value) {
    let attrs = {};
    let regex = /([A-Z0-9-]+)=(?:"([^"]*?)"|([^,]*?))/g;
    let match;
    while ((match = regex.exec(value)) !== null) {
      attrs[match[1]] = match[2] || match[3];
    }
    return attrs;
  }
  _parseRange(value) {
    if (!value)
      return null;
    let svalue = value.split("@");
    let start = svalue[1] ? parseInt(svalue[1]) : this._lastItemRangeEnd + 1;
    let end = start + parseInt(svalue[0]) - 1;
    let range = { start, end };
    this._lastItemRangeEnd = range.end;
    return range;
  }
  _parseLine(line) {
    let match = line.match(/^#(EXT[A-Z0-9-]+)(?::(.*))?/);
    if (match) {
      const tag = match[1];
      const value = match[2] || "";
      switch (tag) {
        case "EXT-X-PROGRAM-DATE-TIME":
          this.emit("starttime", new Date(value).getTime());
          break;
        case "EXT-X-MEDIA-SEQUENCE":
          this._seq = parseInt(value);
          break;
        case "EXT-X-MAP": {
          let attrs = this._parseAttrList(value);
          if (!attrs.URI) {
            this.destroy(new Error("`EXT-X-MAP` found without required attribute `URI`"));
            return;
          }
          this.emit("item", {
            url: attrs.URI,
            seq: this._seq,
            init: true,
            duration: 0,
            range: this._parseRange(attrs.BYTERANGE)
          });
          break;
        }
        case "EXT-X-BYTERANGE": {
          this._nextItemRange = this._parseRange(value);
          break;
        }
        case "EXTINF":
          this._nextItemDuration = Math.round(parseFloat(value.split(",")[0]) * 1e3);
          break;
        case "EXT-X-ENDLIST":
          this.emit("endlist");
          break;
      }
    } else if (!/^#/.test(line) && line.trim()) {
      this.emit("item", {
        url: line.trim(),
        seq: this._seq++,
        duration: this._nextItemDuration,
        range: this._nextItemRange
      });
      this._nextItemRange = null;
    }
  }
  _write(chunk, encoding2, callback) {
    let lines = chunk.toString("utf8").split("\n");
    if (this._lastLine) {
      lines[0] = this._lastLine + lines[0];
    }
    lines.forEach((line, i) => {
      if (this.destroyed)
        return;
      if (i < lines.length - 1) {
        this._parseLine(line);
      } else {
        this._lastLine = line;
      }
    });
    callback();
  }
}
m3u8Parser$1.default = m3u8Parser;
var dashMpdParser = {};
var parseTime = {};
Object.defineProperty(parseTime, "__esModule", { value: true });
parseTime.durationStr = parseTime.humanStr = void 0;
const numberFormat = /^\d+$/;
const timeFormat = /^(?:(?:(\d+):)?(\d{1,2}):)?(\d{1,2})(?:\.(\d{3}))?$/;
const timeUnits = {
  ms: 1,
  s: 1e3,
  m: 6e4,
  h: 36e5
};
parseTime.humanStr = (time) => {
  if (typeof time === "number") {
    return time;
  }
  if (numberFormat.test(time)) {
    return +time;
  }
  const firstFormat = timeFormat.exec(time);
  if (firstFormat) {
    return +(firstFormat[1] || 0) * timeUnits.h + +(firstFormat[2] || 0) * timeUnits.m + +firstFormat[3] * timeUnits.s + +(firstFormat[4] || 0);
  } else {
    let total = 0;
    const r = /(-?\d+)(ms|s|m|h)/g;
    let rs;
    while ((rs = r.exec(time)) !== null) {
      total += +rs[1] * timeUnits[rs[2]];
    }
    return total;
  }
};
parseTime.durationStr = (time) => {
  let total = 0;
  const r = /(\d+(?:\.\d+)?)(S|M|H)/g;
  let rs;
  while ((rs = r.exec(time)) !== null) {
    total += +rs[1] * timeUnits[rs[2].toLowerCase()];
  }
  return total;
};
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(dashMpdParser, "__esModule", { value: true });
const stream_1$1 = require$$0$7;
const sax_1 = __importDefault$1(sax);
const parse_time_1$1 = parseTime;
class DashMPDParser extends stream_1$1.Writable {
  constructor(targetID) {
    super();
    this._parser = sax_1.default.createStream(false, { lowercase: true });
    this._parser.on("error", this.destroy.bind(this));
    let lastTag;
    let currtime = 0;
    let seq = 0;
    let segmentTemplate;
    let timescale, offset, duration, baseURL;
    let timeline = [];
    let getSegments = false;
    let gotSegments = false;
    let isStatic;
    let treeLevel;
    let periodStart;
    const tmpl = (str) => {
      const context = {
        RepresentationID: targetID,
        Number: seq,
        Time: currtime
      };
      return str.replace(/\$(\w+)\$/g, (m, p1) => `${context[p1]}`);
    };
    this._parser.on("opentag", (node2) => {
      switch (node2.name) {
        case "mpd":
          currtime = node2.attributes.availabilitystarttime ? new Date(node2.attributes.availabilitystarttime).getTime() : 0;
          isStatic = node2.attributes.type !== "dynamic";
          break;
        case "period":
          seq = 0;
          timescale = 1e3;
          duration = 0;
          offset = 0;
          baseURL = [];
          treeLevel = 0;
          periodStart = parse_time_1$1.durationStr(node2.attributes.start) || 0;
          break;
        case "segmentlist":
          seq = parseInt(node2.attributes.startnumber) || seq;
          timescale = parseInt(node2.attributes.timescale) || timescale;
          duration = parseInt(node2.attributes.duration) || duration;
          offset = parseInt(node2.attributes.presentationtimeoffset) || offset;
          break;
        case "segmenttemplate":
          segmentTemplate = node2.attributes;
          seq = parseInt(node2.attributes.startnumber) || seq;
          timescale = parseInt(node2.attributes.timescale) || timescale;
          break;
        case "segmenttimeline":
        case "baseurl":
          lastTag = node2.name;
          break;
        case "s":
          timeline.push({
            duration: parseInt(node2.attributes.d),
            repeat: parseInt(node2.attributes.r),
            time: parseInt(node2.attributes.t)
          });
          break;
        case "adaptationset":
        case "representation":
          treeLevel++;
          if (!targetID) {
            targetID = node2.attributes.id;
          }
          getSegments = node2.attributes.id === `${targetID}`;
          if (getSegments) {
            if (periodStart) {
              currtime += periodStart;
            }
            if (offset) {
              currtime -= offset / timescale * 1e3;
            }
            this.emit("starttime", currtime);
          }
          break;
        case "initialization":
          if (getSegments) {
            this.emit("item", {
              url: baseURL.filter((s) => !!s).join("") + node2.attributes.sourceurl,
              seq,
              init: true,
              duration: 0
            });
          }
          break;
        case "segmenturl":
          if (getSegments) {
            gotSegments = true;
            let tl = timeline.shift();
            let segmentDuration = ((tl === null || tl === void 0 ? void 0 : tl.duration) || duration) / timescale * 1e3;
            this.emit("item", {
              url: baseURL.filter((s) => !!s).join("") + node2.attributes.media,
              seq: seq++,
              duration: segmentDuration
            });
            currtime += segmentDuration;
          }
          break;
      }
    });
    const onEnd = () => {
      if (isStatic) {
        this.emit("endlist");
      }
      if (!getSegments) {
        this.destroy(Error(`Representation '${targetID}' not found`));
      } else {
        this.emit("end");
      }
    };
    this._parser.on("closetag", (tagName) => {
      switch (tagName) {
        case "adaptationset":
        case "representation":
          treeLevel--;
          if (segmentTemplate && timeline.length) {
            gotSegments = true;
            if (segmentTemplate.initialization) {
              this.emit("item", {
                url: baseURL.filter((s) => !!s).join("") + tmpl(segmentTemplate.initialization),
                seq,
                init: true,
                duration: 0
              });
            }
            for (let { duration: itemDuration, repeat, time } of timeline) {
              itemDuration = itemDuration / timescale * 1e3;
              repeat = repeat || 1;
              currtime = time || currtime;
              for (let i = 0; i < repeat; i++) {
                this.emit("item", {
                  url: baseURL.filter((s) => !!s).join("") + tmpl(segmentTemplate.media),
                  seq: seq++,
                  duration: itemDuration
                });
                currtime += itemDuration;
              }
            }
          }
          if (gotSegments) {
            this.emit("endearly");
            onEnd();
            this._parser.removeAllListeners();
            this.removeAllListeners("finish");
          }
          break;
      }
    });
    this._parser.on("text", (text) => {
      if (lastTag === "baseurl") {
        baseURL[treeLevel] = text;
        lastTag = null;
      }
    });
    this.on("finish", onEnd);
  }
  _write(chunk, encoding2, callback) {
    this._parser.write(chunk);
    callback();
  }
}
dashMpdParser.default = DashMPDParser;
var queue = {};
Object.defineProperty(queue, "__esModule", { value: true });
queue.Queue = void 0;
class Queue {
  /**
   * A really simple queue with concurrency.
   *
   * @param {Function} worker
   * @param {Object} options
   * @param {!number} options.concurrency
   */
  constructor(worker, options = {}) {
    this._worker = worker;
    this._concurrency = options.concurrency || 1;
    this.tasks = [];
    this.total = 0;
    this.active = 0;
  }
  /**
   * Push a task to the queue.
   *
   *  @param {T} item
   *  @param {!Function} callback
   */
  push(item, callback) {
    this.tasks.push({ item, callback });
    this.total++;
    this._next();
  }
  /**
   * Process next job in queue.
   */
  _next() {
    if (this.active >= this._concurrency || !this.tasks.length) {
      return;
    }
    const { item, callback } = this.tasks.shift();
    let callbackCalled = false;
    this.active++;
    this._worker(item, (err, result) => {
      if (callbackCalled) {
        return;
      }
      this.active--;
      callbackCalled = true;
      callback === null || callback === void 0 ? void 0 : callback(err, result);
      this._next();
    });
  }
  /**
   * Stops processing queued jobs.
   */
  die() {
    this.tasks = [];
  }
}
queue.Queue = Queue;
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
const stream_1 = require$$0$7;
const miniget_1 = __importDefault(dist$1);
const m3u8_parser_1 = __importDefault(m3u8Parser$1);
const dash_mpd_parser_1 = __importDefault(dashMpdParser);
const queue_1 = queue;
const parse_time_1 = parseTime;
const supportedParsers = {
  m3u8: m3u8_parser_1.default,
  "dash-mpd": dash_mpd_parser_1.default
};
let m3u8stream$1 = (playlistURL, options = {}) => {
  const stream2 = new stream_1.PassThrough({ highWaterMark: options.highWaterMark });
  const chunkReadahead = options.chunkReadahead || 3;
  const liveBuffer = options.liveBuffer || 2e4;
  const requestOptions = options.requestOptions;
  const Parser3 = supportedParsers[options.parser || (/\.mpd$/.test(playlistURL) ? "dash-mpd" : "m3u8")];
  if (!Parser3) {
    throw TypeError(`parser '${options.parser}' not supported`);
  }
  let begin = 0;
  if (typeof options.begin !== "undefined") {
    begin = typeof options.begin === "string" ? parse_time_1.humanStr(options.begin) : Math.max(options.begin - liveBuffer, 0);
  }
  const forwardEvents = (req2) => {
    for (let event of ["abort", "request", "response", "redirect", "retry", "reconnect"]) {
      req2.on(event, stream2.emit.bind(stream2, event));
    }
  };
  let currSegment;
  const streamQueue = new queue_1.Queue((req2, callback) => {
    currSegment = req2;
    let size = 0;
    req2.on("data", (chunk) => size += chunk.length);
    req2.pipe(stream2, { end: false });
    req2.on("end", () => callback(null, size));
  }, { concurrency: 1 });
  let segmentNumber = 0;
  let downloaded = 0;
  const requestQueue = new queue_1.Queue((segment, callback) => {
    let reqOptions = Object.assign({}, requestOptions);
    if (segment.range) {
      reqOptions.headers = Object.assign({}, reqOptions.headers, {
        Range: `bytes=${segment.range.start}-${segment.range.end}`
      });
    }
    let req2 = miniget_1.default(new URL(segment.url, playlistURL).toString(), reqOptions);
    req2.on("error", callback);
    forwardEvents(req2);
    streamQueue.push(req2, (_, size) => {
      downloaded += +size;
      stream2.emit("progress", {
        num: ++segmentNumber,
        size,
        duration: segment.duration,
        url: segment.url
      }, requestQueue.total, downloaded);
      callback(null);
    });
  }, { concurrency: chunkReadahead });
  const onError2 = (err) => {
    stream2.emit("error", err);
    stream2.end();
  };
  let refreshThreshold;
  let minRefreshTime;
  let refreshTimeout2;
  let fetchingPlaylist = true;
  let ended = false;
  let isStatic = false;
  let lastRefresh;
  const onQueuedEnd = (err) => {
    currSegment = null;
    if (err) {
      onError2(err);
    } else if (!fetchingPlaylist && !ended && !isStatic && requestQueue.tasks.length + requestQueue.active <= refreshThreshold) {
      let ms2 = Math.max(0, minRefreshTime - (Date.now() - lastRefresh));
      fetchingPlaylist = true;
      refreshTimeout2 = setTimeout(refreshPlaylist, ms2);
    } else if ((ended || isStatic) && !requestQueue.tasks.length && !requestQueue.active) {
      stream2.end();
    }
  };
  let currPlaylist;
  let lastSeq;
  let starttime = 0;
  const refreshPlaylist = () => {
    lastRefresh = Date.now();
    currPlaylist = miniget_1.default(playlistURL, requestOptions);
    currPlaylist.on("error", onError2);
    forwardEvents(currPlaylist);
    const parser = currPlaylist.pipe(new Parser3(options.id));
    parser.on("starttime", (a) => {
      if (starttime) {
        return;
      }
      starttime = a;
      if (typeof options.begin === "string" && begin >= 0) {
        begin += starttime;
      }
    });
    parser.on("endlist", () => {
      isStatic = true;
    });
    parser.on("endearly", currPlaylist.unpipe.bind(currPlaylist, parser));
    let addedItems = [];
    const addItem = (item) => {
      if (!item.init) {
        if (item.seq <= lastSeq) {
          return;
        }
        lastSeq = item.seq;
      }
      begin = item.time;
      requestQueue.push(item, onQueuedEnd);
      addedItems.push(item);
    };
    let tailedItems = [], tailedItemsDuration = 0;
    parser.on("item", (item) => {
      let timedItem = Object.assign({ time: starttime }, item);
      if (begin <= timedItem.time) {
        addItem(timedItem);
      } else {
        tailedItems.push(timedItem);
        tailedItemsDuration += timedItem.duration;
        while (tailedItems.length > 1 && tailedItemsDuration - tailedItems[0].duration > liveBuffer) {
          const lastItem = tailedItems.shift();
          tailedItemsDuration -= lastItem.duration;
        }
      }
      starttime += timedItem.duration;
    });
    parser.on("end", () => {
      currPlaylist = null;
      if (!addedItems.length && tailedItems.length) {
        tailedItems.forEach((item) => {
          addItem(item);
        });
      }
      refreshThreshold = Math.max(1, Math.ceil(addedItems.length * 0.01));
      minRefreshTime = addedItems.reduce((total, item) => item.duration + total, 0);
      fetchingPlaylist = false;
      onQueuedEnd(null);
    });
  };
  refreshPlaylist();
  stream2.end = () => {
    ended = true;
    streamQueue.die();
    requestQueue.die();
    clearTimeout(refreshTimeout2);
    currPlaylist === null || currPlaylist === void 0 ? void 0 : currPlaylist.destroy();
    currSegment === null || currSegment === void 0 ? void 0 : currSegment.destroy();
    stream_1.PassThrough.prototype.end.call(stream2, null);
    return stream2;
  };
  return stream2;
};
m3u8stream$1.parseTimestamp = parse_time_1.humanStr;
var dist = m3u8stream$1;
const utils$1 = utils$5;
const qs = require$$1$b;
const { parseTimestamp: parseTimestamp$1 } = dist;
const BASE_URL = "https://www.youtube.com/watch?v=";
const TITLE_TO_CATEGORY = {
  song: { name: "Music", url: "https://music.youtube.com/" }
};
const getText = (obj) => {
  var _a2, _b2;
  return ((_b2 = (_a2 = obj == null ? void 0 : obj.runs) == null ? void 0 : _a2[0]) == null ? void 0 : _b2.text) ?? (obj == null ? void 0 : obj.simpleText);
};
infoExtras.getMedia = (info2) => {
  var _a2;
  let media = {};
  let results = [];
  try {
    results = info2.response.contents.twoColumnWatchNextResults.results.results.contents;
  } catch (err) {
  }
  let result = results.find((v) => v.videoSecondaryInfoRenderer);
  if (!result) {
    return {};
  }
  try {
    let metadataRows = (result.metadataRowContainer || result.videoSecondaryInfoRenderer.metadataRowContainer).metadataRowContainerRenderer.rows;
    for (let row of metadataRows) {
      if (row.metadataRowRenderer) {
        let title = getText(row.metadataRowRenderer.title).toLowerCase();
        let contents = row.metadataRowRenderer.contents[0];
        media[title] = getText(contents);
        let runs = contents.runs;
        if ((_a2 = runs == null ? void 0 : runs[0]) == null ? void 0 : _a2.navigationEndpoint) {
          media[`${title}_url`] = new URL(
            runs[0].navigationEndpoint.commandMetadata.webCommandMetadata.url,
            BASE_URL
          ).toString();
        }
        if (title in TITLE_TO_CATEGORY) {
          media.category = TITLE_TO_CATEGORY[title].name;
          media.category_url = TITLE_TO_CATEGORY[title].url;
        }
      } else if (row.richMetadataRowRenderer) {
        let contents = row.richMetadataRowRenderer.contents;
        let boxArt = contents.filter(
          (meta) => meta.richMetadataRenderer.style === "RICH_METADATA_RENDERER_STYLE_BOX_ART"
        );
        for (let { richMetadataRenderer } of boxArt) {
          let meta = richMetadataRenderer;
          media.year = getText(meta.subtitle);
          let type = getText(meta.callToAction).split(" ")[1];
          media[type] = getText(meta.title);
          media[`${type}_url`] = new URL(meta.endpoint.commandMetadata.webCommandMetadata.url, BASE_URL).toString();
          media.thumbnails = meta.thumbnail.thumbnails;
        }
        let topic = contents.filter((meta) => meta.richMetadataRenderer.style === "RICH_METADATA_RENDERER_STYLE_TOPIC");
        for (let { richMetadataRenderer } of topic) {
          let meta = richMetadataRenderer;
          media.category = getText(meta.title);
          media.category_url = new URL(meta.endpoint.commandMetadata.webCommandMetadata.url, BASE_URL).toString();
        }
      }
    }
  } catch (err) {
  }
  return media;
};
const isVerified = (badges) => !!(badges == null ? void 0 : badges.find((b) => b.metadataBadgeRenderer.tooltip === "Verified"));
infoExtras.getAuthor = (info2) => {
  var _a2;
  let channelId, thumbnails = [], subscriberCount, verified = false;
  try {
    let results = info2.response.contents.twoColumnWatchNextResults.results.results.contents;
    let v = results.find((v2) => {
      var _a3, _b2;
      return (_b2 = (_a3 = v2 == null ? void 0 : v2.videoSecondaryInfoRenderer) == null ? void 0 : _a3.owner) == null ? void 0 : _b2.videoOwnerRenderer;
    });
    let videoOwnerRenderer = v.videoSecondaryInfoRenderer.owner.videoOwnerRenderer;
    channelId = videoOwnerRenderer.navigationEndpoint.browseEndpoint.browseId;
    thumbnails = videoOwnerRenderer.thumbnail.thumbnails.map((thumbnail) => {
      thumbnail.url = new URL(thumbnail.url, BASE_URL).toString();
      return thumbnail;
    });
    subscriberCount = utils$1.parseAbbreviatedNumber(getText(videoOwnerRenderer.subscriberCountText));
    verified = isVerified(videoOwnerRenderer.badges);
  } catch (err) {
  }
  try {
    let videoDetails = (_a2 = info2.player_response.microformat) == null ? void 0 : _a2.playerMicroformatRenderer;
    let id = (videoDetails == null ? void 0 : videoDetails.channelId) || channelId || info2.player_response.videoDetails.channelId;
    let author = {
      id,
      name: (videoDetails == null ? void 0 : videoDetails.ownerChannelName) ?? info2.player_response.videoDetails.author,
      user: (videoDetails == null ? void 0 : videoDetails.ownerProfileUrl.split("/").slice(-1)[0]) ?? null,
      channel_url: `https://www.youtube.com/channel/${id}`,
      external_channel_url: videoDetails ? `https://www.youtube.com/channel/${videoDetails.externalChannelId}` : "",
      user_url: videoDetails ? new URL(videoDetails.ownerProfileUrl, BASE_URL).toString() : "",
      thumbnails,
      verified,
      subscriber_count: subscriberCount
    };
    if (thumbnails.length) {
      utils$1.deprecate(author, "avatar", author.thumbnails[0].url, "author.avatar", "author.thumbnails[0].url");
    }
    return author;
  } catch (err) {
    return {};
  }
};
const parseRelatedVideo = (details, rvsParams) => {
  var _a2;
  if (!details) return;
  try {
    let viewCount = getText(details.viewCountText);
    let shortViewCount = getText(details.shortViewCountText);
    let rvsDetails = rvsParams.find((elem) => elem.id === details.videoId);
    if (!/^\d/.test(shortViewCount)) {
      shortViewCount = (rvsDetails == null ? void 0 : rvsDetails.short_view_count_text) || "";
    }
    viewCount = (/^\d/.test(viewCount) ? viewCount : shortViewCount).split(" ")[0];
    let browseEndpoint = details.shortBylineText.runs[0].navigationEndpoint.browseEndpoint;
    let channelId = browseEndpoint.browseId;
    let name = getText(details.shortBylineText);
    let user = (browseEndpoint.canonicalBaseUrl || "").split("/").slice(-1)[0];
    let video = {
      id: details.videoId,
      title: getText(details.title),
      published: getText(details.publishedTimeText),
      author: {
        id: channelId,
        name,
        user,
        channel_url: `https://www.youtube.com/channel/${channelId}`,
        user_url: `https://www.youtube.com/user/${user}`,
        thumbnails: details.channelThumbnail.thumbnails.map((thumbnail) => {
          thumbnail.url = new URL(thumbnail.url, BASE_URL).toString();
          return thumbnail;
        }),
        verified: isVerified(details.ownerBadges),
        [Symbol.toPrimitive]() {
          console.warn(
            `\`relatedVideo.author\` will be removed in a near future release, use \`relatedVideo.author.name\` instead.`
          );
          return video.author.name;
        }
      },
      short_view_count_text: shortViewCount.split(" ")[0],
      view_count: viewCount.replace(/,/g, ""),
      length_seconds: details.lengthText ? Math.floor(parseTimestamp$1(getText(details.lengthText)) / 1e3) : rvsParams ? `${rvsParams.length_seconds}` : void 0,
      thumbnails: details.thumbnail.thumbnails,
      richThumbnails: details.richThumbnail ? details.richThumbnail.movingThumbnailRenderer.movingThumbnailDetails.thumbnails : [],
      isLive: !!((_a2 = details.badges) == null ? void 0 : _a2.find((b) => b.metadataBadgeRenderer.label === "LIVE NOW"))
    };
    utils$1.deprecate(
      video,
      "author_thumbnail",
      video.author.thumbnails[0].url,
      "relatedVideo.author_thumbnail",
      "relatedVideo.author.thumbnails[0].url"
    );
    utils$1.deprecate(video, "ucid", video.author.id, "relatedVideo.ucid", "relatedVideo.author.id");
    utils$1.deprecate(
      video,
      "video_thumbnail",
      video.thumbnails[0].url,
      "relatedVideo.video_thumbnail",
      "relatedVideo.thumbnails[0].url"
    );
    return video;
  } catch (err) {
  }
};
infoExtras.getRelatedVideos = (info2) => {
  let rvsParams = [], secondaryResults = [];
  try {
    rvsParams = info2.response.webWatchNextResponseExtensionData.relatedVideoArgs.split(",").map((e) => qs.parse(e));
  } catch (err) {
  }
  try {
    secondaryResults = info2.response.contents.twoColumnWatchNextResults.secondaryResults.secondaryResults.results;
  } catch (err) {
    return [];
  }
  let videos = [];
  for (let result of secondaryResults || []) {
    let details = result.compactVideoRenderer;
    if (details) {
      let video = parseRelatedVideo(details, rvsParams);
      if (video) videos.push(video);
    } else {
      let autoplay = result.compactAutoplayRenderer || result.itemSectionRenderer;
      if (!autoplay || !Array.isArray(autoplay.contents)) continue;
      for (let content of autoplay.contents) {
        let video = parseRelatedVideo(content.compactVideoRenderer, rvsParams);
        if (video) videos.push(video);
      }
    }
  }
  return videos;
};
infoExtras.getLikes = (info2) => {
  try {
    let contents = info2.response.contents.twoColumnWatchNextResults.results.results.contents;
    let video = contents.find((r) => r.videoPrimaryInfoRenderer);
    let buttons = video.videoPrimaryInfoRenderer.videoActions.menuRenderer.topLevelButtons;
    let accessibilityText = buttons.find((b) => b.segmentedLikeDislikeButtonViewModel).segmentedLikeDislikeButtonViewModel.likeButtonViewModel.likeButtonViewModel.toggleButtonViewModel.toggleButtonViewModel.defaultButtonViewModel.buttonViewModel.accessibilityText;
    return parseInt(accessibilityText.match(/[\d,.]+/)[0].replace(/\D+/g, ""));
  } catch (err) {
    return null;
  }
};
infoExtras.cleanVideoDetails = (videoDetails, info2) => {
  var _a2, _b2;
  videoDetails.thumbnails = videoDetails.thumbnail.thumbnails;
  delete videoDetails.thumbnail;
  utils$1.deprecate(
    videoDetails,
    "thumbnail",
    { thumbnails: videoDetails.thumbnails },
    "videoDetails.thumbnail.thumbnails",
    "videoDetails.thumbnails"
  );
  videoDetails.description = videoDetails.shortDescription || getText(videoDetails.description);
  delete videoDetails.shortDescription;
  utils$1.deprecate(
    videoDetails,
    "shortDescription",
    videoDetails.description,
    "videoDetails.shortDescription",
    "videoDetails.description"
  );
  videoDetails.lengthSeconds = ((_b2 = (_a2 = info2.player_response.microformat) == null ? void 0 : _a2.playerMicroformatRenderer) == null ? void 0 : _b2.lengthSeconds) || info2.player_response.videoDetails.lengthSeconds;
  return videoDetails;
};
infoExtras.getStoryboards = (info2) => {
  var _a2, _b2, _c2, _d2;
  const parts = (_d2 = (_c2 = (_b2 = (_a2 = info2.player_response) == null ? void 0 : _a2.storyboards) == null ? void 0 : _b2.playerStoryboardSpecRenderer) == null ? void 0 : _c2.spec) == null ? void 0 : _d2.split("|");
  if (!parts) return [];
  const url = new URL(parts.shift());
  return parts.map((part, i) => {
    let [thumbnailWidth, thumbnailHeight, thumbnailCount, columns, rows, interval, nameReplacement, sigh] = part.split("#");
    url.searchParams.set("sigh", sigh);
    thumbnailCount = parseInt(thumbnailCount, 10);
    columns = parseInt(columns, 10);
    rows = parseInt(rows, 10);
    const storyboardCount = Math.ceil(thumbnailCount / (columns * rows));
    return {
      templateUrl: url.toString().replace("$L", i).replace("$N", nameReplacement),
      thumbnailWidth: parseInt(thumbnailWidth, 10),
      thumbnailHeight: parseInt(thumbnailHeight, 10),
      thumbnailCount,
      interval: parseInt(interval, 10),
      columns,
      rows,
      storyboardCount
    };
  });
};
infoExtras.getChapters = (info2) => {
  var _a2, _b2, _c2, _d2, _e2;
  const playerOverlayRenderer = (_b2 = (_a2 = info2.response) == null ? void 0 : _a2.playerOverlays) == null ? void 0 : _b2.playerOverlayRenderer;
  const playerBar = (_d2 = (_c2 = playerOverlayRenderer == null ? void 0 : playerOverlayRenderer.decoratedPlayerBarRenderer) == null ? void 0 : _c2.decoratedPlayerBarRenderer) == null ? void 0 : _d2.playerBar;
  const markersMap = (_e2 = playerBar == null ? void 0 : playerBar.multiMarkersPlayerBarRenderer) == null ? void 0 : _e2.markersMap;
  const marker = Array.isArray(markersMap) && markersMap.find((m) => {
    var _a3;
    return Array.isArray((_a3 = m.value) == null ? void 0 : _a3.chapters);
  });
  if (!marker) return [];
  const chapters = marker.value.chapters;
  return chapters.map((chapter) => ({
    title: getText(chapter.chapterRenderer.title),
    start_time: chapter.chapterRenderer.timeRangeStartMillis / 1e3
  }));
};
const { setTimeout: setTimeout$1 } = require$$0$b;
var cache = class Cache extends Map {
  constructor(timeout = 1e3) {
    super();
    this.timeout = timeout;
  }
  set(key, value) {
    if (this.has(key)) {
      clearTimeout(super.get(key).tid);
    }
    super.set(key, {
      tid: setTimeout$1(this.delete.bind(this, key), this.timeout).unref(),
      value
    });
  }
  get(key) {
    let entry = super.get(key);
    if (entry) {
      return entry.value;
    }
    return null;
  }
  getOrSet(key, fn) {
    if (this.has(key)) {
      return this.get(key);
    } else {
      let value = fn();
      this.set(key, value);
      (async () => {
        try {
          await value;
        } catch (err) {
          this.delete(key);
        }
      })();
      return value;
    }
  }
  delete(key) {
    let entry = super.get(key);
    if (entry) {
      clearTimeout(entry.tid);
      super.delete(key);
    }
  }
  clear() {
    for (let entry of this.values()) {
      clearTimeout(entry.tid);
    }
    super.clear();
  }
};
var sig = {};
(function(exports) {
  const querystring = require$$1$b;
  const Cache2 = cache;
  const utils2 = utils$5;
  const vm = require$$3;
  exports.cache = new Cache2(1);
  exports.getFunctions = (html5playerfile, options) => exports.cache.getOrSet(html5playerfile, async () => {
    if (html5playerfile.includes("/player_ias_tce.vflset/")) {
      console.debug("jsUrl URL points to tce-variant player script, rewriting to non-tce.");
      html5playerfile = html5playerfile.replace("/player_ias_tce.vflset/", "/player_ias.vflset/");
    }
    const body2 = await utils2.request(html5playerfile, options);
    const functions = exports.extractFunctions(body2);
    exports.cache.set(html5playerfile, functions);
    return functions;
  });
  const VARIABLE_PART = "[a-zA-Z_\\$][a-zA-Z_0-9\\$]*";
  const DECIPHER_NAME_REGEXPS = {
    "\\b([a-zA-Z0-9_$]+)&&\\(\\1=([a-zA-Z0-9_$]{2,})\\(decodeURIComponent\\(\\1\\)\\)": 2,
    '([a-zA-Z0-9_$]+)\\s*=\\s*function\\(\\s*([a-zA-Z0-9_$]+)\\s*\\)\\s*{\\s*\\2\\s*=\\s*\\2\\.split\\(\\s*""\\s*\\)\\s*;\\s*[^}]+;\\s*return\\s+\\2\\.join\\(\\s*""\\s*\\)': 1,
    '/(?:\\b|[^a-zA-Z0-9_$])([a-zA-Z0-9_$]{2,})\\s*=\\s*function\\(\\s*a\\s*\\)\\s*{\\s*a\\s*=\\s*a\\.split\\(\\s*""\\s*\\)(?:;[a-zA-Z0-9_$]{2}\\.[a-zA-Z0-9_$]{2}\\(a,\\d+\\))?/': 1,
    "\\bm=([a-zA-Z0-9$]{2,})\\(decodeURIComponent\\(h\\.s\\)\\)": 1,
    "\\bc&&\\(c=([a-zA-Z0-9$]{2,})\\(decodeURIComponent\\(c\\)\\)": 1,
    '(?:\\b|[^a-zA-Z0-9$])([a-zA-Z0-9$]{2,})\\s*=\\s*function\\(\\s*a\\s*\\)\\s*\\{\\s*a\\s*=\\s*a\\.split\\(\\s*""\\s*\\)': 1,
    '([\\w$]+)\\s*=\\s*function\\((\\w+)\\)\\{\\s*\\2=\\s*\\2\\.split\\(""\\)\\s*;': 1
  };
  const VARIABLE_PART_DEFINE = `\\"?${VARIABLE_PART}\\"?`;
  const BEFORE_ACCESS = '(?:\\[\\"|\\.)';
  const AFTER_ACCESS = '(?:\\"\\]|)';
  const VARIABLE_PART_ACCESS = BEFORE_ACCESS + VARIABLE_PART + AFTER_ACCESS;
  const REVERSE_PART = ":function\\(\\w\\)\\{(?:return )?\\w\\.reverse\\(\\)\\}";
  const SLICE_PART = ":function\\(\\w,\\w\\)\\{return \\w\\.slice\\(\\w\\)\\}";
  const SPLICE_PART = ":function\\(\\w,\\w\\)\\{\\w\\.splice\\(0,\\w\\)\\}";
  const SWAP_PART = ":function\\(\\w,\\w\\)\\{var \\w=\\w\\[0\\];\\w\\[0\\]=\\w\\[\\w%\\w\\.length\\];\\w\\[\\w(?:%\\w.length|)\\]=\\w(?:;return \\w)?\\}";
  const DECIPHER_REGEXP = `function(?: ${VARIABLE_PART})?\\(([a-zA-Z])\\)\\{\\1=\\1\\.split\\(""\\);\\s*((?:(?:\\1=)?${VARIABLE_PART}${VARIABLE_PART_ACCESS}\\(\\1,\\d+\\);)+)return \\1\\.join\\(""\\)\\}`;
  const HELPER_REGEXP = `var (${VARIABLE_PART})=\\{((?:(?:${VARIABLE_PART_DEFINE}${REVERSE_PART}|${VARIABLE_PART_DEFINE}${SLICE_PART}|${VARIABLE_PART_DEFINE}${SPLICE_PART}|${VARIABLE_PART_DEFINE}${SWAP_PART}),?\\n?)+)\\};`;
  const SCVR = "[a-zA-Z0-9$_]";
  const MCR = `${SCVR}+`;
  const AAR = "\\[(\\d+)]";
  const N_TRANSFORM_NAME_REGEXPS = {
    [`${SCVR}="nn"\\[\\+${MCR}\\.${MCR}],${MCR}\\(${MCR}\\),${MCR}=${MCR}\\.${MCR}\\[${MCR}]\\|\\|null\\).+\\|\\|(${MCR})\\(""\\)`]: 1,
    [`${SCVR}="nn"\\[\\+${MCR}\\.${MCR}],${MCR}\\(${MCR}\\),${MCR}=${MCR}\\.${MCR}\\[${MCR}]\\|\\|null\\)&&\\(${MCR}=(${MCR})${AAR}`]: 1,
    [`${SCVR}="nn"\\[\\+${MCR}\\.${MCR}],${MCR}=${MCR}\\.get\\(${MCR}\\)\\).+\\|\\|(${MCR})\\(""\\)`]: 1,
    [`${SCVR}="nn"\\[\\+${MCR}\\.${MCR}],${MCR}=${MCR}\\.get\\(${MCR}\\)\\)&&\\(${MCR}=(${MCR})\\[(\\d+)]`]: 1,
    [`\\(${SCVR}=String\\.fromCharCode\\(110\\),${SCVR}=${SCVR}\\.get\\(${SCVR}\\)\\)&&\\(${SCVR}=(${MCR})(?:${AAR})?\\(${SCVR}\\)`]: 1,
    [`\\.get\\("n"\\)\\)&&\\(${SCVR}=(${MCR})(?:${AAR})?\\(${SCVR}\\)`]: 1
  };
  const N_TRANSFORM_REGEXP = 'function\\(\\s*(\\w+)\\s*\\)\\s*\\{var\\s*(\\w+)=(?:\\1\\.split\\(.*?\\)|String\\.prototype\\.split\\.call\\(\\1,.*?\\)),\\s*(\\w+)=(\\[.*?]);\\s*\\3\\[\\d+](.*?try)(\\{.*?})catch\\(\\s*(\\w+)\\s*\\)\\s*\\{\\s*return"[\\w-]+([A-z0-9-]+)"\\s*\\+\\s*\\1\\s*}\\s*return\\s*(\\2\\.join\\(""\\)|Array\\.prototype\\.join\\.call\\(\\2,.*?\\))};';
  const DECIPHER_ARGUMENT = "sig";
  const N_ARGUMENT = "ncode";
  const matchRegex = (regex, str) => {
    const match = str.match(new RegExp(regex, "s"));
    if (!match) throw new Error(`Could not match ${regex}`);
    return match;
  };
  const matchGroup = (regex, str, idx = 0) => matchRegex(regex, str)[idx];
  const getFuncName = (body2, regexps) => {
    let fn;
    for (const [regex, idx] of Object.entries(regexps)) {
      try {
        fn = matchGroup(regex, body2, idx);
        try {
          fn = matchGroup(`${fn.replace(/\$/g, "\\$")}=\\[([a-zA-Z0-9$\\[\\]]{2,})\\]`, body2, 1);
        } catch (err) {
        }
        break;
      } catch (err) {
        continue;
      }
    }
    if (!fn || fn.includes("[")) throw Error("Could not match");
    return fn;
  };
  const DECIPHER_FUNC_NAME = "DisTubeDecipherFunc";
  const extractDecipherFunc = exports.d1 = (body2) => {
    try {
      const helperObject = matchGroup(HELPER_REGEXP, body2, 0);
      const decipherFunc = matchGroup(DECIPHER_REGEXP, body2, 0);
      const resultFunc = `var ${DECIPHER_FUNC_NAME}=${decipherFunc};`;
      const callerFunc = `${DECIPHER_FUNC_NAME}(${DECIPHER_ARGUMENT});`;
      return helperObject + resultFunc + callerFunc;
    } catch (e) {
      return null;
    }
  };
  const extractDecipherWithName = exports.d2 = (body2) => {
    try {
      const decipherFuncName = getFuncName(body2, DECIPHER_NAME_REGEXPS);
      const funcPattern = `(${decipherFuncName.replace(/\$/g, "\\$")}=function\\([a-zA-Z0-9_]+\\)\\{.+?\\})`;
      const decipherFunc = `var ${matchGroup(funcPattern, body2, 1)};`;
      const helperObjectName = matchGroup(";([A-Za-z0-9_\\$]{2,})\\.\\w+\\(", decipherFunc, 1);
      const helperPattern = `(var ${helperObjectName.replace(/\$/g, "\\$")}=\\{[\\s\\S]+?\\}\\};)`;
      const helperObject = matchGroup(helperPattern, body2, 1);
      const callerFunc = `${decipherFuncName}(${DECIPHER_ARGUMENT});`;
      return helperObject + decipherFunc + callerFunc;
    } catch (e) {
      return null;
    }
  };
  const getExtractFunctions = (extractFunctions, body2, postProcess = null) => {
    for (const extractFunction of extractFunctions) {
      try {
        const func = extractFunction(body2);
        if (!func) continue;
        return new vm.Script(postProcess ? postProcess(func) : func);
      } catch (err) {
        continue;
      }
    }
    return null;
  };
  let decipherWarning = false;
  const extractDecipher = (body2) => {
    const decipherFunc = getExtractFunctions([extractDecipherFunc, extractDecipherWithName], body2);
    if (!decipherFunc && !decipherWarning) {
      console.warn(
        `\x1B[33mWARNING:\x1B[0m Could not parse decipher function.
Stream URLs will be missing.
Please report this issue by uploading the "${utils2.saveDebugFile(
          "base.js",
          body2
        )}" file on https://github.com/distubejs/ytdl-core/issues/144.`
      );
      decipherWarning = true;
    }
    return decipherFunc;
  };
  const N_TRANSFORM_FUNC_NAME = "DisTubeNTransformFunc";
  const extractNTransformFunc = exports.n1 = (body2) => {
    try {
      const nFunc = matchGroup(N_TRANSFORM_REGEXP, body2, 0);
      const resultFunc = `var ${N_TRANSFORM_FUNC_NAME}=${nFunc}`;
      const callerFunc = `${N_TRANSFORM_FUNC_NAME}(${N_ARGUMENT});`;
      return resultFunc + callerFunc;
    } catch (e) {
      return null;
    }
  };
  const extractNTransformWithName = exports.n2 = (body2) => {
    try {
      const nFuncName = getFuncName(body2, N_TRANSFORM_NAME_REGEXPS);
      const funcPattern = `(${nFuncName.replace(/\$/g, "\\$")}=function\\([a-zA-Z0-9_]+\\)\\{.+?\\})`;
      const nTransformFunc = `var ${matchGroup(funcPattern, body2, 1)};`;
      const callerFunc = `${nFuncName}(${N_ARGUMENT});`;
      return nTransformFunc + callerFunc;
    } catch (e) {
      return null;
    }
  };
  let nTransformWarning = false;
  const extractNTransform = (body2) => {
    const nTransformFunc = getExtractFunctions(
      [extractNTransformFunc, extractNTransformWithName],
      body2,
      (code) => code.replace(/if\s*\(\s*typeof\s*[\w$]+\s*===?.*?\)\s*return\s+[\w$]+\s*;?/, "")
    );
    if (!nTransformFunc && !nTransformWarning) {
      console.warn(
        `\x1B[33mWARNING:\x1B[0m Could not parse n transform function.
Please report this issue by uploading the "${utils2.saveDebugFile(
          "base.js",
          body2
        )}" file on https://github.com/distubejs/ytdl-core/issues/144.`
      );
      nTransformWarning = true;
    }
    return nTransformFunc;
  };
  exports.extractFunctions = (body2) => [extractDecipher(body2), extractNTransform(body2)];
  exports.setDownloadURL = (format, decipherScript, nTransformScript) => {
    if (!decipherScript) return;
    const decipher = (url2) => {
      const args = querystring.parse(url2);
      if (!args.s) return args.url;
      const components = new URL(decodeURIComponent(args.url));
      const context = {};
      context[DECIPHER_ARGUMENT] = decodeURIComponent(args.s);
      components.searchParams.set(args.sp || "sig", decipherScript.runInNewContext(context));
      return components.toString();
    };
    const nTransform = (url2) => {
      const components = new URL(decodeURIComponent(url2));
      const n = components.searchParams.get("n");
      if (!n || !nTransformScript) return url2;
      const context = {};
      context[N_ARGUMENT] = n;
      components.searchParams.set("n", nTransformScript.runInNewContext(context));
      return components.toString();
    };
    const cipher = !format.url;
    const url = format.url || format.signatureCipher || format.cipher;
    format.url = nTransform(cipher ? decipher(url) : url);
    delete format.signatureCipher;
    delete format.cipher;
  };
  exports.decipherFormats = async (formats2, html5player, options) => {
    const decipheredFormats = {};
    const [decipherScript, nTransformScript] = await exports.getFunctions(html5player, options);
    formats2.forEach((format) => {
      exports.setDownloadURL(format, decipherScript, nTransformScript);
      decipheredFormats[format.url] = format;
    });
    return decipheredFormats;
  };
})(sig);
(function(exports) {
  const sax$1 = sax;
  const utils2 = utils$5;
  const { setTimeout: setTimeout2 } = require$$0$b;
  const formatUtils2 = formatUtils$1;
  const urlUtils2 = urlUtils$1;
  const extras = infoExtras;
  const Cache2 = cache;
  const sig$1 = sig;
  const BASE_URL2 = "https://www.youtube.com/watch?v=";
  exports.cache = new Cache2();
  exports.watchPageCache = new Cache2();
  const AGE_RESTRICTED_URLS = ["support.google.com/youtube/?p=age_restrictions", "youtube.com/t/community_guidelines"];
  exports.getBasicInfo = async (id, options) => {
    var _a2, _b2, _c2;
    utils2.applyIPv6Rotations(options);
    utils2.applyDefaultHeaders(options);
    utils2.applyDefaultAgent(options);
    utils2.applyOldLocalAddress(options);
    const retryOptions = Object.assign({}, options.requestOptions);
    const { jar, dispatcher: dispatcher2 } = options.agent;
    utils2.setPropInsensitive(
      options.requestOptions.headers,
      "cookie",
      jar.getCookieStringSync("https://www.youtube.com")
    );
    options.requestOptions.dispatcher = dispatcher2;
    const info2 = await retryFunc(getWatchHTMLPage, [id, options], retryOptions);
    const playErr = utils2.playError(info2.player_response);
    if (playErr) throw playErr;
    Object.assign(info2, {
      // Replace with formats from iosPlayerResponse
      // formats: parseFormats(info.player_response),
      related_videos: extras.getRelatedVideos(info2)
    });
    const media = extras.getMedia(info2);
    const additional = {
      author: extras.getAuthor(info2),
      media,
      likes: extras.getLikes(info2),
      age_restricted: !!(media && AGE_RESTRICTED_URLS.some((url) => Object.values(media).some((v) => typeof v === "string" && v.includes(url)))),
      // Give the standard link to the video.
      video_url: BASE_URL2 + id,
      storyboards: extras.getStoryboards(info2),
      chapters: extras.getChapters(info2)
    };
    info2.videoDetails = extras.cleanVideoDetails(
      Object.assign(
        {},
        (_b2 = (_a2 = info2.player_response) == null ? void 0 : _a2.microformat) == null ? void 0 : _b2.playerMicroformatRenderer,
        (_c2 = info2.player_response) == null ? void 0 : _c2.videoDetails,
        additional
      ),
      info2
    );
    return info2;
  };
  const getWatchHTMLURL = (id, options) => `${BASE_URL2 + id}&hl=${options.lang || "en"}&bpctr=${Math.ceil(Date.now() / 1e3)}&has_verified=1`;
  const getWatchHTMLPageBody = (id, options) => {
    const url = getWatchHTMLURL(id, options);
    return exports.watchPageCache.getOrSet(url, () => utils2.request(url, options));
  };
  const EMBED_URL = "https://www.youtube.com/embed/";
  const getEmbedPageBody = (id, options) => {
    const embedUrl = `${EMBED_URL + id}?hl=${options.lang || "en"}`;
    return utils2.request(embedUrl, options);
  };
  const getHTML5player = (body2) => {
    let html5playerRes = /<script\s+src="([^"]+)"(?:\s+type="text\/javascript")?\s+name="player_ias\/base"\s*>|"jsUrl":"([^"]+)"/.exec(body2);
    return (html5playerRes == null ? void 0 : html5playerRes[1]) || (html5playerRes == null ? void 0 : html5playerRes[2]);
  };
  const retryFunc = async (func, args, options) => {
    let currentTry = 0, result;
    if (!options.maxRetries) options.maxRetries = 3;
    if (!options.backoff) options.backoff = { inc: 500, max: 5e3 };
    while (currentTry <= options.maxRetries) {
      try {
        result = await func(...args);
        break;
      } catch (err) {
        if ((err == null ? void 0 : err.statusCode) < 500 || currentTry >= options.maxRetries) throw err;
        let wait = Math.min(++currentTry * options.backoff.inc, options.backoff.max);
        await new Promise((resolve2) => setTimeout2(resolve2, wait));
      }
    }
    return result;
  };
  const jsonClosingChars = /^[)\]}'\s]+/;
  const parseJSON = (source, varName, json2) => {
    if (!json2 || typeof json2 === "object") {
      return json2;
    } else {
      try {
        json2 = json2.replace(jsonClosingChars, "");
        return JSON.parse(json2);
      } catch (err) {
        throw Error(`Error parsing ${varName} in ${source}: ${err.message}`);
      }
    }
  };
  const findJSON = (source, varName, body2, left, right, prependJSON) => {
    let jsonStr = utils2.between(body2, left, right);
    if (!jsonStr) {
      throw Error(`Could not find ${varName} in ${source}`);
    }
    return parseJSON(source, varName, utils2.cutAfterJS(`${prependJSON}${jsonStr}`));
  };
  const findPlayerResponse = (source, info2) => {
    var _a2;
    if (!info2) return {};
    const player_response = ((_a2 = info2.args) == null ? void 0 : _a2.player_response) || info2.player_response || info2.playerResponse || info2.embedded_player_response;
    return parseJSON(source, "player_response", player_response);
  };
  const getWatchHTMLPage = async (id, options) => {
    let body2 = await getWatchHTMLPageBody(id, options);
    let info2 = { page: "watch" };
    try {
      try {
        info2.player_response = utils2.tryParseBetween(body2, "var ytInitialPlayerResponse = ", "}};", "", "}}") || utils2.tryParseBetween(body2, "var ytInitialPlayerResponse = ", ";var") || utils2.tryParseBetween(body2, "var ytInitialPlayerResponse = ", ";<\/script>") || findJSON("watch.html", "player_response", body2, /\bytInitialPlayerResponse\s*=\s*\{/i, "<\/script>", "{");
      } catch (_e2) {
        let args = findJSON("watch.html", "player_response", body2, /\bytplayer\.config\s*=\s*{/, "<\/script>", "{");
        info2.player_response = findPlayerResponse("watch.html", args);
      }
      info2.response = utils2.tryParseBetween(body2, "var ytInitialData = ", "}};", "", "}}") || utils2.tryParseBetween(body2, "var ytInitialData = ", ";<\/script>") || utils2.tryParseBetween(body2, 'window["ytInitialData"] = ', "}};", "", "}}") || utils2.tryParseBetween(body2, 'window["ytInitialData"] = ', ";<\/script>") || findJSON("watch.html", "response", body2, /\bytInitialData("\])?\s*=\s*\{/i, "<\/script>", "{");
      info2.html5player = getHTML5player(body2);
    } catch (_) {
      throw Error(
        `Error when parsing watch.html, maybe YouTube made a change.
Please report this issue with the "${utils2.saveDebugFile(
          "watch.html",
          body2
        )}" file on https://github.com/distubejs/ytdl-core/issues.`
      );
    }
    return info2;
  };
  const parseFormats = (player_response) => {
    var _a2, _b2, _c2;
    return (_c2 = ((_a2 = player_response == null ? void 0 : player_response.streamingData) == null ? void 0 : _a2.formats) || []) == null ? void 0 : _c2.concat(((_b2 = player_response == null ? void 0 : player_response.streamingData) == null ? void 0 : _b2.adaptiveFormats) || []);
  };
  const parseAdditionalManifests = (player_response, options) => {
    let streamingData = player_response == null ? void 0 : player_response.streamingData, manifests = [];
    if (streamingData) {
      if (streamingData.dashManifestUrl) {
        manifests.push(getDashManifest(streamingData.dashManifestUrl, options));
      }
      if (streamingData.hlsManifestUrl) {
        manifests.push(getM3U8(streamingData.hlsManifestUrl, options));
      }
    }
    return manifests;
  };
  exports.getInfo = async (id, options) => {
    utils2.applyIPv6Rotations(options);
    utils2.applyDefaultHeaders(options);
    utils2.applyDefaultAgent(options);
    utils2.applyOldLocalAddress(options);
    utils2.applyPlayerClients(options);
    const info2 = await exports.getBasicInfo(id, options);
    let funcs = [];
    info2.html5player = info2.html5player || getHTML5player(await getWatchHTMLPageBody(id, options)) || getHTML5player(await getEmbedPageBody(id, options));
    if (!info2.html5player) {
      throw Error("Unable to find html5player file");
    }
    info2.html5player = new URL(info2.html5player, BASE_URL2).toString();
    let bestPlayerResponse = null;
    try {
      const promises = [];
      if (options.playerClients.includes("WEB_EMBEDDED")) promises.push(fetchWebEmbeddedPlayer(id, info2, options));
      if (options.playerClients.includes("TV")) promises.push(fetchTvPlayer(id, info2, options));
      if (options.playerClients.includes("IOS")) promises.push(fetchIosJsonPlayer(id, options));
      if (options.playerClients.includes("ANDROID")) promises.push(fetchAndroidJsonPlayer(id, options));
      if (promises.length > 0) {
        const responses = await Promise.allSettled(promises);
        const successfulResponses = responses.filter((r) => r.status === "fulfilled").map((r) => r.value).filter((r) => r);
        console.log(`Found ${successfulResponses.length} successful responses from clients`);
        if (successfulResponses.length > 0) {
          bestPlayerResponse = successfulResponses[0];
          funcs.push(sig$1.decipherFormats(parseFormats(bestPlayerResponse), info2.html5player, options));
          funcs.push(...parseAdditionalManifests(bestPlayerResponse, options));
        }
      }
      if (!bestPlayerResponse && options.playerClients.includes("WEB")) {
        bestPlayerResponse = info2.player_response;
        funcs.push(sig$1.decipherFormats(parseFormats(info2.player_response), info2.html5player, options));
        funcs.push(...parseAdditionalManifests(info2.player_response, options));
      }
    } catch (error) {
      console.error("Error fetching formats:", error);
      if (!bestPlayerResponse && options.playerClients.includes("WEB")) {
        bestPlayerResponse = info2.player_response;
        funcs.push(sig$1.decipherFormats(parseFormats(info2.player_response), info2.html5player, options));
        funcs.push(...parseAdditionalManifests(info2.player_response, options));
      }
    }
    if (funcs.length === 0) {
      throw new Error("Failed to find any playable formats");
    }
    let results = await Promise.all(funcs);
    info2.formats = Object.values(Object.assign({}, ...results));
    info2.formats = info2.formats.filter((format) => format && format.url && format.mimeType);
    if (info2.formats.length === 0) {
      throw new Error("No playable formats found");
    }
    info2.formats = info2.formats.map((format) => {
      const enhancedFormat = formatUtils2.addFormatMeta(format);
      if (!enhancedFormat.audioBitrate && enhancedFormat.hasAudio) {
        enhancedFormat.audioBitrate = estimateAudioBitrate(enhancedFormat);
      }
      if (!enhancedFormat.isHLS && enhancedFormat.mimeType && (enhancedFormat.mimeType.includes("hls") || enhancedFormat.mimeType.includes("x-mpegURL") || enhancedFormat.mimeType.includes("application/vnd.apple.mpegurl"))) {
        enhancedFormat.isHLS = true;
      }
      return enhancedFormat;
    });
    info2.formats.sort(formatUtils2.sortFormats);
    const bestFormat = info2.formats.find((format) => format.hasVideo && format.hasAudio) || info2.formats.find((format) => format.hasVideo) || info2.formats.find((format) => format.hasAudio) || info2.formats[0];
    info2.bestFormat = bestFormat;
    info2.videoUrl = bestFormat.url;
    info2.selectedFormat = bestFormat;
    info2.full = true;
    return info2;
  };
  const getPlaybackContext = async (html5player, options) => {
    const body2 = await utils2.request(html5player, options);
    const mo = body2.match(/(signatureTimestamp|sts):(\d+)/);
    return {
      contentPlaybackContext: {
        html5Preference: "HTML5_PREF_WANTS",
        signatureTimestamp: mo == null ? void 0 : mo[2]
      }
    };
  };
  const LOCALE = { hl: "en", timeZone: "UTC", utcOffsetMinutes: 0 }, CHECK_FLAGS = { contentCheckOk: true, racyCheckOk: true };
  const WEB_EMBEDDED_CONTEXT = {
    client: {
      clientName: "WEB_EMBEDDED_PLAYER",
      clientVersion: "1.20240723.01.00",
      ...LOCALE
    }
  };
  const TVHTML5_CONTEXT = {
    client: {
      clientName: "TVHTML5",
      clientVersion: "7.20241201.18.00",
      ...LOCALE
    }
  };
  const fetchWebEmbeddedPlayer = async (videoId, info2, options) => {
    const payload = {
      context: WEB_EMBEDDED_CONTEXT,
      videoId,
      playbackContext: await getPlaybackContext(info2.html5player, options),
      ...CHECK_FLAGS
    };
    return await playerAPI(videoId, payload, options);
  };
  const fetchTvPlayer = async (videoId, info2, options) => {
    const payload = {
      context: TVHTML5_CONTEXT,
      videoId,
      playbackContext: await getPlaybackContext(info2.html5player, options),
      ...CHECK_FLAGS
    };
    return await playerAPI(videoId, payload, options);
  };
  const playerAPI = async (videoId, payload, options) => {
    const { jar, dispatcher: dispatcher2 } = options.agent;
    const opts = {
      requestOptions: {
        method: "POST",
        dispatcher: dispatcher2,
        query: {
          prettyPrint: false,
          t: utils2.generateClientPlaybackNonce(12),
          id: videoId
        },
        headers: {
          "Content-Type": "application/json",
          Cookie: jar.getCookieStringSync("https://www.youtube.com"),
          "X-Goog-Api-Format-Version": "2"
        },
        body: JSON.stringify(payload)
      }
    };
    const response2 = await utils2.request("https://youtubei.googleapis.com/youtubei/v1/player", opts);
    const playErr = utils2.playError(response2);
    if (playErr) throw playErr;
    if (!response2.videoDetails || videoId !== response2.videoDetails.videoId) {
      const err = new Error("Malformed response from YouTube");
      err.response = response2;
      throw err;
    }
    return response2;
  };
  const IOS_CLIENT_VERSION = "19.42.1", IOS_DEVICE_MODEL = "iPhone16,2", IOS_USER_AGENT_VERSION = "17_5_1", IOS_OS_VERSION = "17.5.1.21F90";
  const fetchIosJsonPlayer = async (videoId, options) => {
    const payload = {
      videoId,
      cpn: utils2.generateClientPlaybackNonce(16),
      contentCheckOk: true,
      racyCheckOk: true,
      context: {
        client: {
          clientName: "IOS",
          clientVersion: IOS_CLIENT_VERSION,
          deviceMake: "Apple",
          deviceModel: IOS_DEVICE_MODEL,
          platform: "MOBILE",
          osName: "iOS",
          osVersion: IOS_OS_VERSION,
          hl: "en",
          gl: "US",
          utcOffsetMinutes: -240
        },
        request: {
          internalExperimentFlags: [],
          useSsl: true
        },
        user: {
          lockedSafetyMode: false
        }
      }
    };
    const { jar, dispatcher: dispatcher2 } = options.agent;
    const opts = {
      requestOptions: {
        method: "POST",
        dispatcher: dispatcher2,
        query: {
          prettyPrint: false,
          t: utils2.generateClientPlaybackNonce(12),
          id: videoId
        },
        headers: {
          "Content-Type": "application/json",
          cookie: jar.getCookieStringSync("https://www.youtube.com"),
          "User-Agent": `com.google.ios.youtube/${IOS_CLIENT_VERSION}(${IOS_DEVICE_MODEL}; U; CPU iOS ${IOS_USER_AGENT_VERSION} like Mac OS X; en_US)`,
          "X-Goog-Api-Format-Version": "2"
        },
        body: JSON.stringify(payload)
      }
    };
    const response2 = await utils2.request("https://youtubei.googleapis.com/youtubei/v1/player", opts);
    const playErr = utils2.playError(response2);
    if (playErr) throw playErr;
    if (!response2.videoDetails || videoId !== response2.videoDetails.videoId) {
      const err = new Error("Malformed response from YouTube");
      err.response = response2;
      throw err;
    }
    return response2;
  };
  const ANDROID_CLIENT_VERSION = "19.30.36", ANDROID_OS_VERSION = "14", ANDROID_SDK_VERSION = "34";
  const fetchAndroidJsonPlayer = async (videoId, options) => {
    const payload = {
      videoId,
      cpn: utils2.generateClientPlaybackNonce(16),
      contentCheckOk: true,
      racyCheckOk: true,
      context: {
        client: {
          clientName: "ANDROID",
          clientVersion: ANDROID_CLIENT_VERSION,
          platform: "MOBILE",
          osName: "Android",
          osVersion: ANDROID_OS_VERSION,
          androidSdkVersion: ANDROID_SDK_VERSION,
          hl: "en",
          gl: "US",
          utcOffsetMinutes: -240
        },
        request: {
          internalExperimentFlags: [],
          useSsl: true
        },
        user: {
          lockedSafetyMode: false
        }
      }
    };
    const { jar, dispatcher: dispatcher2 } = options.agent;
    const opts = {
      requestOptions: {
        method: "POST",
        dispatcher: dispatcher2,
        query: {
          prettyPrint: false,
          t: utils2.generateClientPlaybackNonce(12),
          id: videoId
        },
        headers: {
          "Content-Type": "application/json",
          cookie: jar.getCookieStringSync("https://www.youtube.com"),
          "User-Agent": `com.google.android.youtube/${ANDROID_CLIENT_VERSION} (Linux; U; Android ${ANDROID_OS_VERSION}; en_US) gzip`,
          "X-Goog-Api-Format-Version": "2"
        },
        body: JSON.stringify(payload)
      }
    };
    const response2 = await utils2.request("https://youtubei.googleapis.com/youtubei/v1/player", opts);
    const playErr = utils2.playError(response2);
    if (playErr) throw playErr;
    if (!response2.videoDetails || videoId !== response2.videoDetails.videoId) {
      const err = new Error("Malformed response from YouTube");
      err.response = response2;
      throw err;
    }
    return response2;
  };
  const getDashManifest = (url, options) => new Promise((resolve2, reject) => {
    let formats2 = {};
    const parser = sax$1.parser(false);
    parser.onerror = reject;
    let adaptationSet;
    parser.onopentag = (node2) => {
      if (node2.name === "ADAPTATIONSET") {
        adaptationSet = node2.attributes;
      } else if (node2.name === "REPRESENTATION") {
        const itag = parseInt(node2.attributes.ID);
        if (!isNaN(itag)) {
          formats2[url] = Object.assign(
            {
              itag,
              url,
              bitrate: parseInt(node2.attributes.BANDWIDTH),
              mimeType: `${adaptationSet.MIMETYPE}; codecs="${node2.attributes.CODECS}"`
            },
            node2.attributes.HEIGHT ? {
              width: parseInt(node2.attributes.WIDTH),
              height: parseInt(node2.attributes.HEIGHT),
              fps: parseInt(node2.attributes.FRAMERATE)
            } : {
              audioSampleRate: node2.attributes.AUDIOSAMPLINGRATE
            }
          );
        }
      }
    };
    parser.onend = () => {
      resolve2(formats2);
    };
    utils2.request(new URL(url, BASE_URL2).toString(), options).then((res) => {
      parser.write(res);
      parser.close();
    }).catch(reject);
  });
  const getM3U8 = async (url, options) => {
    url = new URL(url, BASE_URL2);
    const body2 = await utils2.request(url.toString(), options);
    let formats2 = {};
    body2.split("\n").filter((line) => /^https?:\/\//.test(line)).forEach((line) => {
      const itag = parseInt(line.match(/\/itag\/(\d+)\//)[1]);
      formats2[line] = { itag, url: line };
    });
    return formats2;
  };
  for (let funcName of ["getBasicInfo", "getInfo"]) {
    const func = exports[funcName];
    exports[funcName] = async (link, options = {}) => {
      utils2.checkForUpdates();
      let id = await urlUtils2.getVideoID(link);
      const key = [funcName, id, options.lang].join("-");
      return exports.cache.getOrSet(key, () => func(id, options));
    };
  }
  exports.validateID = urlUtils2.validateID;
  exports.validateURL = urlUtils2.validateURL;
  exports.getURLVideoID = urlUtils2.getURLVideoID;
  exports.getVideoID = urlUtils2.getVideoID;
})(info);
const PassThrough = require$$0$7.PassThrough;
const getInfo = info;
const utils = utils$5;
const formatUtils = formatUtils$1;
const urlUtils = urlUtils$1;
const miniget = dist$1;
const m3u8stream = dist;
const { parseTimestamp } = dist;
const agent = agent$2;
const ytdl = (link, options) => {
  const stream2 = createStream(options);
  ytdl.getInfo(link, options).then(
    (info2) => {
      downloadFromInfoCallback(stream2, info2, options);
    },
    stream2.emit.bind(stream2, "error")
  );
  return stream2;
};
var lib = ytdl;
ytdl.getBasicInfo = getInfo.getBasicInfo;
ytdl.getInfo = getInfo.getInfo;
ytdl.chooseFormat = formatUtils.chooseFormat;
ytdl.filterFormats = formatUtils.filterFormats;
ytdl.validateID = urlUtils.validateID;
ytdl.validateURL = urlUtils.validateURL;
ytdl.getURLVideoID = urlUtils.getURLVideoID;
ytdl.getVideoID = urlUtils.getVideoID;
ytdl.createAgent = agent.createAgent;
ytdl.createProxyAgent = agent.createProxyAgent;
ytdl.cache = {
  info: getInfo.cache,
  watch: getInfo.watchPageCache
};
ytdl.version = require$$8.version;
const createStream = (options) => {
  const stream2 = new PassThrough({ highWaterMark: (options == null ? void 0 : options.highWaterMark) || 1024 * 512 });
  stream2._destroy = () => {
    stream2.destroyed = true;
  };
  return stream2;
};
const pipeAndSetEvents = (req2, stream2, end) => {
  ["abort", "request", "response", "error", "redirect", "retry", "reconnect"].forEach((event) => {
    req2.prependListener(event, stream2.emit.bind(stream2, event));
  });
  req2.pipe(stream2, { end });
};
const downloadFromInfoCallback = (stream2, info2, options) => {
  var _a2, _b2, _c2, _d2;
  options = options || {};
  let err = utils.playError(info2.player_response);
  if (err) {
    stream2.emit("error", err);
    return;
  }
  if (!info2.formats.length) {
    stream2.emit("error", Error("This video is unavailable"));
    return;
  }
  let format;
  try {
    format = formatUtils.chooseFormat(info2.formats, options);
  } catch (e) {
    stream2.emit("error", e);
    return;
  }
  stream2.emit("info", info2, format);
  if (stream2.destroyed) {
    return;
  }
  let contentLength, downloaded = 0;
  const ondata = (chunk) => {
    downloaded += chunk.length;
    stream2.emit("progress", chunk.length, downloaded, contentLength);
  };
  utils.applyDefaultHeaders(options);
  if (options.IPv6Block) {
    options.requestOptions = Object.assign({}, options.requestOptions, {
      localAddress: utils.getRandomIPv6(options.IPv6Block)
    });
  }
  if (options.agent) {
    options.requestOptions.agent = options.agent.agent;
    if (options.agent.jar) {
      utils.setPropInsensitive(
        options.requestOptions.headers,
        "cookie",
        options.agent.jar.getCookieStringSync("https://www.youtube.com")
      );
    }
    if (options.agent.localAddress) {
      options.requestOptions.localAddress = options.agent.localAddress;
    }
  }
  const dlChunkSize = typeof options.dlChunkSize === "number" ? options.dlChunkSize : 1024 * 1024 * 10;
  let req2;
  let shouldEnd = true;
  if (format.isHLS || format.isDashMPD) {
    req2 = m3u8stream(format.url, {
      chunkReadahead: +info2.live_chunk_readahead,
      begin: options.begin || format.isLive && Date.now(),
      liveBuffer: options.liveBuffer,
      // Now we have passed not only custom "dispatcher" with undici ProxyAgent, but also "agent" field which is compatible for node http
      requestOptions: options.requestOptions,
      parser: format.isDashMPD ? "dash-mpd" : "m3u8",
      id: format.itag
    });
    req2.on("progress", (segment, totalSegments) => {
      stream2.emit("progress", segment.size, segment.num, totalSegments);
    });
    pipeAndSetEvents(req2, stream2, shouldEnd);
  } else {
    const requestOptions = Object.assign({}, options.requestOptions, {
      maxReconnects: 6,
      maxRetries: 3,
      backoff: { inc: 500, max: 1e4 }
    });
    let shouldBeChunked = dlChunkSize !== 0 && (!format.hasAudio || !format.hasVideo);
    if (shouldBeChunked) {
      let start = ((_a2 = options.range) == null ? void 0 : _a2.start) || 0;
      let end = start + dlChunkSize;
      const rangeEnd = (_b2 = options.range) == null ? void 0 : _b2.end;
      contentLength = options.range ? (rangeEnd ? rangeEnd + 1 : parseInt(format.contentLength)) - start : parseInt(format.contentLength);
      const getNextChunk = () => {
        if (stream2.destroyed) return;
        if (!rangeEnd && end >= contentLength) end = 0;
        if (rangeEnd && end > rangeEnd) end = rangeEnd;
        shouldEnd = !end || end === rangeEnd;
        requestOptions.headers = Object.assign({}, requestOptions.headers, {
          Range: `bytes=${start}-${end || ""}`
        });
        req2 = miniget(format.url, requestOptions);
        req2.on("data", ondata);
        req2.on("end", () => {
          if (stream2.destroyed) return;
          if (end && end !== rangeEnd) {
            start = end + 1;
            end += dlChunkSize;
            getNextChunk();
          }
        });
        pipeAndSetEvents(req2, stream2, shouldEnd);
      };
      getNextChunk();
    } else {
      if (options.begin) {
        format.url += `&begin=${parseTimestamp(options.begin)}`;
      }
      if (((_c2 = options.range) == null ? void 0 : _c2.start) || ((_d2 = options.range) == null ? void 0 : _d2.end)) {
        requestOptions.headers = Object.assign({}, requestOptions.headers, {
          Range: `bytes=${options.range.start || "0"}-${options.range.end || ""}`
        });
      }
      req2 = miniget(format.url, requestOptions);
      req2.on("response", (res) => {
        if (stream2.destroyed) return;
        contentLength = contentLength || parseInt(res.headers["content-length"]);
      });
      req2.on("data", ondata);
      pipeAndSetEvents(req2, stream2, shouldEnd);
    }
  }
  stream2._destroy = () => {
    stream2.destroyed = true;
    if (req2) {
      req2.destroy();
      req2.end();
    }
  };
};
ytdl.downloadFromInfo = (info2, options) => {
  const stream2 = createStream(options);
  if (!info2.full) {
    throw Error("Cannot use `ytdl.downloadFromInfo()` when called with info from `ytdl.getBasicInfo()`");
  }
  setImmediate(() => {
    downloadFromInfoCallback(stream2, info2, options);
  });
  return stream2;
};
const ytdl$1 = /* @__PURE__ */ getDefaultExportFromCjs(lib);
const require$2 = createRequire(import.meta.url);
const { connect } = require$2("puppeteer-real-browser");
const pathMap = {
  "www.91porn.com": _91Pron,
  "www.youtube.com": _youtube
};
async function PathAnalysis(path2) {
  console.warn(path2);
  if (!path2) {
    return "";
  }
  const url = new URL(path2);
  const res = await pathMap[url.hostname](path2);
  if (res.analysisUrl) {
    console.log("####地址解析完成：" + res.analysisUrl);
  }
  return res;
}
async function _youtube(path2) {
  const res = {
    analysisUrl: "",
    //下载地址
    fileName: "",
    //文件名称
    suffix: ".mp4",
    //文件后缀
    fileType: DownloadFileType.MP4
  };
  try {
    const info2 = await ytdl$1.getInfo(path2);
    res.fileName = info2.videoDetails.title;
    const formats2 = info2.formats.map((format) => ({
      quality: format.qualityLabel || "audio",
      // 视频质量或音频
      mimeType: format.mimeType,
      // 文件类型（如 video/mp4）
      url: format.url
      // 下载地址
    }));
    console.warn(res.fileName, JSON.stringify(formats2));
    return res;
  } catch (e) {
    console.log(e);
    return res;
  }
}
async function _91Pron(path2) {
  const res = {
    analysisUrl: "",
    //下载地址
    fileName: "",
    //文件名称
    suffix: ".mp4",
    //文件后缀
    fileType: DownloadFileType.MP4,
    cover: ""
  };
  try {
    const { browser: browser2, page } = await connect({
      headless: false,
      turnstile: true,
      disableXvfb: true,
      ignoreAllFlags: false,
      plugins: [require$2("puppeteer-extra-plugin-click-and-wait")()],
      args: [
        // "--disable-blink-features=AutomationControlled", // 禁用自动化标记
        // '--no-sandbox', // 在某些环境中可能需要此参数，但请注意安全风险
        // '--disable-setuid-sandbox', // 同上
        // '--disable-dev-shm-usage', // 禁用 dev shm usage
        // '--disable-accelerated-2d-canvas', // 禁用硬件加速的 canvas
        // '--disable-gpu', // 禁用 GPU 加速，有时可以绕过某些验证
        // "--window-size=1920,1080", // 设置合理视口
      ]
    });
    await page.goto(path2, { waitUntil: ["domcontentloaded"] });
    const selector = "#player_one_html5_api";
    await page.waitForSelector(selector);
    const _videoElment = await page.$(selector + " source");
    const _coverElment = await page.$("#player_one_html5_api");
    const _title = await page.title();
    if (_title) res.fileName = _title.replace(" Chinese homemade video", "");
    if (_videoElment) {
      const _link = await _videoElment.getProperty("src");
      const _cover = await _coverElment.getProperty("poster");
      res.cover = await _cover.jsonValue();
      res.analysisUrl = await _link.jsonValue();
      console.warn(res.cover, res.analysisUrl);
    }
    await browser2.close();
    return res;
  } catch (e) {
    console.log(e);
  }
}
function DownloadFile(downloadObj, savePath, downloadTask) {
  const win2 = new BrowserWindow({
    show: false,
    // 初始不显示窗口
    skipTaskbar: true,
    // 不在任务栏显示
    width: 1,
    // 最小化尺寸
    height: 1,
    x: 0,
    // 放在屏幕外（可选）
    y: 0,
    frame: false,
    // 无边框
    transparent: true,
    // 透明背景（可选）
    webPreferences: {
      nodeIntegration: true,
      // 按需启用
      contextIsolation: false,
      // 根据需求调整
      devTools: false
      // 生产环境禁用开发者工具
    }
  });
  console.warn(JSON.stringify(downloadObj), savePath);
  win2.webContents.session.once("will-download", (_, item) => {
    console.warn("#####create download");
    let startTime = Date.now();
    let previousBytes = 0;
    const filePath = path.join(savePath, downloadObj.fileName + downloadObj.suffix);
    item.setSavePath(filePath);
    console.warn(JSON.stringify(item));
    item.on("updated", (_2, state) => {
      const currentBytes = item.getReceivedBytes();
      const currentTime = Date.now();
      const timeDiff = (currentTime - startTime) / 1e3;
      const bytesDiff = currentBytes - previousBytes;
      const speed = bytesDiff / timeDiff;
      previousBytes = currentBytes;
      startTime = currentTime;
      if (state === "interrupted") {
        console.log("下载中断");
        downloadTask.status = DownloadStatus.PAUSE;
        updateDownloadStatus(downloadTask);
      } else if (state === "progressing") {
        const _progress = (Number(item.getReceivedBytes()) / Number(item.getTotalBytes())).toFixed(2);
        console.log(`下载进度: ${_progress}%`);
        downloadTask.status = DownloadStatus.PENDING;
        downloadTask.TotalBytes = item.getTotalBytes();
        downloadTask.receivedBytes = item.getReceivedBytes();
        downloadTask.speed = speed;
        updateDownloadStatus(downloadTask);
      }
    });
    item.on("done", (_2, state) => {
      win2.destroy();
      if (state === "completed") {
        console.log("下载完成:", filePath);
        downloadTask.status = DownloadStatus.FINISH;
        downloadTask.TotalBytes = item.getTotalBytes();
        downloadTask.receivedBytes = item.getReceivedBytes();
        updateDownloadStatus(downloadTask);
      } else {
        console.log("下载失败:", state);
        downloadTask.status = DownloadStatus.ERROR;
        updateDownloadStatus(downloadTask);
      }
    });
  });
  win2.webContents.downloadURL(downloadObj.analysisUrl);
}
function updateDownloadStatus(downloadTask) {
  global.win.webContents.send("download:updateDownload", downloadTask);
}
const createTask = async (param) => {
  const db = global.db;
  const res = {
    code: 200,
    status: ResultStatus.OK,
    message: "创建成功",
    data: ""
  };
  try {
    const _data = {
      id: crypto.randomUUID({ disableEntropyCache: true }),
      //下载任务id
      originUrl: param.urls,
      //原视频地址
      status: DownloadStatus.ANAL,
      //下载状态
      TotalBytes: 0,
      //视频总字节数
      receivedBytes: 0,
      //已下载的字节数
      speed: 0,
      savePath: param.path,
      //下载的本地地址
      name: new URL(param.urls).origin,
      //文件名
      analysisUrl: "",
      //解析后的下载地址
      suffix: "",
      //文件后缀
      fileType: DownloadFileType.NONE
    };
    let query = [];
    Object.keys(_data).forEach((key, val) => {
      console.warn(val, key);
      if (key !== "speed") {
        query.push(key);
      }
    });
    await db.prepare(
      `INSERT INTO tasks (${query.join(",")}) VALUES (@${query.join(",@")})`
    ).run(_data);
    PathAnalysis(param.urls).then((analysisObj) => {
      console.warn(analysisObj.analysisUrl);
      if (analysisObj.analysisUrl) {
        _data.fileObj = analysisObj;
        DownloadFile(analysisObj, param.path, _data);
      } else {
        _data.status = DownloadStatus.ANALERROR;
        updateDownloadStatus(_data);
      }
    });
    res.data = _data;
  } catch (error) {
    console.warn(error.message);
    res.status = ResultStatus.ERROR;
    res.message = "创建失败" + error.message;
  }
  return res;
};
const queryTask = async (param) => {
  const db = global.db;
  const res = {
    code: 200,
    status: ResultStatus.OK,
    message: "查询成功",
    data: ""
  };
  try {
    let query = "";
    if (param.status === 1) {
      query = "SELECT * FROM tasks WHERE status == ?";
    } else {
      query = "SELECT * FROM tasks WHERE status != ?";
    }
    const _res = await db.prepare(query).all(
      "FINISH"
    );
    console.warn(_res);
    res.data = _res;
  } catch (error) {
    console.warn(error.message);
    res.status = ResultStatus.ERROR;
    res.message = "查询失败" + error.message;
  }
  return res;
};
const DownloadHandler = () => {
  const DOMAIN = "download";
  ipcMain.handle(`${DOMAIN}:editTask`, async (_) => {
    return "ok";
  });
  ipcMain.handle(`${DOMAIN}:createTask`, async (_, param) => {
    return await createTask(param);
  });
  ipcMain.handle(`${DOMAIN}:getTaskList`, async (_, param) => {
    return await queryTask(param);
  });
  ipcMain.handle(`${DOMAIN}:getVideoUrl`, async (_) => {
    return "ok";
  });
};
const chooseFolderPath = async () => {
  const res = {
    code: 200,
    status: ResultStatus.ERROR,
    message: "",
    data: ""
  };
  try {
    const directory = await dialog.showOpenDialog({ properties: ["openDirectory"] });
    if (!directory.canceled) {
      const directoryPath = directory.filePaths[0];
      console.log("Selected directory:", directoryPath);
      res.data = directoryPath;
      res.status = ResultStatus.OK;
      return res;
    }
    return res;
  } catch (e) {
    return res;
  }
};
const openFolderPath = async (paths) => {
  const res = {
    code: 200,
    status: ResultStatus.OK,
    message: "",
    data: ""
  };
  try {
    await shell.openPath(path.join(paths));
  } catch (e) {
    res.status = ResultStatus.ERROR;
    res.message = "打开失败" + e;
  }
  return res;
};
const FileHandler = () => {
  const DOMAIN = "file";
  ipcMain.handle(`${DOMAIN}:chooseFolderPath`, async () => {
    return chooseFolderPath();
  });
  ipcMain.handle(`${DOMAIN}:openFolderPath`, async (_, param) => {
    return await openFolderPath(param.path);
  });
};
const getSysConfig = () => {
  const res = {
    code: 200,
    status: ResultStatus.ERROR,
    message: "",
    data: ""
  };
  const _config = {
    downloadPath: app.getPath("downloads"),
    platform: process.platform
  };
  res.data = _config;
  return res;
};
const SysHandler = () => {
  const DOMAIN = "sys";
  ipcMain.handle(`${DOMAIN}:getSysConfig`, async () => {
    return getSysConfig();
  });
  ipcMain.handle(`${DOMAIN}:operationWindow`, function(_, param) {
    const { type } = param;
    const currOperationWindow = global.win;
    switch (type) {
      case "max":
        currOperationWindow.maximize();
        break;
      case "restore":
        currOperationWindow.unmaximize();
        break;
      case "min":
        currOperationWindow.minimize();
        break;
      case "close":
        currOperationWindow.close();
        break;
    }
  });
};
const InitHandler = () => {
  DownloadHandler();
  FileHandler();
  SysHandler();
};
const publicDir = () => {
  const node_serve_path = process.resourcesPath;
  const PUBLIC_PATH = "/public";
  const isPackaged = app.isPackaged;
  let file_path = "";
  if (!isPackaged) {
    file_path = join(process.cwd(), PUBLIC_PATH);
  } else {
    switch (process.platform) {
      case "win32":
        file_path = join(node_serve_path, PUBLIC_PATH);
        break;
      case "darwin":
        file_path = join(node_serve_path, PUBLIC_PATH);
        break;
      case "linux":
        file_path = join(node_serve_path, PUBLIC_PATH);
        break;
    }
  }
  return file_path;
};
const createTables = async (db) => {
  console.log("=======start create table");
  db.exec(`create table if not exists tasks (
    id varchar(500) PRIMARY KEY NOT NULL,
    status varchar(10) NOT NULL,
    originUrl varchar(500) NOT NULL,
    TotalBytes INTEGER,
    receivedBytes INTEGER,
    savePath varchar(500) NOT NULL,
    name varchar(500), 
    analysisUrl varchar(500), 
    suffix varchar(10), 
    fileType varchar(10)
  )`);
  db.exec(`create table if not exists config (
    id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
    proxyHost varchar(64),
    proxyPort varchar(32),
    useProxy INTEGER,
    savePath varchar(500) NOT NULL
  )`);
};
const require$1 = createRequire$1(import.meta.url);
const conDb = () => {
  const DB_NAME = "sql.db";
  const DB_PATH = resolve(publicDir(), DB_NAME);
  try {
    if (!fs.existsSync(DB_PATH)) {
      fs.writeFileSync(DB_PATH, "");
    }
    const db = require$1("better-sqlite3")(DB_PATH, {});
    db.pragma("journal_mode = WAL");
    return db;
  } catch (e) {
    console.warn("==error==", e.message);
    return e;
  }
};
const initDB = () => {
  try {
    const db = conDb();
    createTables(db);
    return db;
  } catch (e) {
    return "";
  }
};
const __dirname = path$1.dirname(fileURLToPath(import.meta.url));
process.env.APP_ROOT = path$1.join(__dirname, "..");
console.log("Node.js environment:", typeof __filename);
const VITE_DEV_SERVER_URL = process.env["VITE_DEV_SERVER_URL"];
const MAIN_DIST = path$1.join(process.env.APP_ROOT, "dist-electron");
const RENDERER_DIST = path$1.join(process.env.APP_ROOT, "dist");
process.env.VITE_PUBLIC = VITE_DEV_SERVER_URL ? path$1.join(process.env.APP_ROOT, "public") : RENDERER_DIST;
let win;
function createWindow() {
  win = new BrowserWindow({
    icon: path$1.join(process.env.VITE_PUBLIC, "electron-vite.svg"),
    width: 1200,
    height: 650,
    frame: false,
    titleBarStyle: "hiddenInset",
    webPreferences: {
      preload: path$1.join(__dirname, "preload.mjs")
    }
  });
  if (process.platform === "darwin") {
    win.setWindowButtonVisibility(true);
  }
  win.webContents.on("did-finish-load", () => {
    win == null ? void 0 : win.webContents.send("main-process-message", (/* @__PURE__ */ new Date()).toLocaleString());
  });
  if (VITE_DEV_SERVER_URL) {
    win.loadURL(VITE_DEV_SERVER_URL);
  } else {
    win.loadFile(path$1.join(RENDERER_DIST, "index.html"));
  }
  win.webContents.openDevTools();
}
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
    win = null;
  }
});
app.on("activate", () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});
app.whenReady().then(async () => {
  global.db = initDB();
  createWindow();
  InitHandler();
  global.win = win;
  global.downloadStack = [];
});
export {
  MAIN_DIST,
  RENDERER_DIST,
  VITE_DEV_SERVER_URL
};
